(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var home_vc_1 = require('../viewcontrols/home/home.vc');
var MyApp = (function (_super) {
    __extends(MyApp, _super);
    function MyApp(router, config) {
        _super.call(this);
        config.routingType = config.STATE;
        router.configure([
            { pattern: '', view: home_vc_1.default }
        ]);
    }
    MyApp.prototype.error = function (ev) {
        console.log(ev.error);
    };
    return MyApp;
}(platypus_1.App));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MyApp;
platypus_1.register.app('app', MyApp, [
    platypus_1.routing.Router,
    platypus_1.web.IBrowserConfig
]);

},{"../viewcontrols/home/home.vc":9,"platypus":10}],2:[function(require,module,exports){
"use strict";
require('platypus');
require('platypusui');
require('./app/app');

},{"./app/app":1,"platypus":10,"platypusui":11}],3:[function(require,module,exports){
"use strict";
var platypus_1 = require('platypus');
var BaseRepository = (function () {
    function BaseRepository() {
    }
    BaseRepository._inject = {
        utils: platypus_1.Utils
    };
    return BaseRepository;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseRepository;

},{"platypus":10}],4:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_repo_1 = require('../base/base.repo');
var entry_svc_1 = require('../../services/entry/entry.svc');
var EntryRepository = (function (_super) {
    __extends(EntryRepository, _super);
    function EntryRepository(entrySvc) {
        _super.call(this);
        this.entrySvc = entrySvc;
    }
    EntryRepository.prototype.getRedditList = function () {
        return this.entrySvc.getRedditList();
    };
    return EntryRepository;
}(base_repo_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EntryRepository;
platypus_1.register.injectable('entry-repo', EntryRepository, [entry_svc_1.default]);

},{"../../services/entry/entry.svc":6,"../base/base.repo":3,"platypus":10}],5:[function(require,module,exports){
"use strict";
var platypus_1 = require('platypus');
var BaseService = (function () {
    function BaseService() {
        this.host = 'https://www.reddit.com/r/Showerthoughts.json';
    }
    BaseService._inject = {
        http: platypus_1.async.Http,
        Promise: platypus_1.async.IPromise,
        utils: platypus_1.Utils
    };
    return BaseService;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseService;

},{"platypus":10}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_svc_1 = require('../base/base.svc');
var EntryService = (function (_super) {
    __extends(EntryService, _super);
    function EntryService() {
        _super.apply(this, arguments);
    }
    EntryService.prototype.getRedditList = function () {
        return this.http.json({
            method: 'GET',
            url: this.host
        }).then(function (success) {
            return success.response;
        }, function (err) {
            console.log(err);
            throw err;
        });
    };
    return EntryService;
}(base_svc_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EntryService;
platypus_1.register.injectable('entry-svc', EntryService);

},{"../base/base.svc":5,"platypus":10}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var BaseViewControl = (function (_super) {
    __extends(BaseViewControl, _super);
    function BaseViewControl() {
        _super.apply(this, arguments);
        this.context = {};
    }
    return BaseViewControl;
}(platypus_1.ui.ViewControl));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseViewControl;

},{"platypus":10}],8:[function(require,module,exports){
module.exports = "\n<plat-foreach class=\"entry-list\" plat-context=\"entries\">\n    <div class=\"entry\">\n        <p class=\"title\">{{title}}</p>\n        <p class=\"author\">{{author}}</p>\n    </div>\n</plat-foreach>\n";

},{}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var platypus_1 = require('platypus');
var base_vc_1 = require('../base/base.vc');
var entry_repo_1 = require('../../repositories/entry/entry.repo');
var HomeViewControl = (function (_super) {
    __extends(HomeViewControl, _super);
    function HomeViewControl(entryRepo) {
        _super.call(this);
        this.entryRepo = entryRepo;
        this.templateString = require('./home.vc.html');
        this.context = {
            entries: [],
        };
    }
    HomeViewControl.prototype.navigatedTo = function () {
        var _this = this;
        this.entryRepo.getRedditList().then(function (success) {
            console.log("We made it to the reddit.");
            console.log(success);
            _this.context.entries = success;
        }, function (err) {
            console.log("Uh, oh. Something's not right.");
            console.log(err);
        });
    };
    return HomeViewControl;
}(base_vc_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = HomeViewControl;
platypus_1.register.viewControl('home-vc', HomeViewControl, [entry_repo_1.default]);

},{"../../repositories/entry/entry.repo":4,"../base/base.vc":7,"./home.vc.html":8,"platypus":10}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* tslint:disable */
/**
 * PlatypusTS v0.20.4 (https://platypi.io)
 * Copyright 2015 Platypi, LLC. All rights reserved.
 *
 * PlatypusTS is licensed under the MIT license found at
 * https://github.com/Platypi/platypusts/blob/master/LICENSE
 *
 */
/**
 * The entry point into the platypus library.
 */
var plat;
(function (plat_1) {
    'use strict;';
    /* tslint:disable:no-unused-variable */
    /*
     */
    var __prefix = '$', __CONTEXT = 'context', __AppStatic = __prefix + 'AppStatic', __App = __prefix + 'App', __Http = __prefix + 'Http', __HttpRequestInstance = __prefix + 'HttpRequestInstance', __HttpConfig = __prefix + 'HttpConfig', __Promise = __prefix + 'Promise', __Compat = __prefix + 'Compat', __ControlFactory = __prefix + 'ControlFactory', __AttributeControlFactory = __prefix + 'AttributeControlFactory', __Document = __prefix + 'Document', __DispatchEventInstance = __prefix + 'DispatchEventInstance', __ErrorEventStatic = __prefix + 'ErrorEventStatic', __EventManagerStatic = __prefix + 'EventManagerStatic', __LifecycleEventStatic = __prefix + 'LifecycleEventStatic', __LifecycleEventInstance = __prefix + 'LifecycleEventInstance', __Log = __prefix + 'Log', __Parser = __prefix + 'Parser', __Regex = __prefix + 'Regex', __Tokenizer = __prefix + 'Tokenizer', __NavigatorInstance = __prefix + 'NavigatorInstance', __ContextManagerStatic = __prefix + 'ContextManagerStatic', __ContextManagerInstance = __prefix + 'ContextManagerInstance', __Compiler = __prefix + 'Compiler', __CommentManagerFactory = __prefix + 'CommentManagerFactory', __CommentManagerInstance = __prefix + 'CommentManagerInstance', __ElementManagerFactory = __prefix + 'ElementManagerFactory', __ElementManagerInstance = __prefix + 'ElementManagerInstance', __NodeManagerStatic = __prefix + 'NodeManagerStatic', __TextManagerFactory = __prefix + 'TextManagerFactory', __TextManagerInstance = __prefix + 'TextManagerInstance', __CacheFactory = __prefix + 'CacheFactory', __ManagerCache = __prefix + 'ManagerCache', __TemplateCache = __prefix + 'TemplateCache', __Animator = __prefix + 'Animator', __AttributesFactory = __prefix + 'AttributesFactory', __AttributesInstance = __prefix + 'AttributesInstance', __BindableTemplatesFactory = __prefix + 'BindableTemplatesFactory', __Dom = __prefix + 'Dom', __DomEvents = __prefix + 'DomEvents', __IDomEventsConfig = __prefix + 'IDomEventsConfig', __DomEventInstance = __prefix + 'DomEventInstance', __ResourcesFactory = __prefix + 'ResourcesFactory', __ResourcesInstance = __prefix + 'ResourcesInstance', __TemplateControlFactory = __prefix + 'TemplateControlFactory', __TemplateControlInstance = __prefix + 'TemplateControlInstance', __Utils = __prefix + 'Utils', __Browser = __prefix + 'Browser', __BrowserConfig = __prefix + 'BrowserConfig', __Router = __prefix + 'Router', __RouterStatic = __prefix + 'RouterStatic', __UrlUtilsInstance = __prefix + 'UrlUtilsInstance', __Window = __prefix + 'Window', __LocalStorage = __prefix + 'LocalStorage', __SessionStorage = __prefix + 'SessionStorage', __Geolocation = __prefix + 'Geolocation', __BaseSegmentFactory = __prefix + 'BaseSegmentFactory', __BaseSegmentInstance = __prefix + 'BaseSegmentInstance', __StaticSegmentInstance = __prefix + 'StaticSegmentInstance', __VariableSegmentInstance = __prefix + 'VariableSegmentInstance', __DynamicSegmentInstance = __prefix + 'DynamicSegmentInstance', __SplatSegmentInstance = __prefix + 'SplatSegmentInstance', __StateStatic = __prefix + 'StateStatic', __StateInstance = __prefix + 'StateInstance', __RouteRecognizerInstance = __prefix + 'RouteRecognizerInstance', __InjectorStatic = __prefix + 'InjectorStatic', __History = __prefix + 'History', __Location = __prefix + 'Location', 
    /**
     */
    __Plat = 'plat-', __Bind = __Plat + 'bind', __Href = __Plat + 'href', __Src = __Plat + 'src', __KeyDown = __Plat + 'keydown', __KeyPress = __Plat + 'keypress', __KeyUp = __Plat + 'keyup', __CharPress = __Plat + 'charpress', __Name = __Plat + 'name', __Options = __Plat + 'options', __Checked = __Plat + 'checked', __Disabled = __Plat + 'disabled', __Selected = __Plat + 'selected', __ReadOnly = __Plat + 'readonly', __Visible = __Plat + 'visible', __Style = __Plat + 'style', __Tap = __Plat + 'tap', __Blur = __Plat + 'blur', __Change = __Plat + 'change', __Copy = __Plat + 'copy', __Cut = __Plat + 'cut', __Paste = __Plat + 'paste', __DblTap = __Plat + 'dbltap', __Focus = __Plat + 'focus', __Submit = __Plat + 'submit', __TouchStart = __Plat + 'touchstart', __TouchEnd = __Plat + 'touchend', __TouchMove = __Plat + 'touchmove', __TouchCancel = __Plat + 'touchcancel', __Hold = __Plat + 'hold', __Release = __Plat + 'release', __Swipe = __Plat + 'swipe', __SwipeLeft = __Plat + 'swipeleft', __SwipeRight = __Plat + 'swiperight', __SwipeUp = __Plat + 'swipeup', __SwipeDown = __Plat + 'swipedown', __Track = __Plat + 'track', __TrackLeft = __Plat + 'trackleft', __TrackRight = __Plat + 'trackright', __TrackUp = __Plat + 'trackup', __TrackDown = __Plat + 'trackdown', __TrackEnd = __Plat + 'trackend', __React = __Plat + 'react', __Link = __Plat + 'link', __ForEach = __Plat + 'foreach', __Html = __Plat + 'html', __If = __Plat + 'if', __Ignore = __Plat + 'ignore', __Select = __Plat + 'select', __Template = __Plat + 'template', __Routeport = __Plat + 'routeport', __Viewport = __Plat + 'viewport', __Control = __Plat + 'control', __ViewControl = __Plat + 'viewcontrol', __Resources = __Plat + 'resources', __Context = __Plat + __CONTEXT, __TemplateContext = __Template + '-' + __CONTEXT, __Callback = __Plat + 'callback', __AttributePrefix = 'data-', 
    /**
     */
    __TemplateControlCache = '__templateControlCache', __Head = 'head', __Meta = 'meta', __Title = 'title', __Description = 'description', __Author = 'author', __Creator = 'creator', __MetaLink = 'link', __MetaHref = 'href', __MetaName = 'name', __MetaProperty = 'property', __MetaImage = 'image', __MetaVideo = 'video', __MetaType = 'type', __Rel = 'rel', __Url = 'url', __Article = 'article:', __OpenGraph = 'og:', __Twitter = 'twitter:', __Content = 'content', 
    /**
     */
    __ready = 'ready', __suspend = 'suspend', __resume = 'resume', __online = 'online', __offline = 'offline', __error = 'error', __shutdown = 'shutdown', __exiting = 'exiting', __beforeLoad = 'beforeLoad', 
    /**
     */
    __beforeNavigate = 'beforeNavigate', __navigated = 'navigated', __navigating = 'navigating', __beforeRouteChange = 'beforeRouteChange', __routeChanged = 'routeChanged', __urlChanged = 'urlChanged', 
    /**
     */
    __pause = 'pause', __deviceReady = 'deviceReady', __backButton = 'backbutton', __backClick = 'backclick', __backButtonPressed = 'backButtonPressed', 
    /**
     */
    __Hide = __Plat + 'hide', __Animating = __Plat + 'animating', __SimpleAnimation = __Plat + 'animation', __SimpleTransition = __Plat + 'transition', __Enter = __Plat + 'enter', __Leave = __Plat + 'leave', __Move = __Plat + 'move', __FadeIn = __Plat + 'fadein', __FadeOut = __Plat + 'fadeout', __NavigatingBack = __Plat + 'back-nav', 
    /**
     */
    __event_prefix = '$', __tap = __event_prefix + 'tap', __dbltap = __event_prefix + 'dbltap', __touchstart = __event_prefix + 'touchstart', __touchend = __event_prefix + 'touchend', __touchmove = __event_prefix + 'touchmove', __touchcancel = __event_prefix + 'touchcancel', __hold = __event_prefix + 'hold', __release = __event_prefix + 'release', __swipe = __event_prefix + 'swipe', __swipeleft = __event_prefix + 'swipeleft', __swiperight = __event_prefix + 'swiperight', __swipeup = __event_prefix + 'swipeup', __swipedown = __event_prefix + 'swipedown', __track = __event_prefix + 'track', __trackleft = __event_prefix + 'trackleft', __trackright = __event_prefix + 'trackright', __trackup = __event_prefix + 'trackup', __trackdown = __event_prefix + 'trackdown', __trackend = __event_prefix + 'trackend', 
    /**
     */
    __errorSuffix = 'Error', __platError = 'Plat' + __errorSuffix, __parseError = 'Parsing' + __errorSuffix, __bindError = 'Binding' + __errorSuffix, __compileError = 'Compiling' + __errorSuffix, __nameError = 'PlatName' + __errorSuffix, __navigationError = 'Navigating' + __errorSuffix, __templateError = 'Templating' + __errorSuffix, __contextError = 'Context' + __errorSuffix, __eventError = 'DispatchEvent' + __errorSuffix, __injectableError = 'Injectable' + __errorSuffix, __CompatError = 'Compatibility' + __errorSuffix, 
    /**
     */
    __forEachAliasOptions = {
        index: 'index',
        even: 'even',
        odd: 'odd',
        first: 'first',
        last: 'last'
    }, 
    /**
     */
    __BASE_SEGMENT_TYPE = 'base', __VARIABLE_SEGMENT_TYPE = 'variable', __STATIC_SEGMENT_TYPE = 'static', __SPLAT_SEGMENT_TYPE = 'splat', __DYNAMIC_SEGMENT_TYPE = 'dynamic', 
    /**
     */
    __CONTEXT_CHANGED_PRIORITY = 1000, __startSymbol = '{{', __endSymbol = '}}', __STATIC = 'static', __SINGLETON = 'singleton', __INSTANCE = 'instance', __FACTORY = 'factory', __CLASS = 'class', __CSS = 'css', __COMPILED = '-compiled', __BOUND_PREFIX = '-@', __INIT_SUFFIX = '-init', __START_NODE = ': start node', __END_NODE = ': end node', __POPSTATE = 'popstate', __HASHCHANGE = 'hashchange', __WRAPPED_INJECTOR = 'wrapped', __JSONP_CALLBACK = 'plat_callback', __JS = 'js', __NOOP_INJECTOR = 'noop', __APP = '__app__', __RESOURCE = 'resource', __RESOURCES = __RESOURCE + 's', __ALIAS = 'alias', __ALIASES = __ALIAS + 'es', __OBSERVABLE_RESOURCE = 'observable', __INJECTABLE_RESOURCE = 'injectable', __OBJECT_RESOURCE = 'object', __FUNCTION_RESOURCE = 'function', __LITERAL_RESOURCE = 'literal', __ROOT_RESOURCE = 'root', __ROOT_CONTEXT_RESOURCE = 'rootContext', __CONTROL_RESOURCE = 'control', __CONTEXT_RESOURCE = __CONTEXT;
    /* tslint:disable:no-unused-variable */
    var ___Promise, ___compat, __camelCaseRegex, __capitalCaseRegex, __nativeIsArray = !!Array.isArray;
    var __uids = {}, __objToString = Object.prototype.toString, __toStringClass = '[object ', __errorClass = __toStringClass + 'Error]', __fileClass = __toStringClass + 'File]', __arrayClass = __toStringClass + 'Array]', __boolClass = __toStringClass + 'Boolean]', __dateClass = __toStringClass + 'Date]', __funcClass = __toStringClass + 'Function]', __numberClass = __toStringClass + 'Number]', __objectClass = __toStringClass + 'Object]', __regexpClass = __toStringClass + 'RegExp]', __stringClass = __toStringClass + 'String]', __promiseClass = __toStringClass + 'Promise]', __objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    };
    function noop() { }
    function _defineProperty(obj, key, value, enumerable, configurable, writable) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: enumerable === true,
            configurable: configurable === true,
            writable: writable === true
        });
    }
    function _defineGetter(obj, key, value, enumerable, configurable) {
        Object.defineProperty(obj, key, {
            get: function () { return value; },
            enumerable: enumerable === true,
            configurable: configurable === true
        });
    }
    function _extend(deep, redefine, destination) {
        var sources = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            sources[_i - 3] = arguments[_i];
        }
        if (isNull(destination)) {
            return destination;
        }
        var keys, property, define;
        if (isFunction(redefine)) {
            define = redefine;
        }
        else if (redefine) {
            define = function (obj, key, value) {
                _defineProperty(obj, key, value, true, true, true);
            };
        }
        else {
            define = function (obj, key, value) {
                obj[key] = value;
            };
        }
        if (isEmpty(sources)) {
            sources.push(destination);
        }
        forEach(function (source, k) {
            if (!isObject(source)) {
                return;
            }
            keys = Object.keys(source);
            forEach(function (key) {
                property = source[key];
                if (deep) {
                    if (isArray(property)) {
                        _extend(deep, define, destination[key] || (destination[key] = []), property);
                        return;
                    }
                    else if (isDate(property)) {
                        define(destination, key, new Date(property.getTime()));
                        return;
                    }
                    else if (isRegExp(property)) {
                        define(destination, key, new RegExp(property));
                        return;
                    }
                    else if (isNode(property)) {
                        define(destination, key, property.cloneNode(true));
                        return;
                    }
                    else if (isFile(property)) {
                        define(destination, key, property);
                        return;
                    }
                    else if (isObject(property)) {
                        _extend(deep, define, destination[key] || (destination[key] = {}), property);
                        return;
                    }
                }
                define(destination, key, property);
            }, keys);
        }, sources);
        return destination;
    }
    function _clone(obj, deep) {
        if (!isObject(obj)) {
            return obj;
        }
        else if (isDate(obj)) {
            return new Date(obj.getTime());
        }
        else if (isRegExp(obj)) {
            return new RegExp(obj);
        }
        else if (isNode(obj)) {
            return obj.cloneNode(deep);
        }
        else if (isFile(obj)) {
            return obj;
        }
        else if (isError(obj)) {
            return new obj.constructor(obj.message);
        }
        var type = {};
        if (isArray(obj)) {
            type = [];
        }
        if (isBoolean(deep) && deep) {
            return _extend(true, false, type, obj);
        }
        return _extend(false, false, type, obj);
    }
    function isError(obj) {
        return __objToString.call(obj) === __errorClass;
    }
    function isObject(obj) {
        return obj != null && typeof obj === 'object';
    }
    function isWindow(obj) {
        return !!(obj && obj.document && obj.setInterval);
    }
    function isDocument(obj) {
        return !!(obj && obj.nodeType === Node.DOCUMENT_NODE);
    }
    function isNode(obj) {
        return !!(obj && typeof obj.nodeType === 'number');
    }
    function isDocumentFragment(obj) {
        return !!(obj && obj.nodeType === Node.DOCUMENT_FRAGMENT_NODE);
    }
    function isFile(obj) {
        return isObject(obj) && __objToString.call(obj) === __fileClass;
    }
    function isString(obj) {
        return typeof obj === 'string' || isObject(obj) && __objToString.call(obj) === __stringClass;
    }
    function isRegExp(obj) {
        return isObject(obj) && __objToString.call(obj) === __regexpClass;
    }
    function isPromise(obj) {
        return isObject(obj) && (__objToString.call(obj) === __promiseClass || isFunction(obj.then));
    }
    function isEmpty(obj) {
        if (isNull(obj)) {
            return true;
        }
        if (isString(obj) || isArray(obj)) {
            return obj.length === 0;
        }
        if (!isObject(obj)) {
            return false;
        }
        return Object.keys(obj).length === 0;
    }
    function isBoolean(obj) {
        return obj === true || obj === false || isObject(obj) && __objToString.call(obj) === __boolClass;
    }
    function isNumber(obj) {
        return (typeof obj === 'number' || isObject(obj) && __objToString.call(obj) === __numberClass) && !isNaN(obj);
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    function isNull(obj) {
        return obj === null || obj === undefined;
    }
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isArray(obj) {
        if (__nativeIsArray) {
            return Array.isArray(obj);
        }
        return __objToString.call(obj) === __arrayClass;
    }
    function isArrayLike(obj) {
        if (isNull(obj) || isWindow(obj) || isFunction(obj)) {
            return false;
        }
        return isString(obj) || obj.length >= 0;
    }
    function isDate(obj) {
        return typeof obj === 'object' && __objToString.call(obj) === __dateClass;
    }
    function filter(iterator, obj, context) {
        var arr = [];
        if (isNull(obj)) {
            return arr;
        }
        if (isFunction(obj.filter)) {
            return obj.filter(iterator, context);
        }
        forEach(function (value, key, obj) {
            if (iterator(value, key, obj)) {
                arr.push(value);
            }
        }, obj);
        return arr;
    }
    function where(properties, obj) {
        return filter(function (value) {
            return !some(function (property, key) {
                return value[key] !== property;
            }, properties);
        }, obj);
    }
    function forEach(iterator, obj, context) {
        if (isNull(obj) || !(isObject(obj) || isArrayLike(obj))) {
            return obj;
        }
        var i, key, length;
        if (isFunction(obj.forEach)) {
            return obj.forEach(iterator, context);
        }
        else if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; ++i) {
                iterator.call(context, obj[i], i, obj);
            }
        }
        else {
            var keys = Object.keys(obj);
            length = keys.length;
            while (keys.length > 0) {
                key = keys.shift();
                iterator.call(context, obj[key], key, obj);
            }
        }
        return obj;
    }
    function map(iterator, obj, context) {
        var arr = [];
        if (isNull(obj)) {
            return arr;
        }
        if (isFunction(obj.map)) {
            return obj.map(iterator, context);
        }
        forEach(function (value, key) {
            arr.push(iterator.call(context, value, key, obj));
        }, obj);
        return arr;
    }
    function mapAsync(iterator, obj, context) {
        ___Promise = ___Promise || plat.acquire(__Promise);
        return ___Promise.all(map(iterator, obj, context));
    }
    function mapAsyncWithOrder(iterator, array, context, descending) {
        ___Promise = ___Promise || plat.acquire(__Promise);
        var initialValue = ___Promise.resolve([]);
        if (!isArray(array)) {
            return initialValue;
        }
        iterator = iterator.bind(context);
        var inOrder = function (previousValue, nextValue, nextIndex, array) {
            return previousValue.then(function (items) {
                return iterator(nextValue, nextIndex, array).then(function (moreItems) {
                    return items.concat(moreItems);
                });
            });
        };
        if (descending === true) {
            return array.reduceRight(inOrder, initialValue);
        }
        return array.reduce(inOrder, initialValue);
    }
    function mapAsyncInOrder(iterator, array, context) {
        return mapAsyncWithOrder(iterator, array, context);
    }
    function mapAsyncInDescendingOrder(iterator, array, context) {
        return mapAsyncWithOrder(iterator, array, context, true);
    }
    function pluck(key, obj) {
        return map(function (value) { return value[key]; }, obj);
    }
    function some(iterator, obj, context) {
        if (isNull(obj) || isFunction(obj)) {
            return false;
        }
        var i, key, length, ret;
        if (isFunction(obj.some)) {
            return obj.some(iterator, context);
        }
        else if (isArrayLike(obj)) {
            for (i = 0, length = obj.length; i < length; ++i) {
                ret = iterator.call(context, obj[i], i, obj);
                if (ret === true) {
                    return true;
                }
            }
        }
        else {
            var keys = Object.keys(obj);
            length = keys.length;
            while (keys.length > 0) {
                key = keys.shift();
                ret = iterator.call(context, obj[key], key, obj);
                if (ret === true) {
                    return true;
                }
            }
        }
        return false;
    }
    function postpone(method, args, context) {
        return defer(method, 0, args, context);
    }
    function defer(method, timeout, args, context) {
        function execDefer() {
            method.apply(context, args);
        }
        var timeoutId = setTimeout(execDefer, timeout);
        return function () {
            clearTimeout(timeoutId);
        };
    }
    function setIntervalGlobal(method, interval, args, context) {
        function execInterval() {
            method.apply(context, args);
        }
        var intervalId = setInterval(execInterval, interval);
        return function () {
            clearInterval(intervalId);
        };
    }
    function requestAnimationFrameGlobal(method, context) {
        ___compat = ___compat || (plat.acquire(__Compat));
        var requestAnimFrame = ___compat.requestAnimationFrame;
        if (isUndefined(requestAnimFrame)) {
            return postpone(function () {
                method.call(context, Date.now());
            });
        }
        var animationId = requestAnimFrame(method.bind(context)), cancelAnimFrame = ___compat.cancelAnimationFrame || noop;
        return function () {
            cancelAnimFrame(animationId);
        };
    }
    function uniqueId(prefix) {
        if (isNull(prefix)) {
            prefix = '';
        }
        var puid = __uids[prefix];
        if (isNull(puid)) {
            puid = __uids[prefix] = ['0', '/'];
        }
        var index = puid.length, charCode;
        while (index--) {
            charCode = puid[index].charCodeAt(0);
            // '9' 
            if (charCode === 57) {
                puid[index] = 'A';
                return join();
            }
            // 'Z' 
            if (charCode === 90) {
                puid[index] = 'a';
                return join();
            }
            // 'z' 
            if (charCode === 122) {
                puid[index] = '0';
            }
            else {
                puid[index] = String.fromCharCode(charCode + 1);
                return join();
            }
        }
        puid.unshift('0');
        function join() {
            return prefix + puid.join('');
        }
        return join();
    }
    function camelCase(str) {
        if (!isString(str) || isEmpty(str)) {
            return str;
        }
        str = str.charAt(0).toLowerCase() + str.slice(1);
        __camelCaseRegex = __camelCaseRegex || plat.acquire(__Regex).camelCaseRegex;
        return str.replace(__camelCaseRegex, function (match, delimiter, char, index) {
            return index ? char.toUpperCase() : char;
        });
    }
    function delimit(str, delimiter) {
        if (!isString(str) || isEmpty(str)) {
            return str;
        }
        else if (isNull(delimiter)) {
            delimiter = '';
        }
        __capitalCaseRegex = __capitalCaseRegex || plat.acquire(__Regex).capitalCaseRegex;
        return str.replace(__capitalCaseRegex, function (match, index) {
            return index ? delimiter + match.toLowerCase() : match.toLowerCase();
        });
    }
    function deleteProperty(obj, property) {
        if (!isNull(obj)) {
            /* tslint:disable:no-unused-expression */
            delete obj[property];
        }
        return obj;
    }
    function access(obj, property) {
        if (isNull(obj)) {
            return obj;
        }
        return obj[property];
    }
    function deserializeQuery(search) {
        if (isEmpty(search)) {
            return;
        }
        var split = search.split('&'), query = {}, length = split.length, item;
        for (var i = 0; i < length; ++i) {
            item = split[i].split('=');
            query[item[0]] = item[1];
        }
        return query;
    }
    function serializeQuery(query) {
        var q = '';
        q += map(function (value, key) {
            return key + '=' + value;
        }, query).join('&');
        if (!isEmpty(q)) {
            q = '?' + q;
        }
        return q;
    }
    function booleanReduce(values) {
        if (!isArray(values)) {
            return isBoolean(values) ? values : true;
        }
        return values.reduce(function (prev, current) {
            return prev && current !== false;
        }, true);
    }
    /* tslint:enable:no-unused-variable */
    /* tslint:disable:no-unused-variable */
    var ___document, ___templateCache, ___http, ___log;
    var __nodeNameRegex = /<([\w:]+)/, __whiteSpaceRegex = /\s+/g, __option = [1, '<select multiple="multiple">', '</select>'], __table = [1, '<table>', '</table>'], __tableData = [3, '<table><tbody><tr>', '</tr></tbody></table>'], __svg = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', '</svg>'], __innerTableWrappers = {
        thead: __table,
        tbody: __table,
        tfoot: __table,
        colgroup: __table,
        caption: __table,
        tr: [2, '<table><tbody>', '</tbody></table>'],
        col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
        td: __tableData,
        th: __tableData
    }, __innerHtmlWrappers = _extend(false, false, {}, __innerTableWrappers, {
        option: __option,
        optgroup: __option,
        legend: [1, '<fieldset>', '</fieldset>'],
        area: [1, '<map>', '</map>'],
        param: [1, '<object>', '</object>'],
        text: __svg,
        circle: __svg,
        ellipse: __svg,
        line: __svg,
        path: __svg,
        polygon: __svg,
        polyline: __svg,
        rect: __svg,
        _default: [0, '', '']
    });
    function appendChildren(nodeList, root, clone) {
        var isFragment = isDocumentFragment(root), nullRoot = !isNode(root), fragment = isFragment ?
            root :
            (___document || (___document = plat.acquire(__Document))).createDocumentFragment();
        if (nullRoot) {
            root = fragment;
        }
        var list = isArray(nodeList) ? nodeList : Array.prototype.slice.call(nodeList), length = list.length, i;
        if (clone === true) {
            var item = void 0;
            for (i = 0; i < length; ++i) {
                item = list[i].cloneNode(true);
                fragment.insertBefore(item, null);
            }
        }
        else {
            for (i = 0; i < length; ++i) {
                fragment.insertBefore(list[i], null);
            }
        }
        if (!(isFragment || nullRoot)) {
            root.appendChild(fragment);
        }
        return root;
    }
    function clearNode(node) {
        var childNodes = Array.prototype.slice.call(node.childNodes);
        while (childNodes.length > 0) {
            node.removeChild(childNodes.pop());
        }
    }
    function clearNodeBlock(nodeList, parent) {
        if (!isFunction(nodeList.push)) {
            nodeList = Array.prototype.slice.call(nodeList);
        }
        if (!isNull(parent)) {
            clearNodeBlockWithParent(nodeList, parent);
            return;
        }
        var node;
        while (nodeList.length > 0) {
            node = nodeList.pop();
            parent = node.parentNode;
            if (isNull(parent)) {
                continue;
            }
            parent.removeChild(node);
        }
    }
    function clearNodeBlockWithParent(nodeList, parent) {
        while (nodeList.length > 0) {
            parent.removeChild(nodeList.pop());
        }
    }
    function stringToNode(html) {
        // ___compat is a global variable in utilsglobal 
        ___compat = ___compat || (___compat = plat.acquire(__Compat));
        ___document = ___document || (___document = plat.acquire(__Document));
        var nodeName = __nodeNameRegex.exec(html), element = ___document.createElement('div');
        if (isNull(nodeName)) {
            element = innerHtml(element, html);
            return element.removeChild(element.lastChild);
        }
        // trim html string 
        html = html.trim();
        var mapTag = nodeName[1];
        if (___compat.pushState && isUndefined(__innerTableWrappers[mapTag])) {
            return innerHtml(element, html);
        }
        else if (mapTag === 'body') {
            element = innerHtml(___document.createElement('html'), html);
            return element.removeChild(element.lastChild);
        }
        var wrapper = __innerHtmlWrappers[mapTag] || __innerHtmlWrappers._default, depth = wrapper[0], parentStart = wrapper[1], parentEnd = wrapper[2];
        element = innerHtml(element, parentStart + html + parentEnd);
        while (depth-- > 0) {
            element = element.lastChild;
        }
        return element;
    }
    function setInnerHtml(node, html) {
        clearNode(node);
        if (isEmpty(html)) {
            return;
        }
        var element = stringToNode(html);
        if (element.childNodes.length > 0) {
            appendChildren(element.childNodes, node);
        }
        else {
            node.insertBefore(element, null);
        }
        return node;
    }
    function insertBefore(parent, nodes, endNode) {
        if (isNull(parent) || !isObject(nodes)) {
            return;
        }
        else if (isUndefined(endNode)) {
            endNode = null;
        }
        var fragment;
        if (isNode(nodes)) {
            fragment = nodes;
            nodes = Array.prototype.slice.call(fragment.childNodes);
            parent.insertBefore(fragment, endNode);
            return nodes;
        }
        if (!isFunction(nodes.push)) {
            nodes = Array.prototype.slice.call(nodes);
        }
        ___document = ___document || (___document = plat.acquire(__Document));
        var length = nodes.length;
        fragment = ___document.createDocumentFragment();
        for (var i = 0; i < length; ++i) {
            fragment.insertBefore(nodes[i], null);
        }
        parent.insertBefore(fragment, endNode);
        return nodes;
    }
    function replace(node) {
        var parent = node.parentNode, nodes = insertBefore(parent, node.childNodes, node);
        parent.removeChild(node);
        return nodes;
    }
    function replaceWith(node, newNode) {
        if (isNull(newNode)) {
            return newNode;
        }
        if (node.nodeType === Node.ELEMENT_NODE) {
            var attributes = node.attributes, length_1 = attributes.length, attribute = void 0;
            for (var i = 0; i < length_1; ++i) {
                attribute = attributes[i];
                newNode.setAttribute(attribute.name, attribute.value);
            }
        }
        var parent = node.parentNode;
        insertBefore(newNode, node.childNodes);
        parent.replaceChild(newNode, node);
        return newNode;
    }
    function serializeHtml(html) {
        ___document = ___document || (___document = plat.acquire(__Document));
        var templateElement = ___document.createDocumentFragment();
        if (!isEmpty(html)) {
            setInnerHtml(templateElement, html);
        }
        return templateElement;
    }
    function removeBetween(startNode, endNode) {
        if (isNull(startNode)) {
            return;
        }
        var currentNode = startNode.nextSibling, parentNode = startNode.parentNode, tempNode;
        if (isNull(endNode)) {
            endNode = null;
        }
        if (isNull(parentNode) || (!isNull(endNode) && endNode.parentNode !== parentNode)) {
            return;
        }
        while (currentNode !== endNode) {
            tempNode = currentNode.nextSibling;
            parentNode.removeChild(currentNode);
            currentNode = tempNode;
        }
    }
    function removeAll(startNode, endNode) {
        if (isNull(startNode)) {
            return;
        }
        removeBetween(startNode, endNode);
        removeNode(startNode);
        removeNode(endNode);
    }
    /**
     */
    function innerHtml(element, html) {
        ___compat = ___compat || (___compat = plat.acquire(__Compat));
        if (___compat.msApp) {
            MSApp.execUnsafeLocalFunction(function () {
                element.innerHTML = html;
            });
        }
        else {
            element.innerHTML = html;
        }
        return element;
    }
    function removeNode(node) {
        if (!isNode(node)) {
            return;
        }
        var parentNode = node.parentNode;
        if (!isNull(parentNode)) {
            parentNode.removeChild(node);
        }
    }
    function addClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return;
        }
        var split = className.split(__whiteSpaceRegex), name, classNameRegex;
        if (isUndefined(element.classList)) {
            if (isEmpty(cName)) {
                element.className = className;
                return;
            }
            while (split.length > 0) {
                name = split.shift();
                if (name !== '') {
                    classNameRegex = new RegExp('^' + name + '\\s+|\\s+' + name + '$|\\s+' + name + '\\s+', 'g');
                    if (!classNameRegex.test(cName)) {
                        element.className += ' ' + name;
                    }
                }
            }
            return;
        }
        while (split.length > 0) {
            name = split.shift();
            if (name !== '') {
                element.classList.add(name);
            }
        }
    }
    function removeClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return;
        }
        var split = className.split(__whiteSpaceRegex), name;
        if (isUndefined(element.classList)) {
            if (cName === className) {
                element.className = '';
                return;
            }
            while (split.length > 0) {
                name = split.shift();
                if (name !== '') {
                    element.className = cName = cName
                        .replace(new RegExp('^' + name + '\\s+|\\s+' + name + '$|\\s+' + name + '\\s+', 'g'), '');
                }
            }
            return;
        }
        while (split.length > 0) {
            name = split.shift();
            if (name !== '') {
                element.classList.remove(name);
            }
        }
    }
    function toggleClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return;
        }
        var split = className.split(__whiteSpaceRegex), name;
        if (isUndefined(element.classList)) {
            var classNameRegex = void 0;
            if (cName === '') {
                element.className = className;
            }
            else if (cName === className) {
                element.className = '';
                return;
            }
            while (split.length > 0) {
                name = split.shift();
                if (name !== '') {
                    classNameRegex = new RegExp('^' + name + '\\s+|\\s+' + name + '$|\\s+' + name + '\\s+', 'g');
                    if (classNameRegex.test(cName)) {
                        element.className = cName = cName.replace(classNameRegex, '');
                        continue;
                    }
                    element.className += ' ' + name;
                }
            }
            return;
        }
        while (split.length > 0) {
            name = split.shift();
            if (name !== '') {
                element.classList.toggle(name);
            }
        }
    }
    function replaceClass(element, oldClass, newClass) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(newClass) || newClass === '') {
            return;
        }
        if (isUndefined(element.classList)) {
            var startRegex = new RegExp('^' + oldClass + '\\s+', 'g'), midRegex = new RegExp('\\s+' + oldClass + '\\s+', 'g'), endRegex = new RegExp('\\s+' + oldClass + '$', 'g');
            element.className = cName.replace(startRegex, newClass + ' ')
                .replace(midRegex, ' ' + newClass + ' ')
                .replace(endRegex, ' ' + newClass);
            return;
        }
        element.classList.add(newClass);
        element.classList.remove(oldClass);
    }
    function hasClass(element, className) {
        var cName = (element || {}).className;
        if (!isString(cName) || !isString(className) || className === '') {
            return false;
        }
        var split = className.split(__whiteSpaceRegex);
        if (isUndefined(element.classList)) {
            if (cName === '') {
                return false;
            }
            else if (cName === className) {
                return true;
            }
            var name_1;
            while (split.length > 0) {
                name_1 = split.shift();
                if (!(name_1 === '' || new RegExp('^' + name_1 + '\\s|\\s' + name_1 + '$|\\s' + name_1 + '\\s', 'g').test(cName))) {
                    return false;
                }
            }
            return true;
        }
        while (split.length > 0) {
            name = split.shift();
            if (!(name === '' || element.classList.contains(name))) {
                return false;
            }
        }
        return true;
    }
    function getTemplate(templateUrl) {
        ___templateCache = ___templateCache || (___templateCache = plat.acquire(__TemplateCache));
        ___http = ___http || (___http = plat.acquire(__Http));
        return ___templateCache.put(templateUrl, ___templateCache.read(templateUrl)
            .catch(function (error) {
            if (isNull(error)) {
                return ___http.ajax({ url: templateUrl });
            }
        }).then(function (success) {
            if (isDocumentFragment(success)) {
                return ___templateCache.put(templateUrl, success);
            }
            else if (!isObject(success) || !isString(success.response)) {
                ___log = ___log || (___log = plat.acquire(__Log));
                ___log.warn('No template found at ' + templateUrl);
                return ___templateCache.put(templateUrl);
            }
            var templateString = success.response;
            if (isEmpty(templateString.trim())) {
                return ___templateCache.put(templateUrl);
            }
            return ___templateCache.put(templateUrl, templateString);
        }).catch(function (error) {
            postpone(function () {
                ___log = ___log || (___log = plat.acquire(__Log));
                ___log.error(new Error('Failure to get template from ' + templateUrl + '.'));
            });
            return error;
        }));
    }
    function whenPresent(cb, element) {
        if (!isNode(element)) {
            ___log = ___log || (___log = plat.acquire(__Log));
            ___log.error(new Error('Attempting to check DOM presence of something that isn\'t a Node.'));
            return noop;
        }
        ___document = ___document || (___document = plat.acquire(__Document));
        var body = ___document.body;
        if (isNode(element.parentElement) && body.contains(element)) {
            cb();
            return noop;
        }
        var remove = setIntervalGlobal(function () {
            if (isNode(element.parentElement) && body.contains(element)) {
                remove();
                cb();
            }
        }, 100);
        return remove;
    }
    function whenVisible(cb, element) {
        if (!isNode(element)) {
            ___log = ___log || (___log = plat.acquire(__Log));
            ___log.error(new Error('Attempting to check visibility of something that isn\'t a Node.'));
            return noop;
        }
        var clientWidth = element.clientWidth, clientHeight = element.clientHeight;
        if (!(isNumber(clientWidth) && isNumber(clientHeight))) {
            ___log = ___log || (___log = plat.acquire(__Log));
            ___log.error(new Error('Attempting to check visibility of something that isn\'t an Element.'));
            return noop;
        }
        if (clientWidth > 0 && clientHeight > 0) {
            cb();
            return noop;
        }
        var remove = setIntervalGlobal(function () {
            if (element.clientWidth > 0 && element.clientHeight > 0) {
                remove();
                cb();
            }
        }, 100);
        return remove;
    }
    /* tslint:enable:no-unused-variable */
    var controlInjectors = {}, viewControlInjectors = {}, instanceInjectorDependencies = {}, injectableInjectors = {}, unregisteredInjectors = {}, staticInjectors = {}, animationInjectors = {}, jsAnimationInjectors = {};
    /**
     * Holds all the classes and interfaces related to registering components for platypus.
     */
    var register;
    (function (register) {
        /**
         * Generic function for creating an Injector and
         * adding it to an InjectorObject.
         * @param {plat.dependency.InjectorObject<any>} obj The InjectorObject
         * to which to add an Injector.
         * @param {string} name The name used to set/get the Injector from the
         * InjectorObject.
         * @param {any} Type The constructor or function definition for the Injector.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the
         * Injector.
         * @param {string} injectableType? The injectable type.
         * @param {boolean} isStatic The injectable type is a static type.
         */
        function add(obj, name, Type, dependencies, injectableType, isStatic) {
            var injector = obj[name] = new dependency.Injector(name, Type, dependencies, injectableType);
            if (isStatic === true) {
                staticInjectors[name] = injector;
            }
            return register;
        }
        /**
         * Registers the IApp with the framework. The framework will instantiate the IApp
         * when needed, and wire up the Application Lifecycle events. The dependencies array corresponds to injectables that will be
         * passed into the Constructor of the app.
         * @param {string} name The name of your app.
         * @param {new (...args: any[]) => plat.App} Type The constructor for the IApp.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the app injector.
         */
        function app(name, Type, dependencies) {
            var _Injector = acquire(__InjectorStatic), _AppStatic = acquire(__AppStatic);
            _AppStatic.registerApp(new _Injector(name, Type, dependencies));
            return register;
        }
        register.app = app;
        /**
         * Registers an Control with the framework. The framework will instantiate the
         * Control when needed. The dependencies array corresponds to injectables that
         * will be passed into the Constructor of the control.
         * @param {string} name The control type, corresponding to the HTML notation for creating a new Control (e.g. 'plat-foreach').
         * @param {new (...args: any[]) => plat.Control} Type The constructor for the Control.
         * @param {Array<any>} dependencies? An array of strings representing the dependencies needed for the Control
         * injector.
         */
        function control(name, Type, dependencies, isStatic) {
            if (isString(name)) {
                name = name.toLowerCase();
            }
            else {
                throw new Error('A Control must be registered with a string name');
            }
            if (name === 'head') {
                isStatic = true;
            }
            return add(controlInjectors, name, Type, dependencies, isStatic ? __STATIC : undefined);
        }
        register.control = control;
        /**
         * Registers an ViewControl with the framework. The framework will
         * instantiate the control when needed. The dependencies array corresponds to injectables that will be
         * passed into the Constructor of the control.
         * @param {string} name The control type, corresponding to the HTML notation for creating a new
         * ViewControl. Used for navigation to the specified ViewControl.
         * @param {new (...args: any[]) => plat.ui.ViewControl} Type The constructor for the ViewControl.
         * @param {Array<any>} dependencies? An optional array of strings representing the dependencies needed for the
         * ViewControl injector.
         */
        function viewControl(name, Type, dependencies) {
            if (isString(name)) {
                name = name.toLowerCase();
            }
            else {
                throw new Error('A ViewControl must be registered with a string name');
            }
            return add(viewControlInjectors, name, Type, dependencies);
        }
        register.viewControl = viewControl;
        function injectable(name, Type, dependencies, injectableType) {
            if (!isString(injectableType)) {
                injectableType = __SINGLETON;
            }
            else {
                injectableType = injectableType.toLowerCase();
                if (injectableType === __FACTORY || injectableType === __STATIC || injectableType === __CLASS) {
                    return add(injectableInjectors, name, Type, dependencies, injectableType, true);
                }
                else if (!(injectableType === __SINGLETON || injectableType === __INSTANCE)) {
                    throw new Error('Invalid injectable type ' + injectableType + ' during injectable registration.');
                }
            }
            return add(injectableInjectors, name, Type, dependencies, injectableType, false);
        }
        register.injectable = injectable;
        /**
         * Contains constants for injectable type.
         */
        var injectable;
        (function (injectable) {
            /**
             * Static injectables will be injected before the application loads. This provides a way to create
             * a static constructor and load dependencies into static class properties.
             */
            injectable.STATIC = __STATIC;
            /**
             * Singleton injectables will contain a constructor. A Singleton injectable will be instantiated once and
             * used throughout the application lifetime. It will be instantiated when another component is injected
             * and lists it as a dependency.
             */
            injectable.SINGLETON = __SINGLETON;
            /**
             * Instance injectables will contain a constructor. An Instance injectable will be instantiated multiple times
             * throughout the application lifetime. It will be instantiated whenever another component is injected
             * and lists it as a dependency.
             */
            injectable.INSTANCE = __INSTANCE;
            /**
             * Factory injectables will not contain a constructor but will instead contain a method for obtaining an
             * instance, such as getInstance() or create(). It will be injected before the application loads, similar to a Static
             * injectable.
             */
            injectable.FACTORY = __FACTORY;
            /**
             * Class injectables are essentially a direct reference to a class's constructor. It may contain both
             * static and instance methods as well as a constructor for creating a new instance.
             */
            injectable.CLASS = __CLASS;
        })(injectable = register.injectable || (register.injectable = {}));
        function animation(name, Type, dependencies, animationType) {
            if (isString(animationType)) {
                animationType = animationType.toLowerCase();
                if (!(animationType === __CSS || animationType === __JS)) {
                    throw new Error('Invalid animationType "' + animationType + '" during animation registration.');
                }
            }
            return add((animationType === __JS ? jsAnimationInjectors : animationInjectors), name, Type, dependencies, register.injectable.INSTANCE);
        }
        register.animation = animation;
        /**
         * Contains constants for animation type.
         */
        var animation;
        (function (animation) {
            /**
             * A CSS animation.
             */
            animation.CSS = __CSS;
            /**
             * A JavaScript animation.
             */
            animation.JS = __JS;
        })(animation = register.animation || (register.animation = {}));
    })(register = plat_1.register || (plat_1.register = {}));
    /**
     * Holds classes and interfaces related to dependency injection components in platypus.
     */
    var dependency;
    (function (dependency_1) {
        /**
         * The Injector class is used for dependency injection. You can create an injector object,
         * specify dependencies and a constructor for your component. When the injector object is
         * 'injected' it will create a new instance of your component and pass in the dependencies
         * to the constructor.
         */
        var Injector = (function () {
            /**
             * The constructor for an injector. Converts any non-string dependencies to strings to support mocking Injectors during runtime.
             * @param {string} name The name of the injected type.
             * @param {new () => T} Constructor The constructor method for the component requiring the dependency
             * injection.
             * @param {Array<any>} dependencies An array of strings specifying the injectable dependencies for the
             * associated constructor.
             * @param {string} type The type of injector, used for injectables specifying a injectableType of
             * STATIC, SINGLETON, FACTORY, INSTANCE, or CLASS. The default is SINGLETON.
             */
            function Injector(name, Constructor, dependencies, type) {
                if (type === void 0) { type = null; }
                this.name = name;
                this.Constructor = Constructor;
                this.type = type;
                var deps = this.dependencies = Injector.convertDependencies(dependencies), index = deps.indexOf(__NOOP_INJECTOR), circularReference;
                Object.defineProperty(Constructor, '__injectorName', {
                    value: name,
                    enumerable: false,
                    configurable: true,
                    writable: true
                });
                Object.defineProperty(Constructor, '__injectorDependencies', {
                    value: deps.slice(0),
                    enumerable: false,
                    configurable: true,
                    writable: true
                });
                if (index > -1) {
                    var dependency_2 = dependencies[index];
                    if (isNull(dependency_2)) {
                        throw new TypeError('The dependency for ' +
                            name + ' at index ' +
                            index + ' is undefined, did you forget to include a file?');
                    }
                    throw new TypeError('Could not resolve dependency ' +
                        dependency_2.slice(9, dependency_2.indexOf('(')) +
                        ' for ' +
                        name +
                        '. Are you using a static injectable Type?');
                }
                circularReference = Injector.__findCircularReferences(this);
                if (isString(circularReference)) {
                    throw new Error('Circular dependency detected from ' + this.name + ' to ' + circularReference + '.');
                }
                if (name === __AppStatic) {
                    var App_1 = this.inject();
                    this.dependencies = deps;
                    App_1.start();
                }
            }
            /**
             * Initializes all static injectors.
             */
            Injector.initialize = function () {
                var injectors = staticInjectors, keys = Object.keys(injectors), length = keys.length;
                for (var i = 0; i < length; ++i) {
                    injectors[keys[i]].inject();
                }
                staticInjectors = {};
            };
            /**
             * Gathers and returns the array of listed dependencies.
             * @param {Array<any>} dependencies The array of dependencies specified
             * by either their Constructor or their registered name.
             */
            Injector.getDependencies = function (dependencies) {
                if (isNull(dependencies) || isEmpty(dependencies)) {
                    return [];
                }
                var deps = [], length = dependencies.length;
                for (var i = 0; i < length; ++i) {
                    deps.push(Injector.getDependency(dependencies[i]));
                }
                return deps;
            };
            /**
             * Finds and returns the dependency.
             * @param {any} dependency an object/string used to find the dependency.
             */
            Injector.getDependency = function (dependency) {
                if (isNull(dependency) || dependency === __NOOP_INJECTOR) {
                    return Injector.__noop();
                }
                else if (Injector.isInjector(dependency)) {
                    return dependency;
                }
                return Injector.__locateInjector(dependency);
            };
            /**
             * Converts dependencies specified by their Constructors into
             * equivalent dependencies specified by their registered string
             * name.
             * @param {Array<any>} dependencies The array of dependencies specified
             * by either their Constructor or their registered name.
             */
            Injector.convertDependencies = function (dependencies) {
                if (!isArray(dependencies)) {
                    return [];
                }
                var convert = Injector.convertDependency, deps = [], length = dependencies.length;
                for (var i = 0; i < length; ++i) {
                    deps.push(convert(dependencies[i]));
                }
                return deps;
            };
            /**
             * Converts a dependency specified by its Constructors into an
             * equivalent dependency specified by its registered string
             * name.
             * @param {any} dependency The dependency specified
             * by either a Constructor or a registered name.
             */
            Injector.convertDependency = function (dependency) {
                if (isNull(dependency)) {
                    return __NOOP_INJECTOR;
                }
                return Injector.__getInjectorName(dependency);
            };
            /**
             * Checks if the object being passed in fulfills the requirements for being an Injector.
             * @param {plat.dependency.Injector<any>} dependency The object to check.
             */
            Injector.isInjector = function (dependency) {
                return isFunction(dependency.inject) &&
                    !isUndefined(dependency.type) &&
                    !isUndefined(dependency.name) &&
                    !isUndefined(dependency.Constructor);
            };
            /**
             * Gets the string name related to an injector.
             * @param {any} dependency The object to search for.
             */
            Injector.__getInjectorName = function (dependency) {
                if (isNull(dependency)) {
                    return __NOOP_INJECTOR;
                }
                else if (isString(dependency)) {
                    return dependency;
                }
                var Constructor = dependency, _inject = isObject(Constructor._inject) ? Constructor._inject : {};
                if (isString(Constructor.__injectorName)) {
                    dependency = Constructor.__injectorName;
                }
                if (!isString(dependency)) {
                    return new Injector(dependency, Constructor, _inject.dependencies);
                }
                var find = Injector.__findInjector.bind(Injector, dependency), injector = find(injectableInjectors) ||
                    find(unregisteredInjectors) ||
                    find(staticInjectors) ||
                    find(viewControlInjectors) ||
                    find(controlInjectors) ||
                    find(animationInjectors) ||
                    find(jsAnimationInjectors);
                if (!isObject(injector) && isString(dependency)) {
                    injector = unregisteredInjectors[dependency] = new Injector(dependency, Constructor, Constructor._inject.dependencies);
                }
                if (isObject(injector)) {
                    return injector.name;
                }
                return __NOOP_INJECTOR;
            };
            /**
             * Calls the injector's constructor with the associated dependencies.
             * @param {any} Constructor The Constructor to call.
             * @param {Array<any>} args The arguments to pass to the constructor.
             */
            Injector.__construct = function (Constructor, args, type) {
                if (isNull(Constructor) || isNull(Constructor.prototype)) {
                    return Constructor;
                }
                var obj = Object.create(Constructor.prototype), isInstance = type === __INSTANCE, toInject;
                if (isInstance) {
                    toInject = instanceInjectorDependencies[Constructor.__injectorName];
                }
                if (!isObject(toInject)) {
                    toInject = Injector.__walk(obj, Object.getPrototypeOf(obj), {});
                    if (isInstance) {
                        instanceInjectorDependencies[Constructor.__injectorName] = toInject;
                    }
                }
                var dependencies = acquire(map(function (value) { return value; }, toInject)), keys = Object.keys(toInject), length = keys.length;
                for (var i = 0; i < length; ++i) {
                    obj[keys[i]] = dependencies[i];
                }
                var ret = obj.constructor.apply(obj, args);
                if (!isUndefined(ret)) {
                    return ret;
                }
                return obj;
            };
            /**
             * Walks up an object's prototype, injecting dependencies if they are
             * registered on static '_inject' objects.
             * @param {any} obj The object to walk.
             * @param {any} proto the prototype of the object.
             */
            Injector.__walk = function (obj, proto, extendWith) {
                var Constructor = proto.constructor, parentInject = {};
                if (isObject(Constructor._inject) && Constructor !== Object) {
                    parentInject = Injector.__walk(obj, Object.getPrototypeOf(proto), extendWith);
                }
                var toInject = _clone(Constructor._inject, true);
                return _extend(false, false, {}, extendWith, parentInject, toInject);
            };
            /**
             * Finds an injector object with the associated constructor.
             * @param {any} Constructor The Constructor to locate.
             */
            Injector.__locateInjector = function (Constructor) {
                if (isNull(Constructor)) {
                    return;
                }
                var dependency = Constructor;
                if (isString(Constructor.__injectorName)) {
                    dependency = Constructor.__injectorName;
                }
                var find = Injector.__findInjector.bind(Injector, dependency), injector = find(injectableInjectors) ||
                    find(unregisteredInjectors) ||
                    find(staticInjectors) ||
                    find(controlInjectors) ||
                    find(viewControlInjectors) ||
                    find(animationInjectors) ||
                    find(jsAnimationInjectors);
                if (!isObject(injector)) {
                    if (isFunction(Constructor)) {
                        if (!isString(dependency)) {
                            dependency = uniqueId(__Plat);
                        }
                        injector = new Injector(dependency, Constructor, isObject(Constructor._inject) ? Constructor._injectorDependencies : []);
                        unregisteredInjectors[dependency] = injector;
                    }
                    else {
                        injector = Injector.__wrap(Constructor);
                    }
                }
                return injector;
            };
            /**
             * Finds an injector object with the associated constructor in the given InjectorObject.
             * @param {Function} Constructor The Function
             */
            Injector.__findInjector = function (Constructor, injectors) {
                if (isNull(Constructor)) {
                    return;
                }
                else if (Constructor === Injector || Constructor === __InjectorStatic) {
                    var ret = Injector.__wrap(Injector);
                    ret.name = __InjectorStatic;
                    return ret;
                }
                else if (isString(Constructor)) {
                    return injectors[Constructor] || injectors[Constructor.toLowerCase()];
                }
            };
            /**
             * Once an injector is injected, it is wrapped to prevent further injection.
             * @param {any} value The injected value.
             */
            Injector.__wrap = function (value) {
                return {
                    inject: function () { return value; },
                    name: __WRAPPED_INJECTOR,
                    dependencies: [],
                    Constructor: value
                };
            };
            /**
             * Returns an empty injector object.
             */
            Injector.__noop = function () {
                return {
                    inject: noop,
                    type: __NOOP_INJECTOR,
                    name: __NOOP_INJECTOR,
                    dependencies: [],
                    Constructor: noop
                };
            };
            /**
             * Determines if there is a circular dependency in a dependency tree.
             * @param {plat.dependency.Injector<any>} injector The starting point for the dependency tree search.
             */
            Injector.__findCircularReferences = function (injector) {
                if (!(isObject(injector) && isArray(injector.dependencies))) {
                    return;
                }
                var source = injector.name, dependencies = injector.dependencies, node, stack = [{
                        name: source,
                        dependencies: dependencies.slice(0)
                    }], dependency, locate = Injector.__locateInjector, length;
                while (stack.length > 0) {
                    node = stack.pop();
                    dependencies = node.dependencies;
                    length = dependencies.length;
                    for (var i = 0; i < length; ++i) {
                        dependency = dependencies[i];
                        if (dependency === source) {
                            return node.name;
                        }
                        injector = locate(dependency);
                        if (!(isObject(injector) && isArray(injector.dependencies))) {
                            continue;
                        }
                        stack.push({
                            name: injector.name,
                            dependencies: injector.dependencies.slice(0)
                        });
                    }
                }
            };
            /**
             * Gathers the dependencies for the Injector object and creates a new instance of the
             * Constructor, passing in the dependencies in the order they were specified. If the
             * Injector contains a Constructor for an injectable and the Constructor is registered
             * as a SINGLE type it will only inject that injectable once.
             */
            Injector.prototype.inject = function () {
                var toInject = [], type = this.type;
                var dependencies = this.dependencies, length = dependencies.length, dependency, injectable;
                for (var i = 0; i < length; ++i) {
                    dependency = Injector.getDependency(dependencies[i]);
                    toInject.push(dependency.inject());
                }
                injectable = Injector.__construct(this.Constructor, toInject, type);
                if (isString(type) && type !== __INSTANCE) {
                    this._wrapInjector(injectable);
                }
                injectable.__injectable__type = type;
                return injectable;
            };
            /**
             * Wraps the injector with the instantiated value in the case of a
             * SINGLE or STATIC type so that it does not re-instantiate.
             * @param {any} value The value to wrap
             */
            Injector.prototype._wrapInjector = function (value) {
                this.inject = function () {
                    return value;
                };
                return this;
            };
            return Injector;
        }());
        dependency_1.Injector = Injector;
        /**
         * Publically exposes all the dependency injector objects.
         */
        var injectors;
        (function (injectors) {
            /**
             * An InjectorObject of Controls.
             * Contains all the registered controls for an application.
             */
            injectors.control = controlInjectors;
            /**
             * An InjectorObject of IBaseViewControls.
             * Contains all the registered view controls for an application.
             */
            injectors.viewControl = viewControlInjectors;
            /**
             * An InjectorObject of objects. Contains all the registered
             * injectables for an application.
             */
            injectors.injectable = injectableInjectors;
            /**
             * An InjectorObject of static objects. Contains all the registered
             * static injectables for an application. Once the injectables have been injected, they are removed from this object.
             */
            injectors.staticInjectable = staticInjectors;
            /**
             * An InjectorObject of animations. Can be either CSS or JS implementations.
             */
            injectors.animation = animationInjectors;
            /**
             * An InjectorObject  of animations. Should only contain JS implementations.
             */
            injectors.jsAnimation = jsAnimationInjectors;
        })(injectors = dependency_1.injectors || (dependency_1.injectors = {}));
    })(dependency = plat_1.dependency || (plat_1.dependency = {}));
    if (!isUndefined(window)) {
        if (isUndefined(window.plat)) {
            window.plat = plat;
        }
        if (isUndefined(window.module)) {
            window.module = {};
        }
    }
    function acquire(dependencies) {
        var deps, array = isArray(dependencies);
        if (array) {
            deps = dependency.Injector.getDependencies(dependencies);
        }
        else {
            deps = dependency.Injector.getDependencies([dependencies]);
        }
        var length = deps.length, output = [];
        for (var i = 0; i < length; ++i) {
            output.push(deps[i].inject());
        }
        if (!array) {
            return output[0];
        }
        return output;
    }
    plat_1.acquire = acquire;
    /**
     * Holds all classes and interfaces related to debugging components in platypus.
     */
    var debug;
    (function (debug) {
        /**
         * Handles all logging/debugging for the framework. All logs will be bubbled up to the
         * App.error event to allow for easy debugging.
         */
        var Log = (function () {
            function Log() {
                /**
                 * The ERROR log level
                 */
                this.ERROR = 5;
                /**
                 * The WARN log level
                 */
                this.WARN = 4;
                /**
                 * The INFO log level
                 */
                this.INFO = 3;
                /**
                 * The DEBUG log level
                 */
                this.DEBUG = 2;
                /**
                 * The TRACE log level
                 */
                this.TRACE = 1;
                /**
                 * A configurable log level (defaults to INFO). Any logs sent below this
                 * will be silent.
                 */
                this._level = this.INFO;
            }
            /**
             * Logs fatal errors. This will throw the error after it is logged.
             * @param {Error} error The error to log.
             */
            Log.prototype.error = function (error) {
                this._log(error, this.ERROR);
                throw error;
            };
            Log.prototype.warn = function (message) {
                this._log(message, this.WARN);
            };
            Log.prototype.info = function (message) {
                this._log(message, this.INFO);
            };
            Log.prototype.debug = function (message) {
                this._log(message, this.DEBUG);
            };
            Log.prototype.trace = function (message) {
                this._log(message, this.TRACE);
            };
            Log.prototype.setLogLevel = function (level) {
                if (isString(level)) {
                    level = this[level.toUpperCase()];
                }
                switch (level) {
                    case this.ERROR:
                    case this.WARN:
                    case this.INFO:
                    case this.DEBUG:
                    case this.TRACE:
                        this._level = level;
                        break;
                    default:
                        this._level = this.INFO;
                }
            };
            Log.prototype._log = function (message, level) {
                if (!this._shouldLog(level)) {
                    return;
                }
                if (isString(message)) {
                    message = new Error(message);
                }
                var _ErrorEvent = this._ErrorEvent;
                if (isNull(_ErrorEvent)) {
                    _ErrorEvent = this._ErrorEvent = acquire(__ErrorEventStatic);
                }
                _ErrorEvent.dispatch(__error, Log, message, level);
            };
            /**
             * Detemines whether or not a log level is at or above the current minimum log level.
             * @param {number} level The log level to check against the current minimum log level.
             */
            Log.prototype._shouldLog = function (level) {
                if (!isNumber(level)) {
                    level = this.INFO;
                }
                return this._level < level;
            };
            return Log;
        }());
        debug.Log = Log;
        register.injectable(__Log, Log);
    })(debug = plat_1.debug || (plat_1.debug = {}));
    /**
     * A class containing boolean values signifying browser
     * and/or platform compatibilities.
     */
    var Compat = (function () {
        /**
         * Define everything.
         */
        function Compat() {
            /**
             * An object containing all event lookups.
             */
            this.__events = {};
            this.__defineBooleans();
            this.__defineMappedEvents();
            this.__defineVendorDependencies();
            this.__determineCss();
        }
        /**
         * Check whether or not an event exists.
         * @param {string} event The event to check the existence of.
         */
        Compat.prototype.hasEvent = function (event) {
            var events = this.__events, eventExists = events[event];
            if (isUndefined(eventExists)) {
                var element = this._document.createElement('div');
                if (event === 'input' && this.IE === 9) {
                    eventExists = events[event] = false;
                }
                else {
                    eventExists = events[event] = !isUndefined(element[('on' + event)]);
                }
            }
            return eventExists;
        };
        /**
         * Define booleans.
         */
        Compat.prototype.__defineBooleans = function () {
            var _window = this._window, navigator = _window.navigator || {}, userAgent = (navigator.userAgent || '').toLowerCase(), history = this._history, def = _window.define, msA = _window.MSApp, winJs = _window.WinJS, android = (/android ((?:\d|\.)+)/.exec(userAgent) || [])[1];
            if (isString(android) && !/iemobile/i.test(userAgent)) {
                android = parseInt(android.replace(/\./g, ''), 10);
            }
            this.isCompatible = isFunction(Object.defineProperty) && isFunction(this._document.querySelector);
            this.cordova = !isNull(_window.cordova);
            this.pushState = !(isNull(history) || isNull(history.pushState));
            this.fileSupported = !(isUndefined(_window.File) || isUndefined(_window.FormData));
            this.amd = isFunction(def) && !isNull(def.amd);
            this.msApp = isObject(msA) && isFunction(msA.execUnsafeLocalFunction);
            this.winJs = isObject(winJs) && isObject(winJs.Application);
            this.indexedDb = !isNull(_window.indexedDB);
            this.proto = isObject({}.__proto__);
            this.getProto = isFunction(Object.getPrototypeOf);
            this.setProto = isFunction(Object.setPrototypeOf);
            this.hasTouchEvents = !isUndefined(_window.ontouchstart);
            this.hasPointerEvents = !!navigator.pointerEnabled;
            this.hasMsPointerEvents = !!navigator.msPointerEnabled;
            if (isNumber(android)) {
                this.ANDROID = android;
                return;
            }
            var ie = parseInt((/msie (\d+)/.exec(userAgent) || [])[1], 10) ||
                parseInt((/trident\/.*; rv:(\d+)/.exec(userAgent) || [])[1], 10);
            if (isNumber(ie)) {
                this.IE = ie;
            }
        };
        /**
         * Define mapped events
         */
        Compat.prototype.__defineMappedEvents = function () {
            if (this.hasPointerEvents) {
                this.mappedEvents = {
                    $touchstart: 'pointerdown',
                    $touchend: 'pointerup',
                    $touchmove: 'pointermove',
                    $touchcancel: 'pointercancel'
                };
            }
            else if (this.hasMsPointerEvents) {
                this.mappedEvents = {
                    $touchstart: 'MSPointerDown',
                    $touchend: 'MSPointerUp',
                    $touchmove: 'MSPointerMove',
                    $touchcancel: 'MSPointerCancel'
                };
            }
            else if (this.hasTouchEvents) {
                this.mappedEvents = {
                    $touchstart: 'touchstart',
                    $touchend: 'touchend',
                    $touchmove: 'touchmove',
                    $touchcancel: 'touchcancel'
                };
            }
            else {
                this.mappedEvents = {
                    $touchstart: 'mousedown',
                    $touchend: 'mouseup',
                    $touchmove: 'mousemove',
                    $touchcancel: null
                };
            }
        };
        /**
         * Define animation events and other vendor prefix
         * dependencies.
         */
        Compat.prototype.__defineVendorDependencies = function () {
            var _window = this._window, documentElement = this._document.documentElement, styles = _window.getComputedStyle(documentElement, ''), matches = Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/), prefix, dom, css, jsSyntax;
            if ((isArray(matches) && matches.length > 1)) {
                prefix = (isArray(matches) && matches.length > 1) ? matches[1] : '';
                jsSyntax = prefix[0].toUpperCase() + prefix.slice(1);
                dom = ('WebKit|Moz|MS').match(new RegExp('(' + prefix + ')', 'i'))[1];
                css = '-' + prefix + '-';
            }
            else if (!isUndefined(styles.OLink)) {
                prefix = 'o';
                jsSyntax = dom = 'O';
                css = '-o-';
            }
            else {
                prefix = jsSyntax = dom = css = '';
            }
            this.vendorPrefix = {
                dom: dom,
                lowerCase: prefix,
                css: css,
                upperCase: jsSyntax
            };
            this.requestAnimationFrame = _window.requestAnimationFrame || _window[prefix + 'RequestAnimationFrame'];
            this.cancelAnimationFrame = _window.cancelAnimationFrame ||
                _window[prefix + 'CancelRequestAnimationFrame'] ||
                _window[prefix + 'CancelAnimationFrame'];
            var style = documentElement.style;
            // handle Android issue where style.transition exists but transition events still need vendor prefix 
            // should only affect version 4.1 but we will handle for < 4.4. 
            if ((isUndefined(this.ANDROID) || Math.floor(this.ANDROID / 10) >= 44) &&
                !(isUndefined(style.animation) || isUndefined(style.transition))) {
                this.animationSupported = true;
                this.animationEvents = {
                    $animation: 'animation',
                    $animationStart: 'animationstart',
                    $animationEnd: 'animationend',
                    $animationIteration: 'animationiteration',
                    $transition: 'transition',
                    $transitionStart: 'transitionstart',
                    $transitionEnd: 'transitionend'
                };
            }
            else if (!(isUndefined(style[jsSyntax + 'Animation']) || isUndefined(style[jsSyntax + 'Transition'])) ||
                !(isUndefined(style[prefix + 'Animation']) || isUndefined(style[prefix + 'Transition'])) ||
                !(isUndefined(style[dom + 'Animation']) || isUndefined(style[dom + 'Transition']))) {
                this.animationSupported = true;
                this.animationEvents = {
                    $animation: prefix + 'Animation',
                    $animationStart: prefix + 'AnimationStart',
                    $animationEnd: prefix + 'AnimationEnd',
                    $animationIteration: prefix + 'AnimationIteration',
                    $transition: prefix + 'Transition',
                    $transitionStart: prefix + 'TransitionStart',
                    $transitionEnd: prefix + 'TransitionEnd'
                };
            }
        };
        /**
         * Determines whether or not platypus css styles exist.
         */
        Compat.prototype.__determineCss = function () {
            var _document = this._document, head = _document.head, element = _document.createElement('div');
            element.setAttribute(__Hide, '');
            head.insertBefore(element, null);
            var computedStyle = this._window.getComputedStyle(element), display = computedStyle.display, visibility = computedStyle.visibility;
            this.platCss = display === 'none' || visibility === 'hidden';
            head.removeChild(element);
        };
        Compat._inject = {
            _window: __Window,
            _history: __History,
            _document: __Document
        };
        return Compat;
    }());
    plat_1.Compat = Compat;
    register.injectable(__Compat, Compat);
    /**
     * An extensible class defining common utilities and helper functions.
     */
    var Utils = (function () {
        function Utils() {
        }
        /**
         * An empty method for quickly creating dummy objects.
         */
        Utils.prototype.noop = function () { };
        /**
         * Allows you to extend the properties of an object with any number
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is only a shallow copy of
         * all the source objects to the destination object.
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the
         * destination object.
         */
        Utils.prototype.extend = function (destination) {
            var sources = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                sources[_i - 1] = arguments[_i];
            }
            return _extend.apply(null, [false, false, destination].concat(sources));
        };
        /**
         * Allows you to extend the properties of an object with any number
         * of other objects. If objects share properties, the last object in the
         * arguments will take precedence. This method is a deep copy of
         * all the source objects to the destination object.
         * @param {any} destination The destination object to extend.
         * @param {Array<any>} ...sources Any number of objects with which to extend the
         * destination object.
         */
        Utils.prototype.deepExtend = function (destination) {
            var sources = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                sources[_i - 1] = arguments[_i];
            }
            return _extend.apply(null, [true, false, destination].concat(sources));
        };
        /**
         * Creates a copy of the passed-in object. If deep is true it will
         * be a deep copy (duplicate), else nested objects/arrays will be copied by reference
         * and not duplicated.
         * @param {T} obj The object to clone.
         * @param {boolean} deep? Whether or not it is a deep clone.
         */
        Utils.prototype.clone = function (obj, deep) {
            return _clone(obj, deep);
        };
        /**
         * Takes in anything and determines if it is a type of Object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isObject = function (obj) {
            return isObject(obj);
        };
        /**
         * Takes in anything and determines if it is a window object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isWindow = function (obj) {
            return isWindow(obj);
        };
        /**
         * Takes in anything and determines if it is a document object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isDocument = function (obj) {
            return isDocument(obj);
        };
        /**
         * Takes in anything and determines if it is a Node.
         * @param {any} obj Anything.
         */
        Utils.prototype.isNode = function (obj) {
            return isNode(obj);
        };
        /**
         * Takes in anything and determines if it is a DocumentFragment.
         * @param {any} obj Anything.
         */
        Utils.prototype.isDocumentFragment = function (obj) {
            return isDocumentFragment(obj);
        };
        /**
         * Takes in anything and determines if it is a string.
         * @param {any} obj Anything.
         */
        Utils.prototype.isString = function (obj) {
            return isString(obj);
        };
        /**
         * Takes in anything and determines if it is a RegExp object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isRegExp = function (obj) {
            return isRegExp(obj);
        };
        /**
         * Takes in anything and determines if it is a Promise object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isPromise = function (obj) {
            return isPromise(obj);
        };
        /**
         * Takes in anything and determines if it is empty. Useful for
         * checking for empty strings, arrays, or objects without keys.
         * @param {any} obj Anything.
         */
        Utils.prototype.isEmpty = function (obj) {
            return isEmpty(obj);
        };
        /**
         * Takes in anything and determines if it is a boolean.
         * @param {any} obj Anything.
         */
        Utils.prototype.isBoolean = function (obj) {
            return isBoolean(obj);
        };
        /**
         * Takes in anything and determines if it is a number.
         * @param {any} obj Anything.
         */
        Utils.prototype.isNumber = function (obj) {
            return isNumber(obj);
        };
        /**
         * Takes in anything and determines if it is a File.
         * @param {any} obj Anything.
         */
        Utils.prototype.isFile = function (obj) {
            return isFile(obj);
        };
        /**
         * Takes in anything and determines if it is a function.
         * @param {any} obj Anything.
         */
        Utils.prototype.isFunction = function (obj) {
            return isFunction(obj);
        };
        /**
         * Takes in anything and determines if it is null or undefined.
         * @param {any} obj Anything.
         */
        Utils.prototype.isNull = function (obj) {
            return isNull(obj);
        };
        /**
         * Takes in anything and determines if it is undefined.
         * @param {any} obj Anything.
         */
        Utils.prototype.isUndefined = function (obj) {
            return isUndefined(obj);
        };
        /**
         * Takes in anything and determines if it is an Array.
         * @param {any} obj Anything.
         */
        Utils.prototype.isArray = function (obj) {
            return isArray(obj);
        };
        /**
         * Takes in anything and determines if it has array-like qualities.
         * @param {any} obj Anything.
         */
        Utils.prototype.isArrayLike = function (obj) {
            return isArrayLike(obj);
        };
        /**
         * Takes in anything and determines if it is a Date object.
         * @param {any} obj Anything.
         */
        Utils.prototype.isDate = function (obj) {
            return isDate(obj);
        };
        Utils.prototype.filter = function (iterator, obj, context) {
            return filter(iterator, obj, context);
        };
        /**
         * Takes in a list and object containing key/value pairs to search for in the list.
         * @param {Object} properties An object containing key/value pairs to match with obj's values.
         * @param {Array<T>} array The list used for searching for properties.
         */
        Utils.prototype.where = function (properties, array) {
            return where(properties, array);
        };
        Utils.prototype.forEach = function (iterator, obj, context) {
            return forEach(iterator, obj, context);
        };
        Utils.prototype.map = function (iterator, obj, context) {
            return map(iterator, obj, context);
        };
        Utils.prototype.mapAsync = function (iterator, obj, context) {
            return mapAsync(iterator, obj, context);
        };
        /**
         * Takes in an array and an iterator function. Calls the iterator with all the values in the array. The
         * iterator can return a promise the will resolve with the mapped value. The next value in the array will not be passed to
         * the iterator until the previous promise fulfills.
         * @param {plat.IListIterator<T, plat.async.IThenable<R>>} iterator The transformation function.
         * @param {Array<T>} array An Array.
         * @param {any} context? An optional context to bind to the iterator.
         */
        Utils.prototype.mapAsyncInOrder = function (iterator, array, context) {
            return mapAsyncInOrder(iterator, array, context);
        };
        /**
         * Takes in an array and an iterator function. Calls the iterator with all the values in the array in descending order. The
         * iterator can return a promise the will resolve with the mapped value. The next value in the array will not be passed to
         * the iterator until the previous promise fulfills.
         * @param {plat.IListIterator<T, plat.async.IThenable<R>>} iterator The transformation function.
         * @param {Array<T>} array An Array.
         * @param {any} context? An optional context to bind to the iterator.
         */
        Utils.prototype.mapAsyncInDescendingOrder = function (iterator, array, context) {
            return mapAsyncInDescendingOrder(iterator, array, context);
        };
        /**
         * Takes in an object and a property to extract from all of the object's values. Returns an array of
         * the 'plucked' values.
         * @param {string} key The property to 'pluck' from each value in the array.
         * @param {Array<T>} array The array to pluck the key from
         */
        Utils.prototype.pluck = function (key, array) {
            return pluck(key, array);
        };
        Utils.prototype.some = function (iterator, obj, context) {
            return some(iterator, obj, context);
        };
        /**
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until
         * after the current call stack is clear. Equivalent to a setTimeout with a timeout of 0.
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.postpone = function (method, args, context) {
            return defer(method, 0, args, context);
        };
        /**
         * Takes in a method and array of arguments to pass to that method. Delays calling the method until
         * after the current call stack is clear. Equivalent to a setTimeout with the specified timeout value.
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {number} timeout The time (in milliseconds) to delay before calling the provided method.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.defer = function (method, timeout, args, context) {
            return defer(method, timeout, args, context);
        };
        /**
         * Takes in a method and array of arguments to pass to that method. Adds the method to the call stack every
         * interval amount of time. Equivalent to a setInterval with the specified interval value.
         * @param {(...args: Array<any>) => void} method The method to call.
         * @param {number} interval The time (in milliseconds) between each consecutive call of the provided method.
         * @param {Array<any>} args? The arguments to apply to the method.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.setInterval = function (method, interval, args, context) {
            return setIntervalGlobal(method, interval, args, context);
        };
        /**
         * Uses requestAnimationFrame if it is available, else it does a setTimeout.
         * @param {FrameRequestCallback} method The method to call when the request is fulfilled.
         * @param {any} context? An optional context to bind to the method.
         */
        Utils.prototype.requestAnimationFrame = function (method, context) {
            return requestAnimationFrameGlobal(method, context);
        };
        /**
         * Takes in a prefix and returns a unique identifier string with the prefix preprended. If no prefix
         * is specified, none will be prepended.
         * @param {string} prefix? A string prefix to prepend tothe unique ID.
         */
        Utils.prototype.uniqueId = function (prefix) {
            return uniqueId(prefix);
        };
        /**
         * Takes in a spinal-case, dot.case, or snake_case string and returns
         * a camelCase string. Also can turn a string into camelCase with space
         * as a delimeter.
         * @param {string} str The spinal-case, dot.case, or snake_case string.
         */
        Utils.prototype.camelCase = function (str) {
            return camelCase(str);
        };
        /**
         * Takes a camelCase string and delimits it using the specified delimiter.
         * @param {string} str The camelCased string.
         * @param {string} delimiter The delimiter to add.
         */
        Utils.prototype.delimit = function (str, delimiter) {
            return delimit(str, delimiter);
        };
        return Utils;
    }());
    plat_1.Utils = Utils;
    register.injectable(__Utils, Utils);
    /**
     */
    function Window() {
        return window;
    }
    plat_1.Window = Window;
    register.injectable(__Window, Window);
    /**
     */
    function Document(_window) {
        return _window.document;
    }
    plat_1.Document = Document;
    register.injectable(__Document, Document, [__Window]);
    /**
     * Holds classes and interfaces related to expression handling in platypus.
     */
    var expressions;
    (function (expressions) {
        /**
         * A class for keeping track of commonly used regular expressions.
         */
        var Regex = (function () {
            function Regex() {
                /**
                 * A regular expression for finding markup in a string.
                 */
                this.markupRegex = new RegExp(__startSymbol + '[\\S\\s]*' + __endSymbol);
                /**
                 * Finds the arguments in a method expression.
                 */
                this.argumentRegex = /\((.*)\)/;
                /**
                 * Finds '/*.html' or '/*.htm' in a url. Useful for removing
                 * the html file out of the url.
                 */
                this.initialUrlRegex = /\/[^\/]*\.(?:html|htm)/;
                /**
                 * Finds a protocol delimeter in a string (e.g. ://).
                 */
                this.protocolRegex = /:\/\//;
                /**
                 * Looks for any invalid variable syntax.
                 */
                this.invalidVariableRegex = /[^a-zA-Z0-9@_$]/;
                /**
                 * Grabs the file name from a file path.
                 */
                this.fileNameRegex = /.*(?:\/|\\)/;
                /**
                 * Determines if a character is correlated with a shifted key code.
                 */
                this.shiftedKeyRegex = /[A-Z!@#$%^&*()_+}{":?><|~]/;
                /**
                 * Determines if a url is relative or absolute.
                 */
                this.fullUrlRegex = /^(?:[a-z0-9\-]+:)(?:\/\/)?|(?:\/\/)/i;
                /**
                 * Determines if an email address is valid.
                 */
                this.validateEmail = new RegExp('^(([^<>()[\\]\\\.,;:\\s@\\"]+(\\.[^<>()[\\]\\\.,;:\\s@\\"]+)*)|' +
                    '(\\".+\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|' +
                    '(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$');
                /**
                 * Determines if a telephone number is valid.
                 */
                this.validateTelephone = /^\+?[0-9\.\(\)\s-]*$/;
                /**
                 * A regular expression for matching dynamic segments in a route.
                 */
                this.dynamicSegmentsRegex = /^:([^\/]+)$/;
                /**
                 * A regular expression for matching splat segments in a route.
                 */
                this.splatSegmentRegex = /^\*([^\/]+)$/;
            }
            Object.defineProperty(Regex.prototype, "newLineRegex", {
                /**
                 * A regular expression for matching or removing all newline characters.
                 */
                get: function () {
                    return /\r|\n/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "optionalRouteRegex", {
                /**
                 * Finds optional parameters in a route string.
                 */
                get: function () {
                    return /\((.*?)\)/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "namedParameterRouteRegex", {
                /**
                 * Finds named parameters in a route string.
                 */
                get: function () {
                    return /(\(\?)?:\w+/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "wildcardRouteRegex", {
                /**
                 * Finds an alphanumeric wildcard match in a route string.
                 * exec('/foo/*bar/baz');
                 */
                get: function () {
                    return /\*\w*/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "escapeRouteRegex", {
                /**
                 * Finds invalid characters in a route string.
                 */
                get: function () {
                    return /[\-{}\[\]+?.,\\\^$|#\s]/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "camelCaseRegex", {
                /**
                 * Finds delimeters for spinal-case, snake_case, and dot.case.
                 * useful for converting to camelCase. Also can turn a string
                 * into camelCase with space as a delimeter.
                 */
                get: function () {
                    return /([\-_\.\s])(\w+?)/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "capitalCaseRegex", {
                /**
                 * Finds all capital letters.
                 */
                get: function () {
                    return /[A-Z]/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "whiteSpaceRegex", {
                /**
                 * Finds all whitespace and newline characters
                 * not in string literals. Needs to be combined
                 * with string replace function using $1 argument.
                 */
                get: function () {
                    return /("[^"]*?"|'[^']*?')|[\s\r\n\t\v]/g;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Regex.prototype, "quotationRegex", {
                /**
                 * Finds all single and double quotes.
                 */
                get: function () {
                    return /'|"/g;
                },
                enumerable: true,
                configurable: true
            });
            return Regex;
        }());
        expressions.Regex = Regex;
        register.injectable(__Regex, Regex);
        /**
         * A class that is responsible for taking in a JavaScript expression string and
         * finding all of its tokens (i.e. delimiters, operators, etc).
         */
        var Tokenizer = (function () {
            function Tokenizer() {
                /**
                 * The previous character during tokenization.
                 */
                this.__previousChar = '';
                /**
                 * A regular expression for determining if a potential variable is valid syntax.
                 */
                this.__variableRegex = acquire(__Regex).invalidVariableRegex;
                /**
                 * A queue used for determining the output of the tokenization.
                 */
                this.__outputQueue = [];
                /**
                 * A stack used for determining operator precedence and aiding with the evaluation
                 * operands.
                 */
                this.__operatorStack = [];
                /**
                 * A collection used for determining argument count for certain operations.
                 */
                this.__argCount = [];
                /**
                 * A collection used for determining argument count for certain object literal operations.
                 */
                this.__objArgCount = [];
                /**
                 * The last character encountered while in an operation dealing with the colon operator.
                 * Needs to be an array due to the possibility of nested colon operations.
                 */
                this.__lastColonChar = [];
                /**
                 * The last character encountered while in an operation dealing with commas.
                 * Needs to be an array due to the possibility of nested comma operations.
                 */
                this.__lastCommaChar = [];
            }
            /**
             * Takes in an expression string and outputs a tokenized collection of
             * ITokens.
             * @param {string} input The JavaScript expression string to tokenize.
             */
            Tokenizer.prototype.createTokens = function (input) {
                if (isNull(input)) {
                    return [];
                }
                this._input = input;
                var char, length = input.length, ternary = 0, ternaryFound = false, isSpace = this._isSpace, isAlphaNumeric = this._isAlphaNumeric;
                for (var index = 0; index < length; index++) {
                    char = input[index];
                    // space 
                    if (isSpace(char)) {
                        continue;
                    }
                    else if (isAlphaNumeric(char)) {
                        index = this.__handleAplhaNumeric(index, char);
                    }
                    else if (isDelimiter(char)) {
                        switch (char) {
                            case '.':
                                index = this.__handlePeriod(index, char);
                                break;
                            case '{':
                                this.__handleLeftBrace(char);
                                break;
                            case '}':
                                this.__handleRightBrace(char);
                                break;
                            case '[':
                                this.__handleLeftBracket(char);
                                break;
                            case ']':
                                this.__handleRightBracket(char);
                                break;
                            case '(':
                                this.__handleLeftParenthesis(char);
                                break;
                            case ')':
                                this.__handleRightParenthesis(char);
                                break;
                            case ',':
                                this.__handleComma(char);
                                break;
                            case '\'':
                            case '"':
                                index = this.__handleStringLiteral(index, char);
                                break;
                        }
                    }
                    else if (isOperator(char)) {
                        switch (char) {
                            case '?':
                                ternaryFound = true;
                                ternary++;
                                this.__handleQuestion(char);
                                break;
                            case ':':
                                ternary = this.__handleColon(char, ternary);
                                break;
                            default:
                                index = this.__handleOtherOperator(index, char);
                        }
                    }
                    else if (char === ';') {
                        this._throwError('Unexpected semicolon');
                        return [];
                    }
                    this.__previousChar = char;
                }
                if (ternaryFound && (ternary > 0)) {
                    this._throwError('Improper ternary expression');
                    return [];
                }
                else if (this.__objArgCount.length > 0) {
                    this._throwError('Improper object literal');
                    return [];
                }
                this.__popRemainingOperators();
                var output = this.__outputQueue;
                this._resetTokenizer();
                return output;
            };
            /**
             * Determines character type.
             * @param {string} char The character to check.
             * @param {boolean} isNumberLike Whether or not the character resembles a number.
             */
            Tokenizer.prototype._checkType = function (char, isNumberLike) {
                if (isNumberLike) {
                    return this._isNumeric(char);
                }
                return this._isAlphaNumeric(char);
            };
            /**
             * Looks ahead in the expression to group similar character types.
             * @param {string} char The current character in the expression string.
             * @param {number} index The current index in the expression string.
             * @param {boolean} isNumberLike Whether or not the character resembles a number.
             */
            Tokenizer.prototype._lookAhead = function (char, index, isNumberLike) {
                var ch, input = this._input, maxLength = input.length;
                while (++index < maxLength) {
                    ch = input[index];
                    if (this._checkType(ch, isNumberLike)) {
                        char += ch;
                    }
                    else {
                        break;
                    }
                }
                return char;
            };
            /**
             * Looks ahead in the expression to try and complete the
             * current operator.
             * @param {string} char The operator to find.
             * @param {number} index The current index in the expression string.
             */
            Tokenizer.prototype._lookAheadForOperatorFn = function (char, index) {
                var ch, fn = char, input = this._input, maxLength = input.length;
                while (++index < maxLength) {
                    ch = input[index];
                    fn += ch;
                    if (isOperator(fn)) {
                        char = fn;
                    }
                    else {
                        break;
                    }
                }
                return char;
            };
            /**
             * Looks ahead in the expression until it comes to the ending
             * character to try and complete a particular sequence
             * (e.g. - a string literal). Also strips the first and last
             * characters of the result (i.e. removes the delimiters).
             * @param {string} endChar The ending character.
             * @param {number} index The current index in the expression string.
             */
            Tokenizer.prototype._lookAheadForDelimiter = function (endChar, index) {
                var char = '', ch, input = this._input, maxLength = input.length;
                while ((++index < maxLength) && (ch = input[index]) !== endChar) {
                    char += ch;
                }
                return char;
            };
            /**
             * Pops the operator stack onto the output queue until a particular
             * operator value is reached.
             * @param {plat.expressions.IToken} topOperator The top of the operator stack.
             * @param {string} char The operator value being searched for.
             * @param {string} error The error to throw in the case that the expression
             * is invalid.
             */
            Tokenizer.prototype._popStackForVal = function (topOperator, char, error) {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack;
                while (topOperator.val !== char) {
                    outputQueue.push(operatorStack.shift());
                    topOperator = operatorStack[0];
                    if (operatorStack.length === 0) {
                        return this._throwError(error);
                    }
                }
            };
            /**
             * Check if the "val" property on an IToken
             * is present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Tokenizer.prototype._isValEqual = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return isNull(char);
                }
                else if (obj.val === '') {
                    return char === '';
                }
                return char.indexOf(obj.val) !== -1;
            };
            /**
             * Check if the "val" property on an IToken
             * is not present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Tokenizer.prototype._isValUnequal = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return !isNull(char);
                }
                else if (obj.val === '') {
                    return char !== '';
                }
                return char.indexOf(obj.val) === -1;
            };
            /**
             * Resets all the tokenizer's properties.
             */
            Tokenizer.prototype._resetTokenizer = function () {
                this._input = null;
                this.__previousChar = '';
                this.__outputQueue = [];
                this.__operatorStack = [];
                this.__argCount = [];
                this.__objArgCount = [];
                this.__lastColonChar = [];
                this.__lastCommaChar = [];
            };
            /**
             * Throws a fatal exception in the case of an error.
             * @param {string} error The error message to throw.
             */
            Tokenizer.prototype._throwError = function (error) {
                this._log.error(new Error(error + ' in ' + this._input));
            };
            /**
             * Checks if a single character is numeric.
             * @param {string} char The character to check.
             */
            Tokenizer.prototype._isNumeric = function (char) {
                return ('0' <= char && char <= '9');
            };
            /**
             * Checks if a single character is a space.
             * @param {string} char The character to check.
             */
            Tokenizer.prototype._isSpace = function (char) {
                return (char === ' ' ||
                    char === '\r' ||
                    char === '\n' ||
                    char === '\t' ||
                    char === '\v' ||
                    char === '\u00A0');
            };
            /**
             * Checks if a single character is alphanumeric.
             * @param {string} char The character to check.
             */
            Tokenizer.prototype._isAlphaNumeric = function (char) {
                return ('a' <= char && char <= 'z' ||
                    'A' <= char && char <= 'Z' ||
                    '0' <= char && char <= '9' ||
                    '@' === char ||
                    '_' === char ||
                    '$' === char);
            };
            /**
             * Checks if a string has proper JavaScript variable syntax.
             * @param {string} input The string to check.
             */
            Tokenizer.prototype._isStringValidVariable = function (input) {
                return !this.__variableRegex.test(input);
            };
            /**
             * Handles tokenizing an alphanumeric character.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleAplhaNumeric = function (index, char) {
                var isNumberLike = this._isNumeric(char), lookAhead = this._lookAhead(char, index, isNumberLike);
                this.__outputQueue.push(isNumberLike ? ({ val: Number(lookAhead), args: 0 }) :
                    ({ val: lookAhead, args: -1 }));
                return index + lookAhead.length - 1;
            };
            /**
             * Handles tokenizing a "." character.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handlePeriod = function (index, char) {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack, topOutputLength = outputQueue.length - 1, previousChar = this.__previousChar, lookAhead;
                // if output queue is null OR space or operator or ( or , before . 
                if (topOutputLength < 0 ||
                    this._isSpace(previousChar) ||
                    !isNull(OPERATORS[previousChar]) ||
                    previousChar === '(' ||
                    previousChar === ',') {
                    lookAhead = this._lookAhead(char, index, true);
                    index += lookAhead.length - 1;
                    outputQueue.push({ val: parseFloat(lookAhead), args: 0 });
                }
                else if (this._isValEqual(operatorStack[0], char)) {
                    outputQueue.push({ val: char, args: 0 });
                }
                else if (!(isNull(outputQueue[topOutputLength]) ||
                    !isNumber(Number(outputQueue[topOutputLength].val)) ||
                    this._isValEqual(outputQueue[topOutputLength - 1], char))) {
                    lookAhead = this._lookAhead(char, index, true);
                    index += lookAhead.length - 1;
                    outputQueue[topOutputLength].val += parseFloat(lookAhead);
                }
                else {
                    operatorStack.unshift({ val: char, args: 0 });
                }
                return index;
            };
            /**
             * Handles tokenizing a "{" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleLeftBrace = function (char) {
                this.__operatorStack.unshift({ val: char, args: 0 });
                this.__objArgCount.push(0);
                this.__lastColonChar.push(char);
                this.__lastCommaChar.push(char);
            };
            /**
             * Handles tokenizing a "}" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleRightBrace = function (char) {
                var operatorStack = this.__operatorStack, topOperator = operatorStack[0], lastArgCount = this.__objArgCount.pop();
                if (isNull(topOperator)) {
                    return this._throwError('Improper object literal');
                }
                this._popStackForVal(topOperator, '{', 'Improper object literal');
                // pop left brace off stack 
                operatorStack.shift();
                this.__lastColonChar.pop();
                this.__lastCommaChar.pop();
                this.__outputQueue.push({ val: '{}', args: lastArgCount });
            };
            /**
             * Handles tokenizing a "[" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleLeftBracket = function (char) {
                var previousChar = this.__previousChar, operatorStack = this.__operatorStack;
                if (this._isValEqual(operatorStack[0], '.')) {
                    this.__outputQueue.push(operatorStack.shift());
                }
                operatorStack.unshift({ val: char, args: 0 });
                this.__argCount.push({
                    num: 0,
                    isArray: !(previousChar === ']' ||
                        previousChar === ')' ||
                        this._isAlphaNumeric(previousChar))
                });
                this.__lastCommaChar.push(char);
            };
            /**
             * Handles tokenizing a "]" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleRightBracket = function (char) {
                var operatorStack = this.__operatorStack, topOperator = operatorStack[0], lastArgCountObj = this.__argCount.pop();
                if (isNull(topOperator) || isNull(lastArgCountObj)) {
                    return this._throwError('Brackets mismatch');
                }
                if (!lastArgCountObj.isArray) {
                    lastArgCountObj.num--;
                }
                this._popStackForVal(topOperator, '[', 'Brackets mismatch');
                // pop left bracket off stack 
                operatorStack.shift();
                this.__lastCommaChar.pop();
                // check if function on top of stack 
                this.__outputQueue.push({
                    val: '[]',
                    args: (this.__previousChar === '[') ? -1 : lastArgCountObj.num + 1
                });
            };
            /**
             * Handles tokenizing a "(" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleLeftParenthesis = function (char) {
                var previousChar = this.__previousChar, operatorStack = this.__operatorStack, args;
                if (this._isAlphaNumeric(previousChar) || previousChar === ']' || previousChar === ')') {
                    var outputQueue = this.__outputQueue, topOutput = outputQueue[outputQueue.length - 1], val = isNull(topOutput) ? undefined : topOutput.val;
                    if (val === '[]') {
                        operatorStack.unshift(outputQueue.pop());
                        operatorStack.unshift(outputQueue.pop());
                    }
                    else if (!(val === '()' || this._isNumeric(val))) {
                        operatorStack.unshift(outputQueue.pop());
                    }
                    args = 0;
                }
                else {
                    args = -1;
                }
                this.__argCount.push({ num: args });
                operatorStack.unshift({ val: char, args: args });
                this.__lastCommaChar.push(char);
            };
            /**
             * Handles tokenizing a ")" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleRightParenthesis = function (char) {
                var operatorStack = this.__operatorStack, topOperator = operatorStack[0], localArgCountObj = this.__argCount.pop();
                if (isNull(topOperator)) {
                    return this._throwError('Parentheses mismatch');
                }
                this._popStackForVal(topOperator, '(', 'Parentheses mismatch');
                // pop left parenthesis off stack 
                operatorStack.shift();
                this.__lastCommaChar.pop();
                // check if function on top of stack 
                if (!isNull(localArgCountObj) && localArgCountObj.num >= 0) {
                    var localArgNum = localArgCountObj.num;
                    if (this.__previousChar === '(') {
                        if (this.__removeFnFromStack(localArgNum)) {
                            this.__outputQueue.push({
                                val: '()',
                                args: 0
                            });
                        }
                    }
                    else if (this.__removeFnFromStack(localArgNum + 1)) {
                        this.__outputQueue.push({
                            val: '()',
                            args: (localArgNum + 1)
                        });
                    }
                }
            };
            /**
             * Handles tokenizing a "," character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleComma = function (char) {
                var lastCommaArray = this.__lastCommaChar, lastCommaArg = lastCommaArray[lastCommaArray.length - 1];
                if (lastCommaArg === '(' || lastCommaArg === '[') {
                    var argCountArray = this.__argCount, length_2 = argCountArray.length;
                    if (length_2 > 0) {
                        // increment deepest fn count (don't need to increment obj count because we increment with colon) 
                        argCountArray[length_2 - 1].num++;
                    }
                    else {
                        return this._throwError('Mismatch with ' + lastCommaArg);
                    }
                }
                var topOperator = this.__operatorStack[0];
                if (isNull(topOperator)) {
                    return this._throwError('Unexpected comma');
                }
                this._popStackForVal(topOperator, lastCommaArg, 'Unexpected comma');
            };
            /**
             * Handles tokenizing a string literal.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleStringLiteral = function (index, char) {
                var lookAhead = this._lookAheadForDelimiter(char, index), operatorStack = this.__operatorStack, topOperator = operatorStack[0];
                if (!isNull(topOperator) && (topOperator.val === '[' || (topOperator.val === '(' && topOperator.args >= 0))) {
                    operatorStack.unshift({ val: lookAhead, args: 0 });
                }
                else {
                    this.__outputQueue.push({ val: lookAhead, args: 0 });
                }
                return index + lookAhead.length + 1;
            };
            /**
             * Handles tokenizing a "?" character.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleQuestion = function (char) {
                this.__lastColonChar.push(char);
                this.__determinePrecedence(char);
            };
            /**
             * Handles tokenizing a ":" character.
             * @param {string} char The current char.
             * @param {number} ternary The current ternary counter. Increments when a ternary is found,
             * decrements when a ternary is completed. It can be very useful when there is nested ternaries.
             */
            Tokenizer.prototype.__handleColon = function (char, ternary) {
                var lastColonCharArray = this.__lastColonChar, lastColonCharacter = lastColonCharArray[lastColonCharArray.length - 1], outputQueue = this.__outputQueue;
                if (lastColonCharacter === '?') {
                    var operatorStack = this.__operatorStack, topOperator = operatorStack[0];
                    if (isNull(topOperator)) {
                        this._throwError('Ternary mismatch');
                        return;
                    }
                    ternary--;
                    // pop latest colon char off queue 
                    lastColonCharArray.pop();
                    this._popStackForVal(topOperator, '?', 'Ternary mismatch');
                    outputQueue.push(operatorStack.shift());
                    operatorStack.unshift({ val: char, args: -2 });
                }
                else if (lastColonCharacter === '{') {
                    var objArgCount = this.__objArgCount, outputLast = outputQueue.length - 1;
                    objArgCount[objArgCount.length - 1]++;
                    if (outputLast < 0) {
                        this._throwError('Unexpected colon');
                        return;
                    }
                    outputQueue[outputLast].args = 1;
                }
                else {
                    this._throwError('Unexpected colon');
                    return;
                }
                return ternary;
            };
            /**
             * Handles tokenizing all other operators.
             * @param {number} index The current index in the string being tokenized.
             * @param {string} char The current char.
             */
            Tokenizer.prototype.__handleOtherOperator = function (index, char) {
                var lookAhead = this._lookAheadForOperatorFn(char, index);
                this.__determinePrecedence(lookAhead);
                return index + lookAhead.length - 1;
            };
            /**
             * Pops operators left on the operator stack onto the output queue
             * checking for mismatches.
             */
            Tokenizer.prototype.__popRemainingOperators = function () {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack, topOperator, topOperatorVal;
                while (operatorStack.length > 0) {
                    topOperator = operatorStack.shift();
                    topOperatorVal = topOperator.val;
                    if (topOperatorVal === '(' || topOperatorVal === ')') {
                        return this._throwError('Parentheses mismatch');
                    }
                    outputQueue.push(topOperator);
                }
            };
            /**
             * Grabs essential token details for a given operator.
             * @param {string} operator The operator whose details are being requested.
             */
            Tokenizer.prototype.__determineOperator = function (operator) {
                switch (operator) {
                    case '+':
                    case '-':
                        if (this.__outputQueue.length === 0 || isOperator(this.__previousChar)) {
                            return OPERATORS['u' + operator];
                        }
                    default:
                        return OPERATORS[operator];
                }
            };
            /**
             * Determines the precedence of a given operator in relation to other operators
             * in the operator stack and places it in the operator stack.
             * @param {string} operator The operator whose precedence is being determined.
             */
            Tokenizer.prototype.__determinePrecedence = function (operator) {
                var operatorFn = this.__determineOperator(operator), operatorPrecedence = operatorFn.precedence, isLtR = operatorFn.associativity === 'ltr', operatorStack = this.__operatorStack, outputQueue = this.__outputQueue, firstArrayOperator, firstArrayVal;
                if (operatorStack.length === 0) {
                    operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
                    return;
                }
                do {
                    firstArrayVal = operatorStack[0].val;
                    if (firstArrayVal === '.') {
                        outputQueue.push(operatorStack.shift());
                        continue;
                    }
                    firstArrayOperator = OPERATORS[firstArrayVal];
                    if (!(isNull(firstArrayOperator) ||
                        !(firstArrayOperator.precedence < operatorPrecedence ||
                            (isLtR && firstArrayOperator.precedence === operatorPrecedence)))) {
                        outputQueue.push(operatorStack.shift());
                    }
                    else {
                        operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
                        return;
                    }
                } while (operatorStack.length > 0);
                operatorStack.unshift({ val: operator, args: operatorFn.fn.length - 2 });
            };
            /**
             * Removes a reference to a function that is present in the operator stack and places
             * it in the output queue.
             * @param {number} argCount The current local argument count used with functions,
             * arrays, and object literals.
             */
            Tokenizer.prototype.__removeFnFromStack = function (argCount) {
                var outputQueue = this.__outputQueue, operatorStack = this.__operatorStack, topOperator = operatorStack[0], isValEqual = this._isValEqual, isValUnequal = this._isValUnequal, fnToken, atLeastOne = false;
                while (!isNull(topOperator) &&
                    isValUnequal(topOperator, '([') &&
                    (this._isStringValidVariable(topOperator.val) ||
                        isValEqual(topOperator.val, '.[]') ||
                        isAccessor(topOperator.val))) {
                    fnToken = operatorStack.shift();
                    if (!(fnToken.args !== -1 || isValEqual(fnToken, '.[]'))) {
                        fnToken.args = -2;
                    }
                    outputQueue.push(fnToken);
                    topOperator = operatorStack[0];
                    atLeastOne = true;
                }
                if (!(atLeastOne || isValUnequal(outputQueue[outputQueue.length - argCount - 1], '()'))) {
                    atLeastOne = true;
                }
                return atLeastOne;
            };
            Tokenizer._inject = {
                _log: __Log
            };
            return Tokenizer;
        }());
        expressions.Tokenizer = Tokenizer;
        register.injectable(__Tokenizer, Tokenizer);
        /**
         * A class for parsing JavaScript expression strings and creating
         * IParsedExpressions.
         */
        var Parser = (function () {
            function Parser() {
                /**
                 * A single expression's token representation created by a Tokenizer.
                 */
                this._tokens = [];
                /**
                 * An expression cache. Used so that a JavaScript expression is only ever parsed once.
                 */
                this.__cache = {};
                /**
                 * A dynamically built string array that represents the evaluation function.
                 */
                this.__codeArray = [];
                /**
                 * A list of all the identifiers discovered in the JavaScript expression string.
                 */
                this.__identifiers = [];
                /**
                 * A temporary list of identifiers found used to build and evaluate each actual identifier.
                 */
                this.__tempIdentifiers = [];
                /**
                 * An object whose keys represent a list of all unique aliases found in the JavaScript expression string.
                 */
                this.__aliases = {};
                /**
                 * The constant that needs to be prepended to every dyanmic eval function.
                 */
                this.__fnEvalConstant = 'var initialContext;return ';
            }
            /**
             * Parses a JavaScript expression string.
             * @param {string} expression The JavaScript expression string to parse.
             */
            Parser.prototype.parse = function (expression) {
                var parsedObject = this.__cache[expression];
                if (!isNull(parsedObject)) {
                    return {
                        expression: parsedObject.expression,
                        identifiers: parsedObject.identifiers.slice(0),
                        aliases: parsedObject.aliases.slice(0),
                        evaluate: parsedObject.evaluate
                    };
                }
                this._tokens = this._tokenizer.createTokens(expression);
                parsedObject = this._evaluate(expression);
                var identifiers = parsedObject.identifiers;
                if (identifiers.length === 0) {
                    var noModel_1 = parsedObject.evaluate(null);
                    parsedObject.evaluate = function () { return noModel_1; };
                }
                this.__cache[expression] = parsedObject;
                return parsedObject;
            };
            /**
             * If a key is passed in, it clears that single value in the expression cache. If no
             * key is present, the entire expression cache will be cleared.
             * @param {string} key? An optional key that will clear its stored value in the expression
             * cache if passed in.
             */
            Parser.prototype.clearCache = function (key) {
                if (isString(key)) {
                    deleteProperty(this.__cache, key);
                    return;
                }
                this.__cache = {};
            };
            /**
             * Evaluate the current IToken array.
             * @param {string} expression The JavaScript expression to evaluate.
             */
            Parser.prototype._evaluate = function (expression) {
                var tokens = this._tokens, length = tokens.length, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, useLocalContext = false, tokenObj, token, args;
                for (var index = 0; index < length; index++) {
                    tokenObj = tokens[index];
                    token = tokenObj.val;
                    args = tokenObj.args;
                    // check if its an accessor 
                    if (isAccessor(token)) {
                        switch (token) {
                            case '()':
                                useLocalContext = this.__handleFunction(index, args, useLocalContext);
                                break;
                            case '{}':
                                codeArray.push(this.__convertObject(args));
                                tempIdentifiers.push('.');
                                break;
                            default:
                                // handle empty array 
                                if (args < 0) {
                                    codeArray.push('[]');
                                    tempIdentifiers.push('.');
                                }
                                else if (args > 0) {
                                    codeArray.push(this.__convertArrayLiteral(args));
                                    tempIdentifiers.push('.');
                                }
                                else {
                                    useLocalContext = this.__indexIntoObject(index, token, useLocalContext);
                                }
                                break;
                        }
                    }
                    else if (isOperator(token)) {
                        // check if string literal 
                        if (args === 0) {
                            codeArray.push(this.__convertPrimitive(index, token, args));
                        }
                        else {
                            switch (token) {
                                case '?':
                                    this.__handleQuestion();
                                    break;
                                case ':':
                                    this.__handleColon();
                                    break;
                                case '+':
                                case '-':
                                    if (args === 1) {
                                        token = 'u' + token;
                                    }
                                default:
                                    this.__handleOperator(token, args);
                                    break;
                            }
                        }
                    }
                    else {
                        // potential function or object to index into 
                        if (args < 0) {
                            codeArray.push(this.__convertFunction(index, token, useLocalContext));
                        }
                        else {
                            codeArray.push(this.__convertPrimitive(index, token, args));
                        }
                    }
                }
                // move the rest of the tempIdentifiers to the identifiers 
                this._popRemainingIdentifiers();
                // make the identifiers array unqiue entries only 
                this._makeIdentifiersUnique();
                var parsedExpression = {
                    evaluate: new Function(__CONTEXT, __ALIASES, this.__fnEvalConstant + (codeArray.length === 0 ? ('"' + expression + '"') : codeArray.join('')) + ';'),
                    expression: expression,
                    identifiers: this.__identifiers.slice(0),
                    aliases: Object.keys(this.__aliases)
                };
                // reset parser's properties 
                this._resetParser();
                return parsedExpression;
            };
            /**
             * Peek at the next IToken.
             * @param {number} index The index before the desired IToken
             * in the array.
             */
            Parser.prototype._peek = function (index) {
                return this._tokens[index + 1];
            };
            /**
             * Look back at the previous IToken.
             * @param {number} index The index after the desired IToken
             * in the array.
             */
            Parser.prototype._lookBack = function (index) {
                return this._tokens[index - 1];
            };
            /**
             * Evaluate and remove the leftover identifiers.
             */
            Parser.prototype._popRemainingIdentifiers = function () {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, last;
                while (tempIdentifiers.length > 0) {
                    last = tempIdentifiers.pop();
                    if (last !== '.') {
                        identifiers.push(last);
                    }
                }
            };
            /**
             * Remove duplicate identifiers.
             */
            Parser.prototype._makeIdentifiersUnique = function () {
                var identifiers = this.__identifiers, uniqueIdentifiers = [], uniqueIdentifierObject = {}, identifier;
                while (identifiers.length > 0) {
                    identifier = identifiers.pop();
                    if (!uniqueIdentifierObject[identifier]) {
                        uniqueIdentifierObject[identifier] = true;
                        uniqueIdentifiers.push(identifier);
                    }
                }
                this.__identifiers = uniqueIdentifiers;
            };
            /**
             * Check if the "val" property on an IToken
             * is present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Parser.prototype._isValEqual = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return isNull(char);
                }
                else if (obj.val === '') {
                    return char === '';
                }
                return char.indexOf(obj.val) !== -1;
            };
            /**
             * Check if the "val" property on an IToken
             * is not present in a particular character string.
             * @param {plat.expressions.IToken} obj The IToken
             * with the "val" property to compare.
             * @param {string} char The char to compare with.
             */
            Parser.prototype._isValUnequal = function (obj, char) {
                if (isNull(obj) || isNull(obj.val)) {
                    return !isNull(char);
                }
                else if (obj.val === '') {
                    return char !== '';
                }
                return char.indexOf(obj.val) === -1;
            };
            /**
             * Resets all the parser's properties.
             */
            Parser.prototype._resetParser = function () {
                this._tokens = [];
                this.__codeArray = [];
                this.__identifiers = [];
                this.__tempIdentifiers = [];
                this.__aliases = {};
            };
            /**
             * Throws a fatal exception in the case of an error.
             * @param {string} error The error message to throw.
             */
            Parser.prototype._throwError = function (error) {
                this._log.error(new Error(error));
            };
            /**
             * Handles a token that is a primitive value.
             * @param {number} index The current index in the IToken array.
             * @param {string} token The current IToken value.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__convertPrimitive = function (index, token, args) {
                if (args > 0) {
                    this.__tempIdentifiers.push('.');
                    return token;
                }
                var castTokenIsNumberLike = isNumber(Number(token)), peek = this._peek(index), isPeekIndexer = !(isNull(peek) || peek.args >= 1), isValEqual = this._isValEqual;
                if (isKeyword(token) ||
                    (isString(token) &&
                        (castTokenIsNumberLike ||
                            this._isValUnequal(peek, '[]()') ||
                            (isValEqual(peek, '[]') &&
                                !isPeekIndexer)))) {
                    this.__tempIdentifiers.push('.');
                    return '"' + token + '"';
                }
                else {
                    if (!castTokenIsNumberLike ||
                        (isValEqual(peek, '.[]') &&
                            isPeekIndexer)) {
                        this.__tempIdentifiers.push(token);
                    }
                    else {
                        this.__tempIdentifiers.push('.');
                    }
                    return token;
                }
            };
            /**
             * Handles a potential function or object that needs to be indexed into.
             * @param {number} index The current index in the IToken array.
             * @param {string} token The current IToken value.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             */
            Parser.prototype.__convertFunction = function (index, token, useLocalContext) {
                if (token[0] === '@') {
                    this.__aliases[token.slice(1)] = true;
                }
                else if (isKeyword(token)) {
                    this.__tempIdentifiers.push('.');
                    return token;
                }
                var nextToken = this._peek(index), isValEqual = this._isValEqual;
                if (isValEqual(this._tokens[index - 1], '()') && isValEqual(nextToken, '.[]')) {
                    this.__tempIdentifiers.push('.');
                }
                else {
                    this.__tempIdentifiers.push(token);
                }
                if (!isNull(nextToken)) {
                    switch (nextToken.val) {
                        case '.':
                        case '()':
                            return token;
                        default:
                            if (!useLocalContext) {
                                return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';
                            }
                            break;
                    }
                }
                else {
                    return '(initialContext = (' + this.__findInitialContext.toString() + ')(context,aliases,"' + token + '"))';
                }
            };
            /**
             * Handles an object literal.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__convertObject = function (args) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, key, codeStr = '{', tempIdentifier, temp;
                while (j++ < args) {
                    temp = codeArray.pop();
                    key = codeArray.pop();
                    codeStr += ',"' + key + '":' + temp;
                    if (tempIdentifiers.length > 1) {
                        tempIdentifier = tempIdentifiers.pop();
                        // pop the key's tempIdentifier 
                        tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }
                return codeStr.replace(',', '') + '}';
            };
            /**
             * Handles an Array literal.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__convertArrayLiteral = function (args) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, tempStr = '', tempIdentifier;
                while (j++ < args) {
                    tempStr = codeArray.pop() + ',' + tempStr;
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }
                return '[' + tempStr.slice(0, -1) + ']';
            };
            /**
             * Handles an accessor type function token "()".
             * @param {number} index The current index in the IToken array.
             * @param {number} args The current IToken args.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             */
            Parser.prototype.__handleFunction = function (index, args, useLocalContext) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, previousToken = this._lookBack(index), grabFnName = !isNull(previousToken) && (previousToken.args === -2 || this._isValEqual(previousToken, '.[]')), tempStr = '', tempIdentifier, fnName = '', identifierFnName = '', codeStr, pushedIdentifier = false;
                if (grabFnName) {
                    fnName = codeArray.pop();
                    identifierFnName = tempIdentifiers.pop();
                }
                while (j++ < args) {
                    tempStr = codeArray.pop() + ',' + tempStr;
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                            pushedIdentifier = true;
                        }
                    }
                }
                if (args > 0) {
                    codeStr = '.call(initialContext || context,' + tempStr.slice(0, tempStr.length - 1) + ')';
                }
                else {
                    codeStr = '.call(initialContext || context)';
                }
                if (useLocalContext) {
                    useLocalContext = false;
                    if (codeArray.length > 0) {
                        var context = codeArray.pop(), lastIndex = tempIdentifiers.length - 1;
                        if (!(lastIndex < 0 || tempIdentifiers[lastIndex] === '.' || identifierFnName === '')) {
                            tempIdentifiers[lastIndex] += '.' + identifierFnName;
                            identifiers.push(tempIdentifiers.pop());
                        }
                        else if (!(identifierFnName === '' ||
                            !pushedIdentifier ||
                            context[0] === '[' ||
                            context[context.length - 1] === ']')) {
                            identifiers[identifiers.length - 1] += '.' + identifierFnName;
                        }
                        if (isEmpty(fnName)) {
                            codeStr = context + codeStr;
                        }
                        else {
                            codeStr = '((' + this.__indexIntoContext.toString() + ')(' + context + ',"' +
                                fnName + '") || (function () {}))' + codeStr;
                        }
                    }
                    else {
                        this._throwError('Improper expression or context');
                    }
                }
                else {
                    if (grabFnName) {
                        codeStr = '(initialContext = ((' + this.__findInitialContext.toString() + ')(context,aliases,"' +
                            fnName + '") || (function () {}))' + codeStr + ')';
                        identifiers.push(fnName);
                    }
                    else {
                        codeStr = codeArray.pop() + codeStr;
                    }
                }
                codeArray.push(codeStr);
                var length = tempIdentifiers.length;
                if (this._isValEqual(this._peek(index), '[]') && length > 0 && tempIdentifiers[length - 1] !== '.') {
                    identifiers.push(tempIdentifiers.pop());
                }
                return useLocalContext;
            };
            /**
             * Handles an accessor type token that is for indexing (i.e. "." or "[]").
             * @param {number} index The current index in the IToken array.
             * @param {string} token The current IToken value.
             * @param {boolean} useLocalContext Whether or not we need to use an already parsed object as the current context.
             */
            Parser.prototype.__indexIntoObject = function (index, token, useLocalContext) {
                var isValEqual = this._isValEqual;
                if (isValEqual(this._peek(index), '()')) {
                    return true;
                }
                var codeArray = this.__codeArray, codeStr = codeArray.pop(), identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, previousToken = this._lookBack(index), identifierIndexer = tempIdentifiers.pop(), hasIdentifierIndexer = !isNull(identifierIndexer), lastIndex;
                if (hasIdentifierIndexer && identifierIndexer[0] === '@') {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    identifiers.push(identifierIndexer);
                    if (tempIdentifiers.length > 0) {
                        identifiers.push(tempIdentifiers.pop());
                    }
                }
                else if (isValEqual(previousToken, '++--()[]*/%?:>=<=&&||!===')) {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    tempIdentifiers.push('.');
                }
                else if (token === '[]' && !(isNull(previousToken) || previousToken.args >= 0)) {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',' + codeStr + ')';
                    lastIndex = tempIdentifiers.length - 1;
                    if (lastIndex >= 0) {
                        if (tempIdentifiers[lastIndex] !== '.') {
                            identifiers.push(tempIdentifiers.pop());
                        }
                    }
                    identifiers.push(identifierIndexer);
                }
                else {
                    codeStr = '(' + this.__indexIntoContext.toString() + ')(' + codeArray.pop() + ',"' + codeStr + '")';
                    lastIndex = tempIdentifiers.length - 1;
                    if (lastIndex >= 0) {
                        if (tempIdentifiers[lastIndex] !== '.') {
                            tempIdentifiers[lastIndex] += '.' + identifierIndexer;
                        }
                    }
                    else if (hasIdentifierIndexer && identifierIndexer !== '.' && token !== '.') {
                        identifiers.push(identifierIndexer);
                    }
                }
                codeArray.push(codeStr);
                return useLocalContext;
            };
            /**
             * Handles the "?" operator.
             */
            Parser.prototype.__handleQuestion = function () {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, temp = codeArray.pop(), tempIdentifier;
                for (var i = 0; i < 2; i++) {
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                    else {
                        break;
                    }
                }
                codeArray.push(codeArray.pop() + '?' + temp);
            };
            /**
             * Handles the ":" operator.
             */
            Parser.prototype.__handleColon = function () {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, temp = codeArray.pop(), tempIdentifier;
                for (var i = 0; i < 2; i++) {
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                    else {
                        break;
                    }
                }
                codeArray.push(codeArray.pop() + ':' + temp);
            };
            /**
             * Handles all other operators.
             * @param {string} token The current IToken value.
             * @param {number} args The current IToken args.
             */
            Parser.prototype.__handleOperator = function (token, args) {
                var identifiers = this.__identifiers, tempIdentifiers = this.__tempIdentifiers, codeArray = this.__codeArray, j = 0, tempStr = '', tempIdentifier;
                while (j++ < args) {
                    tempStr = 'function (context, aliases) { return ' + codeArray.pop() + '; }' + ',' + tempStr;
                    if (tempIdentifiers.length > 0) {
                        tempIdentifier = tempIdentifiers.pop();
                        if (tempIdentifier !== '.') {
                            identifiers.push(tempIdentifier);
                        }
                    }
                }
                // push identifier for new result of operator 
                tempIdentifiers.push('.');
                codeArray.push('(' + OPERATORS[token].fn.toString() + ')(context, aliases,' + tempStr.slice(0, tempStr.length - 1) + ')');
            };
            /**
             * Safely finds an initial context.
             * @param {any} context The context object.
             * @param {any} aliases Any aliases that may exist.
             * @param {string} token The property used to find the initial context.
             */
            Parser.prototype.__findInitialContext = function (context, aliases, token) {
                if (token[0] === '@' && aliases !== null && typeof aliases === 'object') {
                    return aliases[token.slice(1)];
                }
                else if (context !== null && typeof context === 'object') {
                    return context[token];
                }
            };
            /**
             * Safely drills down into a specified context with a given token.
             * @param {any} context The context object.
             * @param {string} token The property used to drill into the context.
             */
            Parser.prototype.__indexIntoContext = function (context, token) {
                if (context !== null && typeof context === 'object') {
                    return context[token];
                }
            };
            Parser._inject = {
                _tokenizer: __Tokenizer,
                _log: __Log
            };
            return Parser;
        }());
        expressions.Parser = Parser;
        register.injectable(__Parser, Parser);
    })(expressions = plat_1.expressions || (plat_1.expressions = {}));
    /**
     * Holds classes and interfaces related to web components in platypus.
     */
    var web;
    (function (web) {
        /**
         */
        function Location(_window) {
            return _window.location;
        }
        web.Location = Location;
        register.injectable(__Location, Location, [__Window]);
        /**
         * The class that handles all interaction with the browser.
         */
        var Browser = (function () {
            /**
             * The constructor for a Browser. Assigns a uid and subscribes to the 'beforeLoad' event.
             */
            function Browser() {
                /**
                 * A unique string identifier.
                 */
                this.uid = uniqueId(__Plat);
                /**
                 * The browser's last URL.
                 */
                this.__lastUrl = this._location.href;
                /**
                 * Whether or not the browser is in an initialization state.
                 */
                this.__initializing = false;
                this._EventManager.on(this.uid, __beforeLoad, this.initialize, this);
                if (this._compat.msApp) {
                    this._stack = [];
                }
            }
            /**
             * Initializes the Browser instance, trims the url, and
             * adds events for popstate and hashchange.
             */
            Browser.prototype.initialize = function () {
                var _compat = this._compat;
                this._EventManager.dispose(this.uid);
                this.__initializing = true;
                acquire(__UrlUtilsInstance);
                var url = this.url(), trimmedUrl = url, changed = this._urlChanged.bind(this), _dom = this._dom, _window = this._window;
                if (trimmedUrl !== url) {
                    this.url(trimmedUrl, true);
                }
                if (_compat.pushState) {
                    _dom.addEventListener(_window, __POPSTATE, changed, false);
                }
                _dom.addEventListener(_window, __HASHCHANGE, changed, false);
                this.__initializing = false;
            };
            /**
             * Sets or gets the current _window.location
             * @param {string} url? The URL to set the location to.
             * @param {boolean} replace? Whether or not to replace the current URL in
             * the history.
             */
            Browser.prototype.url = function (url, replace) {
                var location = this._location;
                if (isString(url) && !this._isLastUrl(url)) {
                    if (!replace && isArray(this._stack)) {
                        this._stack.push(location.href);
                    }
                    this._setUrl(url, replace);
                }
                return this.__currentUrl || location.href;
            };
            /**
             * Navigates back in the browser history
             * @param {number} length=1 The length to go back
             */
            Browser.prototype.back = function (length) {
                if (!isNumber(length)) {
                    length = 1;
                }
                var _stack = this._stack;
                if (isArray(_stack) && _stack.length > 1) {
                    this._stack = _stack = _stack.slice(0, _stack.length - (length - 1));
                    this.url(_stack.pop());
                    _stack.pop();
                    return;
                }
                this._history.go(-length);
            };
            /**
             * Navigates forward in the browser history
             * @param {number} length=1 The length to go forward
             */
            Browser.prototype.forward = function (length) {
                if (!isNumber(length)) {
                    length = 1;
                }
                this._history.go(length);
            };
            /**
             * Creates a new UrlUtils object.
             * @param url? The URL to associate with the new UrlUtils
             * instance.
             */
            Browser.prototype.urlUtils = function (url) {
                url = url || this.url();
                var _urlUtils = acquire(__UrlUtilsInstance), _config = Browser.config;
                if (_config.routingType === _config.HASH) {
                    url = url.replace(new RegExp('#' + (_config.hashPrefix || '') + '/?'), '');
                }
                _urlUtils.initialize(url);
                return _urlUtils;
            };
            /**
             * Checks to see if the requested URL is cross domain.
             * @param url The URL to verify whether or not it's cross domain.
             */
            Browser.prototype.isCrossDomain = function (url) {
                if (!isString(url)) {
                    return false;
                }
                var urlUtils = this.urlUtils(url), locationUtils = this.urlUtils();
                // check for protocol:host:port mismatch 
                return urlUtils.protocol !== locationUtils.protocol ||
                    urlUtils.hostname !== locationUtils.hostname ||
                    urlUtils.port !== locationUtils.port;
            };
            /**
             * Formats the URL in the case of HASH routing.
             * @param url The URL to format.
             */
            Browser.prototype.formatUrl = function (url) {
                var config = Browser.config, baseUrl = config.baseUrl, isLocal = !this._regex.fullUrlRegex.test(url) || url.indexOf(baseUrl) > -1;
                if (!isString(url)) {
                    return '';
                }
                if (url === baseUrl) {
                    return url;
                }
                if (url[0] === '/') {
                    url = url.slice(1);
                }
                if (isLocal && config.routingType === config.HASH) {
                    var hasProtocol = url.indexOf(this.urlUtils().protocol) !== -1, prefix = config.hashPrefix || '', append = '#' + prefix, hashRegex = new RegExp(append + '|#/');
                    if (url[url.length - 1] !== '/' && url.indexOf('?') === -1) {
                        url += '/';
                    }
                    if (hasProtocol && !hashRegex.test(url)) {
                        url = url + append + '/';
                    }
                    else if (!hashRegex.test(url)) {
                        url = append + ((url[0] !== '/') ? '/' : '') + url;
                    }
                }
                if (isLocal && url.indexOf(baseUrl) === -1) {
                    url = baseUrl + url;
                }
                return url;
            };
            /**
             * The event to fire in the case of a URL change. It kicks
             * off a 'urlChanged' direct event notification.
             * @param url The URL to verify whether or not it's cross domain.
             */
            Browser.prototype._urlChanged = function () {
                var _this = this;
                if (this.__initializing) {
                    return;
                }
                this.__currentUrl = null;
                var utils = this.urlUtils(), $config = Browser.config, url = this._trimSlashes(utils.href);
                if (this.__lastUrl === url) {
                    return;
                }
                this.__lastUrl = url;
                var $manager = this._EventManager;
                postpone(function () {
                    $manager.dispatch(__urlChanged, _this, $manager.DIRECT, [utils]);
                });
            };
            /**
             * Checks for the existence of pushState and
             * sets the browser URL accordingly.
             * @param {string} url The URL to set.
             * @param {boolean} replace? Whether or not to replace the
             * current URL in the history.
             */
            Browser.prototype._setUrl = function (url, replace) {
                url = this.formatUrl(url);
                var utils = this.urlUtils(url), baseUrl = Browser.config.baseUrl, _history = this._history, _location = this._location;
                if (utils.href.indexOf(baseUrl) === -1) {
                    _location.href = url;
                    return;
                }
                // make sure URL is absolute 
                if (!this._regex.fullUrlRegex.test(url) && url[0] !== '/') {
                    url = baseUrl + url;
                }
                if (this._compat.pushState) {
                    if (replace) {
                        var state = _history.state;
                        if (!isObject(state)) {
                            state = {};
                        }
                        _history.replaceState({
                            previousLocation: state.previousLocation
                        }, '', url);
                    }
                    else {
                        _history.pushState({
                            previousLocation: this.urlUtils().pathname
                        }, '', url);
                    }
                    if (!this.__initializing) {
                        this._urlChanged();
                    }
                }
                else {
                    this.__currentUrl = url;
                    if (replace) {
                        _location.replace(url);
                    }
                    else {
                        _location.href = url;
                    }
                }
            };
            /**
             * Determines if the url is equal to the last url
             * @param {string} url The URL to match
             */
            Browser.prototype._isLastUrl = function (url) {
                var last = this.__lastUrl;
                if (isString(url)) {
                    if (isEmpty(url)) {
                        url = '/';
                    }
                    url = this._trimSlashes(this.urlUtils(url).href);
                }
                return url === last;
            };
            /**
             * Trims trailing slashes from a url.
             * @param {string} url The URL to trim
             */
            Browser.prototype._trimSlashes = function (url) {
                if (!isString(url) || url[url.length - 1] !== '/') {
                    return url;
                }
                return url.slice(0, -1);
            };
            Browser._inject = {
                _EventManager: __EventManagerStatic,
                _compat: __Compat,
                _regex: __Regex,
                _window: __Window,
                _location: __Location,
                _history: __History,
                _dom: __Dom
            };
            /**
             * The IBrowserConfig injectable object.
             */
            Browser.config = {
                HASH: 'hash',
                STATE: 'state',
                routingType: 'hash',
                hashPrefix: '!',
                baseUrl: ''
            };
            return Browser;
        }());
        web.Browser = Browser;
        register.injectable(__Browser, Browser);
        /**
         */
        function IBrowserConfig() {
            return Browser.config;
        }
        web.IBrowserConfig = IBrowserConfig;
        register.injectable(__BrowserConfig, IBrowserConfig);
        /**
         * Deals with obtaining detailed information about an
         * associated URL.
         */
        var UrlUtils = (function () {
            /**
             * The constructor for a UrlUtils instance.
             * Handles parsing the initial URL and obtain the base URL if necessary.
             */
            function UrlUtils() {
                var config = this._browserConfig, baseUrl = config.baseUrl;
                if (isEmpty(baseUrl) || !this._regex.fullUrlRegex.test(baseUrl)) {
                    var url = this._window.location.href, trimmedUrl = url.replace(this._regex.initialUrlRegex, '/');
                    if (isString(baseUrl)) {
                        if (baseUrl.indexOf('/') === 0) {
                            baseUrl = baseUrl.slice(1);
                        }
                    }
                    else {
                        baseUrl = '';
                    }
                    baseUrl = UrlUtils.__getBaseUrl(trimmedUrl) + baseUrl;
                    while (baseUrl[baseUrl.length - 1] === '/') {
                        baseUrl = baseUrl.slice(0, -1);
                    }
                    config.baseUrl = baseUrl + '/';
                }
            }
            /**
             * Creates a query object out of the URL's query search string.
             * @param {string} search The URL's query search string.
             */
            UrlUtils.__getQuery = function (search) {
                return deserializeQuery(search);
            };
            /**
             * Obtains the base URL for the app/site for doing STATE type routing.
             * @param {string} url The initial URL passed into the Browser.
             */
            UrlUtils.__getBaseUrl = function (url) {
                var _regex = acquire(__Regex), _location = acquire(__Location), origin = _location.origin, protocol = _location.protocol, host = _location.host;
                if (protocol === 'file:' || protocol.indexOf('wmapp') > -1 || protocol.indexOf('ms-appx') > -1) {
                    origin = _location.href;
                }
                else if (isUndefined(origin)) {
                    origin = _location.protocol + '//' + _location.host;
                }
                origin = origin.replace(_regex.initialUrlRegex, '');
                return origin.split('?')[0].split('#')[0] + '/';
            };
            /**
             * Initializes and defines properties using
             * the input url.
             * @param {string} url The input to associate with this UrlUtils instance.
             */
            UrlUtils.prototype.initialize = function (url) {
                url = url || '';
                var element = UrlUtils.__urlUtilsElement ||
                    (UrlUtils.__urlUtilsElement = this._document.createElement('a')), _browserConfig = this._browserConfig;
                // always make local urls relative to start page. 
                if (url[0] === '/' && url.indexOf('//') !== 0) {
                    url = url.slice(1);
                }
                // Always append the baseUrl if this is not a full-url 
                if (!this._regex.fullUrlRegex.test(url)) {
                    url = _browserConfig.baseUrl + url;
                }
                element.setAttribute('href', url);
                url = element.href;
                // we need to do this twice for cerain browsers (e.g. win8) 
                element.setAttribute('href', url);
                url = element.href;
                this.href = url;
                this.protocol = element.protocol ? element.protocol.replace(/:$/, '') : '';
                this.host = element.host;
                this.search = element.search ? element.search.replace(/^\?/, '') : '';
                this.hash = element.hash ? element.hash.replace(/^#/, '') : '';
                this.hostname = element.hostname;
                this.port = element.port;
                var path;
                if (!isEmpty(_browserConfig.baseUrl)) {
                    path = url.replace(_browserConfig.baseUrl, '/');
                }
                else {
                    path = (element.pathname.charAt(0) === '/')
                        ? element.pathname
                        : '/' + element.pathname;
                }
                path = path.replace(this._regex.initialUrlRegex, '/');
                this.pathname = path.split('?')[0].split('#')[0];
                this.query = UrlUtils.__getQuery(this.search);
            };
            /**
             * A toString function implementation for the UrlUtils class.
             */
            UrlUtils.prototype.toString = function () {
                return this.href;
            };
            UrlUtils._inject = {
                _EventManager: __EventManagerStatic,
                _document: __Document,
                _window: __Window,
                _compat: __Compat,
                _regex: __Regex,
                _browserConfig: __BrowserConfig
            };
            return UrlUtils;
        }());
        web.UrlUtils = UrlUtils;
        register.injectable(__UrlUtilsInstance, UrlUtils, null, __INSTANCE);
    })(web = plat_1.web || (plat_1.web = {}));
    /**
     * Holds all classes and interfaces related to async components in platypus.
     */
    var async;
    (function (async) {
        var __promiseQueue = [], browserGlobal = (typeof window !== 'undefined') ? window : {}, BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver, scheduleFlush;
        var process = process;
        // decide what async method to use to triggering processing of queued callbacks: 
        if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
            scheduleFlush = useNextTick();
        }
        else if (BrowserMutationObserver) {
            scheduleFlush = useMutationObserver();
        }
        else {
            scheduleFlush = useSetTimeout();
        }
        /**
         * Takes in a generic type corresponding to the fullfilled success type.
         */
        var Promise = (function () {
            /**
             * An ES6 implementation of the Promise API. Useful for asynchronous programming.
             * Takes in 2 generic types corresponding to the fullfilled success and error types.
             * The error type (U) should extend Error in order to get proper stack tracing.
             * @param {plat.async.IResolveFunction<R>} resolveFunction A IResolveFunction for fulfilling/rejecting the Promise.
             */
            function Promise(resolveFunction) {
                if (!isFunction(resolveFunction)) {
                    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
                }
                if (!(this instanceof Promise)) {
                    throw new TypeError('Failed to construct "Promise": ' +
                        'Please use the "new" operator, this object constructor cannot be called as a function.');
                }
                this.__subscribers = [];
                Promise.__invokeResolveFunction(resolveFunction, this);
            }
            Promise.all = function (promises) {
                if (!isArray(promises)) {
                    return Promise.all([promises]);
                }
                return new Promise(function (resolve, reject) {
                    var results = [], remaining = promises.length, promise;
                    if (remaining === 0) {
                        resolve([]);
                    }
                    function resolver(index) {
                        return function (value) { return resolveAll(index, value); };
                    }
                    function resolveAll(index, value) {
                        results[index] = value;
                        if (--remaining === 0) {
                            resolve(results);
                        }
                    }
                    for (var i = 0; i < promises.length; i++) {
                        promise = promises[i];
                        if (isPromise(promise)) {
                            promise.then(resolver(i), reject);
                        }
                        else {
                            resolveAll(i, promise);
                        }
                    }
                });
            };
            Promise.race = function (promises) {
                if (!isArray(promises)) {
                    return Promise.race([promises]);
                }
                return new Promise(function (resolve, reject) {
                    var promise;
                    for (var i = 0; i < promises.length; i++) {
                        promise = promises[i];
                        if (promise && typeof promise.then === 'function') {
                            promise.then(resolve, reject);
                        }
                        else {
                            resolve(promise);
                        }
                    }
                });
            };
            Promise.resolve = function (value) {
                return new Promise(function (resolve, reject) {
                    resolve(value);
                });
            };
            /**
             * Returns a promise that rejects with the input value.
             * @param {any} error The value to reject.
             */
            Promise.reject = function (error) {
                return new Promise(function (resolve, reject) {
                    reject(error);
                });
            };
            /**
             * Invokes the resolve function for a promise. Handles error catching.
             * @param {plat.async.IResolveFunction<R>} resolveFunction The resolve function to invoke.
             * @param {plat.async.Promise<R>} promise The promise on which to invoke the resolve function.
             */
            Promise.__invokeResolveFunction = function (resolveFunction, promise) {
                function resolvePromise(value) {
                    Promise.__resolve(promise, value);
                }
                function rejectPromise(reason) {
                    Promise.__reject(promise, reason);
                }
                try {
                    resolveFunction(resolvePromise, rejectPromise);
                }
                catch (e) {
                    rejectPromise(e);
                }
            };
            /**
             * Invokes a callback for a promise with the specified detail.
             * @param {plat.async.State} settled The state of the promise.
             * @param {any} promise The promise object.
             * @param {(response: any) => void} callback The callback to invoke.
             * @param {any} detail The details to pass to the callback.
             */
            Promise.__invokeCallback = function (settled, promise, callback, detail) {
                var hasCallback = isFunction(callback), value, error, succeeded, failed;
                if (hasCallback) {
                    try {
                        value = callback(detail);
                        succeeded = true;
                    }
                    catch (e) {
                        failed = true;
                        error = e;
                    }
                }
                else {
                    value = detail;
                    succeeded = true;
                }
                if (Promise.__handleThenable(promise, value)) {
                    return;
                }
                else if (hasCallback && succeeded) {
                    Promise.__resolve(promise, value);
                }
                else if (failed) {
                    Promise.__reject(promise, error);
                }
                else if (settled === State.FULFILLED) {
                    Promise.__resolve(promise, value);
                }
                else if (settled === State.REJECTED) {
                    Promise.__reject(promise, value);
                }
            };
            /**
             * Publishes the promise details to all the subscribers for a promise.
             * @param {any} promise The promise object.
             * @param {plat.async.State} settled The state of the promise.
             */
            Promise.__publish = function (promise, settled) {
                var subscribers = promise.__subscribers, detail = promise.__detail, child, callback;
                for (var i = 0; i < subscribers.length; i += 3) {
                    child = subscribers[i];
                    callback = subscribers[i + settled];
                    Promise.__invokeCallback(settled, child, callback, detail);
                }
                promise.__subscribers = null;
            };
            /**
             * Publishes a promises that has been fulfilled.
             * @param {any} promise The promise object.
             */
            Promise.__publishFulfillment = function (promise) {
                Promise.__publish(promise, promise.__state = State.FULFILLED);
            };
            /**
             * Publishes a promises that has been rejected.
             * @param {any} promise The promise object.
             */
            Promise.__publishRejection = function (promise) {
                Promise.__publish(promise, promise.__state = State.REJECTED);
            };
            /**
             * Asynchronously rejects a promise
             * @param {any} promise The promise object.
             * @param {any} reason The detail of the rejected promise.
             */
            Promise.__reject = function (promise, reason) {
                if (promise.__state !== State.PENDING) {
                    return;
                }
                promise.__state = State.SEALED;
                promise.__detail = reason;
                Promise.config.async(Promise.__publishRejection, promise);
            };
            /**
             * Asynchronously fulfills a promise
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {any} value The detail of the fulfilled promise.
             */
            Promise.__fulfill = function (promise, value) {
                if (promise.__state !== State.PENDING) {
                    return;
                }
                promise.__state = State.SEALED;
                promise.__detail = value;
                Promise.config.async(Promise.__publishFulfillment, promise);
            };
            /**
             * Asynchronously fulfills a promise, allowing for promise chaining.
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {any} value The detail of the fulfilled promise.
             */
            Promise.__resolve = function (promise, value) {
                if (promise === value) {
                    Promise.__fulfill(promise, value);
                }
                else if (!Promise.__handleThenable(promise, value)) {
                    Promise.__fulfill(promise, value);
                }
            };
            /**
             * Handles chaining promises together, when a promise is returned from within a then handler.
             * @param {plat.async.Promise<R>} promise The promise object.
             * @param {plat.async.Promise<R>} value The next promise to await.
             */
            Promise.__handleThenable = function (promise, value) {
                var resolved;
                if (promise === value) {
                    Promise.__reject(promise, new TypeError('A promises callback cannot return the same promise.'));
                    return true;
                }
                if (isPromise(value)) {
                    try {
                        value.then.call(value, function (val) {
                            if (resolved) {
                                return true;
                            }
                            resolved = true;
                            if (value !== val) {
                                Promise.__resolve(promise, val);
                            }
                            else {
                                Promise.__fulfill(promise, val);
                            }
                        }, function (val) {
                            if (resolved) {
                                return true;
                            }
                            resolved = true;
                            Promise.__reject(promise, val);
                        });
                        return true;
                    }
                    catch (error) {
                        if (resolved) {
                            return true;
                        }
                        Promise.__reject(promise, error);
                        return true;
                    }
                }
                return false;
            };
            /**
             * Adds a child promise to the parent's subscribers.
             * @param {plat.async.Promise<any>} parent The parent promise.
             * @param {plat.async.Promise<any>} value The child promise.
             * @param {(success: any) => any} onFullfilled The fulfilled method for the child.
             * @param {(error: any) => any} onRejected The rejected method for the child.
             */
            Promise.__subscribe = function (parent, child, onFulfilled, onRejected) {
                var subscribers = parent.__subscribers;
                var length = subscribers.length;
                subscribers[length] = child;
                subscribers[length + State.FULFILLED] = onFulfilled;
                subscribers[length + State.REJECTED] = onRejected;
            };
            Promise.prototype.then = function (onFulfilled, onRejected) {
                var promise = this;
                var thenPromise = new this.constructor(noop, this);
                if (this.__state) {
                    var callbacks_1 = arguments;
                    Promise.config.async(function () {
                        Promise.__invokeCallback(promise.__state, thenPromise, callbacks_1[promise.__state - 1], promise.__detail);
                    });
                }
                else {
                    Promise.__subscribe(this, thenPromise, onFulfilled, onRejected);
                }
                return thenPromise;
            };
            Promise.prototype.catch = function (onRejected) {
                return this.then(null, onRejected);
            };
            /**
             * Outputs the Promise as a readable string.
             */
            Promise.prototype.toString = function () {
                return '[object Promise]';
            };
            /**
             * The configuration for creating asynchronous promise flushing.
             */
            Promise.config = {
                /**
                 */
                async: function (callback, arg) {
                    var length = __promiseQueue.push([callback, arg]);
                    if (length === 1) {
                        scheduleFlush();
                    }
                }
            };
            return Promise;
        }());
        async.Promise = Promise;
        var State;
        (function (State) {
            State[State["PENDING"] = (void 0)] = "PENDING";
            State[State["SEALED"] = 0] = "SEALED";
            State[State["FULFILLED"] = 1] = "FULFILLED";
            State[State["REJECTED"] = 2] = "REJECTED";
        })(State || (State = {}));
        ;
        // node 
        function useNextTick() {
            return function () {
                process.nextTick(flush);
            };
        }
        function useMutationObserver() {
            var observer = new BrowserMutationObserver(flush), _document = acquire(__Document), _window = acquire(__Window), element = _document.createElement('div');
            observer.observe(element, { attributes: true });
            _window.addEventListener('unload', function () {
                observer.disconnect();
                observer = null;
            }, false);
            return function () {
                element.setAttribute('drainQueue', 'drainQueue');
            };
        }
        function useSetTimeout() {
            return function () {
                postpone(flush);
            };
        }
        function flush() {
            var tuple, callback, arg;
            for (var i = 0; i < __promiseQueue.length; i++) {
                tuple = __promiseQueue[i];
                callback = tuple[0];
                arg = tuple[1];
                callback(arg);
            }
            __promiseQueue = [];
        }
        /**
         */
        function IPromise(_window) {
            if (!isNull(_window.Promise) &&
                isFunction(_window.Promise.all) &&
                isFunction(_window.Promise.race) &&
                isFunction(_window.Promise.resolve) &&
                isFunction(_window.Promise.reject)) {
                return _window.Promise;
            }
            return Promise;
        }
        async.IPromise = IPromise;
        register.injectable(__Promise, IPromise, [__Window], __CLASS);
        /**
         * HttpRequest provides a wrapper for the XMLHttpRequest object. Allows for
         * sending AJAX requests to a server. This class does not support
         * synchronous requests.
         */
        var HttpRequest = (function () {
            /**
             * The constructor for a HttpRequest.
             */
            function HttpRequest() {
                var compat = acquire(__Compat);
                this.__fileSupported = compat.fileSupported;
            }
            /**
             * Initializes the HttpRequest with options.
             * @param {plat.async.IHttpConfig} options The IHttpConfigStatic used to customize this HttpRequest.
             */
            HttpRequest.prototype.initialize = function (options) {
                this.__options = _extend(false, false, {}, this._config, options);
            };
            /**
             * Executes an XMLHttpRequest and resolves an IAjaxPromise upon completion.
             */
            HttpRequest.prototype.execute = function () {
                var options = this.__options, url = options.url;
                if (!isString(url) || isEmpty(url.trim())) {
                    return this._invalidOptions();
                }
                options.url = this._browser.urlUtils(url).toString();
                var isCrossDomain = options.isCrossDomain || false, xDomain = false;
                // check if forced cross domain call or cors is not supported (IE9) 
                if (isCrossDomain) {
                    xDomain = true;
                }
                else {
                    this.xhr = new XMLHttpRequest();
                    if (isUndefined(this.xhr.withCredentials)) {
                        xDomain = this._browser.isCrossDomain(url);
                    }
                }
                if (xDomain) {
                    this.xhr = null;
                    this.jsonpCallback = options.jsonpCallback || uniqueId(__JSONP_CALLBACK);
                    return this.executeJsonp();
                }
                return this._sendXhrRequest();
            };
            /**
             * Executes an JSONP request and resolves an IAjaxPromise upon completion.
             */
            HttpRequest.prototype.executeJsonp = function () {
                var _this = this;
                var options = this.__options, url = options.url;
                if (!isString(url) || isEmpty(url.trim())) {
                    return this._invalidOptions();
                }
                options.url = this._browser.urlUtils(url).toString();
                if (isNull(this.jsonpCallback)) {
                    this.jsonpCallback = options.jsonpCallback || uniqueId(__Callback);
                }
                var promise = new AjaxPromise(function (resolve, reject) {
                    var _window = _this._window, _document = _this._document, scriptTag = _document.createElement('script'), jsonpCallback = _this.jsonpCallback, jsonpIdentifier = options.jsonpIdentifier || 'callback';
                    scriptTag.src = url + ((url.indexOf('?') > -1) ? '&' : '?') + jsonpIdentifier + '=' + jsonpCallback;
                    var oldValue = _window[jsonpCallback];
                    _window[jsonpCallback] = function (response) {
                        // clean up 
                        if (isFunction(_this.clearTimeout)) {
                            _this.clearTimeout();
                        }
                        _document.head.removeChild(scriptTag);
                        if (isUndefined(oldValue)) {
                            deleteProperty(_window, jsonpCallback);
                        }
                        else {
                            _window[jsonpCallback] = oldValue;
                        }
                        // call callback 
                        resolve({
                            response: response,
                            // ok 
                            status: 200
                        });
                    };
                    _document.head.appendChild(scriptTag);
                    var timeout = options.timeout;
                    if (isNumber(timeout) && timeout > 0) {
                        // we first postpone to avoid always timing out when debugging, though this is not 
                        // a foolproof method. 
                        _this.clearTimeout = postpone(function () {
                            _this.clearTimeout = defer(function () {
                                reject(new AjaxError({
                                    response: 'Request timed out in ' + timeout + 'ms for ' + url,
                                    // request timeout 
                                    status: 408
                                }));
                                _window[jsonpCallback] = noop;
                            }, timeout - 1);
                        });
                    }
                });
                promise.initialize(this);
                return promise;
            };
            /**
             * A wrapper for the XMLHttpRequest's onReadyStateChanged callback.
             */
            HttpRequest.prototype._xhrOnReadyStateChange = function () {
                var xhr = this.xhr;
                if (xhr.readyState === 4) {
                    var status_1 = xhr.status;
                    if (status_1 === 0) {
                        var response = xhr.response;
                        if (isNull(response)) {
                            try {
                                response = xhr.responseText;
                            }
                            catch (e) { }
                        }
                        // file protocol issue **Needs to be tested more thoroughly** 
                        // ok if response is not empty, Not Found otherwise 
                        if (!isEmpty(response)) {
                            return true;
                        }
                        return false;
                    }
                    // 304 is not modified 
                    if ((status_1 >= 200 && status_1 < 300) || status_1 === 304) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
                // else {} TODO: add progress for xhr if we choose to add progress to AjaxPromise 
            };
            /**
             * The function that initializes and sends the XMLHttpRequest.
             */
            HttpRequest.prototype._sendXhrRequest = function () {
                var _this = this;
                var xhr = this.xhr, options = this.__options, method = options.method, url = options.url, promise = new AjaxPromise(function (resolve, reject) {
                    xhr.onreadystatechange = function () {
                        var success = _this._xhrOnReadyStateChange();
                        if (isNull(success)) {
                            return;
                        }
                        var response = _this._formatResponse(options.responseType, success);
                        if (success) {
                            resolve(response);
                        }
                        else {
                            reject(new AjaxError(response));
                        }
                        _this.xhr = options = null;
                    };
                    if (!isString(method)) {
                        _this._log.info('AjaxOptions method was not of type string. Defaulting to "GET".');
                        method = 'GET';
                    }
                    xhr.open(method.toUpperCase(), url, 
                    // synchronous XHR not supported 
                    true, options.user, options.password);
                    var responseType = options.responseType;
                    if (!(_this.__fileSupported || responseType === '' || responseType === 'text')) {
                        responseType = '';
                    }
                    // Android < 4.4 will throw a DOM Exception 12 if responseType is set to json. 
                    // The only way to do feature detection is with try/catch. 
                    if (responseType === 'json') {
                        try {
                            xhr.responseType = responseType;
                        }
                        catch (e) {
                            xhr.responseType = '';
                        }
                    }
                    xhr.withCredentials = options.withCredentials;
                    var mimeType = options.overrideMimeType, data = options.data;
                    if (isString(mimeType) && !isEmpty(mimeType)) {
                        xhr.overrideMimeType(mimeType);
                    }
                    if (isNull(data) || data === '') {
                        // no data exists so set headers and send request 
                        _this.__setHeaders();
                        xhr.send();
                    }
                    else {
                        var transforms = options.transforms || [], length_3 = transforms.length, contentType = options.contentType, contentTypeExists = isString(contentType) && !isEmpty(contentType);
                        if (length_3 > 0) {
                            // if data transforms defined, assume they're going to take care of 
                            // any and all transformations. 
                            for (var i = 0; i < length_3; ++i) {
                                data = transforms[i](data, xhr);
                            }
                            // if contentType exists, assume they did not set it in 
                            // their headers as well 
                            if (contentTypeExists) {
                                xhr.setRequestHeader('Content-Type', contentType);
                            }
                            _this.__setHeaders();
                            xhr.send(data);
                        }
                        else if (isObject(data)) {
                            // if isObject and contentType exists we want to transform the data 
                            if (contentTypeExists) {
                                var contentTypeLower = contentType.toLowerCase();
                                if (contentTypeLower.indexOf('x-www-form-urlencoded') !== -1) {
                                    // perform an encoded form transformation 
                                    data = _this.__serializeFormData();
                                    // set Content-Type header because we're assuming they didn't set it 
                                    // in their headers object 
                                    xhr.setRequestHeader('Content-Type', contentType);
                                    _this.__setHeaders();
                                    xhr.send(data);
                                }
                                else if (contentTypeLower.indexOf('multipart/form-data') !== -1) {
                                    // need to check if File is a supported object 
                                    if (_this.__fileSupported) {
                                        // use FormData 
                                        data = _this.__appendFormData();
                                        // do not set the Content-Type header due to modern browsers 
                                        // setting special headers for multipart/form-data 
                                        _this.__setHeaders();
                                        xhr.send(data);
                                    }
                                    else {
                                        // use iframe trick for older browsers (do not send a request) 
                                        // this case is the reason for this giant, terrible, nested if-else statement 
                                        _this.__submitFramedFormData().then(function (response) {
                                            resolve(response);
                                        }, function () {
                                            _this.xhr = null;
                                        });
                                    }
                                }
                                else {
                                    // assume stringification is possible 
                                    data = JSON.stringify(data);
                                    // set Content-Type header because we're assuming they didn't set it 
                                    // in their headers object 
                                    xhr.setRequestHeader('Content-Type', contentType);
                                    _this.__setHeaders();
                                    xhr.send(data);
                                }
                            }
                            else {
                                // contentType does not exist so simply set defined headers and send raw data 
                                _this.__setHeaders();
                                xhr.send(data);
                            }
                        }
                        else {
                            // if contentType exists set Content-Type header because we're assuming they didn't set it 
                            // in their headers object 
                            if (contentTypeExists) {
                                xhr.setRequestHeader('Content-Type', contentType);
                            }
                            _this.__setHeaders();
                            xhr.send(data);
                        }
                    }
                    var timeout = options.timeout;
                    if (isNumber(timeout) && timeout > 0) {
                        // we first postpone to avoid always timing out when debugging, though this is not 
                        // a foolproof method. 
                        _this.clearTimeout = postpone(function () {
                            _this.clearTimeout = defer(function () {
                                reject(new AjaxError({
                                    response: 'Request timed out in ' + timeout + 'ms for ' + options.url,
                                    status: xhr.status,
                                    getAllResponseHeaders: function () { return xhr.getAllResponseHeaders(); },
                                    xhr: xhr
                                }));
                                xhr.onreadystatechange = null;
                                xhr.abort();
                                _this.xhr = null;
                            }, timeout - 1);
                        });
                    }
                });
                promise.initialize(this);
                return promise;
            };
            /**
             * Returns a promise that is immediately rejected due to an error.
             */
            HttpRequest.prototype._invalidOptions = function () {
                var _this = this;
                return new AjaxPromise(function (resolve, reject) {
                    _this._log.warn('Attempting a request without specifying a url');
                    reject(new AjaxError({
                        response: 'Attempting a request without specifying a url',
                        status: null,
                        getAllResponseHeaders: null,
                        xhr: null
                    }));
                });
            };
            /**
             * The function that formats the response from the XMLHttpRequest.
             * @param {string} responseType The user designated responseType
             * @param {boolean} success Signifies if the response was a success
             */
            HttpRequest.prototype._formatResponse = function (responseType, success) {
                var xhr = this.xhr, status = xhr.status, response = xhr.response;
                // need to try, catch instead of boolean short circuit because chrome doesn't like checking 
                // responseText when the responseType is anything other than empty or 'text' 
                if (isNull(response)) {
                    try {
                        response = xhr.responseText;
                    }
                    catch (e) { }
                }
                if (status === 0) {
                    // file protocol issue **Needs to be tested more thoroughly** 
                    // ok if response empty, Not Found otherwise 
                    status = success ? 200 : 404;
                }
                xhr.onreadystatechange = null;
                if (isFunction(this.clearTimeout)) {
                    this.clearTimeout();
                }
                if (responseType === 'json' && isString(response)) {
                    try {
                        response = JSON.parse(response);
                    }
                    catch (e) { }
                }
                return {
                    response: response,
                    status: status,
                    getAllResponseHeaders: function () { return xhr.getAllResponseHeaders(); },
                    xhr: xhr
                };
            };
            /**
             * Sets the headers for an XMLHttpRequest
             */
            HttpRequest.prototype.__setHeaders = function () {
                var headers = this.__options.headers, keys = Object.keys(headers || {}), xhr = this.xhr, length = keys.length, key, i;
                for (i = 0; i < length; ++i) {
                    key = keys[i];
                    xhr.setRequestHeader(key, headers[key]);
                }
            };
            /**
             * Serializes multipart form data in an XMLHttpRequest as a string.
             */
            HttpRequest.prototype.__serializeFormData = function () {
                var data = this.__options.data, keys = Object.keys(data), key, val, formBuffer = [];
                while (keys.length > 0) {
                    key = keys.pop();
                    val = data[key];
                    if (isNull(val)) {
                        val = '';
                    }
                    else if (isObject(val)) {
                        // may throw a fatal error but this is an invalid case 
                        this._log.warn('Invalid form entry with key "' + key + '" and value "' + val);
                        val = JSON.stringify(val);
                    }
                    formBuffer.push(encodeURIComponent(key) + '=' + encodeURIComponent(val));
                }
                return formBuffer.join('&').replace(/%20/g, '+');
            };
            /**
             * Creates FormData to add to the XMLHttpRequest.
             */
            HttpRequest.prototype.__appendFormData = function () {
                var data = this.__options.data, formData = new FormData(), keys = Object.keys(data), key, val;
                while (keys.length > 0) {
                    key = keys.pop();
                    val = data[key];
                    if (isNull(val)) {
                        formData.append(key, '');
                    }
                    else if (isObject(val)) {
                        if (isFile(val)) {
                            formData.append(key, val, val.name || val.fileName || 'blob');
                        }
                        else {
                            // may throw a fatal error but this is an invalid case 
                            this._log.warn('Invalid form entry with key "' + key + '" and value "' + val);
                            formData.append(key, JSON.stringify(val));
                        }
                    }
                    else {
                        formData.append(key, val);
                    }
                }
                return formData;
            };
            /**
             * Handles submitting multipart form data using an iframe.
             */
            HttpRequest.prototype.__submitFramedFormData = function () {
                var _this = this;
                var options = this.__options, data = options.data, url = options.url, _document = this._document, $body = _document.body, Promise = acquire(__Promise), form = _document.createElement('form'), iframe = _document.createElement('iframe'), iframeName = uniqueId('iframe_target'), keys = Object.keys(data), key;
                iframe.name = form.target = iframeName;
                iframe.src = 'javascript:false;';
                form.enctype = form.encoding = 'multipart/form-data';
                form.action = url;
                form.method = 'POST';
                form.style.display = 'none';
                while (keys.length > 0) {
                    key = keys.pop();
                    form.insertBefore(this.__createInput(key, data[key]), null);
                }
                return new Promise(function (resolve, reject) {
                    _this.xhr.abort = function () {
                        iframe.onload = null;
                        $body.removeChild(form);
                        $body.removeChild(iframe);
                        reject();
                    };
                    iframe.onload = function () {
                        var content = iframe.contentDocument.body.innerHTML;
                        $body.removeChild(form);
                        $body.removeChild(iframe);
                        resolve({
                            response: content,
                            status: 200,
                            getAllResponseHeaders: function () { return ''; }
                        });
                        _this.xhr = iframe.onload = null;
                    };
                    $body.insertBefore(form, null);
                    $body.insertBefore(iframe, null);
                    form.submit();
                });
            };
            /**
             * Creates input for form data submissions.
             */
            HttpRequest.prototype.__createInput = function (key, val) {
                var _document = this._document, input = _document.createElement('input');
                input.type = 'hidden';
                input.name = key;
                if (isNull(val)) {
                    input.value = '';
                }
                else if (isObject(val)) {
                    // check if val is an pseudo File 
                    if (isFunction(val.slice) && !(isUndefined(val.name) || isUndefined(val.path))) {
                        var fileList = _document.querySelectorAll('input[type="file"][name="' + key + '"]'), length_4 = fileList.length;
                        // if no inputs found, stringify the data 
                        if (length_4 === 0) {
                            this._log.info('Could not find input[type="file"] with [name="' + key +
                                '"]. Stringifying data instead.');
                            input.value = JSON.stringify(val);
                        }
                        else if (length_4 === 1) {
                            input = fileList[0];
                            // swap nodes 
                            var clone = input.cloneNode(true);
                            input.parentNode.insertBefore(clone, input);
                        }
                        else {
                            // rare case but may have multiple forms with file inputs 
                            // that have the same name 
                            var fileInput = void 0, path = val.path;
                            while (length_4-- > 0) {
                                fileInput = fileList[length_4];
                                if (fileInput.value === path) {
                                    input = fileInput;
                                    // swap nodes 
                                    var inputClone = input.cloneNode(true);
                                    input.parentNode.insertBefore(inputClone, input);
                                    break;
                                }
                            }
                            // could not find the right file 
                            if (length_4 === -1) {
                                this._log.info('Could not find input[type="file"] with [name="' + key + '"] and [value="' +
                                    val.path + '"]. Stringifying data instead.');
                                input.value = JSON.stringify(val);
                            }
                        }
                    }
                    else {
                        // may throw a fatal error but this is an invalid case 
                        this._log.info('Invalid form entry with key "' + key + '" and value "' + val);
                        input.value = JSON.stringify(val);
                    }
                }
                else {
                    input.value = val;
                }
                return input;
            };
            HttpRequest._inject = {
                _browser: __Browser,
                _window: __Window,
                _document: __Document,
                _config: __HttpConfig,
                _log: __Log
            };
            return HttpRequest;
        }());
        async.HttpRequest = HttpRequest;
        /**
         * A class that forms an Error object with an IAjaxResponse.
         */
        var AjaxError = (function () {
            /**
             * The constructor for an AjaxError.
             * @param {plat.async.IAjaxResponse} response The IAjaxResponse object.
             */
            function AjaxError(response) {
                /**
                 * The name of the Error ('AjaxError')
                 */
                this.name = 'AjaxError';
                Error.apply(this);
                this.response = this.message = response.response;
                this.status = response.status;
                this.getAllResponseHeaders = response.getAllResponseHeaders;
                this.xhr = response.xhr;
            }
            /**
             * Outputs a formatted string describing the AjaxError.
             */
            AjaxError.prototype.toString = function () {
                var response = this.response, responseText = response;
                if (isObject(response) && !response.hasOwnProperty('toString')) {
                    responseText = JSON.stringify(response);
                }
                return 'Request failed with status: ' + this.status + ' and response: ' + responseText;
            };
            return AjaxError;
        }());
        async.AjaxError = AjaxError;
        // have to bypass TS flags in order to properly extend Error 
        AjaxError.prototype = Error.prototype;
        /**
         * Describes a type of Promise that fulfills with an IAjaxResponse
         * and can be optionally cancelled.
         */
        var AjaxPromise = (function (_super) {
            __extends(AjaxPromise, _super);
            function AjaxPromise(resolveFunction, promise) {
                _super.call(this, resolveFunction);
                /**
                 * The Window object.
                 */
                this._window = acquire(__Window);
                if (!isNull(promise)) {
                    this.__http = promise.__http;
                }
            }
            /**
             * A method to initialize this AjaxPromise, passing it the
             * associated IHttpRequest.
             * @param {plat.async.HttpRequest} http The http request for this promise.
             */
            AjaxPromise.prototype.initialize = function (http) {
                if (isObject(http) && isNull(this.__http)) {
                    this.__http = http;
                }
            };
            /**
             * A method to cancel the AJAX call associated with this AjaxPromise.
             */
            AjaxPromise.prototype.cancel = function () {
                var http = this.__http, xhr = http.xhr, jsonpCallback = http.jsonpCallback;
                if (isFunction(http.clearTimeout)) {
                    http.clearTimeout();
                }
                if (!isNull(xhr)) {
                    xhr.onreadystatechange = null;
                    xhr.abort();
                    http.xhr = null;
                }
                else if (!isNull(jsonpCallback)) {
                    this._window[jsonpCallback] = noop;
                }
                this.__subscribers = [];
            };
            AjaxPromise.prototype.then = function (onFulfilled, onRejected) {
                return _super.prototype.then.call(this, onFulfilled, onRejected);
            };
            AjaxPromise.prototype.catch = function (onRejected) {
                return _super.prototype.catch.call(this, onRejected);
            };
            return AjaxPromise;
        }(Promise));
        async.AjaxPromise = AjaxPromise;
        /**
         * The instantiated class of the injectable for making
         * AJAX requests.
         */
        var Http = (function () {
            function Http() {
                /**
                 * Provides value mappings for XMLHttpRequestResponseTypes
                 */
                this.responseType = {
                    DEFAULT: '',
                    ARRAYBUFFER: 'arraybuffer',
                    BLOB: 'blob',
                    DOCUMENT: 'document',
                    JSON: 'json',
                    TEXT: 'text'
                };
                /**
                 * Provides Content-Type mappings for Http POST requests.
                 */
                this.contentType = {
                    ENCODED_FORM: 'application/x-www-form-urlencoded;charset=utf-8',
                    JSON: 'application/json;charset=utf-8',
                    MULTIPART_FORM: 'multipart/form-data',
                    OCTET_STREAM: 'application/octet-stream;charset=utf-8',
                    XML: 'application/xml;charset=utf-8',
                    PLAIN_TEXT: 'text/plain',
                    HTML: 'text/html'
                };
            }
            /**
             * A wrapper method for the Http class that creates and executes a new Http with
             * the specified IHttpConfig. This function will check if
             * XMLHttpRequest level 2 is present, and will default to JSONP if it isn't and
             * the request is cross-domain.
             * @param {plat.async.IHttpConfig} options The IHttpConfig for either the XMLHttpRequest
             * or the JSONP callback.
             */
            Http.prototype.ajax = function (options) {
                var request = acquire(__HttpRequestInstance);
                request.initialize(options);
                return request.execute();
            };
            /**
             * A direct method to force a cross-domain JSONP request.
             * @param {plat.async.IJsonpConfig} options The IJsonpConfig
             */
            Http.prototype.jsonp = function (options) {
                var request = acquire(__HttpRequestInstance);
                request.initialize(options);
                return request.executeJsonp();
            };
            /**
             * Makes an ajax request, specifying responseType: 'json'.
             * @param {plat.async.IHttpConfig} options The IHttpConfig
             * for either the XMLHttpRequest or the JSONP callback.
             */
            Http.prototype.json = function (options) {
                var request = acquire(__HttpRequestInstance);
                request.initialize(_extend(false, false, {}, options, { responseType: 'json' }));
                return request.execute();
            };
            /**
             * Default Http config
             */
            Http.config = {
                url: null,
                method: 'GET',
                responseType: '',
                transforms: [],
                headers: {},
                withCredentials: false,
                timeout: null,
                jsonpIdentifier: 'callback',
                contentType: 'application/json;charset=utf-8'
            };
            return Http;
        }());
        async.Http = Http;
        register.injectable(__Http, Http);
        register.injectable(__HttpRequestInstance, HttpRequest, null, __INSTANCE);
        /**
         */
        function IHttpConfig() {
            return Http.config;
        }
        async.IHttpConfig = IHttpConfig;
        register.injectable(__HttpConfig, IHttpConfig);
    })(async = plat_1.async || (plat_1.async = {}));
    /**
     * Holds classes and interfaces related to storage in platypus.
     */
    var storage;
    (function (storage_1) {
        /**
         * The keyed collection of all created Caches in the
         * ICacheFactory.
         */
        var caches = {}, 
        /**
         * Internal storage for all the items stored in each Cache.
         */
        internalCaches = {};
        /**
         * A Cache class, for use with the ICacheFactory injectable.
         * Used for storing objects. Takes in a generic type corresponding to the type of objects it contains.
         */
        var Cache = (function () {
            /**
             * The constructor for a Cache.
             * @param {string} id The id to use to retrieve the cache from the ICacheFactory.
             * @param {plat.storage.ICacheOptions} options The ICacheOptions for customizing the cache.
             */
            function Cache(uid, options) {
                this.__uid = uid;
                this.__options = options;
                this.__size = 0;
                if (isNull(options)) {
                    this.__options = {
                        timeout: 0
                    };
                }
                internalCaches[uid] = {};
            }
            /**
             * Method for creating a new cache object. Takes a generic type to denote the
             * type of objects stored in the new cache.  If a cache with the same ID already exists
             * in the ICacheFactory, a new cache will not be created.
             * @param {string} uid The ID of the new Cache.
             * @param {plat.storage.ICacheOptions} options ICacheOptions
             * for customizing the Cache.
             */
            Cache.create = function (uid, options) {
                var cache = caches[uid];
                if (isNull(cache)) {
                    cache = caches[uid] = new Cache(uid, options);
                }
                return cache;
            };
            /**
             * Gets a cache out of the ICacheFactory if it exists.
             * @param {string} uid The identifier used to search for the cache.
             */
            Cache.fetch = function (uid) {
                return caches[uid];
            };
            /**
             * Clears the ICacheFactory and all of its caches.
             */
            Cache.clear = function () {
                var keys = Object.keys(caches), length = keys.length;
                for (var i = 0; i < length; ++i) {
                    caches[keys[i]].clear();
                }
                caches = {};
            };
            /**
             * Retrieves the ICacheInfo about this cache
             * (i.e. ID, size, options)
             */
            Cache.prototype.info = function () {
                return {
                    uid: this.__uid,
                    size: this.__size,
                    options: this.__options
                };
            };
            /**
             * Method for inserting an object into an Cache.
             * @param {string} key The key to use for storage/retrieval of the object.
             * @param {T} value The value to store with the associated key.
             */
            Cache.prototype.put = function (key, value) {
                var val = internalCaches[this.__uid][key];
                internalCaches[this.__uid][key] = value;
                if (isUndefined(val)) {
                    this.__size++;
                }
                var timeout = this.__options.timeout;
                if (isNumber(timeout) && timeout > 0) {
                    defer(this.remove, timeout, [key], this);
                }
                return value;
            };
            /**
             * Method for retrieving an object from an Cache.
             * @param key The key to search for in an Cache.
             */
            Cache.prototype.read = function (key) {
                return internalCaches[this.__uid][key];
            };
            /**
             * Method for removing an object from an Cache.
             * @param {string} key The key to remove from the Cache.
             */
            Cache.prototype.remove = function (key) {
                deleteProperty(internalCaches[this.__uid], key);
                this.__size--;
            };
            /**
             * Method for clearing an Cache, removing all of its keys.
             */
            Cache.prototype.clear = function () {
                internalCaches[this.__uid] = {};
                this.__size = 0;
            };
            /**
             * Method for removing an ICache from the ICacheFactory.
             */
            Cache.prototype.dispose = function () {
                this.clear();
                deleteProperty(caches, this.__uid);
            };
            return Cache;
        }());
        storage_1.Cache = Cache;
        /**
         */
        function ICacheFactory() {
            return Cache;
        }
        storage_1.ICacheFactory = ICacheFactory;
        register.injectable(__CacheFactory, ICacheFactory, null, __FACTORY);
        /**
         */
        storage_1.managerCache = Cache.create('__managerCache');
        /**
         */
        function IManagerCache() {
            return storage_1.managerCache;
        }
        storage_1.IManagerCache = IManagerCache;
        register.injectable(__ManagerCache, IManagerCache);
        /**
         * Used for caching compiled nodes. This class will
         * clone a template when you put it in the cache. It will
         * also clone the template when you retrieve it.
         */
        var TemplateCache = (function (_super) {
            __extends(TemplateCache, _super);
            /**
             * The constructor for a TemplateCache. Creates a new Cache
             * with the ID "__templateCache".
             */
            function TemplateCache() {
                _super.call(this, '__templateCache');
            }
            TemplateCache.prototype.put = function (key, value) {
                var Promise = this._Promise;
                _super.prototype.put.call(this, key, Promise.resolve(value));
                if (isDocumentFragment(value)) {
                    value = value.cloneNode(true);
                }
                else if (isNode(value)) {
                    var fragment = document.createDocumentFragment();
                    fragment.appendChild(value.cloneNode(true));
                    value = fragment;
                }
                else if (isString(value) || isNull(value)) {
                    value = serializeHtml(value);
                }
                return Promise.resolve(value);
            };
            /**
             * Method for retrieving a Node from this cache. The DocumentFragment that resolves from the returned
             * Promise will be cloned to avoid manipulating the cached template.
             * @param {string} key The key to search for in this cache.
             */
            TemplateCache.prototype.read = function (key) {
                var _this = this;
                var promise = _super.prototype.read.call(this, key);
                if (isNull(promise)) {
                    return this._Promise.reject(null);
                }
                return promise.then(function (node) {
                    return _this.put(key, node);
                }, function (error) {
                    _this._log.warn('Error retrieving template, ' + key + ', from promise.');
                    return null;
                });
            };
            TemplateCache._inject = {
                _Promise: __Promise,
                _log: __Log
            };
            return TemplateCache;
        }(Cache));
        storage_1.TemplateCache = TemplateCache;
        register.injectable(__TemplateCache, TemplateCache);
        /**
         * A base class for storing data with a designated storage type.
         */
        var BaseStorage = (function () {
            /**
             * The constructor for a BaseStorage.
             */
            function BaseStorage(storage) {
                var _this = this;
                this._storage = storage;
                forEach(function (value, key) {
                    _this[key] = value;
                }, storage);
            }
            Object.defineProperty(BaseStorage.prototype, "length", {
                /**
                 * Returns the number of items in storage.
                 */
                get: function () {
                    return this._storage.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Clears storage, deleting all of its keys.
             */
            BaseStorage.prototype.clear = function () {
                this._storage.clear();
            };
            /**
             * Gets an item out of storage with the assigned key.
             * @param {string} key The key of the item to retrieve from storage.
             */
            BaseStorage.prototype.getItem = function (key) {
                return this._storage.getItem(key);
            };
            /**
             * Allows for iterating over storage keys with an index. When
             * called with an index, it will return the key at that index in
             * storage.
             * @param {number} index The index used to retrieve the associated key.
             */
            BaseStorage.prototype.key = function (index) {
                return this._storage.key(index);
            };
            /**
             * Searches in storage for an item and removes it if it
             * exists.
             * @param {string} key The key of the item to remove from storage.
             */
            BaseStorage.prototype.removeItem = function (key) {
                this._storage.removeItem(key);
            };
            /**
             * Adds data to storage with the designated key.
             * @param {string} key The key of the item to store in storage.
             * @param {string} data The data to store in storage with the key.
             */
            BaseStorage.prototype.setItem = function (key, data) {
                this._storage.setItem(key, data);
                this[key] = this.getItem(key);
            };
            return BaseStorage;
        }());
        storage_1.BaseStorage = BaseStorage;
        /**
         * A class used to wrap HTML5 localStorage into an injectable.
         */
        var LocalStorage = (function (_super) {
            __extends(LocalStorage, _super);
            function LocalStorage() {
                _super.call(this, acquire(__Window).localStorage);
            }
            return LocalStorage;
        }(BaseStorage));
        storage_1.LocalStorage = LocalStorage;
        register.injectable(__LocalStorage, LocalStorage);
        /**
         * A class for wrapping SessionStorage as an injectable.
         */
        var SessionStorage = (function (_super) {
            __extends(SessionStorage, _super);
            function SessionStorage() {
                _super.call(this, acquire(__Window).sessionStorage);
            }
            return SessionStorage;
        }(BaseStorage));
        storage_1.SessionStorage = SessionStorage;
        register.injectable(__SessionStorage, SessionStorage);
    })(storage = plat_1.storage || (plat_1.storage = {}));
    /* tslint:disable:no-unused-variable */
    /**
     * An object used to create ITokenDetails for every operator.
     */
    var OPERATORS = {
        'u+': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return +a(context, aliases);
            }
        },
        '+': {
            precedence: 6, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) + b(context, aliases);
            }
        },
        'u-': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return -a(context, aliases);
            }
        },
        '-': {
            precedence: 6, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) - b(context, aliases);
            }
        },
        '*': {
            precedence: 5, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) * b(context, aliases);
            }
        },
        '/': {
            precedence: 5, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) / b(context, aliases);
            }
        },
        '%': {
            precedence: 5, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) % b(context, aliases);
            }
        },
        '?': {
            precedence: 15, associativity: 'rtl',
            fn: function () { return undefined; }
        },
        ':': {
            precedence: 15, associativity: 'rtl',
            fn: function () { return undefined; }
        },
        '>': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) > b(context, aliases);
            }
        },
        '<': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) < b(context, aliases);
            }
        },
        '!': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return !a(context, aliases);
            }
        },
        '~': {
            precedence: 4, associativity: 'rtl',
            fn: function (context, aliases, a) {
                return ~a(context, aliases);
            }
        },
        '&': {
            precedence: 10, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) & b(context, aliases);
            }
        },
        '|': {
            precedence: 12, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) | b(context, aliases);
            }
        },
        '>>': {
            precedence: 7, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) >> b(context, aliases);
            }
        },
        '<<': {
            precedence: 7, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) << b(context, aliases);
            }
        },
        '>>>': {
            precedence: 7, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) >>> b(context, aliases);
            }
        },
        '&&': {
            precedence: 13, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) && b(context, aliases);
            }
        },
        '||': {
            precedence: 14, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) || b(context, aliases);
            }
        },
        '==': {
            precedence: 9, associativity: 'ltr',
            /* tslint:disable:triple-equals */
            fn: function (context, aliases, a, b) {
                return a(context, aliases) == b(context, aliases);
            }
        },
        '===': {
            precedence: 9, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) === b(context, aliases);
            }
        },
        '!=': {
            precedence: 9, associativity: 'ltr',
            /* tslint:disable:triple-equals */
            fn: function (context, aliases, a, b) {
                return a(context, aliases) != b(context, aliases);
            }
        },
        '!==': {
            precedence: 9, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) !== b(context, aliases);
            }
        },
        '>=': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) >= b(context, aliases);
            }
        },
        '<=': {
            precedence: 8, associativity: 'ltr',
            fn: function (context, aliases, a, b) {
                return a(context, aliases) <= b(context, aliases);
            }
        },
        '=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '++': {
            precedence: 3, associativity: '',
            fn: function (context, aliases, a) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '--': {
            precedence: 3, associativity: '',
            fn: function (context, aliases, a) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '+=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '-=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '*=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '/=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        },
        '%=': {
            precedence: 17, associativity: 'rtl',
            fn: function (context, aliases, a, b) {
                var _log = plat.acquire(__Log);
                _log.error(new Error('Assignment operators are not supported'));
            }
        }
    };
    /**
     * An object used to create ITokenDetails for every accessor.
     */
    var ACCESSORS = {
        '()': { precedence: 2, associativity: null, fn: null },
        '[]': { precedence: 2, associativity: null, fn: null },
        '.': { precedence: 2, associativity: null, fn: null },
        '{}': { precedence: 1, associativity: null, fn: null }
    };
    /**
     * An object used to create ITokenDetails for every delimiter.
     */
    var DELIMITERS = {
        '{': { precedence: 1, associativity: null, fn: null },
        '}': { precedence: 1, associativity: null, fn: null },
        '[': { precedence: 2, associativity: null, fn: null },
        ']': { precedence: 2, associativity: null, fn: null },
        '(': { precedence: 2, associativity: null, fn: null },
        ')': { precedence: 2, associativity: null, fn: null },
        '.': { precedence: 2, associativity: null, fn: null },
        ',': { precedence: 18, associativity: null, fn: null },
        '\'': { precedence: 0, associativity: null, fn: null },
        '"': { precedence: 0, associativity: null, fn: null }
    };
    /**
     * An object used to get literal values from string values of false, true, and undefined
     */
    var KEYWORDS = {
        false: false,
        true: true,
        null: null,
        undefined: 'undefined'
    };
    /**
     * Checks if a string is in the DELIMITERS array.
     * @param {string} key The string to index into the DELIMITERS array.
     */
    function isDelimiter(key) {
        return !isNull(DELIMITERS[key]);
    }
    /**
     * Checks if a string is in the ACCESSORS array.
     * @param {string} key The string to index into the ACCESSORS array.
     */
    function isAccessor(key) {
        return !isNull(ACCESSORS[key]);
    }
    /**
     * Checks if a string is in the OPERATORS array.
     * @param {string} key The string to index into the OPERATORS array.
     */
    function isOperator(key) {
        return !isNull(OPERATORS[key]);
    }
    /**
     * Checks if a string is in the KEYWORDS array.
     * @param {string} key The string to index into the KEYWORDS array.
     */
    function isKeyword(key) {
        return !isUndefined(KEYWORDS[key]);
    }
    /* tslint:enable:no-unused-variable */
    /**
     * Holds all classes and interfaces related to observable components in platypus.
     */
    var observable;
    (function (observable) {
        /**
         * The array methods to be overwritten if it is to be observed.
         */
        var arrayMethods = ['push', 'pop', 'reverse', 'shift', 'sort', 'splice', 'unshift'];
        /**
         * A class for managing both context inheritance and observable properties on controls and
         * facilitating in data-binding.
         */
        var ContextManager = (function () {
            function ContextManager() {
                /**
                 * Reference to the Compat injectable.
                 */
                this._compat = acquire(__Compat);
                /**
                 * An object for quickly accessing callbacks associated with a given identifier.
                 */
                this.__identifiers = {};
                /**
                 * An object for quickly accessing child context associations (helps with
                 * notifying child properties).
                 */
                this.__identifierHash = {};
                /**
                 * An object for storing listeners for Array length changes.
                 */
                this.__lengthListeners = {};
                /**
                 * An object for quickly accessing previously accessed or observed objects and properties.
                 */
                this.__contextObjects = {};
                /**
                 * Whether or not the property currently being modified is due to an observed array function.
                 */
                this.__isArrayFunction = false;
            }
            /**
             * Gets the ContextManager associated to the given control. If no
             * ContextManager exists, one is created for that control.
             * @param {plat.Control} control The control on which to locate the ContextManager.
             */
            ContextManager.getManager = function (control) {
                var contextManager, managers = ContextManager.__managers, uid = control.uid, manager = managers[uid];
                if (!isNull(manager)) {
                    contextManager = manager;
                    return contextManager;
                }
                contextManager = managers[uid] = new ContextManager();
                contextManager.context = control;
                return contextManager;
            };
            ContextManager.dispose = function (control) {
                if (isNull(control)) {
                    return;
                }
                var uid = control.uid, controls = ContextManager.__controls, identifiers = controls[uid] || {}, managers = ContextManager.__managers, manager = managers[uid];
                if (!isNull(manager)) {
                    manager.dispose();
                    deleteProperty(managers, uid);
                }
                var keys = Object.keys(identifiers), listeners;
                while (keys.length > 0) {
                    listeners = identifiers[keys.shift()];
                    while (listeners.length > 0) {
                        listeners.shift()();
                    }
                }
                deleteProperty(controls, uid);
                if (!isNull(control.context)) {
                    ContextManager.unObserve(control.context);
                    ContextManager.defineProperty(control, __CONTEXT, control.context, true, true, true);
                }
            };
            /**
             * Removes all listeners for an Array associated with a given uid.
             * @param {string} absoluteIdentifier The identifier used to locate the array.
             * @param {string} uid The uid used to search for listeners.
             */
            ContextManager.removeArrayListeners = function (absoluteIdentifier, uid) {
                var listeners = ContextManager.arrayChangeListeners[absoluteIdentifier];
                if (!isNull(listeners)) {
                    deleteProperty(listeners, uid);
                }
            };
            /**
             * Safely retrieves the local context given a root context and an Array of
             * property strings.
             * @param {any} rootContext The root object in which to find a local context.
             * @param {Array<string>} split The string array containing properties used to index into
             * the rootContext.
             */
            ContextManager.getContext = function (rootContext, split) {
                if (isNull(rootContext)) {
                    return rootContext;
                }
                split = split.slice(0);
                while (split.length > 0) {
                    rootContext = rootContext[split.shift()];
                    if (isNull(rootContext)) {
                        return rootContext;
                    }
                }
                return rootContext;
            };
            /**
             * Defines an object property with the associated value. Useful for unobserving objects.
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             * @param {boolean} writable? Whether or not assignment operators work on the property.
             */
            ContextManager.defineProperty = function (obj, key, value, enumerable, configurable, writable) {
                _defineProperty(obj, key, value, enumerable, configurable, writable);
            };
            /**
             * Defines an object property with the associated value. Useful for unobserving objects.
             * @param {any} obj The object on which to define the property.
             * @param {string} key The property key.
             * @param {any} value The value used to define the property.
             * @param {boolean} enumerable? Whether or not the property should be enumerable (able to be iterated
             * over in a loop)
             * @param {boolean} configurable? Whether or not the property is able to be reconfigured.
             */
            ContextManager.defineGetter = function (obj, key, value, enumerable, configurable) {
                _defineGetter(obj, key, value, enumerable, configurable);
            };
            /**
             * Pushes the function for removing an observed property upon adding the property.
             * @param {string} identifer The identifier for which the remove listener is being pushed.
             * @param {string} uid The unique ID of the control observing the identifier.
             * @param {plat.IRemoveListener} listener The function for removing the observed property.
             */
            ContextManager.pushRemoveListener = function (identifier, uid, listener) {
                var controls = ContextManager.__controls, control = controls[uid], listeners;
                if (isNull(control)) {
                    control = controls[uid] = {};
                }
                listeners = control[identifier];
                if (isNull(listeners)) {
                    listeners = control[identifier] = [];
                }
                listeners.push(listener);
            };
            /**
             * Splices a given function for removing an observed property.
             * @param {string} identifer The identifier for which the remove listener is being spliced.
             * @param {string} uid The unique ID of the control observing the identifier.
             * @param {plat.IRemoveListener} listener The function for removing the observed property.
             */
            ContextManager.spliceRemoveListener = function (identifier, uid, listener) {
                var controls = ContextManager.__controls, control = controls[uid], listeners;
                if (isNull(control)) {
                    return;
                }
                listeners = control[identifier];
                if (isNull(listeners)) {
                    return;
                }
                var index = listeners.indexOf(listener);
                if (index === -1) {
                    return;
                }
                listeners.splice(index, 1);
                if (listeners.length === 0) {
                    deleteProperty(control, identifier);
                }
            };
            /**
             * Removes a specified identifier from being observed for a given set of control IDs.
             * @param {Array<string>} uids The set of unique Ids for which to remove the specified identifier.
             * @param {string} identifier The identifier to stop observing.
             */
            ContextManager.removeIdentifier = function (uids, identifier) {
                var length = uids.length, controls = ContextManager.__controls, identifiers;
                for (var i = 0; i < length; ++i) {
                    identifiers = controls[uids[i]];
                    if (isNull(identifiers)) {
                        continue;
                    }
                    deleteProperty(identifiers, identifier);
                }
            };
            /**
             * Ensures that an identifier path will exist on a given control. Will create
             * objects/arrays if necessary.
             * @param {plat.ui.TemplateControl} control The TemplateControl
             * on which to create the context.
             * @param {string} identifier The period-delimited identifier string used to create
             * the context path.
             */
            ContextManager.createContext = function (control, identifier) {
                var context = control.context;
                if (!isObject(context)) {
                    if (isNull(context)) {
                        context = control.context = {};
                    }
                    else {
                        ContextManager._log.warn('A child control is trying to create a child context that has ' +
                            'a parent control with a primitive type context');
                        return;
                    }
                }
                var split = identifier.split('.'), property, temp;
                while (split.length > 0) {
                    property = split.shift();
                    temp = context[property];
                    if (isNull(temp)) {
                        if (isNumber(Number(split[0]))) {
                            temp = context[property] = [];
                        }
                        else {
                            temp = context[property] = {};
                        }
                    }
                    context = temp;
                }
                return context;
            };
            /**
             * Iterates through all the nested properties in an object and redefines the properties to not use getters/setters
             * @param {any} obj The object to stop observing.
             */
            ContextManager.unObserve = function (obj) {
                _extend(true, true, obj);
            };
            /**
             * Safely retrieves the local context for this manager given an Array of
             * property strings and observes it if not found.
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             * @param {boolean} observe? Whether or not to observe the identifier indicated by the
             * split Array.
             */
            ContextManager.prototype.getContext = function (split, observe) {
                return this._getContext(split.join('.'), split, observe);
            };
            /**
             * Given a period-delimited identifier, observes an object and calls the given listener when the
             * object changes.
             * @param {string} absoluteIdentifier The period-delimited identifier noting the property to be observed.
             * @param {plat.observable.IListener} observableListener An object implmenting IObservableListener. The listener will be
             * notified of object changes.
             */
            ContextManager.prototype.observe = function (absoluteIdentifier, observableListener) {
                var _this = this;
                if (isEmpty(absoluteIdentifier)) {
                    return noop;
                }
                var split = absoluteIdentifier.split('.'), key = split.pop(), isLength = key === 'length', hasIdentifier = this._hasIdentifier(absoluteIdentifier), hasObservableListener = !isNull(observableListener), join, context;
                if (split.length > 0) {
                    join = split.join('.');
                    context = this._getContext(join, split, true);
                }
                else {
                    join = key;
                    context = this.context;
                }
                if (!isObject(context)) {
                    if (hasObservableListener) {
                        if (isLength) {
                            this.__lengthListeners[absoluteIdentifier] = observableListener;
                            ContextManager.pushRemoveListener(absoluteIdentifier, observableListener.uid, function () {
                                deleteProperty(_this.__lengthListeners, absoluteIdentifier);
                            });
                        }
                        return this._addObservableListener(absoluteIdentifier, observableListener, isLength);
                    }
                    return noop;
                }
                // set observedIdentifier to null 
                this.__observedIdentifier = null;
                this.__contextObjects[absoluteIdentifier] = context[key];
                // if observedIdentifier is not null, the primitive is already being watched 
                var observedIdentifier = this.__observedIdentifier, isObserved = !isNull(observedIdentifier), removeCallback = noop;
                if (isObserved) {
                    hasIdentifier = true;
                }
                if (hasObservableListener) {
                    var removeObservedCallback_1 = noop, removeAbsoluteCallback_1 = this._addObservableListener(absoluteIdentifier, observableListener, isLength);
                    if (isObserved && absoluteIdentifier !== observedIdentifier) {
                        removeObservedCallback_1 = this._addObservableListener(observedIdentifier, observableListener, isLength);
                    }
                    removeCallback = function () {
                        removeAbsoluteCallback_1();
                        removeObservedCallback_1();
                    };
                }
                var parentIsArray = isArray(context), removeObservableListener = removeCallback, removeListener = noop, removeArrayObserve = noop, numKey = Number(key);
                if (parentIsArray && numKey >= context.length) {
                    removeListener = this.observe(join + '.length', {
                        uid: observableListener.uid,
                        listener: function (newValue, oldValue) {
                            if (numKey >= newValue) {
                                return;
                            }
                            removeListener();
                            _this._define(absoluteIdentifier, context, key);
                        }
                    });
                    removeCallback = function () {
                        removeObservableListener();
                        removeListener();
                    };
                }
                else if (!hasIdentifier) {
                    // check if value is defined and context manager hasn't seen this identifier 
                    if (parentIsArray && isLength) {
                        var property = split.pop(), parentContext = this.getContext(split, false);
                        this.__observedIdentifier = null;
                        access(parentContext, property);
                        if (isString(this.__observedIdentifier)) {
                            join = this.__observedIdentifier;
                        }
                        if (hasObservableListener) {
                            var uid_1 = observableListener.uid;
                            removeListener = this.observeArrayMutation(uid_1, noop, join, context, null);
                            removeArrayObserve = this.observe(join, {
                                uid: uid_1,
                                listener: function (newValue, oldValue) {
                                    removeListener();
                                    removeListener = _this.observeArrayMutation(uid_1, noop, join, newValue, oldValue);
                                }
                            });
                        }
                        removeCallback = function () {
                            removeObservableListener();
                            removeArrayObserve();
                            removeListener();
                        };
                    }
                    else {
                        this._define(absoluteIdentifier, context, key);
                    }
                }
                return removeCallback;
            };
            /**
             * Observes an array and calls the listener when certain functions are called on
             * that array. The watched functions are push, pop, shift, splice, unshift, sort,
             * and reverse.
             * @param {string} uid The unique ID of the object observing the array.
             * @param {(changes: Array<plat.observable.IArrayChanges<any>>) => void} listener The callback for after
             * when an observed Array function has been called.
             * @param {string} absoluteIdentifier The identifier from the root context used to find the array.
             * @param {Array<any>} array The array to be observed.
             * @param {Array<any>} oldArray The old array to stop observing.
             */
            ContextManager.prototype.observeArrayMutation = function (uid, listener, absoluteIdentifier, array, oldArray) {
                if (isArray(oldArray)) {
                    this._restoreArray(oldArray);
                }
                if (isNull(array)) {
                    return noop;
                }
                var split = absoluteIdentifier.split('.'), property = split.pop(), context = this.getContext(split, false);
                this.__observedIdentifier = null;
                access(context, property);
                if (isString(this.__observedIdentifier)) {
                    absoluteIdentifier = this.__observedIdentifier;
                }
                var removeListeners = [];
                if (isFunction(listener)) {
                    removeListeners.push(this._pushArrayListener(uid, absoluteIdentifier, listener));
                }
                this._overwriteArray(absoluteIdentifier, array);
                return function () {
                    while (removeListeners.length > 0) {
                        removeListeners.pop()();
                    }
                };
            };
            /**
             * Disposes the memory for an ContextManager.
             */
            ContextManager.prototype.dispose = function () {
                this.context = null;
                this.__identifiers = {};
                this.__identifierHash = {};
                this.__contextObjects = {};
            };
            /**
             * Pushes Array mutation listeners and removers.
             * @param {string} uid The unique identifier to store the callback.
             * @param {string} absoluteIdentifier The identifier of the Array being observed.
             * @param {(changes: Array<plat.observable.IArrayChanges<any>>) => void} listener The Array mutation listener.
             */
            ContextManager.prototype._pushArrayListener = function (uid, absoluteIdentifier, listener) {
                var arrayListeners = ContextManager.arrayChangeListeners, arrayCallbacks = arrayListeners[absoluteIdentifier];
                if (isNull(arrayCallbacks)) {
                    arrayCallbacks = arrayListeners[absoluteIdentifier] = {};
                }
                var callbacks = arrayCallbacks[uid];
                if (isNull(callbacks)) {
                    callbacks = arrayCallbacks[uid] = [];
                }
                var listenerRemoved = false, removeListener = function () {
                    if (listenerRemoved) {
                        return;
                    }
                    listenerRemoved = true;
                    ContextManager.spliceRemoveListener(absoluteIdentifier, uid, removeListener);
                    var index = callbacks.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    callbacks.splice(index, 1);
                    if (callbacks.length === 0) {
                        deleteProperty(arrayCallbacks, uid);
                        if (isEmpty(arrayCallbacks)) {
                            deleteProperty(arrayListeners, absoluteIdentifier);
                        }
                    }
                };
                callbacks.push(listener);
                ContextManager.pushRemoveListener(absoluteIdentifier, uid, removeListener);
                return removeListener;
            };
            /**
             * Restores an array to use Array.prototype instead of listener functions.
             * @param {Array<any>} array The array to restore.
             */
            ContextManager.prototype._restoreArray = function (array) {
                var _compat = this._compat;
                if (_compat.setProto) {
                    Object.setPrototypeOf(array, Object.create(Array.prototype));
                }
                else if (_compat.proto) {
                    array.__proto__ = Object.create(Array.prototype);
                }
                else {
                    var length_5 = arrayMethods.length, method = void 0;
                    for (var i = 0; i < length_5; ++i) {
                        method = arrayMethods[i];
                        array[method] = Array.prototype[method];
                    }
                }
            };
            /**
             * Overwrites an Array's prototype to observe mutation functions.
             * @param {string} absoluteIdentifier The identifier for the Array off context.
             * @param {Array<any>} array The array to overwrite.
             */
            ContextManager.prototype._overwriteArray = function (absoluteIdentifier, array) {
                var _compat = this._compat, length = arrayMethods.length, method, i;
                if (_compat.proto) {
                    var obj = Object.create(Array.prototype);
                    for (i = 0; i < length; ++i) {
                        method = arrayMethods[i];
                        obj[method] = this._overwriteArrayFunction(absoluteIdentifier, method);
                    }
                    if (_compat.setProto) {
                        Object.setPrototypeOf(array, obj);
                    }
                    else {
                        array.__proto__ = obj;
                    }
                    return;
                }
                for (i = 0; i < length; ++i) {
                    method = arrayMethods[i];
                    ContextManager.defineProperty(array, method, this._overwriteArrayFunction(absoluteIdentifier, method), false, true, true);
                }
            };
            /**
             * Gets the context object of an identifier.
             * @param {string} identifier The identifier for which we're getting the context.
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             * @param {boolean} observe? Whether or not to observe the identifier indicated by the
             * split Array.
             */
            ContextManager.prototype._getContext = function (identifier, split, observe) {
                var context = this.__contextObjects[identifier];
                if (isNull(context)) {
                    if (observe === true) {
                        context = this.__contextObjects[identifier] = this._observeImmediateContext(split, identifier);
                    }
                    else {
                        context = this._getImmediateContext(split);
                    }
                }
                return context;
            };
            /**
             * Gets the immediate context of identifier by splitting on ".".
             * @param {Array<string>} split The string array containing properties used to index into
             * the context.
             */
            ContextManager.prototype._getImmediateContext = function (split) {
                var context = this.context;
                while (split.length > 0) {
                    context = context[split.shift()];
                    if (isNull(context)) {
                        break;
                    }
                }
                return context;
            };
            /**
             * Gets the immediate context of identifier by splitting on "."
             * and observes the objects along the way.
             * @param {Array<string>} split The identifier's split string array containing properties
             * used to index into the context.
             * @param {string} identifier The identifier being observed.
             */
            ContextManager.prototype._observeImmediateContext = function (split, identifier) {
                if (isNull(this.__identifiers[identifier])) {
                    this.observe(identifier, null);
                }
                return this._getImmediateContext(split);
            };
            /**
             * Obtains the old value and new value of a given context
             * property on a property changed event.
             * @param {Array<string>} split The split identifier of the property that changed.
             * @param {any} newRootContext The new context.
             * @param {any} oldRootContext The old context.
             */
            ContextManager.prototype._getValues = function (split, newRootContext, oldRootContext) {
                var property, doNew = isObject(newRootContext), doOld = isObject(oldRootContext);
                while (split.length > 1) {
                    property = split.shift();
                    if (doNew) {
                        newRootContext = newRootContext[property];
                        if (isNull(newRootContext)) {
                            doNew = false;
                        }
                    }
                    if (doOld) {
                        oldRootContext = oldRootContext[property];
                        if (isNull(oldRootContext)) {
                            doOld = false;
                        }
                    }
                    if (!(doNew || doOld)) {
                        break;
                    }
                }
                property = split[0];
                var newValue, oldValue;
                if (!isNull(newRootContext)) {
                    newValue = newRootContext[property];
                }
                if (!isNull(oldRootContext)) {
                    oldValue = oldRootContext[property];
                }
                return {
                    newValue: newValue,
                    oldValue: oldValue
                };
            };
            /**
             * Notifies all child properties being observed that a parent property
             * has changed.
             * @param {string} identifier The identifier for the property that changed.
             * @param {any} newValue The new value of the property.
             * @param {any} oldValue The old value of the property.
             * @param {Array<string>} mappings? An array of mapped child identifier keys to notify.
             */
            ContextManager.prototype._notifyChildProperties = function (identifier, newValue, oldValue, mappings) {
                var _this = this;
                mappings = mappings || Object.keys(this.__identifierHash[identifier] || {});
                var length = mappings.length, binding, property, parentProperty, split, values = {}, value, period = '.', lengthStr = 'length', key, keyIsLength, start = identifier.length + 1, newParent, oldParent, newChild, oldChild;
                for (var i = 0; i < length; ++i) {
                    binding = mappings[i];
                    property = binding.slice(start);
                    split = property.split(period);
                    key = split.pop();
                    keyIsLength = (key === lengthStr);
                    parentProperty = split.join(period);
                    if (isEmpty(parentProperty)) {
                        newParent = newValue;
                        oldParent = oldValue;
                        newChild = isNull(newParent) ? undefined : newParent[key];
                        oldChild = isNull(oldParent) ? undefined : oldParent[key];
                        if (keyIsLength && !isArray(oldParent) && isArray(newParent)) {
                            var lengthListener = this.__lengthListeners[binding];
                            if (!isNull(lengthListener)) {
                                var uid = lengthListener.uid;
                                var arraySplit = identifier.split(period), arrayKey = arraySplit.pop();
                                var join = arraySplit.join(period);
                                var arrayParent = this._getContext(join, arraySplit, false);
                                this.__observedIdentifier = null;
                                access(arrayParent, arrayKey);
                                if (isString(this.__observedIdentifier)) {
                                    join = this.__observedIdentifier;
                                }
                                var removeListener = this.observeArrayMutation(uid, noop, join, newParent, null);
                                this.observe(join, {
                                    uid: uid,
                                    listener: function (nValue, oValue) {
                                        removeListener();
                                        removeListener = _this.observeArrayMutation(uid, noop, join, nValue, oValue);
                                    }
                                });
                                deleteProperty(this.__lengthListeners, binding);
                            }
                        }
                    }
                    else {
                        value = values[parentProperty];
                        if (isNull(value)) {
                            value = values[parentProperty] = this._getValues(split, newValue, oldValue);
                        }
                        newParent = value.newValue;
                        oldParent = value.oldValue;
                        newChild = isNull(newParent) ? newParent : newParent[key];
                        oldChild = isNull(oldParent) ? oldParent : oldParent[key];
                    }
                    values[property] = {
                        newValue: newChild,
                        oldValue: oldChild
                    };
                    if (isObject(newParent) && (!isArray(newParent) || newParent.length > key)) {
                        this._define(binding, newParent, key);
                    }
                    this._execute(binding, newChild, oldChild);
                }
                values = null;
            };
            /**
             * Adds a listener to be fired for a particular identifier.
             * @param {string} absoluteIdentifier The identifier being observed.
             * @param {plat.observable.IListener} observableListener The function and associated unique ID to be fired
             * for this identifier.
             * @param {boolean} isLength? Indicates the property being observed is an Array's length.
             */
            ContextManager.prototype._addObservableListener = function (absoluteIdentifier, observableListener, isLength) {
                var _this = this;
                if (isLength === true) {
                    var split = absoluteIdentifier.split('.');
                    // pop length key 
                    split.pop();
                    var property = split.pop(), context = this.getContext(split, false);
                    if (isObject(context)) {
                        this.__observedIdentifier = null;
                        access(context, property);
                        if (isString(this.__observedIdentifier)) {
                            absoluteIdentifier = this.__observedIdentifier + (isLength === true ? '.length' : '');
                        }
                    }
                }
                this.__add(absoluteIdentifier, observableListener);
                var uid = observableListener.uid, remove = function () {
                    ContextManager.spliceRemoveListener(absoluteIdentifier, uid, remove);
                    _this._removeCallback(absoluteIdentifier, observableListener);
                };
                ContextManager.pushRemoveListener(absoluteIdentifier, uid, remove);
                return remove;
            };
            /**
             * Observes a property on a given context specified by an identifier.
             * @param {string} identifier The full identifier path for the property being observed.
             * @param {any} immediateContext The object whose property will be observed.
             * @param {string} key The property key for the value on the immediateContext that's
             * being observed.
             */
            ContextManager.prototype._define = function (identifier, immediateContext, key) {
                if (isObject(immediateContext[key])) {
                    this.__defineObject(identifier, immediateContext, key);
                }
                else {
                    this.__definePrimitive(identifier, immediateContext, key);
                }
            };
            /**
             * Intercepts an array function for observation.
             * @param {string} absoluteIdentifier The full identifier path for the observed array.
             * @param {string} method The array method being called.
             */
            ContextManager.prototype._overwriteArrayFunction = function (absoluteIdentifier, method) {
                var callbackObjects = ContextManager.arrayChangeListeners[absoluteIdentifier] || {}, _this = this;
                // we can't use a fat-arrow function here because we need the array context. 
                return function observedArrayFn() {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i - 0] = arguments[_i];
                    }
                    var oldLength = this.length, originalArray = this.slice(0), returnValue, isUnshift = method === 'unshift', isShift = method === 'shift', isSplice = method === 'splice', selfNotify = isShift || isUnshift || isSplice, isUpdate = method === 'sort' || method === 'reverse', oldArray, addedCount, index, newLength, removed;
                    if (selfNotify) {
                        _this.__isArrayFunction = true;
                        returnValue = Array.prototype[method].apply(this, args);
                        _this.__isArrayFunction = false;
                        newLength = this.length;
                        index = 0;
                        if (isShift) {
                            addedCount = 0;
                            removed = oldLength > 0 ? [returnValue] : [];
                        }
                        else if (isUnshift) {
                            addedCount = args.length;
                            removed = [];
                        }
                        else {
                            addedCount = args.length - 2;
                            index = args[0];
                            removed = returnValue;
                        }
                    }
                    else {
                        returnValue = Array.prototype[method].apply(this, args);
                        newLength = this.length;
                        if (isUpdate) {
                            oldArray = originalArray;
                        }
                        else if (method === 'push') {
                            addedCount = args.length;
                            index = oldLength;
                            removed = [];
                        }
                        else if (method === 'pop') {
                            addedCount = 0;
                            index = newLength;
                            removed = oldLength > 0 ? [returnValue] : [];
                        }
                    }
                    if (isShift || isSplice || method === 'pop') {
                        ContextManager.unObserve(returnValue);
                    }
                    var keys = Object.keys(callbackObjects), length = keys.length, callbacks, jLength, i, j;
                    for (i = 0; i < length; ++i) {
                        callbacks = callbackObjects[keys[i]];
                        jLength = callbacks.length;
                        for (j = 0; j < jLength; ++j) {
                            callbacks[j]([{
                                    object: this,
                                    type: method,
                                    index: index,
                                    removed: removed,
                                    addedCount: addedCount,
                                    oldArray: oldArray
                                }]);
                        }
                    }
                    if (selfNotify) {
                        _this._notifyChildProperties(absoluteIdentifier, this, originalArray);
                    }
                    else {
                        _this._execute(absoluteIdentifier + '.length', newLength, oldLength);
                    }
                    return returnValue;
                };
            };
            /**
             * Removes a single listener callback
             * @param {string} identifier The identifier attached to the callbacks.
             * @param {plat.observable.IListener} listener The observable listener to remove.
             */
            ContextManager.prototype._removeCallback = function (identifier, listener) {
                var callbacks = this.__identifiers[identifier];
                if (isNull(callbacks)) {
                    return;
                }
                // splice the observed listener 
                var index = callbacks.indexOf(listener);
                if (index === -1) {
                    return;
                }
                callbacks.splice(index, 1);
                if (callbacks.length === 0) {
                    deleteProperty(this.__contextObjects, identifier);
                }
            };
            /**
             * Checks if the specified identifier is already being
             * observed in this context.
             * @param {string} identifier The identifier being observed.
             */
            ContextManager.prototype._hasIdentifier = function (identifier) {
                return !isEmpty(this.__identifiers[identifier]);
            };
            /**
             * Executes the listeners for the specified identifier on
             * this context.
             * @param {string} identifier The identifier attached to the callbacks.
             * @param {any} value The new value on this context specified by
             * the identifier.
             * @param {any} oldValue The old value on this context specified by
             * the identifier.
             */
            ContextManager.prototype._execute = function (identifier, value, oldValue) {
                var observableListeners = this.__identifiers[identifier];
                if (isUndefined(value)) {
                    deleteProperty(this.__contextObjects, identifier);
                }
                else {
                    this.__contextObjects[identifier] = value;
                }
                if (value === oldValue || isNull(observableListeners)) {
                    return;
                }
                var listeners = observableListeners.slice(0), length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i].listener(value, oldValue);
                }
            };
            /**
             * Defines a getter and setter for an object using Object.defineProperty.
             * @param {string} identifier The identifier of the object being defined.
             * @param {any} immediateContext The parent object of the object being defined.
             * @param {string} key The property key of the object being defined.
             */
            ContextManager.prototype.__defineObject = function (identifier, immediateContext, key) {
                var _this = this;
                var value = immediateContext[key];
                Object.defineProperty(immediateContext, key, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        _this.__observedIdentifier = identifier;
                        return value;
                    },
                    set: function (newValue) {
                        if (value === newValue) {
                            return;
                        }
                        var oldValue = value;
                        value = newValue;
                        if (_this.__isArrayFunction) {
                            return;
                        }
                        ContextManager.unObserve(oldValue);
                        var props = _this.__identifierHash[identifier], childPropertiesExist = false, mappings;
                        if (isObject(props)) {
                            mappings = Object.keys(props);
                            childPropertiesExist = mappings.length > 0;
                        }
                        _this._execute(identifier, value, oldValue);
                        if (childPropertiesExist) {
                            _this._notifyChildProperties(identifier, value, oldValue, mappings);
                            if (!isObject(value)) {
                                _this.__definePrimitive(identifier, immediateContext, key);
                            }
                        }
                        else if (isEmpty(_this.__identifiers[identifier])) {
                            ContextManager.defineProperty(immediateContext, key, value, true, true, true);
                        }
                        else if (!isObject(value)) {
                            _this.__definePrimitive(identifier, immediateContext, key);
                        }
                    }
                });
            };
            /**
             * Defines a getter and setter for a primitive using Object.defineProperty.
             * @param {string} identifier The identifier of the primitive being defined.
             * @param {any} immediateContext The parent object of the primitive being defined.
             * @param {string} key The property key of the primitive being defined.
             */
            ContextManager.prototype.__definePrimitive = function (identifier, immediateContext, key) {
                var _this = this;
                var value = immediateContext[key], isDefined = !isNull(value);
                if (isArray(immediateContext) && key === 'length') {
                    return;
                }
                Object.defineProperty(immediateContext, key, {
                    configurable: true,
                    enumerable: true,
                    get: function () {
                        _this.__observedIdentifier = identifier;
                        return value;
                    },
                    set: function (newValue) {
                        if (value === newValue) {
                            return;
                        }
                        var oldValue = value;
                        value = newValue;
                        if (_this.__isArrayFunction && isArray(immediateContext)) {
                            return;
                        }
                        var props = _this.__identifierHash[identifier], childPropertiesExist = false, mappings;
                        if (isObject(props)) {
                            mappings = Object.keys(props);
                            childPropertiesExist = mappings.length > 0;
                        }
                        _this._execute(identifier, newValue, oldValue);
                        if (!childPropertiesExist && isEmpty(_this.__identifiers[identifier])) {
                            ContextManager.defineProperty(immediateContext, key, value, true, true, true);
                        }
                        else if (isObject(value)) {
                            _this.__defineObject(identifier, immediateContext, key);
                            if (childPropertiesExist) {
                                _this._notifyChildProperties(identifier, newValue, oldValue, mappings);
                            }
                        }
                        else if (!isDefined) {
                            _this.__definePrimitive(identifier, immediateContext, key);
                            isDefined = true;
                        }
                    }
                });
            };
            /**
             * Adds and associates a listener with a given identifier.
             * @param {string} identifier The identifier to attach the listener.
             * @param {plat.observable.IListener} observableListener The listener being added.
             */
            ContextManager.prototype.__add = function (identifier, observableListener) {
                var callbacks = this.__identifiers[identifier], priority = observableListener.priority, found = false;
                if (isNull(callbacks)) {
                    callbacks = this.__identifiers[identifier] = [];
                }
                if (isNumber(priority)) {
                    var length_6 = callbacks.length;
                    for (var i = 0; i < length_6; ++i) {
                        if (priority > callbacks[i].priority) {
                            callbacks.splice(i, 0, observableListener);
                            found = true;
                            break;
                        }
                    }
                }
                else {
                    observableListener.priority = -1;
                }
                if (!found) {
                    callbacks.push(observableListener);
                }
                this.__addHashValues(identifier);
            };
            /**
             * Adds a mapping for an identifier which allows quick access to it
             * if a parent context is changed.
             * @param {string} identifier The identifier to map.
             */
            ContextManager.prototype.__addHashValues = function (identifier) {
                var identifierHash = this.__identifierHash;
                if (isObject(identifierHash[identifier])) {
                    return;
                }
                identifierHash[identifier] = {};
                var index, period = '.', ident = identifier, hashValue;
                while ((index = ident.lastIndexOf(period)) !== -1) {
                    ident = ident.slice(0, index);
                    hashValue = identifierHash[ident];
                    if (isNull(hashValue)) {
                        hashValue = identifierHash[ident] = {};
                        if (ident !== identifier) {
                            hashValue[identifier] = true;
                        }
                    }
                    else if (ident !== identifier && !hashValue[identifier]) {
                        hashValue[identifier] = true;
                    }
                }
            };
            /**
             * A set of functions to be fired when a particular observed array is mutated.
             */
            ContextManager.arrayChangeListeners = {};
            /**
             * An object for quickly accessing a previously created ContextManager.
             */
            ContextManager.__managers = {};
            /**
             * An object for storing functions to remove listeners for observed identifiers.
             */
            ContextManager.__controls = {};
            return ContextManager;
        }());
        observable.ContextManager = ContextManager;
        /**
         */
        function IContextManagerStatic(_log) {
            ContextManager._log = _log;
            return ContextManager;
        }
        observable.IContextManagerStatic = IContextManagerStatic;
        register.injectable(__ContextManagerStatic, IContextManagerStatic, [
            __Log
        ], __STATIC);
        register.injectable(__ContextManagerInstance, ContextManager, null, __INSTANCE);
    })(observable = plat_1.observable || (plat_1.observable = {}));
    /**
     * Holds classes and interfaces related to event management components in platypus.
     */
    var events;
    (function (events) {
        /**
         * An event class that propagates through a control tree.
         * Propagation of the event always starts at the sender, allowing a control to both
         * initialize and consume an event. If a consumer of an event throws an error while
         * handling the event it will be logged to the app using Log.debug. Errors will
         * not stop propagation of the event.
         */
        var DispatchEvent = (function () {
            function DispatchEvent() {
                /**
                 * Whether or not preventDefault() was called on the event. Senders of the
                 * event can check this property to know if they should carry out a default
                 * action as a result of the event.
                 */
                this.defaultPrevented = false;
                /**
                 * Whether or not the event propagation was stopped.
                 */
                this.stopped = false;
            }
            DispatchEvent.prototype.initialize = function (name, sender, direction) {
                this.name = name;
                this.direction = direction || this._EventManager.UP;
                this.sender = sender;
            };
            /**
             * Cancels the default action (if there is one) for an event. Does not affect propagation.
             */
            DispatchEvent.prototype.preventDefault = function () {
                if (!this.defaultPrevented) {
                    this._ContextManager.defineGetter(this, 'defaultPrevented', true);
                }
            };
            /**
             * Call this method to halt the propagation of an upward-moving event.
             * Downward events cannot be stopped with this method.
             */
            DispatchEvent.prototype.stopPropagation = function () {
                if (this.direction === this._EventManager.UP) {
                    this.stopped = true;
                    this._EventManager.propagatingEvents[this.name] = false;
                }
            };
            DispatchEvent._inject = {
                _EventManager: __EventManagerStatic,
                _ContextManager: __ContextManagerStatic
            };
            return DispatchEvent;
        }());
        events.DispatchEvent = DispatchEvent;
        register.injectable(__DispatchEventInstance, DispatchEvent, null, __INSTANCE);
        /**
         * Represents a Lifecycle Event. Lifecycle Events are always direct events.
         */
        var LifecycleEvent = (function (_super) {
            __extends(LifecycleEvent, _super);
            function LifecycleEvent() {
                _super.apply(this, arguments);
            }
            /**
             * Creates a new LifecycleEvent and fires it.
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             */
            LifecycleEvent.dispatch = function (name, sender) {
                var event = acquire(__LifecycleEventInstance);
                event.initialize(name, sender);
                EventManager.sendEvent(event);
                return event;
            };
            /**
             * Initializes the event, populating its public properties.
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             */
            LifecycleEvent.prototype.initialize = function (name, sender) {
                _super.prototype.initialize.call(this, name, sender, this._EventManager.DIRECT);
            };
            return LifecycleEvent;
        }(DispatchEvent));
        events.LifecycleEvent = LifecycleEvent;
        /**
         */
        function ILifecycleEventStatic() {
            return LifecycleEvent;
        }
        events.ILifecycleEventStatic = ILifecycleEventStatic;
        register.injectable(__LifecycleEventStatic, ILifecycleEventStatic, null, __STATIC);
        register.injectable(__LifecycleEventInstance, LifecycleEvent, null, __INSTANCE);
        /**
         * Manages dispatching events, handling all propagating events as well as any error handling.
         */
        var EventManager = (function () {
            function EventManager() {
            }
            /**
             * Initializes the EventManager, creating the initial ALM event listeners.
             */
            EventManager.initialize = function () {
                if (EventManager.__initialized) {
                    return;
                }
                EventManager.__initialized = true;
                var lifecycleListeners = EventManager.__lifecycleEventListeners, _compat = EventManager._compat, _document = EventManager._document, _window = EventManager._window, _dom = EventManager._dom, dispatch = LifecycleEvent.dispatch, listener;
                while (lifecycleListeners.length > 0) {
                    listener = lifecycleListeners.pop();
                    _document.removeEventListener(listener.name, listener.value, false);
                }
                if (_compat.cordova) {
                    var eventNames = [__resume, __online, __offline], winJs_1 = _compat.winJs, length_7 = eventNames.length, event_1, dispatcher = function (ev) { return function () {
                        dispatch(ev, EventManager);
                    }; }, fn = void 0;
                    for (var i = 0; i < length_7; ++i) {
                        event_1 = eventNames[i];
                        fn = dispatcher(event_1);
                        lifecycleListeners.push({
                            name: event_1,
                            value: fn
                        });
                        _dom.addEventListener(_document, event_1, fn, false);
                    }
                    fn = dispatcher(__suspend);
                    lifecycleListeners.push({
                        name: __pause,
                        value: fn
                    });
                    _dom.addEventListener(_document, __pause, fn, false);
                    fn = dispatcher(__ready);
                    lifecycleListeners.push({
                        name: __deviceReady,
                        value: fn
                    });
                    _dom.addEventListener(_document, __deviceReady, fn, false);
                    fn = function () {
                        if (!winJs_1) {
                            dispatch(__backButton, EventManager);
                        }
                        return true;
                    };
                    lifecycleListeners.push({
                        name: __backButton,
                        value: fn
                    });
                    _dom.addEventListener(_document, __backButton, fn, false);
                    if (winJs_1) {
                        fn = function () {
                            dispatch(__backButton, EventManager);
                            return true;
                        };
                        lifecycleListeners.push({
                            name: __backClick,
                            value: fn
                        });
                        _window.WinJS.Application.addEventListener(__backClick, fn, false);
                    }
                }
                else if (_compat.amd) {
                    return;
                }
                else {
                    _dom.addEventListener(_window, 'load', function () {
                        dispatch(__ready, EventManager);
                    });
                }
            };
            /**
             * Removes all event listeners for a given uid. Useful for garbage collection when
             * certain objects that listen to events go out of scope.
             * @param {string} uid The uid for which the event listeners will be removed.'
             */
            EventManager.dispose = function (uid) {
                deleteProperty(EventManager.__eventsListeners, uid);
            };
            /**
             * Registers a listener for a DispatchEvent. The listener will be called when a DispatchEvent is
             * propagating over the given uid. Any number of listeners can exist for a single event name.
             * @param {string} uid A unique id to associate with the object registering the listener.
             * @param {string} eventName The name of the event to listen to.
             * @param {(ev: DispatchEvent, ...args: any[]) => void} listener The method called when the event is fired.
             * @param {any} context? The context with which to call the listener method.
             */
            EventManager.on = function (uid, eventName, listener, context) {
                var eventsListener = EventManager.__eventsListeners[uid];
                if (isNull(eventsListener)) {
                    eventsListener = EventManager.__eventsListeners[uid] = {
                        listeners: {},
                        context: context
                    };
                }
                var eventListeners = eventsListener.listeners[eventName];
                if (!isArray(eventListeners)) {
                    eventListeners = eventsListener.listeners[eventName] = [];
                }
                eventListeners.push(listener);
                return function () {
                    var index = eventListeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    eventListeners.splice(index, 1);
                };
            };
            EventManager.dispatch = function (name, sender, direction, args) {
                var _dispatchEvent = acquire(__DispatchEventInstance);
                _dispatchEvent.initialize(name, sender, direction);
                EventManager.sendEvent(_dispatchEvent, args);
                return _dispatchEvent;
            };
            /**
             * Returns whether or not the given string is a registered direction.
             * @param {string} direction The direction of the event
             */
            EventManager.hasDirection = function (direction) {
                return (direction === EventManager.UP ||
                    direction === EventManager.DOWN ||
                    direction === EventManager.DIRECT);
            };
            /**
             * Determines the appropriate direction and dispatches the event accordingly.
             * @param {plat.events.DispatchEvent} event The DispatchEvent to send
             * @param {Array<any>} args The arguments associated with the event
             */
            EventManager.sendEvent = function (event, args) {
                var name = event.name, direction = event.direction;
                args = args || [];
                EventManager.propagatingEvents[name] = true;
                args = args || [];
                switch (direction) {
                    case EventManager.UP:
                        EventManager._dispatchUp(event, args);
                        break;
                    case EventManager.DOWN:
                        EventManager._dispatchDown(event, args);
                        break;
                    case EventManager.DIRECT:
                        EventManager._dispatchDirect(event, args);
                        break;
                }
                deleteProperty(EventManager.propagatingEvents, name);
            };
            /**
             * Dispatches the event up the control chain.
             * @param {plat.events.DispatchEvent} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             */
            EventManager._dispatchUp = function (event, args) {
                var name = event.name, parent = event.sender;
                while (!isNull(parent) && EventManager.propagatingEvents[name]) {
                    if (isNull(parent.uid)) {
                        parent = parent.parent;
                        continue;
                    }
                    EventManager.__executeEvent(parent.uid, event, args);
                    parent = parent.parent;
                }
            };
            /**
             * Dispatches the event down the control chain.
             * @param {plat.events.DispatchEvent} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             */
            EventManager._dispatchDown = function (event, args) {
                var controls = [], control, name = event.name;
                controls.push(event.sender);
                while (controls.length && EventManager.propagatingEvents[name]) {
                    control = controls.pop();
                    if (isNull(control.uid)) {
                        continue;
                    }
                    EventManager.__executeEvent(control.uid, event, args);
                    if (isNull(control.controls)) {
                        continue;
                    }
                    controls = controls.concat(control.controls);
                }
            };
            /**
             * Dispatches the event directly to all listeners.
             * @param {plat.events.DispatchEvent} event The event being dispatched.
             * @param {Array<any>} args The arguments associated with the event.
             */
            EventManager._dispatchDirect = function (event, args) {
                var uids = Object.keys(EventManager.__eventsListeners), length = uids.length, name = event.name, eventsListener;
                for (var i = 0; i < length; ++i) {
                    if (!EventManager.propagatingEvents[name]) {
                        break;
                    }
                    eventsListener = EventManager.__eventsListeners[uids[i]];
                    if (isNull(eventsListener) || isNull(eventsListener.listeners[name])) {
                        continue;
                    }
                    EventManager.__callListeners(eventsListener.context, event, eventsListener.listeners[name], args);
                }
            };
            /**
             * Dispatches the event to the listeners for the given uid.
             * @param {string} uid The uid used to find the event listeners.
             * @param {plat.events.DispatchEvent} The event.
             * @param {Array<any>} args The arguments to send to the listeners.
             */
            EventManager.__executeEvent = function (uid, ev, args) {
                var eventsListener = EventManager.__eventsListeners[uid];
                if (isNull(eventsListener)) {
                    return;
                }
                var context = eventsListener.context, listeners = eventsListener.listeners[ev.name];
                if (isNull(listeners)) {
                    return;
                }
                EventManager.__callListeners(context, ev, listeners, args);
            };
            /**
             * Calls event listeners with the given context, event, and arguments.
             * @param {any} context The context with which to call the listeners.
             * @param {plat.events.DispatchEvent} The event.
             * @param {Array<(ev: DispatchEvent, ...args: any[]) => void>} The event listeners.
             * @param {Array<any>} args The arguments to send to the listeners.
             */
            EventManager.__callListeners = function (context, ev, listeners, args) {
                var name = ev.name, length = listeners.length, index = -1;
                args = [ev].concat(args);
                while (++index < length && EventManager.propagatingEvents[name]) {
                    try {
                        listeners[index].apply(context, args);
                    }
                    catch (e) {
                        EventManager._log.debug(e);
                    }
                }
            };
            /**
             * An upward-moving event will start at the sender and move
             * up the parent chain.
             */
            EventManager.UP = 'up';
            /**
             * A downward-moving event will start at the sender and move
             * to its children and beyond.
             */
            EventManager.DOWN = 'down';
            /**
             * Goes through all listeners for an event name, ignoring order.
             */
            EventManager.DIRECT = 'direct';
            /**
             * Keeps track of which events are currently propagating.
             */
            EventManager.propagatingEvents = {};
            /**
             * Holds all the event listeners keyed by uid.
             */
            EventManager.__eventsListeners = {};
            /**
             * Holds all the event listeners for the application lifefycle events.
             */
            EventManager.__lifecycleEventListeners = [];
            /**
             * whether or not the event manager has been initialized.
             */
            EventManager.__initialized = false;
            return EventManager;
        }());
        events.EventManager = EventManager;
        /**
         */
        function IEventManagerStatic(_log, _compat, _document, _window, _dom) {
            EventManager._log = _log;
            EventManager._compat = _compat;
            EventManager._document = _document;
            EventManager._window = _window;
            EventManager._dom = _dom;
            return EventManager;
        }
        events.IEventManagerStatic = IEventManagerStatic;
        register.injectable(__EventManagerStatic, IEventManagerStatic, [
            __Log,
            __Compat,
            __Document,
            __Window,
            __Dom
        ], __STATIC);
        /**
         * Represents an internal Error Event. This is used for any
         * internal errors (both fatal and warnings). All error events are
         * direct events.
         */
        var ErrorEvent = (function (_super) {
            __extends(ErrorEvent, _super);
            function ErrorEvent() {
                _super.apply(this, arguments);
            }
            /**
             * Creates a new ErrorEvent and fires it.
             * @param {string} name The name of the event.
             * @param {any} sender The sender of the event.
             * @param {E} error The error that occurred, resulting in the event.
             * @param {number} logLevel The severity level of the error
             */
            ErrorEvent.dispatch = function (name, sender, error, logLevel) {
                var event = acquire(ErrorEvent);
                event.initialize(name, sender, null, error);
                event.logLevel = logLevel;
                ErrorEvent._EventManager.sendEvent(event);
                return event;
            };
            ErrorEvent.prototype.initialize = function (name, sender, direction, error) {
                _super.prototype.initialize.call(this, name, sender, this._EventManager.DIRECT);
                this.error = error;
            };
            return ErrorEvent;
        }(DispatchEvent));
        events.ErrorEvent = ErrorEvent;
        /**
         */
        function IErrorEventStatic(_EventManager) {
            ErrorEvent._EventManager = _EventManager;
            return ErrorEvent;
        }
        events.IErrorEventStatic = IErrorEventStatic;
        register.injectable(__ErrorEventStatic, IErrorEventStatic, [__EventManagerStatic], __STATIC);
    })(events = plat_1.events || (plat_1.events = {}));
    /**
     * Used for facilitating data and DOM manipulation. Contains lifecycle events
     * as well as properties for communicating with other controls. This is the base
     * class for all types of controls.
     */
    var Control = (function () {
        /**
         * The constructor for a control. Any injectables specified during control registration will be
         * passed into the constructor as arguments as long as the control is instantiated with its associated
         * injector.
         */
        function Control() {
            /**
             * A unique id, created during instantiation and found on every Control.
             */
            this.uid = uniqueId(__Plat);
            /**
             * Specifies the priority of the control. The purpose of
             * this is so that controls like plat-bind can have a higher
             * priority than plat-tap. The plat-bind will be initialized
             * and loaded before plat-tap, meaning it has the first chance
             * to respond to events.
             */
            this.priority = 0;
            /**
             * Contains DOM helper methods for manipulating this control's element.
             */
            this.dom = Control._dom;
            /**
             * Contains helper methods for data manipulation.
             */
            this.utils = acquire(__Utils);
            /**
             * Reference to the Log injectable.
             */
            this._log = Control._log;
        }
        Control.getRootControl = function (control) {
            if (isNull(control)) {
                return control;
            }
            else if (!isNull(control.root)) {
                return control.root;
            }
            while (!(isNull(control.parent) || control.hasOwnContext)) {
                if (!isNull(control.root)) {
                    return control.root;
                }
                control = control.parent;
            }
            if (!control.hasOwnContext && isObject(control.context)) {
                Control._log.debug('Root control: ' + control.type + ' found that sets its context to an Object but does not set the hasOwnContext ' +
                    'flag to true. Please set the flag if the control intends to use its own context.');
            }
            return control;
        };
        /**
         * Given a control, calls the loaded method for the control if it exists.
         * @param {plat.Control} control The control to load.
         */
        Control.load = function (control) {
            var _Promise = Control._Promise;
            if (isNull(control)) {
                return _Promise.resolve();
            }
            var ctrl = control;
            if (isString(ctrl.absoluteContextPath)) {
                if (isFunction(ctrl.contextChanged)) {
                    var contextManager = Control._ContextManager.getManager(ctrl.root);
                    contextManager.observe(ctrl.absoluteContextPath, {
                        uid: control.uid,
                        priority: __CONTEXT_CHANGED_PRIORITY,
                        listener: function (newValue, oldValue) {
                            ui.TemplateControl.contextChanged(control, newValue, oldValue);
                        }
                    });
                    if (isFunction(ctrl.zCC__plat)) {
                        ctrl.zCC__plat();
                        deleteProperty(ctrl, 'zCC__plat');
                    }
                }
                var element = ctrl.element;
                if (isNode(element) && isFunction(element.removeAttribute)) {
                    element.removeAttribute(__Hide);
                }
            }
            if (isFunction(control.loaded)) {
                return _Promise.resolve(control.loaded());
            }
            return _Promise.resolve();
        };
        /**
         * Disposes all the necessary memory for a control. Uses specific dispose
         * methods related to a control's constructor if necessary.
         * @param {plat.Control} control The Control to dispose.
         */
        Control.dispose = function (control) {
            var ctrl = control;
            if (isNull(ctrl)) {
                return;
            }
            else if (!isUndefined(ctrl.templateControl)) {
                AttributeControl.dispose(ctrl);
                return;
            }
            else if (ctrl.hasOwnContext) {
                ui.ViewControl.dispose(ctrl);
                return;
            }
            else if (ctrl.controls) {
                ui.TemplateControl.dispose(ctrl);
                return;
            }
            if (isFunction(control.dispose)) {
                control.dispose();
            }
            Control.removeEventListeners(control);
            Control._ContextManager.dispose(control);
            control.element = null;
            Control.removeParent(control);
            if (control.__injectable__type === __STATIC) {
                var injector = controlInjectors[control.type];
                register.control(control.type, control.constructor, injector.dependencies, true);
            }
        };
        /**
         * Splices a control from its parent's controls list. Sets the control's parent
         * to null.
         * @param {plat.Control} control The control whose parent will be removed.
         */
        Control.removeParent = function (control) {
            if (isNull(control)) {
                return;
            }
            var parent = control.parent;
            if (isNull(parent)) {
                return;
            }
            var controls = parent.controls || [], index = controls.indexOf(control);
            if (index !== -1) {
                controls.splice(index, 1);
            }
            control.parent = null;
        };
        /**
         * Removes all event listeners for a control with the given uid.
         * @param {plat.Control} control The control having its event listeners removed.
         */
        Control.removeEventListeners = function (control) {
            if (isNull(control)) {
                return;
            }
            var removeListeners = Control.__eventListeners, uid = control.uid;
            var listeners = removeListeners[uid];
            if (isArray(listeners)) {
                var index = listeners.length;
                while (index-- > 0) {
                    listeners[index]();
                }
                deleteProperty(removeListeners, uid);
            }
        };
        /**
         * Returns a new instance of Control.
         */
        Control.getInstance = function () {
            return new Control();
        };
        /**
         * Adds a function to remove an event listener for the control specified
         * by its uid.
         * @param {string} uid The uid of the control associated with the remove function.
         * @param {plat.IRemoveListener} listener The remove function to add.
         */
        Control.__addRemoveListener = function (uid, listener) {
            var removeListeners = Control.__eventListeners;
            if (isArray(removeListeners[uid])) {
                removeListeners[uid].push(listener);
                return;
            }
            removeListeners[uid] = [listener];
        };
        /**
         * Removes a IRemoveListener from a control's listeners.
         * @param {string} uid The uid of the control associated with the remove function.
         * @param {plat.IRemoveListener} listener The remove function to add.
         */
        Control.__spliceRemoveListener = function (uid, listener) {
            var removeListeners = Control.__eventListeners, controlListeners = removeListeners[uid];
            if (isArray(controlListeners)) {
                var index = controlListeners.indexOf(listener);
                if (index === -1) {
                    return;
                }
                controlListeners.splice(index, 1);
            }
        };
        /**
         * Gets controls that have a specific key/value string pair.
         * @param {plat.Control} control The at which to start searching for key/value pairs.
         * @param {string} key The key to search for on all the controls in the tree.
         * @param {string} value The expected value used to find similar controls.
         */
        Control.__getControls = function (control, key, value) {
            var controls = [], root = Control.getRootControl(control), child;
            if (!isNull(root) && root[key] === value) {
                controls.push(root);
            }
            var children = root.controls;
            if (isNull(children)) {
                return controls;
            }
            var queue = [].concat(children);
            while (queue.length > 0) {
                child = queue.shift();
                if (child[key] === value) {
                    controls.push(child);
                }
                if (isNull(child.controls)) {
                    continue;
                }
                queue = queue.concat(child.controls);
            }
            return controls;
        };
        /**
         * The initialize event method for a control. In this method a control should initialize all the necessary
         * variables. This method is typically only necessary for view controls. If a control does not implement
         * IBaseViewControl then it is not safe to access, observe, or modify
         * the context property in this method. A view control should call services/set context in this method in
         * order to fire the loaded event. No control will be loaded until the view control has specified a context.
         */
        Control.prototype.initialize = function () { };
        /**
         * The loaded event method for a control. This event is fired after a control has been loaded,
         * meaning all of its children have also been loaded and initial DOM has been created and populated. It is now
         * safe for all controls to access, observe, and modify the context property.
         */
        Control.prototype.loaded = function () { };
        /**
         * Retrieves all the controls with the specified name.
         * @param {string} name The string name with which to populate the returned controls array.
         */
        Control.prototype.getControlsByName = function (name) {
            return Control.__getControls(this, 'name', name);
        };
        Control.prototype.getControlsByType = function (type) {
            if (isString(type)) {
                return Control.__getControls(this, 'type', type);
            }
            return Control.__getControls(this, 'constructor', type);
        };
        Control.prototype.addEventListener = function (element, type, listener, useCapture) {
            if (!isFunction(listener)) {
                this._log.warn('"Control.addEventListener" must take a function as the third argument.');
                return noop;
            }
            listener = listener.bind(this);
            var removeListener = this.dom.addEventListener(element, type, listener, useCapture), uid = this.uid;
            Control.__addRemoveListener(uid, removeListener);
            return function () {
                removeListener();
                Control.__spliceRemoveListener(uid, removeListener);
            };
        };
        Control.prototype.observe = function (listener, identifier) {
            var _this = this;
            var control = isObject(this.context) ? this : this.parent, root = Control.getRootControl(control);
            if (isNull(control)) {
                return noop;
            }
            else if (isNull(control.absoluteContextPath)) {
                this._log.warn('Should not call plat.Control.observe prior to the control being loaded');
                return noop;
            }
            var absoluteIdentifier;
            if (isEmpty(identifier)) {
                absoluteIdentifier = control.absoluteContextPath;
            }
            else if (isString(identifier)) {
                var identifierExpression = (Control._parser || acquire(__Parser)).parse(identifier), identifiers = identifierExpression.identifiers;
                if (identifiers.length > 1) {
                    this._log.warn('Only a single identifier can be observed when calling the function plat.Control.observe');
                }
                var expression = identifierExpression.identifiers[0];
                if (expression[0] === '@') {
                    var split = expression.split('.'), start = split.shift().slice(1), join = split.length > 0 ? ('.' + split.join('.')) : '';
                    if (start === __ROOT_CONTEXT_RESOURCE) {
                        absoluteIdentifier = __CONTEXT + join;
                    }
                    else if (start === __CONTEXT_RESOURCE) {
                        absoluteIdentifier = control.absoluteContextPath + join;
                    }
                    else {
                        absoluteIdentifier = control.absoluteContextPath + '.' + expression;
                    }
                }
                else {
                    absoluteIdentifier = control.absoluteContextPath + '.' + expression;
                }
            }
            else {
                absoluteIdentifier = control.absoluteContextPath + '.' + identifier;
            }
            var _ContextManager = Control._ContextManager || acquire(__ContextManagerStatic), contextManager = _ContextManager.getManager(root);
            return contextManager.observe(absoluteIdentifier, {
                listener: function (newValue, oldValue) {
                    listener.call(_this, newValue, oldValue, identifier);
                },
                uid: this.uid
            });
        };
        Control.prototype.observeArray = function (listener, identifier) {
            var control = isObject(this.context) ? this : this.parent, context = control.context;
            if (isNull(control) || !isObject(context)) {
                return noop;
            }
            var array, absoluteIdentifier;
            if (isEmpty(identifier)) {
                array = context;
                absoluteIdentifier = control.absoluteContextPath;
            }
            else if (isString(identifier)) {
                var identifierExpression = (Control._parser || acquire(__Parser)).parse(identifier);
                array = identifierExpression.evaluate(context);
                absoluteIdentifier = control.absoluteContextPath + '.' + identifierExpression.identifiers[0];
            }
            else {
                array = context[identifier];
                absoluteIdentifier = control.absoluteContextPath + '.' + identifier;
            }
            if (!isArray(array)) {
                return noop;
            }
            var listenerIsFunction = isFunction(listener);
            if (!listenerIsFunction) {
                return noop;
            }
            listener = listener.bind(this);
            var ContextManager = Control._ContextManager || acquire(__ContextManagerStatic), contextManager = ContextManager.getManager(Control.getRootControl(control)), uid = this.uid, callback = function (changes) {
                listener(changes, identifier);
            }, removeListener = contextManager.observeArrayMutation(uid, callback, absoluteIdentifier, array, null), removeCallback = contextManager.observe(absoluteIdentifier, {
                listener: function (newValue, oldValue) {
                    removeListener();
                    removeListener = contextManager
                        .observeArrayMutation(uid, callback, absoluteIdentifier, newValue, oldValue);
                },
                uid: uid
            });
            return function () {
                removeListener();
                removeCallback();
            };
        };
        Control.prototype.observeExpression = function (listener, expression) {
            var _this = this;
            if (isEmpty(expression)) {
                return noop;
            }
            if (isString(expression)) {
                expression = (Control._parser || acquire(__Parser)).parse(expression);
            }
            else if (!isFunction(expression.evaluate)) {
                return noop;
            }
            var control = !isNull(this.resources) ?
                this :
                this.parent;
            if (isNull(control) || !isString(control.absoluteContextPath)) {
                return noop;
            }
            var aliases = expression.aliases, alias, length = aliases.length, resources = {}, resourceObj, ContextManager = Control._ContextManager || acquire(__ContextManagerStatic), getManager = ContextManager.getManager, TemplateControl = ui.TemplateControl, findResource = TemplateControl.findResource, evaluateExpression = TemplateControl.evaluateExpression, type, i;
            for (i = 0; i < length; ++i) {
                alias = aliases[i];
                resourceObj = findResource(control, alias);
                if (!isNull(resourceObj)) {
                    type = resourceObj.resource.type;
                    if (type === __OBSERVABLE_RESOURCE || type === __LITERAL_RESOURCE) {
                        resources[alias] = getManager(resourceObj.control);
                    }
                }
            }
            var identifiers = expression.identifiers, contextManager = getManager(Control.getRootControl(control)), identifier, split = [], topIdentifier, absoluteContextPath = control.absoluteContextPath, absolutePath = absoluteContextPath + '.', managers = {};
            length = identifiers.length;
            for (i = 0; i < length; ++i) {
                identifier = identifiers[i];
                split = identifier.split('.');
                topIdentifier = split[0];
                if (identifier[0] === '@') {
                    alias = topIdentifier.slice(1);
                    if (alias === __CONTEXT_RESOURCE) {
                        managers[absoluteContextPath + identifier.replace(topIdentifier, '')] = contextManager;
                    }
                    else if (alias === __ROOT_CONTEXT_RESOURCE) {
                        managers[identifier.replace(topIdentifier, 'context')] = contextManager;
                    }
                    else {
                        identifier = identifier.replace(topIdentifier, 'resources.' + alias + '.value');
                        if (!isNull(resources[alias])) {
                            managers[identifier] = resources[alias];
                        }
                    }
                    continue;
                }
                managers[absolutePath + identifier] = contextManager;
            }
            identifiers = Object.keys(managers);
            length = identifiers.length;
            var oldValue = evaluateExpression(expression, control), listeners = [], uid = this.uid, observableListener = function () {
                var value = evaluateExpression(expression, control);
                listener.call(_this, value, oldValue, expression.expression);
                oldValue = value;
            };
            for (i = 0; i < length; ++i) {
                identifier = identifiers[i];
                listeners.push(managers[identifier].observe(identifier, {
                    uid: uid,
                    listener: observableListener
                }));
            }
            return function () {
                var length = listeners.length;
                for (var i_1 = 0; i_1 < length; ++i_1) {
                    listeners[i_1]();
                }
            };
        };
        Control.prototype.evaluateExpression = function (expression, aliases) {
            return ui.TemplateControl.evaluateExpression(expression, this.parent, aliases);
        };
        /**
         * Finds the first instance of the specified property
         * in the parent control chain. Returns undefined if not found.
         * @param {string} property The property identifer
         */
        Control.prototype.findProperty = function (property) {
            var control = this, expression = (Control._parser || acquire(__Parser)).parse(property), value;
            while (!isNull(control)) {
                value = expression.evaluate(control);
                if (!isNull(value)) {
                    return {
                        expresssion: expression,
                        control: control,
                        value: value
                    };
                }
                control = control.parent;
            }
        };
        Control.prototype.dispatchEvent = function (name, direction) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var manager = Control._EventManager || acquire(__EventManagerStatic);
            if (!manager.hasDirection(direction)) {
                if (!isUndefined(direction)) {
                    args.unshift(direction);
                }
                direction = manager.UP;
            }
            var sender = this;
            if (!isNull(sender.templateControl)) {
                sender = sender.templateControl;
            }
            manager.dispatch(name, sender, direction, args);
        };
        /**
         * Registers a listener for a DispatchEvent. The listener will be called when a
         * DispatchEvent is propagating over the control. Any number of listeners can exist
         * for a single event name.
         * @param {string} name The name of the event, cooinciding with the DispatchEvent name.
         * @param {(ev: plat.events.DispatchEvent, ...args: Array<any>) => void} listener The method called when the
         * DispatchEvent is fired.
         */
        Control.prototype.on = function (name, listener) {
            var _EventManager = Control._EventManager || acquire(__EventManagerStatic);
            return _EventManager.on(this.uid, name, listener, this);
        };
        /**
         * The dispose event is called when a control is being removed from memory. A control should release
         * all of the memory it is using, including DOM event and property listeners.
         */
        Control.prototype.dispose = function () { };
        /**
         * An object containing all controls' registered event listeners.
         */
        Control.__eventListeners = {};
        return Control;
    }());
    plat_1.Control = Control;
    /**
     */
    function IControlFactory(_parser, _ContextManager, _EventManager, _Promise, _dom, _log) {
        Control._parser = _parser;
        Control._ContextManager = _ContextManager;
        Control._EventManager = _EventManager;
        Control._Promise = _Promise;
        Control._dom = _dom;
        Control._log = _log;
        return Control;
    }
    plat_1.IControlFactory = IControlFactory;
    register.injectable(__ControlFactory, IControlFactory, [
        __Parser,
        __ContextManagerStatic,
        __EventManagerStatic,
        __Promise,
        __Dom,
        __Log
    ], __FACTORY);
    /**
     * A type of control that can be used as an attribute but will
     * not be used to add, remove, or modify DOM.
     */
    var AttributeControl = (function (_super) {
        __extends(AttributeControl, _super);
        function AttributeControl() {
            _super.apply(this, arguments);
            /**
             * Specifies the TemplateControl associated with this
             * control's element. Can be null if no TemplateControl
             * exists.
             */
            this.templateControl = null;
        }
        /**
         * Method for disposing an attribute control. Removes any
         * necessary objects from the control.
         * @param {plat.AttributeControl} control The AttributeControl to dispose.
         */
        AttributeControl.dispose = function (control) {
            deleteProperty(control, 'templateControl');
            Control.dispose(control);
        };
        /**
         * Returns a new instance of AttributeControl.
         */
        AttributeControl.getInstance = function () {
            return new AttributeControl();
        };
        return AttributeControl;
    }(Control));
    plat_1.AttributeControl = AttributeControl;
    /**
     */
    function IAttributeControlFactory() {
        return AttributeControl;
    }
    plat_1.IAttributeControlFactory = IAttributeControlFactory;
    register.injectable(__AttributeControlFactory, IAttributeControlFactory, null, __FACTORY);
    /**
     * Holds all the classes and interfaces related to UI components for platypus.
     */
    var ui;
    (function (ui) {
        /**
         * The base control for any control that affects the UI. They provide properties for the control to use
         * to manage its body HTML.
         */
        var TemplateControl = (function (_super) {
            __extends(TemplateControl, _super);
            function TemplateControl() {
                _super.apply(this, arguments);
                /**
                 * By default TemplateControls have a priority of 100.
                 */
                this.priority = 100;
                /**
                 * The context of an TemplateControl, used for inheritance and data-binding.
                 */
                this.context = null;
                /**
                 * Specifies the absolute path from where the context was created to this Control's context.
                 * Used by the ContextManager for maintaining context parity
                 * (e.g. 'context.childContextProperty.grandChildContextProperty').
                 */
                this.absoluteContextPath = null;
                /**
                 * Flag indicating whether or not the TemplateControl defines the context property.
                 */
                this.hasOwnContext = false;
                /**
                 * Allows a TemplateControl to either swap its element with another element (e.g. plat-select),
                 * or replace its element altogether. If null or empty string, the element will be removed from the DOM, and the
                 * childNodes of the element will be in its place. In addition, when the element is placed startNode and endNode Comments
                 * are created, and the childNodes are added to the elementNodes property on the control. The replaceWith
                 * property can be any property that works with document.createElement(). If the control's element had
                 * attributes (as well as attribute Controls), those attributes will be carried to the swapped element. The default
                 * replaceWith is 'any,' meaning it will default to a 'div' in the case that the control type is used as the
                 * element's nodename (e.g. `<plat-foreach plat-context="..."></plat-foreach>`), but will maintain whatever element type
                 * is used otherwise (e.g. `<tr plat-control="plat-foreach" plat-context="..."></tr>`).
                 */
                this.replaceWith = 'any';
            }
            TemplateControl.evaluateExpression = function (expression, control, aliases) {
                if (isEmpty(expression)) {
                    return expression;
                }
                if (isString(expression)) {
                    expression = TemplateControl._parser.parse(expression);
                }
                else if (!isFunction(expression.evaluate)) {
                    return expression;
                }
                if (isNull(control)) {
                    return expression.evaluate(null, aliases);
                }
                if (expression.aliases.length > 0) {
                    aliases = TemplateControl.getResources(control, expression.aliases, aliases);
                    if (isEmpty(aliases)) {
                        return;
                    }
                }
                return expression.evaluate(control.context, aliases);
            };
            /**
             * Given a control and Array of aliases, finds the associated resources and builds a context object containing
             * the values. Returns the object.
             * @param {plat.ui.TemplateControl} control The control used as the starting point for finding resources.
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {IObject<any>} resources? An optional resources object to extend, if no resources object is passed in a
             * new one will be created.
             */
            TemplateControl.getResources = function (control, aliases, resources) {
                if (isNull(control)) {
                    return {};
                }
                var length = aliases.length, alias, resource, resourceObj, cache = TemplateControl.__resourceCache[control.uid];
                if (isNull(cache)) {
                    cache = TemplateControl.__resourceCache[control.uid] = {};
                }
                resources = resources || {};
                for (var i = 0; i < length; ++i) {
                    alias = aliases[i];
                    if (alias[0] === '@') {
                        alias = alias.slice(1);
                    }
                    if (alias === __CONTEXT_RESOURCE) {
                        resources[alias] = control.context;
                        continue;
                    }
                    else if (alias === __ROOT_CONTEXT_RESOURCE) {
                        resources[alias] = Control.getRootControl(control).context;
                        continue;
                    }
                    if (!isNull(resources[alias])) {
                        continue;
                    }
                    else if (!isNull(cache[alias])) {
                        var resourceControl = cache[alias].control, controlResources = resourceControl.resources;
                        if (isNull(controlResources)) {
                            resourceObj = TemplateControl.findResource(control, alias);
                        }
                        else {
                            resourceObj = {
                                control: resourceControl,
                                resource: controlResources[alias]
                            };
                        }
                    }
                    else {
                        resourceObj = TemplateControl.findResource(control, alias);
                    }
                    if (isNull(resourceObj)) {
                        if (control.type.indexOf(__COMPILED) !== -1) {
                            continue;
                        }
                        TemplateControl._log.warn('Resource alias: ' + alias + ' is not defined.');
                        continue;
                    }
                    cache[alias] = resourceObj;
                    resource = resourceObj.resource;
                    resources[alias] = isNull(resource) ? resource : resource.value;
                }
                return resources;
            };
            /**
             * Starts at a control and searches up its parent chain for a particular resource alias.
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * @param {plat.ui.TemplateControl} control The control on which to start searching for the resource alias.
             * @param {string} alias The alias to search for.
             */
            TemplateControl.findResource = function (control, alias) {
                var resource;
                if (isNull(control) || isNull(control.resources) || !isString(alias) || isEmpty(alias)) {
                    return;
                }
                if (alias[0] === '@') {
                    alias = alias.slice(1);
                }
                var isRootContext = alias === __ROOT_CONTEXT_RESOURCE;
                if (isRootContext || alias === __CONTEXT_RESOURCE || alias === __CONTROL_RESOURCE) {
                    if (isRootContext) {
                        control = Control.getRootControl(control);
                    }
                    resource = (control.resources || {})[alias];
                    if (isNull(resource)) {
                        return;
                    }
                    return {
                        resource: resource,
                        control: control
                    };
                }
                while (!isNull(control)) {
                    resource = (control.resources || {})[alias];
                    if (!isNull(resource)) {
                        return {
                            resource: resource,
                            control: control
                        };
                    }
                    control = control.parent;
                }
            };
            /**
             * Recursively disposes a control and its children.
             * @param {plat.ui.TemplateControl} control A control to dispose.
             */
            TemplateControl.dispose = function (control) {
                if (isNull(control)) {
                    return;
                }
                var uid = control.uid, childControls = control.controls, controls = (childControls && childControls.slice(0)), ContextManager = Control._ContextManager, define = ContextManager.defineProperty;
                if (!isNull(controls)) {
                    var length_8 = controls.length - 1;
                    for (var i = length_8; i >= 0; --i) {
                        Control.dispose(controls[i]);
                    }
                }
                if (isFunction(control.dispose)) {
                    control.dispose();
                }
                Control.removeEventListeners(control);
                TemplateControl.removeElement(control);
                TemplateControl._ResourcesFactory.dispose(control);
                TemplateControl._BindableTemplatesFactory.dispose(control);
                deleteProperty(TemplateControl.__resourceCache, control.uid);
                ContextManager.dispose(control);
                events.EventManager.dispose(control.uid);
                TemplateControl._managerCache.remove(uid);
                Control.removeParent(control);
                define(control, __RESOURCES, null, true, true, true);
                control.attributes = null;
                control.bindableTemplates = null;
                control.controls = [];
                control.root = null;
                control.innerTemplate = null;
                if (control.__injectable__type === __STATIC) {
                    var injector = controlInjectors[control.type];
                    register.control(control.type, control.constructor, injector.dependencies, true);
                }
            };
            /**
             * Loads the control tree depth first (visit children, then visit self).
             * @param {plat.ui.TemplateControl} control The control serving as the root control to load.
             */
            TemplateControl.loadControl = function (control) {
                var children = control.controls, length = children.length, child;
                for (var i = 0; i < length; ++i) {
                    child = children[i];
                    if (!isNull(child.controls)) {
                        TemplateControl.loadControl(child);
                    }
                    else {
                        child.loaded();
                    }
                }
                control.loaded();
            };
            /**
             * Notifies a control that its context has been changed by
             * calling the `control.contextChanged` method if it exists.
             * @param {plat.ui.TemplateControl} control The control whose context changed.
             * @param {any} newValue The new value of the control's context.
             * @param {any} oldValue The old value of the control's context.
             */
            TemplateControl.contextChanged = function (control, newValue, oldValue) {
                control.context = newValue;
                TemplateControl.setContextResources(control);
                if (isFunction(control.contextChanged)) {
                    control.contextChanged(newValue, oldValue);
                }
            };
            /**
             * Sets the `context` resource value on a TemplateControl. If the control specifies
             * hasOwnContext as true, the `rootContext` resource value will be set.
             * @param {plat.ui.TemplateControl} control The control whose context resources will be set.
             */
            TemplateControl.setContextResources = function (control) {
                var value = control.context;
                if (isNull(control.resources)) {
                    control.resources = TemplateControl._ResourcesFactory.getInstance();
                    control.resources.initialize(control);
                }
                if (control.hasOwnContext) {
                    if (isNull(control.resources.rootContext)) {
                        control.resources.add({
                            root: {
                                type: __OBSERVABLE_RESOURCE,
                                value: value
                            }
                        });
                    }
                    else {
                        control.resources.rootContext.value = value;
                    }
                }
                if (isNull(control.resources.context)) {
                    control.resources.add({
                        context: {
                            type: __OBSERVABLE_RESOURCE,
                            value: value
                        }
                    });
                    return;
                }
                control.resources.context.value = value;
            };
            /**
             * Completely removes a control's element from its parentNode.
             * @param {plat.ui.TemplateControl} control The control whose element should be removed.
             */
            TemplateControl.removeElement = function (control) {
                if (isNull(control)) {
                    return;
                }
                var element = control.element, parentNode;
                if (control.replaceWith === null ||
                    control.replaceWith === '' ||
                    isDocumentFragment(element)) {
                    removeAll(control.startNode, control.endNode);
                    control.elementNodes = control.startNode = control.endNode = null;
                    return;
                }
                else if (isNull(element)) {
                    return;
                }
                parentNode = element.parentNode;
                if (!isNull(parentNode)) {
                    parentNode.removeChild(element);
                }
                control.element = null;
            };
            /**
             * Sets the absoluteContextPath read-only property on a control.
             * @param {plat.ui.TemplateControl} control The control on which to set the absoluteContextPath.
             * @param {string} path The path to set on the control.
             */
            TemplateControl.setAbsoluteContextPath = function (control, path) {
                Control._ContextManager.defineGetter(control, 'absoluteContextPath', path, false, true);
            };
            /**
             * Determines the template for a control by searching for a templateUrl,
             * using the provided templateUrl, or serializing the control's templateString.
             * @param {plat.ui.TemplateControl} control The control whose template is being determined.
             * @param {string} templateUrl? The potential template URL to use to grab the template.
             */
            TemplateControl.determineTemplate = function (control, templateUrl) {
                var templateCache = TemplateControl._templateCache, dom = control.dom, Promise = TemplateControl._Promise;
                if (!isNull(templateUrl)) {
                }
                else if (!isNull(control.templateUrl)) {
                    templateUrl = control.templateUrl;
                }
                else if (!isNull(control.templateString)) {
                    var type_1 = control.type;
                    return templateCache.read(type_1).catch(function (template) {
                        if (isNull(template)) {
                            template = control.templateString;
                        }
                        return templateCache.put(type_1, template);
                    });
                }
                else {
                    return Promise.reject(null);
                }
                return dom.getTemplate(templateUrl);
            };
            /**
             * Detaches a TemplateControl. Disposes its children,
             * but does not dispose the TemplateControl.
             * @param {plat.ui.TemplateControl} control The control to be detached.
             */
            TemplateControl.detach = function (control) {
                if (isNull(control) || isNull(control.controls)) {
                    return;
                }
                var controls = control.controls.slice(0), length = controls.length;
                for (var i = 0; i < length; ++i) {
                    Control.dispose(controls[i]);
                }
                Control.removeEventListeners(control);
                TemplateControl.removeElement(control);
                TemplateControl._ResourcesFactory.dispose(control, true);
                deleteProperty(TemplateControl.__resourceCache, control.uid);
                Control._ContextManager.dispose(control);
                events.EventManager.dispose(control.uid);
                TemplateControl._managerCache.remove(control.uid);
                Control.removeParent(control);
                control.controls = [];
                control.attributes = null;
            };
            /**
             * Returns a new instance of TemplateControl.
             */
            TemplateControl.getInstance = function () {
                return new TemplateControl();
            };
            /**
             * This event is fired when an TemplateControl's context property
             * is changed by an ancestor control.
             * @param {any} newValue? The new value of the context.
             * @param {any} oldValue The old value of the context.
             */
            TemplateControl.prototype.contextChanged = function (newValue, oldValue) { };
            /**
             * A method called for TemplateControls to set their template.
             * During this method a control should ready its template for compilation. Whatever is in the control's
             * element (or elementNodes if replaceWith is implemented) after this method's execution will be compiled
             * and appear on the DOM.
             */
            TemplateControl.prototype.setTemplate = function () { };
            /**
             * Finds the associated resources and builds a context object containing
             * the values.
             * @param {Array<string>} aliases An array of aliases to search for.
             * @param {IObject<any>} resources? An optional resources object to extend,
             * if no resources object is passed in a new one will be created.
             */
            TemplateControl.prototype.getResources = function (aliases, resources) {
                return TemplateControl.getResources(this, aliases, resources);
            };
            /**
             * Starts at a control and searches up its parent chain for a particular resource alias.
             * If the resource is found, it will be returned along with the control instance on which
             * the resource was found.
             * @param {string} alias The alias to search for.
             */
            TemplateControl.prototype.findResource = function (alias) {
                return TemplateControl.findResource(this, alias);
            };
            TemplateControl.prototype.evaluateExpression = function (expression, context) {
                return TemplateControl.evaluateExpression(expression, this, context);
            };
            /**
             * An object for quickly retrieving previously accessed resources.
             */
            TemplateControl.__resourceCache = {};
            return TemplateControl;
        }(Control));
        ui.TemplateControl = TemplateControl;
        /**
         */
        function ITemplateControlFactory(_ResourcesFactory, _BindableTemplatesFactory, _managerCache, _templateCache, _parser, _http, _Promise, _log) {
            TemplateControl._ResourcesFactory = _ResourcesFactory;
            TemplateControl._BindableTemplatesFactory = _BindableTemplatesFactory;
            TemplateControl._managerCache = _managerCache;
            TemplateControl._templateCache = _templateCache;
            TemplateControl._parser = _parser;
            TemplateControl._http = _http;
            TemplateControl._Promise = _Promise;
            TemplateControl._log = _log;
            return TemplateControl;
        }
        ui.ITemplateControlFactory = ITemplateControlFactory;
        register.injectable(__TemplateControlFactory, ITemplateControlFactory, [
            __ResourcesFactory,
            __BindableTemplatesFactory,
            __ManagerCache,
            __TemplateCache,
            __Parser,
            __Http,
            __Promise,
            __Log
        ], __FACTORY);
        register.injectable(__TemplateControlInstance, TemplateControl, null, __INSTANCE);
        /**
         * An extended TemplateControl that allows for the binding of a value to
         * another listening control (e.g. plat-bind control).
         */
        var BindControl = (function (_super) {
            __extends(BindControl, _super);
            function BindControl() {
                _super.apply(this, arguments);
                /**
                 * Set to 120, higher than `plat-bind` to ensure that BinControls load
                 * prior to the `plat-bind`.
                 */
                this.priority = 120;
                /**
                 * The set of functions added externally that listens
                 * for property changes.
                 */
                this._listeners = [];
            }
            /**
             * Adds a listener to be called when the bindable property changes.
             * @param {plat.IPropertyChangedListener<any>} listener The function that acts as a listener.
             */
            BindControl.prototype.onInput = function (listener) {
                var listeners = this._listeners;
                listeners.push(listener);
                return function () {
                    var index = listeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    listeners.splice(index, 1);
                };
            };
            /**
             * A function that allows this control to observe both the bound property itself as well as
             * potential child properties if being bound to an object.
             * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
             * databinding.
             */
            BindControl.prototype.observeProperties = function (binder) { };
            /**
             * A function that signifies when this control's bindable property has changed.
             * @param {any} newValue The new value of the property after the change.
             * @param {any} oldValue? The old value of the property prior to the change.
             */
            BindControl.prototype.inputChanged = function (newValue, oldValue) {
                if (newValue === oldValue) {
                    return;
                }
                var listeners = this._listeners, length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            };
            /**
             * Removes references to the listeners
             * defined externally.
             */
            BindControl.prototype.dispose = function () {
                this._listeners = [];
            };
            return BindControl;
        }(TemplateControl));
        ui.BindControl = BindControl;
        /**
         * A control used in a Viewport for page navigation. The
         * control has navigation events that are called when navigating to and from the control. A ViewControl
         * represents a routing component on a page (i.e. a piece of a page that is associated with a particular route).
         * It has the ability to initiate, approve, and reject navigation to/from itself. A ViewControl also has the
         * ability to inject a Router and configure sub-navigation.
         */
        var ViewControl = (function (_super) {
            __extends(ViewControl, _super);
            function ViewControl() {
                _super.apply(this, arguments);
                /**
                 * Specifies that this control will have its own context, and it should not inherit a context.
                 */
                this.hasOwnContext = true;
            }
            /**
             * Recursively disposes a ViewControl and its children.
             * @param {plat.ui.ViewControl} control A control to dispose.
             */
            ViewControl.dispose = function (control) {
                TemplateControl.dispose(control);
            };
            /**
             * Returns a new instance of a ViewControl.
             */
            ViewControl.getInstance = function () {
                return new ViewControl();
            };
            /**
             * Allows a ViewControl to asynchronously decide if the app is able to navigate away from the
             * current view. A possible use of this method might be to popup a confirmation modal. You can
             * return a boolean or IThenable<boolean> to accept/reject navigation.
             * A word of caution, this is a navigation-blocking function. It is best to avoid long-running functions.
             */
            ViewControl.prototype.canNavigateFrom = function () { };
            /**
             * Allows a ViewControl to asynchronously decide if it can be navigated to with the given parameters/query.
             * You can return a boolean or IThenable<boolean> to accept/reject navigation.
             * A word of caution, this is a navigation-blocking function. It is best to avoid long-running functions.
             */
            ViewControl.prototype.canNavigateTo = function (parameters, query) { };
            /**
             * This method is called when the ViewControl is going out of scope as a result of a navigation.
             */
            ViewControl.prototype.navigatingFrom = function () { };
            /**
             * This method is called when the ViewControl has come into scope as a result of navigation. It can
             * receive the route parameters and query in order to set its context.
             */
            ViewControl.prototype.navigatedTo = function (parameters, query) { };
            return ViewControl;
        }(TemplateControl));
        ui.ViewControl = ViewControl;
        /**
         * An extensible class dealing with the creation, deletion, and modification
         * of DOM.
         */
        var Dom = (function () {
            function Dom() {
                /**
                 * Reference to the DomEvents injectable.
                 */
                this._domEvents = acquire(__DomEvents);
            }
            Dom.prototype.addEventListener = function (element, type, listener, useCapture) {
                return this._domEvents.addEventListener(element, type, listener, useCapture);
            };
            Dom.prototype.appendChildren = function (nodeList, root) {
                return appendChildren(nodeList, root);
            };
            Dom.prototype.cloneChildren = function (nodeList, root) {
                return appendChildren(nodeList, root, true);
            };
            /**
             * Clears a DOM Node by removing all of its childNodes.
             * @param {Node} node The DOM Node to clear.
             */
            Dom.prototype.clearNode = function (node) {
                return clearNode(node);
            };
            Dom.prototype.clearNodeBlock = function (nodeList, parent) {
                return clearNodeBlock(nodeList, parent);
            };
            /**
             * Sets the innerHTML of a Node. Can take in a Node rather than an Element
             * because it does not use innerHTML on the passed-in Node (it appends its
             * childNodes).
             * @param {Node} node The Node to set innerHTML.
             * @param {string} html HTML string to be put inside the node.
             */
            Dom.prototype.setInnerHtml = function (node, html) {
                return setInnerHtml(node, html);
            };
            Dom.prototype.insertBefore = function (parent, nodes, endNode) {
                return insertBefore(parent, nodes, endNode);
            };
            /**
             * Takes the child nodes of the given node and places them above the node
             * in the DOM. Then removes the given node.
             * @param {Node} node The Node to replace.
             */
            Dom.prototype.replace = function (node) {
                return replace(node);
            };
            Dom.prototype.replaceWith = function (node, newNode) {
                return replaceWith(node, newNode);
            };
            /**
             * Takes in a string representing innerHTML and returns a DocumentFragment
             * containing the serialized DOM.
             * @param {string} html The DOM string.
             */
            Dom.prototype.serializeHtml = function (html) {
                return serializeHtml(html);
            };
            /**
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode.  If endNode is not specified,
             * DOM will be removed until the end of the parentNode's children.
             * @param {Node} startNode The starting node, which will not be removed.
             * @param {Node} endNode The ending node, which will not be removed.
             */
            Dom.prototype.removeBetween = function (startNode, endNode) {
                return removeBetween(startNode, endNode);
            };
            /**
             * Takes in a startNode and endNode, each having the same parentNode.
             * Removes every node in between the startNode and endNode as well as
             * the startNode and the endNode.  If endNode is not specified, DOM
             * will be removed until the end of the parentNode's children.
             * @param {Node} startNode The first node to remove.
             * @param {Node} endNode The last node to remove.
             */
            Dom.prototype.removeAll = function (startNode, endNode) {
                return removeAll(startNode, endNode);
            };
            /**
             * Adds a class or multiple classes to the specified element.
             * @param {Element} element The element to which the class name is being added.
             * @param {string} className The class name or space delimited class names to add to the element.
             */
            Dom.prototype.addClass = function (element, className) {
                return addClass(element, className);
            };
            /**
             * Removes a class or multiple classes from the specified element.
             * @param {Element} element The element from which the class name is being removed.
             * @param {string} className The class name or space delimited class names to remove from the element.
             */
            Dom.prototype.removeClass = function (element, className) {
                return removeClass(element, className);
            };
            /**
             * Toggles a class or multiple classes from the specified element.
             * @param {Element} element The element on which the class name is being toggled.
             * @param {string} className The class name or space delimited class names to toggle on the element.
             */
            Dom.prototype.toggleClass = function (element, className) {
                return toggleClass(element, className);
            };
            /**
             * Replaces a single class with another class.
             * @param {Element} element The element on which the class name is being toggled.
             * @param {string} oldClass The class name being replaced.
             * @param {string} newClass The class name doing the replacing.
             */
            Dom.prototype.replaceClass = function (element, oldClass, newClass) {
                return replaceClass(element, oldClass, newClass);
            };
            /**
             * Returns whether or not an element has a particular class or classes assigned to it.
             * @param {Element} element The element on which the class name is being checked.
             * @param {string} className The class name or space delimited class names to check on the element.
             */
            Dom.prototype.hasClass = function (element, className) {
                return hasClass(element, className);
            };
            /**
             * Retrieves and serializes HTML from an HTML template file using ajax. Will facilitate caching the template
             * as well.
             * @param {string} templateUrl The url where the HTML template is stored.
             */
            Dom.prototype.getTemplate = function (templateUrl) {
                return getTemplate(templateUrl);
            };
            /**
             * Inspects the Element and resolves when the Element is present in the DOM body.
             * @param {() => void} cb A callback that will fire when the element is present in the DOM body.
             * @param {Element} element The element whose presence is being inspected.
             */
            Dom.prototype.whenPresent = function (cb, element) {
                return whenPresent(cb, element);
            };
            /**
             * Inspects the Element and resolves when the Element is visible in the DOM.
             * @param {() => void} cb A callback that will fire when the element is visible in the DOM.
             * @param {Element} element The element whose visibility is being inspected.
             */
            Dom.prototype.whenVisible = function (cb, element) {
                return whenVisible(cb, element);
            };
            Dom._inject = {
                _domEvents: __DomEvents
            };
            return Dom;
        }());
        ui.Dom = Dom;
        register.injectable(__Dom, Dom);
        /**
         * The class which provides a way for TemplateControls to bind a template
         * to a context. Useful for narrowing context without needing another
         * TemplateControl. In addition, this object provides a performance increase because
         * it will only compile the template once. This object is also useful when a
         * TemplateControls expects multiple configuration templates in its innerHTML. It can
         * separate those templates and reuse them accordingly.
         */
        var BindableTemplates = (function () {
            function BindableTemplates() {
                /**
                 * Reference to the IResourcesFactory injectable.
                 */
                this._ResourcesFactory = acquire(__ResourcesFactory);
                /**
                 * Reference to the IControlFactory injectable.
                 */
                this._ControlFactory = acquire(__ControlFactory);
                /**
                 * Reference to the ITemplateControlFactory injectable.
                 */
                this._TemplateControlFactory = acquire(__TemplateControlFactory);
                /**
                 * Reference to the IContextManagerStatic injectable.
                 */
                this._ContextManager = acquire(__ContextManagerStatic);
                /**
                 * Reference to the IPromise injectable.
                 */
                this._Promise = acquire(__Promise);
                /**
                 * Reference to a cache injectable that stores ElementManagers.
                 */
                this._managerCache = acquire(__ManagerCache);
                /**
                 * Reference to the Document injectable.
                 */
                this._document = acquire(__Document);
                /**
                 * Reference to the IElementManagerFactory injectable.
                 */
                this._ElementManagerFactory = acquire(__ElementManagerFactory);
                /**
                 * Reference to the BindableTemplatesFactory injectable.
                 */
                this._BindableTemplatesFactory = acquire(__BindableTemplatesFactory);
                /**
                 * Reference to the Log injectable.
                 */
                this._log = acquire(__Log);
                /**
                 * Stores promises that resolve to all the compiled templates for this object, ready to be bound to a data context.
                 * All created templates are DocumentFragments, allowing an TemplateControl to
                 * easily insert the template into the DOM (without iterating over childNodes).
                 */
                this.templates = {};
                /**
                 * A keyed cache of ElementManagers that represent the roots of compiled templates
                 * created by this instance.
                 */
                this.cache = {};
                /**
                 * A collection of all the controls created while compiling an added template. Useful during disposal.
                 */
                this.__compiledControls = [];
            }
            /**
             * Creates a new instance of BindableTemplates and returns it. If a BindableTemplates is
             * passed in, it will use the properties on the original BindableTemplates.
             * @param {plat.ui.TemplateControl} control The TemplateControl
             * containing the new BindableTemplates object, used for data
             * context inheritance for templates.
             * @param {plat.ui.BindableTemplates} original? An optional BindableTemplates
             * object to copy.
             */
            BindableTemplates.create = function (control, original) {
                var bindableTemplates = new BindableTemplates();
                bindableTemplates.control = control;
                if (!isNull(original)) {
                    bindableTemplates.templates = original.templates;
                    bindableTemplates.cache = original.cache;
                }
                return bindableTemplates;
            };
            /**
             * Clears the memory being held by control's bindableTemplates.
             * @param {plat.ui.TemplateControl} control The control whose bindableTemplates will be disposed.
             */
            BindableTemplates.dispose = function (control) {
                if (isNull(control)) {
                    return;
                }
                var instance = control.bindableTemplates;
                if (isNull(instance) || !isFunction(instance.dispose)) {
                    return;
                }
                instance.dispose();
            };
            /**
             * Determines whether or not a control was created using bindableTemplates.
             * @param {plat.ui.TemplateControl} control The potential bound control.
             */
            BindableTemplates.isBoundControl = function (control) {
                if (isNull(control)) {
                    return false;
                }
                var parent = control.parent;
                if (isNull(parent)) {
                    return false;
                }
                return control.type.indexOf(parent.type + __BOUND_PREFIX) === 0;
            };
            BindableTemplates.prototype.once = function (template, relativeIdentifier, resources) {
                var _this = this;
                var fragment;
                if (isNull(template)) {
                    return this._Promise.resolve(this._document.createDocumentFragment());
                }
                else if (isString(template)) {
                    fragment = serializeHtml(template);
                }
                else if (isDocumentFragment(template)) {
                    fragment = template;
                }
                else {
                    fragment = this._document.createDocumentFragment();
                    if (isNode(template)) {
                        fragment.appendChild(template);
                    }
                    else if (isArrayLike(template)) {
                        appendChildren(template, fragment);
                    }
                    else {
                        return this._Promise.resolve(fragment);
                    }
                }
                if (!(isNull(relativeIdentifier) || isNumber(relativeIdentifier) || isString(relativeIdentifier))) {
                    this._log.warn(this.control.type + ' cannot bind template with relativeIdentifier: ' + relativeIdentifier +
                        '. Identifier must be either a string or number');
                    return;
                }
                var parent = this.control, controlManager = this._managerCache.read(parent.uid), manager = this._ElementManagerFactory.getInstance(), control = this._createBoundControl('', fragment, relativeIdentifier, resources), nodeMap = this._createNodeMap(control, fragment, relativeIdentifier);
                parent.controls.push(control);
                controlManager.children = [];
                manager.initialize(nodeMap, controlManager);
                manager.setUiControlTemplate();
                return manager.fulfillAndLoad().then(function () {
                    var _document = _this._document;
                    control.startNode = fragment.insertBefore(_document.createComment(control.type + __START_NODE), fragment.firstChild);
                    control.endNode = fragment.insertBefore(_document.createComment(control.type + __END_NODE), null);
                    return fragment;
                });
            };
            BindableTemplates.prototype.bind = function (key, relativeIdentifier, resources) {
                return this._bind(key, relativeIdentifier, resources);
            };
            BindableTemplates.prototype.add = function (key, template, overwrite) {
                if (isEmpty(key)) {
                    this._log.debug(this.control.type + ' must use a valid key to add a template to BindableTemplates.');
                    return;
                }
                var templatePromise = this.templates[key];
                if (!isNull(templatePromise) && !overwrite) {
                    return;
                }
                if (isNull(template)) {
                    return;
                }
                else if (isString(template)) {
                    this._compile(key, serializeHtml(template));
                    return;
                }
                else if (isDocumentFragment(template)) {
                    this._compile(key, template);
                    return;
                }
                var fragment = this._document.createDocumentFragment();
                if (isNode(template)) {
                    fragment.appendChild(template);
                }
                else if (isArrayLike(template)) {
                    appendChildren(template, fragment);
                }
                else {
                    return;
                }
                this._compile(key, fragment);
            };
            BindableTemplates.prototype.replace = function (index, key, relativeIdentifier, resources) {
                var control = this.control.controls[index];
                if (!BindableTemplates.isBoundControl(control)) {
                    this._log.warn('The child control of ' + this.control.type + ' at the specified index: ' + index +
                        ' is not a bound control and thus cannot be replaced by BindableTemplates.');
                    return this._Promise.resolve([]);
                }
                var endNode = control.endNode;
                if (!(isNode(endNode) && isNode(endNode.parentNode))) {
                    this._log.warn('The child control of ' + this.control.type + ' at the specified index: ' + index +
                        ' had either no placeholding comment nodes or its comment nodes had no parent and thus ' +
                        'cannot be replaced by BindableTemplates.');
                    return this._Promise.resolve([]);
                }
                return this._bind(key, relativeIdentifier, resources, index);
            };
            /**
             * Clears the memory being held by this instance.
             */
            BindableTemplates.prototype.dispose = function () {
                var dispose = this._TemplateControlFactory.dispose, compiledControls = this.__compiledControls, length = compiledControls.length;
                for (var i = 0; i < length; ++i) {
                    dispose(compiledControls[i]);
                }
                this.__compiledControls = [];
                this.control = null;
                this.cache = {};
                this.templates = {};
            };
            /**
             * Method for linking a template to a data context and returning a clone of the template,
             * with all new Controls created if the template contains controls. If no data context
             * is specified, it will be inherited.
             * @param {string} key The key used to retrieve the template.
             * @param {string} relativeIdentifier? The identifier string relative to this control's context
             * (e.g. 'foo.bar.baz' would signify the object this.context.foo.bar.baz). This is the
             * most efficient way of specifying context, else the framework has to search for the
             * object.
             * @param {plat.IObject<plat.IResource>} resources? An object used as the resources for any top-level
             * controls created in the template.
             * @param {number} index? An optional index only to be used if the newly bound template is intended to
             * replace an existing Control in the child controls Array and its element in the DOM.
             */
            BindableTemplates.prototype._bind = function (key, relativeIdentifier, resources, index) {
                var _this = this;
                var templatePromise = this.templates[key], noIndex = isNull(index);
                if (isNull(templatePromise)) {
                    this._log.error(new Error(this.control.type + ' cannot bind template, no template stored with key: ' + key));
                    return;
                }
                if (!(isNull(relativeIdentifier) || isNumber(relativeIdentifier) || isString(relativeIdentifier))) {
                    this._log.warn(this.control.type + ' cannot bind template with relativeIdentifier: ' + relativeIdentifier +
                        '. Identifier must be either a string or number');
                    return;
                }
                templatePromise = templatePromise.then(function (result) {
                    var template = result.cloneNode(true), control = _this._createBoundControl(key, template, relativeIdentifier, resources), nodeMap = _this._createNodeMap(control, template, relativeIdentifier);
                    if (noIndex) {
                        _this.control.controls.push(control);
                    }
                    return _this._bindTemplate(key, nodeMap);
                });
                if (!noIndex) {
                    return templatePromise.then(function (fragment) {
                        var childNodes = Array.prototype.slice.call(fragment.childNodes), oldControl = _this.control.controls[index], endNode = oldControl.endNode, parentNode = endNode.parentNode, nextSibling = endNode.nextSibling;
                        _this._TemplateControlFactory.dispose(oldControl);
                        parentNode.insertBefore(fragment, nextSibling);
                        return childNodes;
                    }).then(null, function (error) {
                        postpone(function () {
                            if (isString(error)) {
                                error = new Error(error);
                            }
                            _this._log.error(error);
                        });
                        return _this._document.createDocumentFragment();
                    });
                }
                return templatePromise.then(null, function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                    return _this._document.createDocumentFragment();
                });
            };
            /**
             * Creates the template's bound control and INodeMap and initiates
             * the binding of the INodeMap for a cloned template.
             * @param {string} key The template key.
             * @param {plat.processing.INodeMap} nodeMap The node map to bind.
             */
            BindableTemplates.prototype._bindTemplate = function (key, nodeMap) {
                var _this = this;
                var control = nodeMap.uiControlNode.control, disposed = false, dispose = isFunction(control.dispose) ? control.dispose.bind(control) : noop;
                control.dispose = function () {
                    disposed = true;
                    dispose();
                    control.dispose = dispose;
                };
                return this._bindNodeMap(key, nodeMap).then(function () {
                    var _document = _this._document, template = nodeMap.element;
                    if (disposed) {
                        return _document.createDocumentFragment();
                    }
                    control.startNode = template.insertBefore(_document.createComment(control.type + __START_NODE), template.firstChild);
                    control.endNode = template.insertBefore(_document.createComment(control.type + __END_NODE), null);
                    return template;
                }, function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                    return null;
                });
            };
            /**
             * Clones the compiled ElementManager using the newly created
             * INodeMap and binds and loads this control's
             * ElementManager.
             * @param {string} key The template key used to grab the ElementManager.
             * @param {plat.processing.INodeMap} nodeMap The node map to bind.
             */
            BindableTemplates.prototype._bindNodeMap = function (key, nodeMap) {
                var manager = this.cache[key], child = nodeMap.uiControlNode.control, template = nodeMap.element, _managerCache = this._managerCache;
                manager.clone(template, _managerCache.read(this.control.uid), nodeMap);
                return _managerCache.read(child.uid).bindAndLoad();
            };
            /**
             * Creates the template's compiled, bound control and INodeMap and initiates
             * the compilation of the template.
             * @param {string} key The template key.
             * @param {DocumentFragment} template The HTML template being bound.
             */
            BindableTemplates.prototype._compile = function (key, template) {
                var control = this._createBoundControl(key + __COMPILED, template), nodeMap = this._createNodeMap(control, template);
                this.__compiledControls.push(control);
                this._compileNodeMap(control, nodeMap, key);
            };
            /**
             * Instantiates a new ElementManager for the root of this
             * template and resolves any asynchronous url templates within the template being compiled.
             * @param {plat.ui.TemplateControl} control The newly created control used to bind the template.
             * @param {plat.processing.INodeMap} nodeMap The newly created node map to bind.
             * @param {string} key The template key.
             */
            BindableTemplates.prototype._compileNodeMap = function (control, nodeMap, key) {
                var _this = this;
                var manager = this._ElementManagerFactory.getInstance(), promises = [];
                manager.isClone = true;
                manager.initialize(nodeMap, null);
                manager.setUiControlTemplate();
                this.cache[key] = manager;
                promises.push(manager.fulfillTemplate());
                this.templates[key] = this._Promise.all(promises).then(function () {
                    var element = nodeMap.element, clone = element.cloneNode(true), _document = _this._document, startNode = control.startNode = _document.createComment(control.type + __START_NODE), endNode = control.endNode = _document.createComment(control.type + __END_NODE);
                    element.insertBefore(startNode, element.firstChild);
                    element.insertBefore(endNode, null);
                    return clone;
                });
            };
            /**
             * Creates an INodeMap for either a template being compiled or a
             * template being bound.
             * @param {plat.ui.TemplateControl} uiControl The newly created control used to bind the template.
             * @param {Node} template The template being compiled.
             * @param {string} childContext? A potential child context string identifier.
             */
            BindableTemplates.prototype._createNodeMap = function (uiControl, template, childContext) {
                return {
                    element: template,
                    attributes: {},
                    nodes: [],
                    childContext: childContext,
                    uiControlNode: {
                        control: uiControl,
                        nodeName: uiControl.type,
                        expressions: [],
                        injector: null
                    }
                };
            };
            /**
             * Creates a TemplateControl used for binding either a template being compiled
             * or a template being bound.
             * @param {string} key The template key.
             * @param {DocumentFragment} template The template being compiled or being bound.
             * @param {plat.IObject<plat.ui.IResource>} resources? A set of resources to add to the control used to
             * compile/bind this template.
             */
            BindableTemplates.prototype._createBoundControl = function (key, template, childContext, resources) {
                var _TemplateControlFactory = this._TemplateControlFactory, control = _TemplateControlFactory.getInstance(), _ResourcesFactory = this._ResourcesFactory, parent = this.control, compiledManager = this.cache[key], isCompiled = isObject(compiledManager), _resources = _ResourcesFactory.getInstance();
                if (isCompiled) {
                    var compiledControl = compiledManager.getUiControl();
                    _resources.initialize(control, compiledControl.resources);
                    _resources.add(resources);
                }
                else {
                    _resources.initialize(control, resources);
                }
                control.resources = _resources;
                _ResourcesFactory.addControlResources(control);
                control.bindableTemplates = this._BindableTemplatesFactory.create(control, parent.bindableTemplates);
                control.parent = parent;
                control.controls = [];
                control.element = template;
                control.type = parent.type + __BOUND_PREFIX + key;
                control.root = this._ControlFactory.getRootControl(control);
                if (isCompiled) {
                    var contextManager = this._ContextManager.getManager(control.root);
                    control.absoluteContextPath = parent.absoluteContextPath || __CONTEXT;
                    if (!isNull(childContext)) {
                        control.absoluteContextPath += '.' + childContext;
                    }
                    control.context = contextManager.getContext(control.absoluteContextPath.split('.'), false);
                }
                return control;
            };
            return BindableTemplates;
        }());
        ui.BindableTemplates = BindableTemplates;
        /**
         */
        function IBindableTemplatesFactory() {
            return BindableTemplates;
        }
        ui.IBindableTemplatesFactory = IBindableTemplatesFactory;
        register.injectable(__BindableTemplatesFactory, IBindableTemplatesFactory, null, __FACTORY);
        /**
         * The class that stores the information about an Element's attributes (NamedNodeMap).
         * Methods are implemented to allow you to observe for changes on an attribute.
         */
        var Attributes = (function () {
            function Attributes() {
                /**
                 * The set of functions added externally that listens
                 * for attribute changes.
                 */
                this.__listeners = {};
            }
            Attributes.getInstance = function () {
                return new Attributes();
            };
            /**
             * Initializes this instance with a Control and the camelCased
             * attribute properties and their values.
             * @param {plat.Control} control The function that acts as a listener.
             * @param {plat.IObject<string>} attributes The camelCased attribute properties and their values.
             */
            Attributes.prototype.initialize = function (control, attributes) {
                this.__control = control;
                var keys = Object.keys(attributes), attributeListeners = this.__listeners, key, length = keys.length;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    this[key] = attributes[key];
                    attributeListeners[key] = [];
                }
            };
            /**
             * Provides a way to observe an attribute for changes.
             * @param {plat.IPropertyChangedListener} listener The listener function to be called when the attribute changes.
             * @param {string} key The attribute to observe for changes (e.g. 'src').
             */
            Attributes.prototype.observe = function (listener, key) {
                var listeners = this.__listeners[camelCase(key)];
                if (isNull(listeners)) {
                    return noop;
                }
                listener = listener.bind(this.__control);
                listeners.push(listener);
                return function () {
                    var index = listeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    listeners.splice(index, 1);
                };
            };
            /**
             * Used to show an attribute has been changed and forces listeners to be fired.
             * @param {string} key The attribute being observed for changes (e.g. 'src').
             * @param {any} newValue The new value of the attribute.
             * @param {any} oldValue The previous value of the attribute.
             */
            Attributes.prototype._attributeChanged = function (key, newValue, oldValue) {
                var listeners = this.__listeners[camelCase(key)], length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            };
            return Attributes;
        }());
        ui.Attributes = Attributes;
        function IAttributesFactory() {
            return Attributes;
        }
        ui.IAttributesFactory = IAttributesFactory;
        register.injectable(__AttributesInstance, Attributes, null, __INSTANCE);
        register.injectable(__AttributesFactory, IAttributesFactory, null, __FACTORY);
        /**
         * Resources are used for providing aliases to use in markup expressions. They
         * are particularly useful when trying to access properties outside of the
         * current context, as well as reassigning context at any point in an app.
         */
        var Resources = (function () {
            function Resources() {
                /**
                 * An object representing all of the currently available resources.
                 */
                this.__resources = {};
                /**
                 * Whether this Resources instance has been bound yet.
                 */
                this.__bound = false;
            }
            /**
             * Populates an IResource value if necessary, and adds it to the given
             * control's resources.
             * @param {plat.ui.TemplateControl} control The control for which to create a resource.
             * @param {plat.ui.IResource} resource The object used to set the resource values.
             */
            Resources.create = function (control, resource) {
                if (isNull(resource)) {
                    return resource;
                }
                var value;
                switch (resource.type.toLowerCase()) {
                    case __INJECTABLE_RESOURCE:
                        var injector = injectableInjectors[resource.value];
                        if (!isNull(injector)) {
                            resource.value = injector.inject();
                        }
                        break;
                    case __OBSERVABLE_RESOURCE:
                        Resources._observeResource(control, resource);
                        break;
                    case __OBJECT_RESOURCE:
                        value = resource.value;
                        if (isString(value)) {
                            resource.value = control.evaluateExpression(value);
                        }
                        break;
                    case __LITERAL_RESOURCE:
                        break;
                    case __FUNCTION_RESOURCE:
                        value = resource.value;
                        if (isString(value)) {
                            value = control[value];
                            if (isFunction(value)) {
                                resource.value = value.bind(control);
                            }
                            else {
                                Resources._log.warn('Attempted to create a "function" ' +
                                    'type Resource, but the function ' + value + 'cannot be found on your control.');
                                resource.value = noop;
                            }
                        }
                        break;
                }
                return resource;
            };
            /**
             * Adds resource aliases for `@control` and `@context`. The resources are
             * aliases for the control instance and the control.context.
             * @param {plat.ui.TemplateControl} control The control on which to add the resources.
             */
            Resources.addControlResources = function (control) {
                control.resources.add({
                    context: {
                        value: control.context,
                        type: __OBSERVABLE_RESOURCE
                    },
                    control: {
                        value: control,
                        type: __OBJECT_RESOURCE
                    }
                });
                if (control.hasOwnContext) {
                    Resources.__addRoot(control);
                }
            };
            Resources.bindResources = function (resourcesInstance) {
                var resources = resourcesInstance.__resources;
                if (isNull(resources)) {
                    return;
                }
                var control = resourcesInstance.__controlInstance, aliases = Object.keys(resources), controlResources = Resources.__controlResources, length = aliases.length, alias;
                for (var i = 0; i < length; ++i) {
                    alias = aliases[i];
                    if (controlResources[alias] === true) {
                        continue;
                    }
                    resourcesInstance[alias] = resources[alias] = Resources.create(control, resourcesInstance[alias]);
                }
                resourcesInstance.__bound = true;
            };
            /**
             * Disposes a resource instance, removing its reference
             * from a control and breaking references to all resource
             * objects.
             * @param {plat.ui.TemplateControl} control The control whose resources will be disposed.
             * @param {boolean} persist? Whether or not to persist a resource object post
             * disposal or set it to null.
             */
            Resources.dispose = function (control, persist) {
                var resources = control.resources;
                if (isNull(resources)) {
                    return;
                }
                var keys = Object.keys(resources.__resources), key, length = keys.length, define = Resources._ContextManager.defineProperty, resource;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    resource = resources[key];
                    if (!isNull(resource) && (resource.type === __OBSERVABLE_RESOURCE || resource.type === __LITERAL_RESOURCE)) {
                        define(resources, key, persist ? _clone(resource, true) : null, true, true, true);
                    }
                }
                Resources._removeListeners(resources.__controlInstance);
            };
            /**
             * Parses a resources Element (`<plat-resources>`) and creates
             * an IObject<IResource> with its element children.
             * @param {Element} element The resources element to parse.
             */
            Resources.parseElement = function (element) {
                var children = Array.prototype.slice.call(element.children), child, _regex = Resources._regex, whiteSpaceRegex = _regex.whiteSpaceRegex, quotationRegex = _regex.quotationRegex, resources = {}, resource, types = Resources.__resourceTypes, attrs, attr, nodeName, text;
                while (children.length > 0) {
                    child = children.pop();
                    nodeName = child.nodeName.toLowerCase();
                    if (!types[nodeName]) {
                        continue;
                    }
                    attrs = child.attributes;
                    resource = {};
                    attr = attrs.getNamedItem(__ALIAS);
                    if (isNull(attr)) {
                        continue;
                    }
                    resource.alias = attr.value;
                    text = child.textContent.replace(whiteSpaceRegex, '$1');
                    if (isEmpty(text)) {
                        continue;
                    }
                    resource.value = (nodeName === __INJECTABLE_RESOURCE || nodeName === __LITERAL_RESOURCE) ?
                        text.replace(quotationRegex, '') : text;
                    resource.type = nodeName;
                    resources[resource.alias] = resource;
                }
                return resources;
            };
            /**
             * Returns a new instance with type Resources.
             */
            Resources.getInstance = function () {
                return new Resources();
            };
            /**
             * Observes the resource if the type is `observable`.
             * @param {plat.ui.TemplateControl} control The control in charge of the observable resource.
             * @param {plat.ui.IResource} resource The resource to observe.
             */
            Resources._observeResource = function (control, resource) {
                var value = resource.value, uid = control.uid, removeListeners = Resources.__observableResourceRemoveListeners[uid];
                if (isNull(removeListeners)) {
                    removeListeners = Resources.__observableResourceRemoveListeners[uid] = [];
                }
                if (isString(value)) {
                    if (!isNull(resource.initialValue)) {
                        value = resource.initialValue;
                    }
                    else {
                        resource.initialValue = value;
                    }
                    var listener = control.observeExpression(function (newValue) {
                        resource.value = newValue;
                    }, value);
                    resource.value = control.evaluateExpression(value);
                    removeListeners.push(listener);
                }
            };
            /**
             * Removes observable resource listeners for a specified control.
             * @param {plat.ui.TemplateControl} control The control whose listeners are being removed.
             */
            Resources._removeListeners = function (control) {
                if (isNull(control)) {
                    return;
                }
                var uid = control.uid, removeListeners = Resources.__observableResourceRemoveListeners[uid];
                if (isArray(removeListeners)) {
                    var length_9 = removeListeners.length;
                    for (var i = 0; i < length_9; ++i) {
                        removeListeners[i]();
                    }
                }
                deleteProperty(Resources.__observableResourceRemoveListeners, uid);
            };
            /**
             * Adds a `@root` alias and `@rootContext` to a control, specifying that it contains the root
             * and root context. Root controls are generally the root ViewControl.
             * @param {plat.ui.TemplateControl} control The root control.
             */
            Resources.__addRoot = function (control) {
                control.resources.add({
                    root: {
                        value: control,
                        type: __OBJECT_RESOURCE,
                        alias: __ROOT_RESOURCE
                    },
                    rootContext: {
                        value: control.context,
                        type: __OBSERVABLE_RESOURCE,
                        alias: __ROOT_CONTEXT_RESOURCE
                    }
                });
            };
            Resources.prototype.initialize = function (controlInstance, resources) {
                this.__controlInstance = controlInstance;
                if (isNull(resources)) {
                    return;
                }
                else if (isNode(resources)) {
                    resources = Resources.parseElement(resources);
                }
                else if (isObject(resources.resources)) {
                    resources = resources.resources;
                }
                this.__resources = resources;
                var keys = Object.keys(resources), key, length = keys.length;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    this[key] = resources[key];
                }
            };
            Resources.prototype.add = function (resources) {
                if (isNull(resources)) {
                    return;
                }
                else if (isNode(resources)) {
                    resources = Resources.parseElement(resources);
                }
                var keys = Object.keys(resources), length = keys.length, resource, control = this.__controlInstance, bound = this.__bound, key, create = Resources.create;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    resource = resources[key];
                    resource.alias = key;
                    this[key] = this.__resources[key] = bound ? create(control, resource) : resource;
                }
            };
            /**
             * The injectable resource type token.
             */
            Resources.INJECTABLE = __INJECTABLE_RESOURCE;
            /**
             * The object resource type token. Objects should be literal objects and won't be observed.
             */
            Resources.OBJECT = __OBJECT_RESOURCE;
            /**
             * The observable resource type token. Observable resources are expected to be
             * string identifiers and will be observed.
             */
            Resources.OBSERVABLE = __OBSERVABLE_RESOURCE;
            /**
             * The literal resource type token. Literals will be observed on the resource object,
             * so if you change `resources.<alias>.value` it will be reflected everywhere it is
             * observed.
             */
            Resources.LITERAL = __LITERAL_RESOURCE;
            /**
             * The function resource type token.
             */
            Resources.FUNCTION = __FUNCTION_RESOURCE;
            /**
             * An object consisting of keyed arrays containing functions for removing observation listeners.
             */
            Resources.__observableResourceRemoveListeners = {};
            return Resources;
        }());
        ui.Resources = Resources;
        /**
         */
        function IResourcesFactory(_ContextManager, _regex, _log) {
            Resources._ContextManager = _ContextManager;
            Resources._regex = _regex;
            Resources._log = _log;
            var controlResources = {}, resourceTypes = {};
            controlResources[__CONTROL_RESOURCE] = controlResources[__CONTEXT_RESOURCE] = controlResources[__ROOT_RESOURCE] = controlResources[__ROOT_CONTEXT_RESOURCE] = true;
            resourceTypes[__INJECTABLE_RESOURCE] = resourceTypes[__OBJECT_RESOURCE] = resourceTypes[__OBSERVABLE_RESOURCE] = resourceTypes[__FUNCTION_RESOURCE] = resourceTypes[__LITERAL_RESOURCE] = true;
            Resources.__controlResources = controlResources;
            Resources.__resourceTypes = resourceTypes;
            return Resources;
        }
        ui.IResourcesFactory = IResourcesFactory;
        register.injectable(__ResourcesFactory, IResourcesFactory, [
            __ContextManagerStatic,
            __Regex,
            __Log
        ], __FACTORY);
        register.injectable(__ResourcesInstance, Resources, null, __INSTANCE);
        /**
         * A class for managing DOM event registration and handling.
         */
        var DomEvents = (function () {
            /**
             * Retrieve the type of touch events for this browser and create the default gesture style.
             */
            function DomEvents() {
                /**
                 * An object containing the event types for all of the
                 * supported gestures.
                 */
                this._gestures = DomEvents.gestures;
                /**
                 * The version of android, or -1 if not on android.
                 */
                this._androidVersion = isUndefined(this._compat.ANDROID) ? -1 : this._compat.ANDROID;
                /**
                 * Whether or not we're on Android 4.4.x or below.
                 */
                this._android44orBelow = this._androidVersion > -1 && Math.floor(this._androidVersion / 10) <= 44;
                /**
                 * Whether or not the user is using mouse when touch events are present.
                 */
                this._inMouse = false;
                /**
                 * An object with keyed subscribers that keep track of all of the
                 * events registered on a particular element.
                 */
                this._subscribers = {};
                /**
                 * An object containing the number of currently active
                 * events of each base type.
                 */
                this._gestureCount = {
                    $tap: 0,
                    $dbltap: 0,
                    $hold: 0,
                    $release: 0,
                    $swipe: 0,
                    $track: 0,
                    $trackend: 0
                };
                /**
                 * Whether or not the user moved while in touch.
                 */
                this.__hasMoved = false;
                /**
                 * Whether or not their is a registered "release" event.
                 */
                this.__hasRelease = false;
                /**
                 * Whether or not we should be detecting move events.
                 */
                this.__detectingMove = false;
                /**
                 * The current tap count to help distinguish single from double taps.
                 */
                this.__tapCount = 0;
                /**
                 * The total number of touches on the screen.
                 */
                this.__touchCount = 0;
                /**
                 * A function to remove a deferred tap given the case that a tap delay was needed for
                 * something such as a double tap to zoom feature.
                 */
                this.__cancelDeferredTap = noop;
                /**
                 * A function for removing a deferred hold event.
                 */
                this.__cancelDeferredHold = noop;
                /**
                 * A regular expressino for determining a "cancel" event.
                 */
                this.__cancelRegex = /cancel/i;
                /**
                 * A regular expressino for determining a pointer end event.
                 */
                this.__pointerEndRegex = /up|cancel/i;
                /**
                 * Whether or not there are any swipe subscribers for the current target during touch move events.
                 */
                this.__haveSwipeSubscribers = false;
                /**
                 * A function to stop listening for blur events on the currently focused element.
                 */
                this.__blurRemover = noop;
                /**
                 * A set of flags signifying whether we should ignore native events or not.
                 */
                this.__ignoreEvent = { mousedown: false, mouseup: false };
                /**
                 * A function with a bound context that prevents default and stops propagation for delayed or phantom clicks.
                 */
                this.__boundPreventDefaultClick = this.__preventDefaultClick.bind(this);
                /**
                 * A hash map for mapping custom events to standard events.
                 */
                this.__reverseMap = {};
                /**
                 * An object containing the number of currently active mapped touch
                 * events of each type.
                 */
                this.__mappedCount = {
                    $touchstart: 0,
                    $touchmove: 0,
                    $touchend: 0,
                    $touchcancel: 0
                };
                /**
                 * A hash of the current pointer touch points on the page.
                 */
                this.__pointerHash = {};
                /**
                 * An array containing all current pointer touch points on the page.
                 */
                this.__pointerEvents = [];
                /**
                 * A set of touch start, move, and end listeners to be place on the document.
                 */
                this.__listeners = {};
                this.__getTypes();
                this.initialize();
            }
            DomEvents.prototype.addEventListener = function (element, type, listener, useCapture) {
                var _this = this;
                var _compat = this._compat, mappedGestures = _compat.mappedEvents, mappedType = mappedGestures[type], mappingExists = !isNull(mappedType), mappedCount = this.__mappedCount, gestures = this._gestures, listenerRemoved = false;
                if (mappingExists) {
                    this.__reverseMap[mappedType] = type;
                    this.__registerElement(element, type);
                    mappedCount[type]++;
                    if (_compat.hasTouchEvents && !this.__cancelRegex.test(mappedType)) {
                        mappedType = mappedType
                            .replace('touch', 'mouse')
                            .replace('start', 'down')
                            .replace('end', 'up');
                        this.__reverseMap[mappedType] = type;
                    }
                }
                element.addEventListener(type, listener, useCapture);
                if (!isUndefined(element['on' + type]) || isUndefined(gestures[type]) || mappingExists) {
                    return function () {
                        if (listenerRemoved) {
                            return;
                        }
                        else if (mappingExists) {
                            if (mappedCount[type] > 0) {
                                mappedCount[type]--;
                            }
                            _this.__unregisterElement(element, type);
                        }
                        listenerRemoved = true;
                        element.removeEventListener(type, listener, useCapture);
                    };
                }
                var swipeGesture = gestures.$swipe, trackGesture = gestures.$track, countType = type;
                if (type.indexOf(trackGesture) !== -1) {
                    var trackend = gestures.$trackend;
                    countType = type === trackend ? trackend : trackGesture;
                }
                else if (type.indexOf(swipeGesture) !== -1) {
                    countType = swipeGesture;
                }
                this._gestureCount[countType]++;
                this.__registerElement(element, type);
                return function () {
                    if (listenerRemoved) {
                        return;
                    }
                    listenerRemoved = true;
                    _this.__removeEventListener(element, type, listener, useCapture);
                };
            };
            /**
             * If DomEvents is inactive, will initialize behavior and
             * begin listening for events.
             */
            DomEvents.prototype.initialize = function () {
                var isActive = this._isActive;
                if (isActive === true) {
                    // has already been initialized and was never disposed 
                    return;
                }
                this.__registerTypes();
                if (isNull(isActive)) {
                    this.__appendGestureStyle();
                }
                this._isActive = true;
            };
            /**
             * Stops listening for touch events and resets the DomEvents
             * instance.
             */
            DomEvents.prototype.dispose = function () {
                this.__unregisterTypes();
                this.__blurRemover();
                this.__blurRemover = noop;
                this._gestureCount = {
                    $tap: 0,
                    $dbltap: 0,
                    $hold: 0,
                    $release: 0,
                    $swipe: 0,
                    $track: 0,
                    $trackend: 0
                };
                this.__mappedCount = {
                    $touchstart: 0,
                    $touchmove: 0,
                    $touchend: 0,
                    $touchcancel: 0
                };
                this._isActive = false;
                this._subscribers = {};
                this.__pointerEvents = [];
                this.__pointerHash = {};
                this.__reverseMap = {};
                this.__ignoreEvent = { mousedown: false, mouseup: false };
                this.__tapCount = this.__touchCount = 0;
                this.__detectingMove = this.__hasMoved = this.__hasRelease = this.__haveSwipeSubscribers = false;
                this.__lastMoveEvent = this.__lastTouchDown = this.__lastTouchUp = null;
                this.__swipeOrigin = this.__capturedTarget = this.__focusedElement = this.__delayedClickRemover = null;
                this.__cancelDeferredHold = this.__cancelDeferredTap = noop;
            };
            /**
             * A listener for touch/mouse start events.
             * @param {plat.ui.IPointerEvent} ev The touch start event object.
             */
            DomEvents.prototype._onTouchStart = function (ev) {
                var _this = this;
                var eventType = ev.type;
                if (this.__ignoreEvent[eventType]) {
                    this.__ignoreEvent[eventType] = false;
                    this.__delayedClickRemover[eventType]();
                    if (ev.target !== this.__focusedElement) {
                        if (ev.cancelable === true) {
                            ev.preventDefault();
                        }
                        return false;
                    }
                    return true;
                }
                else if (this.__touchCount++ > 0) {
                    return true;
                }
                if (eventType !== 'mousedown') {
                    this._inTouch = true;
                }
                else if (this._inTouch === true) {
                    // return immediately if mouse event and currently in a touch 
                    ev.preventDefault();
                    return false;
                }
                else if (this._compat.hasTouchEvents) {
                    this._inMouse = true;
                }
                ev = this.__standardizeEventObject(ev);
                if (isNull(ev)) {
                    return true;
                }
                // set last move back to null and hasMoved to false 
                this.__lastMoveEvent = null;
                this.__hasMoved = false;
                var clientX = ev.clientX, clientY = ev.clientY, timeStamp = ev.timeStamp, target = ev.target, gestures = this._gestures;
                this.__lastTouchDown = {
                    _buttons: ev._buttons,
                    clientX: clientX,
                    clientY: clientY,
                    timeStamp: timeStamp,
                    target: target,
                    identifier: ev.identifier
                };
                this.__swipeOrigin = {
                    clientX: clientX,
                    clientY: clientY,
                    xTimestamp: timeStamp,
                    yTimestamp: timeStamp,
                    xTarget: target,
                    yTarget: target
                };
                if (this._android44orBelow) {
                    this.__haveSwipeSubscribers = this.__findFirstSubscribers(target, [gestures.$swipe, gestures.$swipedown, gestures.$swipeleft, gestures.$swiperight, gestures.$swipeup]).length > 0;
                }
                var gestureCount = this._gestureCount, noHolds = gestureCount.$hold <= 0, noRelease = gestureCount.$release <= 0, mappedCount = this.__mappedCount;
                // if any moving events registered, register move 
                if (eventType === 'touchstart' || mappedCount.$touchmove > 0 || gestureCount.$track > 0 ||
                    gestureCount.$trackend > 0 || gestureCount.$swipe > 0) {
                    this.__registerType(this._moveEvents);
                    this.__detectingMove = true;
                }
                // check mapped events 
                var mappedType = this.__reverseMap[eventType];
                if (mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(ev);
                    }
                }
                // return if no hold or release events are registered 
                if (noHolds && noRelease) {
                    return true;
                }
                var holdInterval = DomEvents.config.intervals.holdInterval, domEvent, subscribeFn, domEventFound = false;
                if (noHolds) {
                    this.__hasRelease = false;
                    this.__cancelDeferredHold = defer(function () {
                        _this.__hasRelease = true;
                    }, holdInterval);
                    return true;
                }
                else if (noRelease) {
                    domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$hold);
                    if ((domEventFound = !isNull(domEvent))) {
                        subscribeFn = function () {
                            domEvent.trigger(ev);
                            _this.__cancelDeferredHold = noop;
                        };
                    }
                }
                else {
                    this.__hasRelease = false;
                    // has both hold and release events registered 
                    domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$hold);
                    if ((domEventFound = !isNull(domEvent))) {
                        subscribeFn = function () {
                            domEvent.trigger(ev);
                            _this.__hasRelease = true;
                            _this.__cancelDeferredHold = noop;
                        };
                    }
                }
                // set timeout to fire the subscribeFn 
                if (domEventFound) {
                    this.__cancelDeferredHold = defer(subscribeFn, holdInterval);
                }
            };
            /**
             * A listener for touch/mouse move events.
             * @param {plat.ui.IPointerEvent} ev The touch move event object.
             */
            DomEvents.prototype._onTouchMove = function (ev) {
                // clear hold event 
                this.__cancelDeferredHold();
                this.__cancelDeferredHold = noop;
                var eventType = ev.type;
                // return immediately if there are multiple touches present, or 
                // if it is a mouse event and currently in a touch 
                if (this._inTouch === true && eventType === 'mousemove') {
                    return true;
                }
                var evt = this.__standardizeEventObject(ev);
                if (isNull(evt)) {
                    return true;
                }
                // check mapped events 
                var mappedType = this.__reverseMap[eventType];
                if (this.__mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(evt);
                    }
                }
                var gestureCount = this._gestureCount, noTracking = gestureCount.$track <= 0, noSwiping = gestureCount.$swipe <= 0, config = DomEvents.config, swipeOrigin = this.__swipeOrigin, x = evt.clientX, y = evt.clientY, minMove = this.__hasMoved ||
                    (this.__getDistance(swipeOrigin.clientX, x, swipeOrigin.clientY, y) >= config.distances.minScrollDistance);
                // if minimum distance not met 
                if (!minMove) {
                    return true;
                }
                this.__hasMoved = true;
                // if no moving events return 
                if (noTracking && noSwiping) {
                    return true;
                }
                var lastMove = this.__lastMoveEvent || swipeOrigin, direction = evt.direction = this.__getDirection(x - lastMove.clientX, y - lastMove.clientY);
                this.__handleOriginChange(direction);
                var dx = Math.abs(x - swipeOrigin.clientX), dy = Math.abs(y - swipeOrigin.clientY);
                evt.velocity = this.__getVelocity(dx, dy, evt.timeStamp - swipeOrigin.xTimestamp, evt.timeStamp - swipeOrigin.yTimestamp);
                if (!noSwiping && this._android44orBelow && this.__haveSwipeSubscribers) {
                    ev.preventDefault();
                }
                // if tracking events exist 
                if (!noTracking) {
                    this.__handleTrack(evt, ev);
                }
                this.__lastMoveEvent = evt;
            };
            /**
             * A listener for touch/mouse end events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype._onTouchEnd = function (ev) {
                var _this = this;
                var eventType = ev.type;
                if (this.__ignoreEvent[eventType]) {
                    this.__ignoreEvent[eventType] = false;
                    this.__delayedClickRemover[eventType]();
                    if (ev.target !== this.__focusedElement) {
                        if (ev.cancelable === true) {
                            ev.preventDefault();
                        }
                        postpone(function () {
                            var target = (_this.__lastTouchUp || {}).target;
                            if (_this._document.body.contains(target)) {
                                _this.__handleInput(target);
                            }
                        });
                        return false;
                    }
                    return true;
                }
                var hasMoved = this.__hasMoved, notMouseUp = eventType !== 'mouseup';
                if (this.__touchCount <= 0) {
                    this.__touchCount = 0;
                }
                else {
                    this.__touchCount--;
                }
                if (notMouseUp) {
                    // all non mouse cases 
                    if (eventType === 'touchend') {
                        // all to handle a strange issue when touch clicking certain types 
                        // of DOM elements 
                        if (hasMoved) {
                            // we check ev.cancelable in the END case in case of scrolling conditions 
                            if (ev.cancelable === true) {
                                ev.preventDefault();
                            }
                        }
                        else if (this._inTouch === true) {
                            // immediately handle the input depending on type for more native-like experience 
                            if (ev.target !== this.__focusedElement) {
                                if (this.__handleInput(ev.target) && ev.cancelable === true) {
                                    ev.preventDefault();
                                }
                            }
                        }
                        else {
                            if (ev.cancelable === true) {
                                ev.preventDefault();
                            }
                            this.__preventClickFromTouch();
                            return true;
                        }
                        this.__preventClickFromTouch();
                    }
                }
                else if (!isUndefined(this._inTouch)) {
                    if (!this._inMouse) {
                        // this is case where touchend fired and now 
                        // mouse end is also being fired 
                        if (ev.cancelable === true) {
                            ev.preventDefault();
                        }
                        return false;
                    }
                    this._inMouse = false;
                }
                // check for cancel event 
                if (this.__cancelRegex.test(eventType)) {
                    this.__handleCanceled(ev);
                    return true;
                }
                // standardizeEventObject creates touches 
                ev = this.__standardizeEventObject(ev);
                if (isNull(ev)) {
                    return true;
                }
                else if (notMouseUp) {
                    this._inTouch = false;
                }
                // check mapped events 
                var mappedType = this.__reverseMap[eventType];
                if (this.__mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(ev);
                    }
                }
                // additional check for mousedown/touchstart - mouseup/touchend inconsistencies 
                if (this.__touchCount > 0) {
                    this.__touchCount = ev.touches.length;
                }
                this.__clearTempStates();
                // handle release event 
                if (this.__hasRelease) {
                    this.__handleRelease(ev);
                }
                // handle swipe events 
                this.__handleSwipe();
                var config = DomEvents.config, intervals = config.intervals, touchEnd = ev.timeStamp, touchDown = this.__lastTouchDown;
                // if the user moved their finger (for scroll) we handle $trackend and return, 
                // else if they had their finger down too long to be considered a tap, we want to return 
                if (hasMoved) {
                    this.__handleTrackEnd(ev);
                    this.__tapCount = 0;
                    // clear captured target 
                    this.__capturedTarget = null;
                    return true;
                }
                else if (isNull(touchDown) || ((touchEnd - touchDown.timeStamp) > intervals.tapInterval)) {
                    this.__tapCount = 0;
                    // clear captured target 
                    this.__capturedTarget = null;
                    return true;
                }
                var lastTouchUp = this.__lastTouchUp, x = ev.clientX, y = ev.clientY;
                // check if can be a double tap event by checking number of taps, distance between taps, 
                // and time between taps 
                if (this.__tapCount > 0 &&
                    this.__getDistance(x, lastTouchUp.clientX, y, lastTouchUp.clientY) <= config.distances.maxDblTapDistance &&
                    ((touchEnd - lastTouchUp.timeStamp) <= intervals.dblTapInterval)) {
                    // handle dbltap events 
                    this.__handleDbltap(ev);
                }
                else {
                    this.__tapCount = 0;
                }
                // handle tap events 
                this.__handleTap(ev);
                this.__lastTouchUp = ev;
                // clear captured target 
                this.__capturedTarget = null;
            };
            /**
             * Clears all temporary states like move and hold events.
             */
            DomEvents.prototype.__clearTempStates = function () {
                // clear hold event 
                this.__cancelDeferredHold();
                this.__cancelDeferredHold = noop;
                if (this.__detectingMove) {
                    this.__unregisterType(this._moveEvents);
                    this.__detectingMove = false;
                }
            };
            /**
             * A function for resetting all values potentially modified during the touch event sequence.
             */
            DomEvents.prototype.__resetTouchEnd = function () {
                this.__tapCount = this.__touchCount = 0;
                this._inTouch = this.__hasRelease = false;
                this.__pointerHash = {};
                this.__pointerEvents = [];
                // clear captured target 
                this.__capturedTarget = null;
            };
            // gesture handling methods 
            /**
             * A function for handling when gestures are canceled via the Browser.
             * @param {plat.ui.IPointerEvent} ev The touch cancel event object.
             */
            DomEvents.prototype.__handleCanceled = function (ev) {
                var touches = ev.touches || this.__pointerEvents, index = this.__getTouchIndex(touches);
                ev = index >= 0 ? touches[index] : this.__standardizeEventObject(ev);
                this._inTouch = false;
                this.__clearTempStates();
                // check mapped events 
                var mappedType = this.__reverseMap[ev.type];
                if (this.__mappedCount[mappedType] > 0) {
                    var mappedDomEvent = this.__findFirstSubscriber(ev.target, mappedType);
                    if (!isNull(mappedDomEvent)) {
                        mappedDomEvent.trigger(ev);
                    }
                }
                if (this.__hasMoved) {
                    // Android 4.4.x fires touchcancel when the finger moves off an element that 
                    // is listening for touch events, so we should handle swipes here in that case. 
                    if (this._android44orBelow) {
                        this.__handleSwipe();
                    }
                    this.__handleTrackEnd(ev);
                }
                this.__resetTouchEnd();
            };
            /**
             * A function for handling and firing tap events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleTap = function (ev) {
                var _this = this;
                this.__tapCount++;
                if (this._gestureCount.$tap <= 0) {
                    return;
                }
                var gestures = this._gestures, domEvent = this.__findFirstSubscriber(ev.target, gestures.$tap);
                if (isNull(domEvent)) {
                    return;
                }
                // fire tap event immediately if no dbltap zoom delay 
                // or a mouse is being used 
                if (DomEvents.config.intervals.dblTapZoomDelay <= 0 ||
                    ev.pointerType === 'mouse' || ev.type === 'mouseup') {
                    ev._buttons = this.__lastTouchDown._buttons;
                    domEvent.trigger(ev);
                    return;
                }
                // defer for tap delay in case of something like desired 
                // dbltap zoom 
                this.__cancelDeferredTap = defer(function () {
                    ev._buttons = _this.__lastTouchDown._buttons;
                    domEvent.trigger(ev);
                    _this.__tapCount = 0;
                    _this.__cancelDeferredTap = noop;
                }, DomEvents.config.intervals.dblTapZoomDelay);
            };
            /**
             * A function for handling and firing double tap events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleDbltap = function (ev) {
                this.__tapCount = 0;
                this.__cancelDeferredTap();
                this.__cancelDeferredTap = noop;
                if (this._gestureCount.$dbltap <= 0) {
                    return;
                }
                var domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$dbltap);
                if (isNull(domEvent)) {
                    return;
                }
                ev._buttons = this.__lastTouchDown._buttons;
                domEvent.trigger(ev);
                // set touch count to -1 to prevent repeated fire on sequential taps 
                this.__tapCount = -1;
            };
            /**
             * A function for handling and firing release events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleRelease = function (ev) {
                var domEvent = this.__findFirstSubscriber(ev.target, this._gestures.$release);
                if (!isNull(domEvent)) {
                    domEvent.trigger(ev);
                }
                this.__hasRelease = false;
            };
            /**
             * A function for handling and firing swipe events.
             */
            DomEvents.prototype.__handleSwipe = function () {
                // if swiping events exist 
                if (this._gestureCount.$swipe <= 0) {
                    return;
                }
                var lastMove = this.__lastMoveEvent;
                if (isNull(lastMove)) {
                    return;
                }
                var origin = this.__swipeOrigin, dx = Math.abs(lastMove.clientX - origin.clientX), dy = Math.abs(lastMove.clientY - origin.clientY), swipeSubscribers = this.__getRegisteredSwipes(lastMove.direction, lastMove.velocity, dx, dy);
                while (swipeSubscribers.length > 0) {
                    swipeSubscribers.pop().trigger(lastMove);
                }
                this.__lastMoveEvent = null;
            };
            /**
             * A function for handling and firing track events.
             * @param {plat.ui.IPointerEvent} ev The touch move event object.
             * @param {plat.ui.IPointerEvent} originalEv The original touch move event object
             * used for preventing default in the case of an ANDROID device.
             */
            DomEvents.prototype.__handleTrack = function (ev, originalEv) {
                var gestures = this._gestures, trackGesture = gestures.$track, direction = ev.direction, eventTarget = this.__capturedTarget || ev.target;
                var domEvents = this.__findFirstSubscribers(eventTarget, [trackGesture, (trackGesture + direction.x), (trackGesture + direction.y)]);
                if (this._android44orBelow) {
                    var anyEvents = this.__findFirstSubscribers(eventTarget, [trackGesture, gestures.$trackdown, gestures.$trackup,
                        gestures.$trackleft, gestures.$trackright, gestures.$trackend]);
                    if (anyEvents.length > 0) {
                        originalEv.preventDefault();
                    }
                }
                if (domEvents.length > 0) {
                    if (this._androidVersion > -1) {
                        originalEv.preventDefault();
                    }
                    while (domEvents.length > 0) {
                        domEvents.pop().trigger(ev);
                    }
                }
            };
            /**
             * A function for handling and firing track end events.
             * @param {plat.ui.IPointerEvent} ev The touch end event object.
             */
            DomEvents.prototype.__handleTrackEnd = function (ev) {
                if (this._gestureCount.$trackend <= 0) {
                    return;
                }
                var eventTarget = this.__capturedTarget || ev.target, domEvent = this.__findFirstSubscriber(eventTarget, this._gestures.$trackend);
                if (isNull(domEvent)) {
                    return;
                }
                domEvent.trigger(ev);
            };
            // touch type and element registration 
            /**
             * A function for determining the proper touch events.
             */
            DomEvents.prototype.__getTypes = function () {
                var _compat = this._compat, touchEvents = _compat.mappedEvents, listeners = this.__listeners, startEvents, moveEvents, endEvents;
                if (_compat.hasPointerEvents) {
                    startEvents = this._startEvents = touchEvents.$touchstart;
                    moveEvents = this._moveEvents = touchEvents.$touchmove;
                    endEvents = this._endEvents = touchEvents.$touchend + ' ' + touchEvents.$touchcancel;
                }
                else if (_compat.hasTouchEvents) {
                    startEvents = this._startEvents = touchEvents.$touchstart + ' mousedown';
                    moveEvents = this._moveEvents = touchEvents.$touchmove + ' mousemove';
                    endEvents = this._endEvents = touchEvents.$touchend + ' mouseup ' + touchEvents.$touchcancel;
                }
                else {
                    var cancelEvent = touchEvents.$touchcancel;
                    startEvents = this._startEvents = touchEvents.$touchstart;
                    moveEvents = this._moveEvents = touchEvents.$touchmove;
                    endEvents = this._endEvents = touchEvents.$touchend + (!cancelEvent ? '' : (' ' + cancelEvent));
                }
                listeners[startEvents] = this._onTouchStart.bind(this);
                listeners[moveEvents] = this._onTouchMove.bind(this);
                listeners[endEvents] = this._onTouchEnd.bind(this);
            };
            /**
             * Registers for and starts listening to start and end touch events on the document.
             */
            DomEvents.prototype.__registerTypes = function () {
                this.__registerType(this._startEvents);
                this.__registerType(this._endEvents);
                // dragstart will cause touchend to not fire 
                this._document.addEventListener('dragstart', this.__preventDefault, false);
            };
            /**
             * Unregisters for and stops listening to all touch events on the document.
             */
            DomEvents.prototype.__unregisterTypes = function () {
                this.__unregisterType(this._startEvents);
                this.__unregisterType(this._endEvents);
                if (this.__detectingMove) {
                    this.__unregisterType(this._moveEvents);
                    this.__detectingMove = false;
                }
                this._document.removeEventListener('dragstart', this.__preventDefault, false);
            };
            /**
             * Registers for and begins listening to a particular touch event type.
             * @param {string} events The events to begin listening for.
             */
            DomEvents.prototype.__registerType = function (events) {
                var listener = this.__listeners[events], _document = this._document, eventSplit = events.split(' '), index = eventSplit.length;
                while (index-- > 0) {
                    _document.addEventListener(eventSplit[index], listener, false);
                }
            };
            /**
             * Unregisters for and stops listening to a particular touch event type.
             * @param {string} events The events to stop listening for.
             */
            DomEvents.prototype.__unregisterType = function (events) {
                var listener = this.__listeners[events], _document = this._document, eventSplit = events.split(' '), index = eventSplit.length;
                while (index-- > 0) {
                    _document.removeEventListener(eventSplit[index], listener, false);
                }
            };
            /**
             * Registers and associates an element with an event.
             * @param {plat.ui.ICustomElement} element The element being tied to a custom event.
             * @param {string} type The type of event.
             */
            DomEvents.prototype.__registerElement = function (element, type) {
                var id, _plat = element.__plat;
                if (isNull(_plat)) {
                    id = uniqueId('domEvent_');
                    element.__plat = _plat = {
                        domEvent: id
                    };
                }
                else if (isNull(_plat.domEvent)) {
                    id = uniqueId('domEvent_');
                    _plat.domEvent = id;
                }
                var _domEvent;
                if (isNull(id)) {
                    var subscriber = this._subscribers[_plat.domEvent];
                    if (isUndefined(subscriber[type])) {
                        _domEvent = new CustomDomEvent(element, type);
                        subscriber[type] = _domEvent;
                    }
                    else {
                        subscriber[type].count++;
                    }
                    subscriber.gestureCount++;
                    return;
                }
                var newSubscriber = { gestureCount: 1 };
                _domEvent = new CustomDomEvent(element, type);
                newSubscriber[type] = _domEvent;
                this._subscribers[id] = newSubscriber;
                if (!isUndefined(element.className)) {
                    addClass(element, DomEvents.config.styleConfig[0].className);
                }
                this.__removeSelections(element);
            };
            /**
             * Unregisters and disassociates an element with an event.
             * @param {plat.ui.ICustomElement} element The element being disassociated with the given custom event.
             * @param {string} type The type of event.
             */
            DomEvents.prototype.__unregisterElement = function (element, type) {
                var _plat = element.__plat;
                if (isNull(_plat) || isNull(_plat.domEvent)) {
                    return;
                }
                var domEventId = _plat.domEvent, eventSubscriber = this._subscribers[domEventId], domEvent = eventSubscriber[type];
                if (isNull(domEvent)) {
                    return;
                }
                domEvent.count--;
                if (domEvent.count === 0) {
                    deleteProperty(eventSubscriber, type);
                }
                eventSubscriber.gestureCount--;
                if (eventSubscriber.gestureCount === 0) {
                    deleteProperty(this._subscribers, domEventId);
                    this.__removeElement(element);
                }
            };
            /**
             * Sets the current touch point and helps standardize the given event object.
             * @param {plat.ui.IPointerEvent} ev The current point being touched.
             */
            DomEvents.prototype.__setTouchPoint = function (ev) {
                var eventType = ev.type, _compat = this._compat;
                if (_compat.hasPointerEvents || _compat.hasMsPointerEvents) {
                    this.__updatePointers(ev, this.__pointerEndRegex.test(eventType));
                    return;
                }
                ev.pointerType = eventType.indexOf('mouse') === -1 ? 'touch' : 'mouse';
            };
            /**
             * Sets the captured target.
             * @param {EventTarget} target The target to capture.
             */
            DomEvents.prototype.__setCapture = function (target) {
                if (isNull(this.__capturedTarget) && !isDocument(target)) {
                    this.__capturedTarget = target;
                }
            };
            /**
             * Sets the captured target.
             * @param {plat.ui.IPointerEvent} ev The current touch point.
             * @param {boolean} remove Whether to remove the touch point or add it.
             */
            DomEvents.prototype.__updatePointers = function (ev, remove) {
                var id = ev.pointerId, pointerHash = this.__pointerHash, pointer = pointerHash[id], index;
                if (remove) {
                    if (!isUndefined(pointer)) {
                        index = this.__pointerEvents.indexOf(pointer);
                        if (index > -1) {
                            this.__pointerEvents.splice(index, 1);
                        }
                        deleteProperty(this.__pointerHash, id);
                    }
                }
                else {
                    if (id === 1 && !isEmpty(pointerHash)) {
                        // this is a mouse movement while mid touch 
                        return;
                    }
                    ev.identifier = ev.pointerId;
                    if (isUndefined(pointer) || (index = this.__pointerEvents.indexOf(pointer)) < 0) {
                        this.__pointerEvents.push(ev);
                    }
                    else {
                        this.__pointerEvents.splice(index, 1, ev);
                    }
                    pointerHash[id] = ev;
                }
            };
            // event and subscription handling 
            /**
             * Searches from the EventTarget up the DOM tree looking for an element with the
             * registered event type.
             * @param {plat.ui.ICustomElement} eventTarget The current target of the touch event.
             * @param {string} type The type of event being searched for.
             */
            DomEvents.prototype.__findFirstSubscriber = function (eventTarget, type) {
                if (isNull(eventTarget)) {
                    return;
                }
                var _plat, subscriber, domEvent;
                do {
                    _plat = eventTarget.__plat;
                    if (isUndefined(_plat) || isUndefined(_plat.domEvent)) {
                        continue;
                    }
                    subscriber = this._subscribers[_plat.domEvent];
                    domEvent = subscriber[type];
                    if (isUndefined(domEvent)) {
                        continue;
                    }
                    return domEvent;
                } while (!isNull(eventTarget = eventTarget.parentNode));
            };
            /**
             * Searches from the EventTarget up the DOM tree looking for all elements with the
             * registered event types.
             * @param {plat.ui.ICustomElement} eventTarget The current target of the touch event.
             * @param {Array<string>} types An array of the types of events being searched for.
             */
            DomEvents.prototype.__findFirstSubscribers = function (eventTarget, types) {
                if (isNull(eventTarget)) {
                    return [];
                }
                var _plat, subscriber, subscriberKeys, subscriberKey, domEvents = [], index;
                do {
                    _plat = eventTarget.__plat;
                    if (isUndefined(_plat) || isUndefined(_plat.domEvent)) {
                        continue;
                    }
                    subscriber = this._subscribers[_plat.domEvent];
                    subscriberKeys = Object.keys(subscriber);
                    while (subscriberKeys.length > 0) {
                        subscriberKey = subscriberKeys.pop();
                        index = types.indexOf(subscriberKey);
                        if (index !== -1) {
                            domEvents.push(subscriber[subscriberKey]);
                            types.splice(index, 1);
                        }
                    }
                } while (types.length > 0 && !isNull(eventTarget = eventTarget.parentNode));
                return domEvents;
            };
            /**
             * Removes an event listener for a given event type.
             * @param {plat.ui.ICustomElement} element The element to remove the listener from.
             * @param {string} type The type of event being removed.
             * @param {plat.ui.IGestureListener} listener The listener being removed.
             * @param {boolean} useCapture? Whether the listener is fired on the capture or bubble phase.
             */
            DomEvents.prototype.__removeEventListener = function (element, type, listener, useCapture) {
                var gestures = this._gestures;
                element.removeEventListener(type, listener, useCapture);
                var swipeGesture = gestures.$swipe, trackGesture = gestures.$track, countType = type;
                if (type.indexOf(trackGesture) !== -1) {
                    var trackend = gestures.$trackend;
                    countType = type === trackend ? trackend : trackGesture;
                }
                else if (type.indexOf(swipeGesture) !== -1) {
                    countType = swipeGesture;
                }
                this._gestureCount[countType]--;
                this.__unregisterElement(element, type);
            };
            /**
             * Removes an element from the subscriber object.
             * @param {plat.ui.ICustomElement} element The element being removed.
             */
            DomEvents.prototype.__removeElement = function (element) {
                this.__returnSelections(element);
                if (!isUndefined(element.className)) {
                    removeClass(element, DomEvents.config.styleConfig[0].className);
                }
                var plat = element.__plat;
                deleteProperty(plat, 'domEvent');
                if (isEmpty(plat)) {
                    deleteProperty(element, '__plat');
                }
            };
            /**
             * Standardizes certain properties on the event object for custom events.
             * @param {plat.ui.IExtendedEvent} ev The event object to be standardized.
             */
            DomEvents.prototype.__standardizeEventObject = function (ev) {
                this.__setTouchPoint(ev);
                var isStart = this._startEvents.indexOf(ev.type) !== -1, touches = ev.touches || this.__pointerEvents, changedTouches = ev.changedTouches, changedTouchesExist = !isUndefined(changedTouches), preventDefault, timeStamp = ev.timeStamp;
                if (changedTouchesExist) {
                    if (isStart) {
                        preventDefault = ev.preventDefault.bind(ev);
                        ev = changedTouches[0];
                        ev.preventDefault = preventDefault;
                    }
                    else {
                        var changedTouchIndex = this.__getTouchIndex(changedTouches);
                        if (changedTouchIndex >= 0) {
                            preventDefault = ev.preventDefault.bind(ev);
                            ev = changedTouches[changedTouchIndex];
                            ev.preventDefault = preventDefault;
                        }
                        else if (this.__getTouchIndex(touches) >= 0) {
                            // we want to return null because our point of interest is in touches 
                            // but was not in changedTouches so it is still playing a part on the page 
                            return null;
                        }
                    }
                }
                if (isStart) {
                    this.__setCapture(ev.target);
                }
                this.__normalizeButtons(ev);
                ev.touches = touches;
                ev.offset = this.__getOffset(ev);
                if (isUndefined(ev.timeStamp) || timeStamp > ev.timeStamp) {
                    ev.timeStamp = timeStamp;
                }
                return ev;
            };
            /**
             * Normalizes the 'buttons' property on an IExetendedEvent.
             * @param {plat.ui.IExtendedEvent} ev The event.
             */
            DomEvents.prototype.__normalizeButtons = function (ev) {
                var buttons;
                if (isNumber(ev.buttons) && ev.buttons !== 0) {
                    buttons = ev.buttons;
                }
                else if (isNumber(ev.which) && ev.which > 0) {
                    buttons = ev.which;
                }
                else {
                    switch (ev.button) {
                        case -1:
                            buttons = 0;
                            break;
                        case 0:
                            buttons = 1;
                            break;
                        case 1:
                            buttons = 4;
                            break;
                        case 2:
                            buttons = 2;
                            break;
                        case 3:
                            buttons = 8;
                            break;
                        case 4:
                            buttons = 16;
                            break;
                        default:
                            buttons = 1;
                            break;
                    }
                }
                ev._buttons = buttons;
            };
            /**
             * Searches through the input array looking for the primary
             * touch down index.
             * @param {Array<plat.ui.IExtendedEvent>} ev The array of touch event objects
             * to search through.
             */
            DomEvents.prototype.__getTouchIndex = function (touches) {
                var identifier = (this.__lastTouchDown || {}).identifier, length = touches.length;
                for (var i = 0; i < length; ++i) {
                    if (touches[i].identifier === identifier) {
                        return i;
                    }
                }
                return -1;
            };
            /**
             * Grabs the x and y offsets of an event object's target.
             * @param {plat.ui.IExtendedEvent} ev The current event object.
             */
            DomEvents.prototype.__getOffset = function (ev) {
                var target = this.__capturedTarget || ev.target;
                if (isDocument(target)) {
                    return {
                        x: ev.clientX,
                        y: ev.clientY
                    };
                }
                else if (!isUndefined(ev.offsetX) && !isUndefined(ev.offsetY) && target === ev.target) {
                    return {
                        x: ev.offsetX,
                        y: ev.offsetY
                    };
                }
                var x, y;
                if (isFunction(target.getBoundingClientRect)) {
                    var rect = target.getBoundingClientRect();
                    x = rect.left;
                    y = rect.top;
                }
                else {
                    x = target.offsetLeft;
                    y = target.offsetTop;
                    while (!isNull(target = target.offsetParent)) {
                        x += target.offsetLeft;
                        y += target.offsetTop;
                    }
                }
                return {
                    x: (ev.clientX - x),
                    y: (ev.clientY - y)
                };
            };
            // utility methods 
            /**
             * Calculates the distance between two (x, y) coordinate points.
             * @param {number} x1 The x-coordinate of the first point.
             * @param {number} x2 The x-coordinate of the second point.
             * @param {number} y1 The y-coordinate of the first point.
             * @param {number} y2 The y-coordinate of the second point.
             */
            DomEvents.prototype.__getDistance = function (x1, x2, y1, y2) {
                var x = x2 - x1, y = y2 - y1;
                return Math.sqrt((x * x) + (y * y));
            };
            /**
             * Calculates the velocity between two (x, y) coordinate points over a given time.
             * @param {number} dx The change in x position.
             * @param {number} dy The change in y position.
             * @param {number} dtx The change in time in x direction.
             * @param {number} dty The change in time in y direction.
             */
            DomEvents.prototype.__getVelocity = function (dx, dy, dtx, dty) {
                var x = 0, y = 0;
                if (dtx > 0) {
                    x = (dx / dtx) || 0;
                }
                if (dty > 0) {
                    y = (dy / dty) || 0;
                }
                return {
                    x: x,
                    y: y
                };
            };
            /**
             * Calculates the direction of movement.
             * @param {number} dx The change in x position.
             * @param {number} dy The change in y position.
             */
            DomEvents.prototype.__getDirection = function (dx, dy) {
                var distanceX = Math.abs(dx), distanceY = Math.abs(dy), lastDirection = (this.__lastMoveEvent || {}).direction || {}, horizontal = dx === 0 ? (lastDirection.x || 'none') : (dx < 0 ? 'left' : 'right'), vertical = dy === 0 ? (lastDirection.y || 'none') : (dy < 0 ? 'up' : 'down');
                return {
                    x: horizontal,
                    y: vertical,
                    primary: (distanceX === distanceY ? (lastDirection.primary || 'none') : (distanceX > distanceY ? horizontal : vertical))
                };
            };
            /**
             * Checks to see if a swipe direction has changed to recalculate
             * an origin point.
             * @param {plat.ui.IDirection} direction The current vertical and horiztonal directions of movement.
             */
            DomEvents.prototype.__handleOriginChange = function (direction) {
                var lastMove = this.__lastMoveEvent;
                if (isNull(lastMove)) {
                    return;
                }
                var swipeDirection = lastMove.direction, xSame = swipeDirection.x === direction.x, ySame = swipeDirection.y === direction.y;
                if (xSame && ySame) {
                    return;
                }
                var origin = this.__swipeOrigin, gestures = this._gestures, swipes = [gestures.$swipe, gestures.$swipedown, gestures.$swipeleft, gestures.$swiperight, gestures.$swipeup];
                if (!xSame) {
                    origin.clientX = lastMove.clientX;
                    origin.xTimestamp = lastMove.timeStamp;
                    origin.xTarget = lastMove.target;
                    if (this._android44orBelow) {
                        this.__haveSwipeSubscribers = this.__findFirstSubscribers(origin.xTarget, swipes).length > 0;
                    }
                }
                if (!ySame) {
                    origin.clientY = lastMove.clientY;
                    origin.yTimestamp = lastMove.timeStamp;
                    origin.yTarget = lastMove.target;
                    if (this._android44orBelow) {
                        this.__haveSwipeSubscribers = this.__findFirstSubscribers(origin.yTarget, swipes).length > 0;
                    }
                }
            };
            /**
             * Checks to see if a swipe event has been registered.
             * @param {plat.ui.IDirection} direction The current horizontal and vertical directions of movement.
             * @param {plat.ui.IVelocity} velocity The current horizontal and vertical velocities.
             * @param {number} dx The distance in the x direction.
             * @param {number} dy The distance in the y direction.
             */
            DomEvents.prototype.__getRegisteredSwipes = function (direction, velocity, dx, dy) {
                var swipeTarget, swipeGesture = this._gestures.$swipe, minSwipeVelocity = DomEvents.config.velocities.minSwipeVelocity, events = [swipeGesture], origin = (this.__swipeOrigin || {});
                if (dx > dy) {
                    swipeTarget = origin.xTarget;
                    if (velocity.x >= minSwipeVelocity) {
                        events.push(swipeGesture + direction.x);
                    }
                }
                else if (dy > dx) {
                    swipeTarget = origin.yTarget;
                    if (velocity.y >= minSwipeVelocity) {
                        events.push(swipeGesture + direction.y);
                    }
                }
                return this.__findFirstSubscribers(swipeTarget, events);
            };
            /**
             * Checks to see if a swipe event has been registered.
             * @param {string} direction The current direction of movement.
             */
            DomEvents.prototype.__isHorizontal = function (direction) {
                return direction === 'left' || direction === 'right';
            };
            /**
             * Appends CSS to the head for gestures if needed.
             */
            DomEvents.prototype.__appendGestureStyle = function () {
                var _document = this._document, styleClasses, classLength;
                if (this._compat.platCss) {
                    return;
                }
                else if (!isNull(_document.styleSheets) && _document.styleSheets.length > 0) {
                    var styleSheet = _document.styleSheets[0];
                    styleClasses = DomEvents.config.styleConfig;
                    classLength = styleClasses.length;
                    while (classLength-- > 0) {
                        styleSheet.insertRule(this.__createStyle(styleClasses[classLength]), 0);
                    }
                    return;
                }
                var head = _document.head, style = _document.createElement('style'), textContent = '';
                style.type = 'text/css';
                styleClasses = DomEvents.config.styleConfig;
                classLength = styleClasses.length;
                while (classLength-- > 0) {
                    textContent = this.__createStyle(styleClasses[classLength]) + textContent;
                }
                style.textContent = textContent;
                head.appendChild(style);
            };
            /**
             * Creates a style text to append to the document head.
             * @param {plat.ui.IDefaultStyle} styleClass The object containing the custom styles for
             * gestures.
             */
            DomEvents.prototype.__createStyle = function (styleClass) {
                var styles = styleClass.styles || [], styleLength = styles.length, style = '.' + styleClass.className + ' { ', textContent = '';
                styleLength = styles.length;
                for (var j = 0; j < styleLength; ++j) {
                    textContent += styles[j] + ';';
                }
                style += textContent + ' } ';
                return style;
            };
            /**
             * Blurs the currently focused element.
             */
            DomEvents.prototype.__blurFocusedElement = function () {
                var focusedElement = this.__focusedElement || {};
                if (isFunction(focusedElement.blur)) {
                    focusedElement.blur();
                }
            };
            /**
             * Listens for blur and then sets the focused element back to null for the next case.
             * @param {HTMLInputElement} target The target to listen for the blur event on.
             */
            DomEvents.prototype.__waitForBlur = function (target) {
                var _this = this;
                this.__blurRemover = this.addEventListener(target, 'blur', function () {
                    _this.__blurRemover();
                    _this.__blurRemover = noop;
                    if (target === _this.__focusedElement) {
                        _this.__focusedElement = null;
                    }
                }, false);
            };
            /**
             * Handles a click target case.
             * @param {HTMLInputElement} target The target to handle click functionaliy for.
             */
            DomEvents.prototype.__clickTarget = function (target) {
                var _this = this;
                var clicked = false, handler = function () {
                    clicked = true;
                    target.removeEventListener('click', handler, false);
                };
                target.addEventListener('click', handler, false);
                postpone(function () {
                    if (clicked) {
                        return;
                    }
                    target.removeEventListener('click', handler, false);
                    if (_this._document.body.contains(target) && isFunction(target.click)) {
                        target.click();
                    }
                });
            };
            /**
             * Handles HTMLInputElements in WebKit based touch applications.
             * @param {HTMLInputElement} target The target to handle functionality for.
             */
            DomEvents.prototype.__handleInput = function (target) {
                this.__blurRemover();
                var nodeName = target.nodeName;
                if (!isString(nodeName)) {
                    this.__focusedElement = null;
                    this.__blurFocusedElement();
                    return;
                }
                var preventDefault = true;
                switch (nodeName.toLowerCase()) {
                    case 'input':
                        switch (target.type) {
                            case 'range':
                                this.__blurFocusedElement();
                                break;
                            case 'text':
                            case 'password':
                            case 'email':
                            case 'number':
                            case 'tel':
                            case 'search':
                            case 'url':
                                target.focus();
                                this.__waitForBlur(target);
                                break;
                            default:
                                this.__blurFocusedElement();
                                this.__clickTarget(target);
                                break;
                        }
                        break;
                    case 'a':
                    case 'button':
                    case 'label':
                        this.__blurFocusedElement();
                        this.__clickTarget(target);
                        break;
                    case 'textarea':
                        target.focus();
                        this.__waitForBlur(target);
                        break;
                    case 'select':
                        preventDefault = false;
                        break;
                    default:
                        this.__blurFocusedElement();
                        this.__clickTarget(target);
                        break;
                }
                this.__focusedElement = target;
                return preventDefault;
            };
            /**
             * Handles the phantom click in WebKit based touch applications.
             */
            DomEvents.prototype.__preventClickFromTouch = function () {
                var _document = this._document, ignoreEvents = this.__ignoreEvent, boundPreventDefault = this.__boundPreventDefaultClick, interval = DomEvents.config.intervals.delayedClickInterval;
                if (interval <= 0) {
                    return;
                }
                this.__delayedClickRemover = {
                    mousedown: defer(function () {
                        ignoreEvents.mousedown = false;
                    }, interval),
                    mouseup: defer(function () {
                        ignoreEvents.mouseup = false;
                    }, interval),
                    click: defer(function () {
                        _document.removeEventListener('click', boundPreventDefault, true);
                    }, interval)
                };
                ignoreEvents.mousedown = ignoreEvents.mouseup = true;
                postpone(function () {
                    _document.addEventListener('click', boundPreventDefault, true);
                });
            };
            /**
             * Prevents default and stops propagation for delayed or phantom clicks.
             * @param {Event} ev The event object.
             */
            DomEvents.prototype.__preventDefaultClick = function (ev) {
                ev.preventDefault();
                ev.stopImmediatePropagation();
                this._document.removeEventListener('click', this.__boundPreventDefaultClick, true);
                this.__delayedClickRemover.click();
                return false;
            };
            /**
             * Removes selection capability from the element.
             * @param {Node} element The element to remove selections on.
             */
            DomEvents.prototype.__removeSelections = function (element) {
                if (!isNode(element)) {
                    return;
                }
                if (!isUndefined(element.onselectstart)) {
                    element.addEventListener('selectstart', this.__preventDefault, false);
                }
                if (!isUndefined(element.ondragstart)) {
                    element.addEventListener('dragstart', this.__preventDefault, false);
                }
            };
            /**
             * Returns selection capability from the element.
             * @param {Node} element The element to return selections on.
             */
            DomEvents.prototype.__returnSelections = function (element) {
                if (!isNode(element)) {
                    return;
                }
                if (!isUndefined(element.onselectstart)) {
                    element.removeEventListener('selectstart', this.__preventDefault, false);
                }
                if (!isUndefined(element.ondragstart)) {
                    element.removeEventListener('dragstart', this.__preventDefault, false);
                }
            };
            /**
             * Prevents default and stops propagation in all elements other than
             * inputs and textareas.
             * @param {Event} ev The event object.
             */
            DomEvents.prototype.__preventDefault = function (ev) {
                var nodeName = ev.target.nodeName;
                if (isString(nodeName)) {
                    nodeName = nodeName.toLowerCase();
                }
                if (nodeName === 'input' || nodeName === 'textarea') {
                    return true;
                }
                ev.preventDefault();
                return false;
            };
            DomEvents._inject = {
                _document: __Document,
                _compat: __Compat
            };
            /**
             * A configuration object for all DOM events.
             */
            DomEvents.config = {
                /**
                 */
                intervals: {
                    /**
                     */
                    tapInterval: 300,
                    /**
                     */
                    dblTapInterval: 300,
                    /**
                     */
                    holdInterval: 400,
                    /**
                     */
                    dblTapZoomDelay: 0,
                    /**
                     */
                    delayedClickInterval: 400
                },
                /**
                 */
                distances: {
                    /**
                     */
                    minScrollDistance: 3,
                    /**
                     */
                    maxDblTapDistance: 10
                },
                /**
                 */
                velocities: {
                    /**
                     */
                    minSwipeVelocity: 0.645
                },
                /**
                 */
                styleConfig: [{
                        /**
                         */
                        className: 'plat-gesture',
                        /**
                         */
                        styles: [
                            '-moz-user-select: none',
                            '-khtml-user-select: none',
                            '-webkit-touch-callout: none',
                            '-webkit-user-select: none',
                            '-webkit-user-drag: none',
                            '-webkit-tap-highlight-color: transparent',
                            '-webkit-overflow-scrolling: touch',
                            '-ms-user-select: none',
                            '-ms-touch-action: manipulation',
                            'touch-action: manipulation'
                        ]
                    }, {
                        /**
                         */
                        className: 'plat-no-touch-action',
                        /**
                         */
                        styles: [
                            '-ms-touch-action: none',
                            'touch-action: none'
                        ]
                    }]
            };
            /**
             * An object containing the event types for all of the
             * supported gestures.
             */
            DomEvents.gestures = {
                $tap: __tap,
                $dbltap: __dbltap,
                $hold: __hold,
                $release: __release,
                $swipe: __swipe,
                $swipeleft: __swipeleft,
                $swiperight: __swiperight,
                $swipeup: __swipeup,
                $swipedown: __swipedown,
                $track: __track,
                $trackleft: __trackleft,
                $trackright: __trackright,
                $trackup: __trackup,
                $trackdown: __trackdown,
                $trackend: __trackend
            };
            return DomEvents;
        }());
        ui.DomEvents = DomEvents;
        register.injectable(__DomEvents, DomEvents);
        /**
         */
        function IDomEventsConfig() {
            return DomEvents.config;
        }
        ui.IDomEventsConfig = IDomEventsConfig;
        register.injectable(__IDomEventsConfig, IDomEventsConfig);
        /**
         * A class for managing a single custom event.
         */
        var DomEvent = (function () {
            function DomEvent() {
                /**
                 * Reference to the Document injectable.
                 */
                this._document = acquire(__Document);
            }
            DomEvent.prototype.initialize = function (element, event, eventType) {
                this.element = element;
                this.event = event;
                this.eventType = isString(eventType) ? eventType : 'CustomEvent';
            };
            /**
             * Triggers its event on its element.
             * @param {Object} eventExtension? An event extension to extend the dispatched CustomEvent.
             * @param {any} detailArg? The detail arg to include in the event object
             * @param {Node} dispatchElement? The element to dispatch the Event from. If not specified,
             * this instance's element will be used.
             */
            DomEvent.prototype.trigger = function (eventExtension, detailArg, dispatchElement) {
                var customEv = this._document.createEvent(this.eventType);
                if (isObject(eventExtension)) {
                    _extend(false, false, customEv, eventExtension);
                }
                customEv.initCustomEvent(this.event, true, true, isNull(detailArg) ? 0 : detailArg);
                return (dispatchElement || this.element).dispatchEvent(customEv);
            };
            return DomEvent;
        }());
        ui.DomEvent = DomEvent;
        register.injectable(__DomEventInstance, DomEvent, null, __INSTANCE);
        /**
         * A specialized class for managing a single custom touch event in DomEvents.
         */
        var CustomDomEvent = (function (_super) {
            __extends(CustomDomEvent, _super);
            function CustomDomEvent(element, event) {
                _super.call(this);
                /**
                 * The number of listeners added for this event on this element.
                 */
                this.count = 0;
                this.element = element;
                this.event = event;
                this.count++;
            }
            /**
             * Triggers its event on its element.
             * @param {plat.ui.IPointerEvent} ev The current touch event object used to extend the
             * newly created custom event.
             */
            CustomDomEvent.prototype.trigger = function (ev) {
                var customEv = this._document.createEvent('CustomEvent'), element = this.element, target = ev.target;
                this.__extendEventObject(customEv, ev);
                customEv.initCustomEvent(this.event, true, true, 0);
                var success = isDocument(element) || element.contains(target) ? target.dispatchEvent(customEv) : element.dispatchEvent(customEv);
                if (!success) {
                    ev.preventDefault();
                }
                return success;
            };
            /**
             * Extends the custom event to mimic a standardized touch event.
             * @param {plat.ui.IGestureEvent} customEv The newly created custom event object.
             * @param {plat.ui.IPointerEvent} ev The current touch event object.
             */
            CustomDomEvent.prototype.__extendEventObject = function (customEv, ev) {
                // not using extend function because this gets called so often for certain events. 
                var pointerType = ev.pointerType;
                customEv.clientX = ev.clientX;
                customEv.clientY = ev.clientY;
                customEv.offsetX = ev.offset.x;
                customEv.offsetY = ev.offset.y;
                customEv.direction = ev.direction || {
                    x: 'none',
                    y: 'none',
                    primary: 'none'
                };
                customEv.touches = ev.touches;
                customEv.velocity = ev.velocity || { x: 0, y: 0 };
                customEv.identifier = ev.identifier || 0;
                customEv.pointerType = isNumber(pointerType) ? this.__convertPointerType(pointerType, ev.type) : pointerType;
                customEv.screenX = ev.screenX;
                customEv.screenY = ev.screenY;
                customEv.pageX = ev.pageX;
                customEv.pageY = ev.pageY;
                customEv.buttons = ev._buttons;
            };
            /**
             * Converts pointer type to a standardized string.
             * @param {any} pointerType The pointer type as either a number or a string.
             * @param {string} eventType The touch event type.
             */
            CustomDomEvent.prototype.__convertPointerType = function (pointerType, eventType) {
                switch (pointerType) {
                    case MSPointerEvent.MSPOINTER_TYPE_MOUSE:
                        return 'mouse';
                    case MSPointerEvent.MSPOINTER_TYPE_PEN:
                        return 'pen';
                    case MSPointerEvent.MSPOINTER_TYPE_TOUCH:
                        return 'touch';
                }
                return (eventType.indexOf('mouse') === -1) ? 'touch' : 'mouse';
            };
            return CustomDomEvent;
        }(DomEvent));
        /**
         * Holds all the classes and interfaces related to UI animation components for platypus.
         */
        var animations;
        (function (animations) {
            /**
             * A class used for animating elements.
             */
            var Animator = (function () {
                function Animator() {
                    /**
                     * Objects representing collections of all currently animated elements.
                     */
                    this._animatedElements = {};
                }
                Animator.prototype.create = function (elements, key, options) {
                    return this._create(elements, key, options, {
                        key: null
                    });
                };
                Animator.prototype.animate = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: null
                    });
                };
                Animator.prototype.enter = function (elements, key, parent, refChild, options) {
                    return this._animate(elements, key, options, {
                        key: 'enter',
                        parent: parent,
                        refChild: refChild
                    });
                };
                Animator.prototype.leave = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: 'leave'
                    });
                };
                Animator.prototype.move = function (elements, key, parent, refChild, options) {
                    return this._animate(elements, key, options, {
                        key: 'move',
                        parent: parent,
                        refChild: refChild
                    });
                };
                Animator.prototype.show = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: 'show'
                    });
                };
                Animator.prototype.hide = function (elements, key, options) {
                    return this._animate(elements, key, options, {
                        key: 'hide'
                    });
                };
                /**
                 * Returns a promise that fulfills when every animation promise in the input array is fulfilled.
                 */
                Animator.prototype.all = function (promises) {
                    var _this = this;
                    var length = promises.length, args = [], animationPromise = new AnimationPromise(function (resolve) {
                        _this._Promise.all(promises).then(function () {
                            resolve();
                        });
                    });
                    for (var i = 0; i < length; ++i) {
                        args = args.concat(promises[i].getInstances());
                    }
                    animationPromise.initialize(args);
                    return animationPromise.then(noop);
                };
                /**
                 * Immediately resolves an empty AnimationPromise.
                 */
                Animator.prototype.resolve = function () {
                    var animationPromise = new AnimationPromise(function (resolve) {
                        resolve(function () {
                            return animationPromise;
                        });
                    });
                    return animationPromise;
                };
                /**
                 * Animates the passed in elements with the given key and handles special animation functionality.
                 * @param {any} elements The Nodes to be animated. All nodes in the Array must have
                 * the same parent, otherwise the animation will not function correctly.
                 * @param {string} key The identifier specifying the type of animation.
                 * @param {any} options? Specified options for the animation.
                 * @param {plat.ui.animations.IAnimationFunction} functionality An object containing detailed information about
                 * special animation functionality.
                 */
                Animator.prototype._animate = function (elements, key, options, functionality) {
                    var animation = this._create(elements, key, options, functionality), current = animation.current;
                    animation.previous.then(function () {
                        requestAnimationFrameGlobal(function () {
                            current.start();
                        });
                    });
                    return current;
                };
                /**
                 * Animates the passed in elements with the given key and handles special animation functionality. Returns both
                 * the previous and current animations for the given element(s).
                 * @param {any} elements The Nodes to be animated. All nodes in the Array must have
                 * the same parent, otherwise the animation will not function correctly.
                 * @param {string} key The identifier specifying the type of animation.
                 * @param {any} options? Specified options for the animation.
                 * @param {plat.ui.animations.IAnimationFunction} functionality An object containing detailed information about
                 * special animation functionality.
                 */
                Animator.prototype._create = function (elements, key, options, functionality) {
                    var _this = this;
                    var animationInjector = animationInjectors[key], animationInstances = [], elementNodes = [], immediateResolve;
                    if (!this._compat.animationSupported || isUndefined(animationInjector)) {
                        animationInjector = jsAnimationInjectors[key];
                        if (isUndefined(animationInjector)) {
                            elements = this.__constructAnimatableElements(elements, { inject: noop }, elementNodes, animationInstances);
                            this._handlePreInitFunctionality(elements, elementNodes, functionality);
                            this._handlePostInitFunctionality(elements, elementNodes, functionality);
                            this._handleEndFunctionality(elements, elementNodes, functionality);
                            immediateResolve = this.resolve();
                            return { previous: immediateResolve, current: immediateResolve };
                        }
                    }
                    elements = this.__constructAnimatableElements(elements, animationInjector, elementNodes, animationInstances);
                    var length = elementNodes.length;
                    if (length === 0) {
                        this._handlePreInitFunctionality(elements, elementNodes, functionality);
                        this._handlePostInitFunctionality(elements, elementNodes, functionality);
                        this._handleEndFunctionality(elements, elementNodes, functionality);
                        immediateResolve = this.resolve();
                        return { previous: immediateResolve, current: immediateResolve };
                    }
                    this._handlePreInitFunctionality(elements, elementNodes, functionality);
                    var id = uniqueId('animation_'), previousAnimations = this.__setAnimationId(id, elementNodes), previousPromise, animationPromise = new AnimationPromise(function (resolve) {
                        var _Promise = _this._Promise;
                        previousPromise = _Promise.all(previousAnimations).then(function () {
                            var animationPromises = [];
                            for (var i = 0; i < length; ++i) {
                                animationPromises.push(animationInstances[i].instantiate(elementNodes[i], options));
                            }
                            _this._handlePostInitFunctionality(elements, elementNodes, functionality);
                            var animationsFinished = _Promise.all(animationPromises), animatingParentId = _this.__isParentAnimating(elementNodes), animatedElement = _this.__generateAnimatedElement(id, elementNodes, animationPromise);
                            if (!isNull(animatingParentId)) {
                                _this._handleEndFunctionality(elements, elementNodes, functionality);
                                animatedElement.animationEnd(true);
                                var parent_1 = _this._animatedElements[animatingParentId], resolvedPromise_1 = isPromise(parent_1.promise) ?
                                    function () {
                                        return parent_1.promise;
                                    } : function () {
                                    return animationPromise;
                                };
                                animationsFinished.then(function () {
                                    resolve(resolvedPromise_1);
                                });
                            }
                            _this.__stopChildAnimations(elementNodes);
                            animatedElement.promise = animationPromise;
                            animationsFinished.then(function () {
                                _this._handleEndFunctionality(elements, elementNodes, functionality);
                                animatedElement.animationEnd();
                                resolve(function () {
                                    return animationPromise;
                                });
                            });
                        });
                    });
                    animationPromise.initialize(animationInstances);
                    return { previous: previousPromise, current: animationPromise };
                };
                /**
                 * Handles different specialized functionalities immediately before the init portion of the animation cycle.
                 * @param {Array<Node>} nodes All the nodes being animated.
                 * @param {Array<Element>} elementNodes The animatable nodes being animated (only of type Node.ELEMENT_NODE).
                 * @param {plat.ui.animations.IAnimationFunction} functionality The specialized animation function attributes.
                 */
                Animator.prototype._handlePreInitFunctionality = function (nodes, elementNodes, functionality) {
                    switch (functionality.key) {
                        case 'move':
                            for (var i = 0; i < length; ++i) {
                                removeNode(nodes[i]);
                            }
                            break;
                        default:
                            break;
                    }
                };
                /**
                 * Handles different specialized functionalities immediately after the init portion of the animation cycle.
                 * @param {Array<Node>} nodes All the nodes being animated.
                 * @param {Array<Element>} elementNodes The animatable nodes being animated (only of type Node.ELEMENT_NODE).
                 * @param {plat.ui.animations.IAnimationFunction} functionality The specialized animation function attributes.
                 */
                Animator.prototype._handlePostInitFunctionality = function (nodes, elementNodes, functionality) {
                    var length, i;
                    switch (functionality.key) {
                        case 'enter':
                        case 'move':
                            var refChild = functionality.refChild, parent_2;
                            if (isNode(refChild)) {
                                parent_2 = refChild.parentNode;
                            }
                            else {
                                parent_2 = functionality.parent;
                                refChild = null;
                            }
                            if (!isNode(parent_2)) {
                                break;
                            }
                            length = nodes.length;
                            for (i = 0; i < length; ++i) {
                                parent_2.insertBefore(nodes[i], refChild);
                            }
                            break;
                        case 'show':
                            length = elementNodes.length;
                            for (i = 0; i < length; ++i) {
                                elementNodes[i].removeAttribute(__Hide);
                            }
                            break;
                        default:
                            break;
                    }
                };
                /**
                 * Handles different specialized functionalities at the end portion of the animation cycle.
                 * @param {Array<Node>} nodes All the nodes being animated.
                 * @param {Array<Element>} elementNodes The animatable nodes being animated (only of type Node.ELEMENT_NODE).
                 * @param {plat.ui.animations.IAnimationFunction} functionality The specialized animation function attributes.
                 */
                Animator.prototype._handleEndFunctionality = function (nodes, elementNodes, functionality) {
                    var length, i;
                    switch (functionality.key) {
                        case 'leave':
                            length = nodes.length;
                            for (i = 0; i < length; ++i) {
                                removeNode(nodes[i]);
                            }
                            break;
                        case 'hide':
                            length = elementNodes.length;
                            for (i = 0; i < length; ++i) {
                                elementNodes[i].setAttribute(__Hide, '');
                            }
                            break;
                        default:
                            break;
                    }
                };
                /**
                 * Sets a new, unique animation ID and denotes the elements as currently being animated.
                 * @param {string} id The animation ID.
                 * @param {Array<Element>} elements The Array of Elements being animated.
                 */
                Animator.prototype.__setAnimationId = function (id, elements) {
                    var animatedElements = this._animatedElements, animatedElement, _plat, promises = [], length = elements.length, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        _plat = element.__plat;
                        if (isUndefined(_plat)) {
                            element.__plat = { animation: id };
                            addClass(element, __Animating);
                        }
                        else if (isUndefined(_plat.animation)) {
                            _plat.animation = id;
                            addClass(element, __Animating);
                        }
                        else {
                            animatedElement = animatedElements[_plat.animation];
                            if (!isUndefined(animatedElement)) {
                                promises.push(animatedElement.promise);
                                animatedElement.animationEnd(true);
                            }
                            _plat.animation = id;
                        }
                    }
                    return promises;
                };
                /**
                 * Generates a new animated element for the Animator to easily reference and be able
                 * to end later on.
                 * @param {string} id The animation ID.
                 * @param {Array<Element>} elements The Array of Elements being animated.
                 * @param {plat.ui.animations.AnimationPromise} animationPromise The animation's associated promise.
                 */
                Animator.prototype.__generateAnimatedElement = function (id, elements, animationPromise) {
                    var animatedElements = this._animatedElements, removeListener = function (cancel) {
                        var _plat, element, length = elements.length, animationId;
                        if (cancel === true) {
                            animationPromise.cancel();
                            deleteProperty(animatedElements, id);
                            return;
                        }
                        for (var i = 0; i < length; ++i) {
                            element = elements[i];
                            _plat = element.__plat || {};
                            animationId = _plat.animation;
                            if (isUndefined(animationId) || animationId !== id) {
                                continue;
                            }
                            removeClass(element, __Animating);
                            deleteProperty(_plat, 'animation');
                            if (isEmpty(_plat)) {
                                deleteProperty(element, '__plat');
                            }
                        }
                        deleteProperty(animatedElements, id);
                    };
                    return animatedElements[id] = {
                        animationEnd: removeListener
                    };
                };
                /**
                 * Checks whether or not any parent elements are animating.
                 * @param {Array<Element>} elements The Elements whose parents we need to check.
                 */
                Animator.prototype.__isParentAnimating = function (elements) {
                    var animationId, element = elements[0];
                    while (!(isDocument(element = element.parentNode) || isNull(element) || element.nodeType !== Node.ELEMENT_NODE)) {
                        if (hasClass(element, __Animating)) {
                            var _plat = element.__plat;
                            animationId = (_plat || {}).animation;
                            if (isString(animationId)) {
                                if (!isNull(this._animatedElements[animationId])) {
                                    return animationId;
                                }
                                deleteProperty(_plat, 'animation');
                                if (isEmpty(_plat)) {
                                    deleteProperty(element, '__plat');
                                }
                                removeClass(element, __Animating);
                            }
                        }
                    }
                };
                /**
                 * Forces child nodes of an animating element to stop animating.
                 * @param {Element} element The element being animated.
                 */
                Animator.prototype.__stopChildAnimations = function (elements) {
                    var animatingElements = this._animatedElements, slice = Array.prototype.slice, customAnimationElements, animatedElement, _plat, id;
                    for (var i = 0; i < elements.length; ++i) {
                        customAnimationElements = slice.call(elements[i].querySelectorAll('.' + __Animating));
                        while (customAnimationElements.length > 0) {
                            _plat = customAnimationElements.pop().__plat || {};
                            id = _plat.animation;
                            if (isNull(id)) {
                                continue;
                            }
                            animatedElement = animatingElements[id] || {};
                            if (isFunction(animatedElement.animationEnd)) {
                                animatedElement.animationEnd(true);
                            }
                        }
                    }
                };
                /**
                 * Sifts through an Array of Nodes and finds all animatable Elements and creates
                 * BaseAnimations for them.
                 * @param {any} elements The Array of Nodes, DocumentFragment, or element to sift through.
                 * @param {plat.dependency.Injector<plat.ui.animations.BaseAnimation>} animationInjector The injector to instantiate
                 * BaseAnimations.
                 * @param {Array<Element>} elementNodes The Array of only animatable elements.
                 * @param {Array<plat.ui.animations.BaseAnimation>>} animationInstances An empty Array of animation instances to add to.
                 */
                Animator.prototype.__constructAnimatableElements = function (elements, animationInjector, elementNodes, animationInstances) {
                    if (!isArray(elements)) {
                        if (isDocumentFragment(elements)) {
                            elements = Array.prototype.slice.call(elements.childNodes);
                        }
                        else if (isArrayLike(elements)) {
                            elements = Array.prototype.slice.call(elements);
                        }
                        else if (!(isNode(elements) && elements.nodeType === Node.ELEMENT_NODE)) {
                            return [];
                        }
                        else {
                            elements = [elements];
                        }
                    }
                    var length = elements.length, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        if (isNode(element) && element.nodeType === Node.ELEMENT_NODE) {
                            elementNodes.push(element);
                            animationInstances.push(animationInjector.inject());
                        }
                    }
                    return elements;
                };
                Animator._inject = {
                    _compat: __Compat,
                    _Promise: __Promise,
                    _document: __Document
                };
                return Animator;
            }());
            animations.Animator = Animator;
            register.injectable(__Animator, Animator);
            /**
             * Describes a type of Promise that can be optionally cancelled.
             * Further, in the case where it may have a parent that is animating (which will cause it to immediately cancel and fulfill
             * itself, it resolves with a IGetAnimatingThenable for acccessing
             * the IAnimationThenable of the animating parent element.
             */
            var AnimationPromise = (function (_super) {
                __extends(AnimationPromise, _super);
                function AnimationPromise(resolveFunction, promise) {
                    _super.call(this, resolveFunction);
                    /**
                     * Reference to the IPromise injectable.
                     */
                    this._Promise = acquire(__Promise);
                    /**
                     * The state of the animation. 0 prior to start, 1 if started, and
                     * 2 if canceled.
                     */
                    this.__animationState = 0;
                    /**
                     * An Array of animation instances linked to this promise.
                     */
                    this.__animationInstances = [];
                    if (!isNull(promise)) {
                        this.__animationInstances = promise.__animationInstances;
                        this.__animationState = promise.__animationState;
                    }
                }
                AnimationPromise.prototype.initialize = function (instances) {
                    if (isEmpty(this.__animationInstances)) {
                        if (isArray(instances)) {
                            this.__animationInstances = instances;
                        }
                        else if (isObject(instances)) {
                            this.__animationInstances = [instances];
                        }
                    }
                };
                /**
                 * Gets the associated animation instances or animated promises.
                 */
                AnimationPromise.prototype.getInstances = function () {
                    return this.__animationInstances;
                };
                /**
                 * Fires the start method on the animation instances to kickoff the animations.
                 */
                AnimationPromise.prototype.start = function () {
                    if (this.__animationState > 0) {
                        return;
                    }
                    var animationInstances = this.__animationInstances, animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.start)) {
                            animationInstance.start();
                        }
                    }
                    this.__animationState = 1;
                };
                /**
                 * Fires the pause method on the animation instance.
                 */
                AnimationPromise.prototype.pause = function () {
                    if (this.__animationState !== 1) {
                        return this._Promise.resolve();
                    }
                    var animationInstances = this.__animationInstances, pausePromises = [], animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.pause)) {
                            pausePromises.push(animationInstance.pause());
                        }
                    }
                    return this._Promise.all(pausePromises).then(noop);
                };
                /**
                 * Fires the resume method on the animation instance.
                 */
                AnimationPromise.prototype.resume = function () {
                    if (this.__animationState !== 1) {
                        return this._Promise.resolve();
                    }
                    var animationInstances = this.__animationInstances, resumePromises = [], animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.resume)) {
                            resumePromises.push(animationInstance.resume());
                        }
                    }
                    return this._Promise.all(resumePromises).then(noop);
                };
                /**
                 * A method to cancel the associated animation.
                 */
                AnimationPromise.prototype.cancel = function () {
                    if (this.__animationState === 2) {
                        return this;
                    }
                    var animationInstances = this.__animationInstances, animationInstance, length = animationInstances.length;
                    for (var i = 0; i < length; ++i) {
                        animationInstance = animationInstances[i];
                        if (isFunction(animationInstance.cancel)) {
                            animationInstance.cancel();
                        }
                        if (isFunction(animationInstance.end)) {
                            animationInstance.end();
                        }
                    }
                    this.__animationState = 2;
                    return this;
                };
                /**
                 * A method to determine whether or not this promise has been canceled.
                 */
                AnimationPromise.prototype.isCanceled = function () {
                    return this.__animationState === 2;
                };
                AnimationPromise.prototype.then = function (onFulfilled) {
                    return _super.prototype.then.call(this, onFulfilled);
                };
                AnimationPromise.prototype.catch = function (onRejected) {
                    return _super.prototype.catch.call(this, onRejected);
                };
                return AnimationPromise;
            }(async.Promise));
            animations.AnimationPromise = AnimationPromise;
            /**
             * A class representing a single animation for a single element.
             */
            var BaseAnimation = (function () {
                function BaseAnimation() {
                    /**
                     * An Array of remove functions to dispose of event listeners.
                     */
                    this.__eventListeners = [];
                }
                /**
                 * A function for initializing the animation or any of its properties before start.
                 */
                BaseAnimation.prototype.initialize = function () { };
                /**
                 * A function denoting the start of the animation.
                 */
                BaseAnimation.prototype.start = function () { };
                /**
                 * A function to be called when the animation is over.
                 */
                BaseAnimation.prototype.end = function () {
                    var eventListeners = this.__eventListeners;
                    while (eventListeners.length > 0) {
                        eventListeners.pop()();
                    }
                    if (isFunction(this._resolve)) {
                        this._resolve();
                        this._resolve = null;
                    }
                };
                /**
                 * A function to be called to pause the animation.
                 */
                BaseAnimation.prototype.pause = function () {
                    return this._Promise.resolve();
                };
                /**
                 * A function to be called to resume a paused animation.
                 */
                BaseAnimation.prototype.resume = function () {
                    return this._Promise.resolve();
                };
                /**
                 * A function to be called to let it be known the animation is being cancelled. Although not
                 * necessary, we call end() in this function as well for safe measure.
                 */
                BaseAnimation.prototype.cancel = function () {
                    this.end();
                };
                /**
                 * Adds an event listener of the specified type to this animation's element. Removal of the
                 * event is handled automatically upon animation end.
                 * @param {string} type The type of event to listen to.
                 * @param {EventListener} listener The listener to fire when the event occurs.
                 * @param {boolean} useCapture? Whether to fire the event on the capture or the bubble phase
                 * of event propagation.
                 */
                BaseAnimation.prototype.addEventListener = function (type, listener, useCapture) {
                    if (!isFunction(listener)) {
                        this._log.warn('An animation\'s "addEventListener" must take a function as the second argument.');
                        return noop;
                    }
                    listener = listener.bind(this);
                    var removeListener = this.dom.addEventListener(this.element, type, function (ev) {
                        ev.stopPropagation();
                        listener(ev);
                    }, useCapture), eventListeners = this.__eventListeners;
                    eventListeners.push(removeListener);
                    return function () {
                        removeListener();
                        var index = eventListeners.indexOf(removeListener);
                        if (index !== -1) {
                            eventListeners.splice(index, 1);
                        }
                    };
                };
                /**
                 * Initializes the element and key properties of this animation and grabs a
                 * reference to its resolve function.
                 * @param {Element} element The element on which the animation will occur.
                 * @param {any} options Specified options for the animation.
                 */
                BaseAnimation.prototype.instantiate = function (element, options) {
                    var _this = this;
                    this.element = element;
                    this.options = options;
                    var promise = new AnimationPromise(function (resolve) {
                        _this._resolve = resolve;
                        _this.initialize();
                    });
                    promise.initialize(this);
                    return promise;
                };
                BaseAnimation._inject = {
                    _window: __Window,
                    _compat: __Compat,
                    _log: __Log,
                    _Promise: __Promise,
                    dom: __Dom,
                    utils: __Utils
                };
                return BaseAnimation;
            }());
            animations.BaseAnimation = BaseAnimation;
            /**
             * A class representing a single CSS animation for a single element.
             */
            var CssAnimation = (function (_super) {
                __extends(CssAnimation, _super);
                function CssAnimation() {
                    _super.apply(this, arguments);
                    /**
                     * A set of browser compatible CSS animation events capable of being listened to.
                     */
                    this._animationEvents = this._compat.animationEvents;
                }
                /**
                 * A function to listen to the start of an animation event.
                 * @param {() => void} listener The function to call when the animation begins.
                 */
                CssAnimation.prototype.animationStart = function (listener) {
                    return this.addEventListener(this._animationEvents.$animationStart, listener, false);
                };
                /**
                 * A function to listen to the end of an animation event.
                 * @param {(ev?: AnimationEvent) => void} listener The function to call when the animation ends.
                 */
                CssAnimation.prototype.animationEnd = function (listener) {
                    return this.addEventListener(this._animationEvents.$animationEnd, listener, false);
                };
                /**
                 * A function to listen to the completion of an animation iteration.
                 * @param {(ev?: AnimationEvent) => void} listener The function to call when the animation iteration completes.
                 */
                CssAnimation.prototype.animationIteration = function (listener) {
                    return this.addEventListener(this._animationEvents.$animationIteration, listener, false);
                };
                /**
                 * A function to listen to the start of a transition event.
                 * @param {(ev?: TransitionEvent) => void} listener The function to call when the transition begins.
                 */
                CssAnimation.prototype.transitionStart = function (listener) {
                    return this.addEventListener(this._animationEvents.$transitionStart, listener, false);
                };
                /**
                 * A function to listen to the end of a transition event.
                 * @param {(ev?: TransitionEvent) => void} listener The function to call when the transition ends.
                 */
                CssAnimation.prototype.transitionEnd = function (listener) {
                    return this.addEventListener(this._animationEvents.$transitionEnd, listener, false);
                };
                return CssAnimation;
            }(BaseAnimation));
            animations.CssAnimation = CssAnimation;
            /**
             * A simple CSS Animation class that places the 'plat-animation' class on an
             * element, checks for animation properties, and waits for the animation to end.
             */
            var SimpleCssAnimation = (function (_super) {
                __extends(SimpleCssAnimation, _super);
                function SimpleCssAnimation() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the animated element.
                     */
                    this.className = __SimpleAnimation;
                    /**
                     * A function for stopping a potential callback in the animation chain.
                     */
                    this._cancelAnimation = noop;
                }
                /**
                 * Adds the class to initialize the animation.
                 */
                SimpleCssAnimation.prototype.initialize = function () {
                    addClass(this.element, this.className + __INIT_SUFFIX);
                };
                /**
                 * A function denoting the start of the animation.
                 */
                SimpleCssAnimation.prototype.start = function () {
                    var _this = this;
                    this._cancelAnimation = requestAnimationFrameGlobal(function () {
                        var element = _this.element, className = _this.className;
                        if (element.offsetParent === null) {
                            _this._dispose();
                            _this.end();
                            return;
                        }
                        addClass(element, className);
                        var animationId = _this._animationEvents.$animation, options = _this.options || {}, computedStyle = _this._window.getComputedStyle(element, options.pseudo), animationName = computedStyle[(animationId + 'Name')];
                        if (animationName === '' || animationName === 'none' ||
                            computedStyle[(animationId + 'PlayState')] === 'paused') {
                            _this._dispose();
                            _this.end();
                            return;
                        }
                        if (!options.preserveInit) {
                            removeClass(element, className + __INIT_SUFFIX);
                        }
                        _this._cancelAnimation = _this.animationEnd(function () {
                            _this._cancelAnimation = requestAnimationFrameGlobal(function () {
                                _this._dispose();
                                _this.end();
                            });
                        });
                    });
                };
                /**
                 * A function to be called to pause the animation.
                 */
                SimpleCssAnimation.prototype.pause = function () {
                    var _this = this;
                    if (this._cancelAnimation === noop) {
                        return this._Promise.resolve();
                    }
                    var animationEvents = this._compat.animationEvents;
                    return new this._Promise(function (resolve) {
                        requestAnimationFrameGlobal(function () {
                            if (_this._cancelAnimation !== noop) {
                                _this.element.style[(animationEvents.$animation + 'PlayState')] = 'paused';
                            }
                            resolve();
                        });
                    });
                };
                /**
                 * A function to be called to resume a paused animation.
                 */
                SimpleCssAnimation.prototype.resume = function () {
                    var _this = this;
                    if (this._cancelAnimation === noop) {
                        return this._Promise.resolve();
                    }
                    var animationEvents = this._compat.animationEvents;
                    return new this._Promise(function (resolve) {
                        requestAnimationFrameGlobal(function () {
                            if (_this._cancelAnimation !== noop) {
                                _this.element.style[(animationEvents.$animation + 'PlayState')] = 'running';
                            }
                            resolve();
                        });
                    });
                };
                /**
                 * A function to be called to let it be known the animation is being cancelled.
                 * Removes the animation class and the animation "-init" class.
                 */
                SimpleCssAnimation.prototype.cancel = function () {
                    this._cancelAnimation();
                    this._dispose();
                    this.end();
                };
                /**
                 * Removes the animation class and the animation "-init" class.
                 */
                SimpleCssAnimation.prototype._dispose = function () {
                    var className = this.className;
                    removeClass(this.element, className + ' ' + className + __INIT_SUFFIX);
                    this._cancelAnimation = noop;
                };
                return SimpleCssAnimation;
            }(CssAnimation));
            animations.SimpleCssAnimation = SimpleCssAnimation;
            register.animation(__SimpleAnimation, SimpleCssAnimation);
            /**
             * An animation control that fades in an element as defined by the included CSS.
             */
            var FadeIn = (function (_super) {
                __extends(FadeIn, _super);
                function FadeIn() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the element fading in.
                     */
                    this.className = __FadeIn;
                }
                return FadeIn;
            }(SimpleCssAnimation));
            animations.FadeIn = FadeIn;
            register.animation(__FadeIn, FadeIn);
            /**
             * An animation control that fades out an element as defined by the included CSS.
             */
            var FadeOut = (function (_super) {
                __extends(FadeOut, _super);
                function FadeOut() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the element fading out.
                     */
                    this.className = __FadeOut;
                }
                return FadeOut;
            }(SimpleCssAnimation));
            animations.FadeOut = FadeOut;
            register.animation(__FadeOut, FadeOut);
            /**
             * An animation control that causes an element to enter as defined by the included CSS.
             */
            var Enter = (function (_super) {
                __extends(Enter, _super);
                function Enter() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the entering element.
                     */
                    this.className = __Enter;
                }
                return Enter;
            }(SimpleCssAnimation));
            animations.Enter = Enter;
            register.animation(__Enter, Enter);
            /**
             * An animation control that causes an element to leave as defined by the included CSS.
             */
            var Leave = (function (_super) {
                __extends(Leave, _super);
                function Leave() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the leaving element.
                     */
                    this.className = __Leave;
                }
                return Leave;
            }(SimpleCssAnimation));
            animations.Leave = Leave;
            register.animation(__Leave, Leave);
            /**
             * An animation control that causes an element to move as defined by the included CSS.
             */
            var Move = (function (_super) {
                __extends(Move, _super);
                function Move() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the leaving element.
                     */
                    this.className = __Move;
                }
                return Move;
            }(SimpleCssAnimation));
            animations.Move = Move;
            register.animation(__Move, Move);
            /**
             * A simple CSS Animation class that places the 'plat-transition' class on an
             * element, checks for transition properties, and waits for the transition to end.
             */
            var SimpleCssTransition = (function (_super) {
                __extends(SimpleCssTransition, _super);
                function SimpleCssTransition() {
                    _super.apply(this, arguments);
                    /**
                     * The class name added to the animated element.
                     */
                    this.className = __SimpleTransition;
                    /**
                     * A function for stopping a potential callback in the animation chain.
                     */
                    this._animationCanceled = noop;
                    /**
                     * A regular expression to normalize modified property keys.
                     */
                    this._normalizeRegex = /-/g;
                    /**
                     * A regular expression grab everything that is not a number.
                     */
                    this._nonNumRegex = /[^\-0-9\.]/g;
                    /**
                     * An Object whose keys are the normalized keys of modified properties.
                     */
                    this._normalizedKeys = {};
                    /**
                     * The "transitionend" event handler call count.
                     */
                    this._transitionCount = 0;
                    /**
                     * The user defined "transitionend" event handler call count.
                     */
                    this._count = 0;
                    /**
                     * Denotes whether or not the transition was ever started.
                     */
                    this._started = false;
                    /**
                     * Denotes whether or not the transition changes are being performed
                     * with CSS or with JS through this.options.
                     */
                    this._usingCss = false;
                }
                /**
                 * Adds the class to enable the transition.
                 */
                SimpleCssTransition.prototype.initialize = function () {
                    addClass(this.element, this.className + __INIT_SUFFIX);
                };
                /**
                 * A function denoting the start of the animation.
                 */
                SimpleCssTransition.prototype.start = function () {
                    var _this = this;
                    this._animationCanceled = requestAnimationFrameGlobal(function () {
                        var element = _this.element, className = _this.className;
                        if (element.offsetParent === null) {
                            _this._animate();
                            _this._dispose();
                            _this.end();
                        }
                        addClass(element, className);
                        _this._started = true;
                        var utils = _this.utils, transitionId = _this._animationEvents.$transition, options = _this.options || {}, computedStyle = _this._window.getComputedStyle(element, options.pseudo), properties = _this._properties = computedStyle[(transitionId + 'Property')].split(','), durations = computedStyle[(transitionId + 'Duration')].split(','), length = properties.length, propLength = length, noTransition = false, prop;
                        while (length-- > 0) {
                            prop = properties[length];
                            if (prop === '' || prop === 'none') {
                                properties.splice(length, 1);
                            }
                            else if (propLength > 1 && prop === 'all') {
                                // most likely developer error (extra comma at end of shorthand multi transition declaration) 
                                // so we will splice 
                                _this._log.debug("Improper transition declaration on class \"" + element.className + "\"");
                                properties.splice(length, 1);
                            }
                        }
                        if (properties.length === 0) {
                            noTransition = true;
                        }
                        else {
                            length = durations.length;
                            while (length-- > 0) {
                                prop = durations[length];
                                if (!(prop === '' || prop === '0s')) {
                                    break;
                                }
                            }
                            if (length < 0) {
                                noTransition = true;
                            }
                        }
                        if (noTransition) {
                            _this._animate();
                            _this._dispose();
                            _this.end();
                            return;
                        }
                        if (utils.isNumber(options.count) && options.count > 0) {
                            _this._count = options.count;
                        }
                        if (options.preserveInit === false) {
                            removeClass(element, className + __INIT_SUFFIX);
                        }
                        _this._animationCanceled = _this.transitionEnd(_this._done);
                        if (_this._animate()) {
                            return;
                        }
                        else if (utils.isEmpty(options.properties)) {
                            _this.__cssTransition(computedStyle, durations);
                            return;
                        }
                        _this._dispose();
                        _this.end();
                    });
                };
                /**
                 * A function to be called to let it be known the animation is being cancelled.
                 */
                SimpleCssTransition.prototype.cancel = function () {
                    this._animationCanceled();
                    if (!this._started) {
                        this._animate();
                    }
                    this._dispose();
                    this.end();
                };
                /**
                 * Removes the animation class and the animation "-init" class.
                 */
                SimpleCssTransition.prototype._dispose = function () {
                    var className = this.className;
                    removeClass(this.element, className + ' ' + className + __INIT_SUFFIX);
                    this._animationCanceled = noop;
                };
                /**
                 * A handler for the "transitionend" event. Will clean up the class and resolve the
                 * promise when necessary based on the options that were input.
                 * @param {TransitionEvent} ev? The transition event object.
                 * @param {boolean} immediate? Whether clean up should be immediate or conditional.
                 */
                SimpleCssTransition.prototype._done = function (ev) {
                    var propertyName = ev.propertyName;
                    if (isString(propertyName)) {
                        var count = ++this._transitionCount;
                        propertyName = propertyName.replace(this._normalizeRegex, '').toLowerCase();
                        if ((count < this._count) ||
                            (!this._usingCss && this._normalizedKeys[propertyName] === true &&
                                count < this._properties.length)) {
                            return;
                        }
                    }
                    this._dispose();
                    this.end();
                };
                /**
                 * Animate the element based on the options passed in.
                 */
                SimpleCssTransition.prototype._animate = function () {
                    var style = this.element.style || {}, properties = (this.options || {}).properties || {}, keys = Object.keys(properties), length = keys.length, key, normalizedKeys = this._normalizedKeys, normalizeRegex = this._normalizeRegex, currentProperty, newProperty, unchanged = 0;
                    while (keys.length > 0) {
                        key = keys.shift();
                        currentProperty = style[key];
                        newProperty = properties[key];
                        if (!isString(newProperty)) {
                            unchanged++;
                            continue;
                        }
                        style[key] = newProperty;
                        if (currentProperty === style[key]) {
                            unchanged++;
                        }
                        else {
                            normalizedKeys[key.replace(normalizeRegex, '').toLowerCase()] = true;
                        }
                    }
                    return unchanged < length;
                };
                /**
                 * Handles element transitions that are defined with CSS.
                 * @param {CSSStyleDeclaration} computedStyle The computed style of the
                 * element.
                 * @param {Array<string>} durations The array of declared transition duration values.
                 */
                SimpleCssTransition.prototype.__cssTransition = function (computedStyle, durations) {
                    var _this = this;
                    var transitionId = this._animationEvents.$transition, delays = computedStyle[(transitionId + 'Delay')].split(','), properties = this._properties, property, duration, delay, length = properties.length, computedProperty, normalizedKeys = this._normalizedKeys, normalizeRegex = this._normalizeRegex, i = 0, count = 0, changed = false, defer = this.utils.defer.bind(this, function (prop, computedProp) {
                        if (_this._animationCanceled === noop) {
                            // disposal has already occurred 
                            return;
                        }
                        else if (prop === 'all' || computedStyle[prop] !== computedProp) {
                            // we can't know if the transition started due to 'all' being set and have to rely on this.options.count 
                            // or 
                            // we know the transition started due to the properties being different 
                            changed = true;
                        }
                        if (++count < length || changed) {
                            return;
                        }
                        _this._dispose();
                        _this.end();
                    });
                    this._usingCss = true;
                    this._count = this._count || length;
                    for (; i < length; ++i) {
                        property = properties[i] = properties[i].trim();
                        duration = durations.length > i ? durations[i].trim() : durations[durations.length - 1].trim();
                        delay = delays.length > i ? delays[i].trim() : delays[delays.length - 1].trim();
                        normalizedKeys[property.replace(normalizeRegex, '').toLowerCase()] = true;
                        computedProperty = computedStyle[property];
                        defer(this._toMs(duration) + this._toMs(delay), [property, computedProperty]);
                    }
                };
                /**
                 * A function that converts a string value expressed as either seconds or milliseconds
                 * to a numerical millisecond value.
                 * @param {string} duration The transition duration specified by the computed style.
                 */
                SimpleCssTransition.prototype._toMs = function (duration) {
                    var regex = this._nonNumRegex, units = duration.match(regex)[0], time = Number(duration.replace(regex, ''));
                    if (!this.utils.isNumber(time)) {
                        return 0;
                    }
                    else if (units === 's') {
                        return time * 1000;
                    }
                    else if (units === 'ms') {
                        return time;
                    }
                    return 0;
                };
                return SimpleCssTransition;
            }(CssAnimation));
            animations.SimpleCssTransition = SimpleCssTransition;
            register.animation(__SimpleTransition, SimpleCssTransition);
        })(animations = ui.animations || (ui.animations = {}));
        /**
         * Holds classes and interfaces related to UI control components in platypus.
         */
        var controls;
        (function (controls_1) {
            /**
             * A control that facilitates routing between ViewControls. A Viewport is
             * the link between a ViewControl, a Navigator, and a Router.
             * It registers with a router and receives route change events. It then instantiates the proper viewcontrol and appends it
             * to the DOM.
             */
            var Viewport = (function (_super) {
                __extends(Viewport, _super);
                function Viewport() {
                    _super.apply(this, arguments);
                }
                /**
                 * Allows the viewport to initialize its navigator with the current
                 * router.
                 */
                Viewport.prototype.initialize = function () {
                    var router = this._router = this._Router.currentRouter(), parentViewport = this._getParentViewport(), parentRouter;
                    if (!(isNull(parentViewport) || isNull(parentViewport._router))) {
                        parentRouter = this._parentRouter = parentViewport._router;
                        parentRouter.addChild(router);
                    }
                    this._navigator.initialize(router);
                };
                /**
                 * The viewport registers itself with its router, notifying the
                 * router that it is ready to receive navigation events.
                 */
                Viewport.prototype.loaded = function () {
                    var _this = this;
                    if (isObject(this.options)) {
                        var animate = this.options.value.animate === true;
                        if (animate) {
                            this.dom.addClass(this.element, __Viewport + '-animate');
                        }
                        this._animate = animate;
                    }
                    this._Promise.resolve(this._router.finishNavigating).then(function () {
                        _this._router.register(_this);
                    });
                };
                /**
                 * The viewport's router has matched a route and is asking the viewport if it is safe to
                 * navigate. Here the viewport can instantiate the new view and ask it if it is safe to
                 * navigate to the view.
                 * @param {plat.routing.IRouteInfo} routeInfo Contains the information necessary to instantiate
                 * the view and feed it the route parameters/query.
                 */
                Viewport.prototype.canNavigateTo = function (routeInfo) {
                    var _this = this;
                    var getRouter = this._Router.currentRouter, currentRouter = getRouter(), response = true, injector = this._Injector.getDependency(routeInfo.delegate.view), view = injector.inject(), parameters = routeInfo.parameters, nextRouter = getRouter();
                    if (!isObject(view)) {
                        return this._Promise.resolve(null);
                    }
                    if (currentRouter !== nextRouter) {
                        nextRouter.initialize(this._router);
                        var navigator_1 = acquire(__NavigatorInstance);
                        view.navigator = navigator_1;
                        navigator_1.initialize(nextRouter);
                    }
                    else {
                        view.navigator = this._navigator;
                    }
                    if (isFunction(view.canNavigateTo)) {
                        response = view.canNavigateTo(parameters, routeInfo.query);
                    }
                    return this._Promise.resolve(response).then(function (canNavigateTo) {
                        _this._nextInjector = injector;
                        _this._nextView = view;
                        return canNavigateTo;
                    });
                };
                /**
                 * The viewport's router has matched a route and is asking the viewport if it is safe to
                 * navigate from the current state. Here the viewport can query the current ViewControl and
                 * ask it if it is safe to navigate from its current state.
                 */
                Viewport.prototype.canNavigateFrom = function () {
                    var view = this.controls[0], response = true;
                    if (isObject(view) && isFunction(view.canNavigateFrom)) {
                        response = view.canNavigateFrom();
                    }
                    return this._Promise.resolve(response);
                };
                /**
                 * The viewport's router has matched a route and determined that it is safe to navigate to the
                 * next view. The viewport will now go through the steps to compile and link the next view then append
                 * it to the DOM.
                 * @param {plat.routing.IRouteInfo} routeInfo Contains the information necessary to instantiate
                 * the view and feed it the route parameters/query.
                 */
                Viewport.prototype.navigateTo = function (routeInfo) {
                    var injector = this._nextInjector || this._Injector.getDependency(routeInfo.delegate.view), nodeMap = this._createNodeMap(injector), element = this.element, node = nodeMap.element, parameters = routeInfo.parameters, query = routeInfo.query, control = nodeMap.uiControlNode.control;
                    this._nextInjector = this._nextView = undefined;
                    if (this._animate) {
                        var animator = this._animator, dom_1 = this.dom;
                        if (this._navigator.isBackNavigation()) {
                            dom_1.addClass(node, __NavigatingBack);
                            animator.enter(node, __Enter, element).then(function () {
                                dom_1.removeClass(node, __NavigatingBack);
                            });
                        }
                        else {
                            animator.enter(node, __Enter, element);
                        }
                    }
                    else {
                        element.insertBefore(node, null);
                    }
                    var viewportManager = this._managerCache.read(this.uid), manager = this._ElementManagerFactory.getInstance();
                    viewportManager.children = [];
                    manager.initialize(nodeMap, viewportManager);
                    if (isFunction(control.navigatedTo)) {
                        control.navigatedTo(routeInfo.parameters, query);
                    }
                    manager.setUiControlTemplate();
                    if (control.hasOwnContext) {
                        return manager.observeRootContext(control, manager.fulfillAndLoad);
                    }
                    return manager.fulfillAndLoad();
                };
                /**
                 * The viewport's router has matched a route and determined that it is safe to navigate to the
                 * next view. It is now safe for the viewport to dispose of the current state.
                 */
                Viewport.prototype.navigateFrom = function () {
                    var _this = this;
                    var view = this.controls[0], promise, viewExists = isObject(view);
                    if (viewExists && isFunction(view.navigatingFrom)) {
                        promise = this._Promise.resolve(view.navigatingFrom());
                    }
                    else {
                        promise = this._Promise.resolve();
                    }
                    return promise.catch(function (error) {
                        if (isObject(error)) {
                            if (isString(error.message)) {
                                _this._log.debug(_this.type + ' error: ' + error.message);
                                return;
                            }
                            _this._log.debug(_this.type + ' error: ' + JSON.stringify(error));
                            return;
                        }
                        _this._log.debug(error);
                    }).then(function () {
                        if (!(_this._animate && viewExists)) {
                            Control.dispose(view);
                            return;
                        }
                        var oldElement = view.element;
                        if (_this._navigator.isBackNavigation()) {
                            _this.dom.addClass(oldElement, __NavigatingBack);
                        }
                        _this._animator.leave(oldElement, __Leave).then(function () {
                            Control.dispose(view);
                        });
                    });
                };
                /**
                 * The viewport is going out of scope, so it needs to unregister from its router in order to stop receiving routing
                 * events.
                 */
                Viewport.prototype.dispose = function () {
                    this._router.unregister(this);
                    this._navigator.dispose();
                };
                /**
                 * Creates an INodeMap for a ViewControl in order to compile it.
                 * @param {plat.dependency.Injector<plat.ui.ViewControl>} The injector used to instantiate the ViewControl.
                 */
                Viewport.prototype._createNodeMap = function (injector) {
                    var control = this._nextView || injector.inject(), doc = this._document, type = injector.name, replaceWith = control.replaceWith, node = (isEmpty(replaceWith) || replaceWith === 'any') ?
                        doc.createElement('div') : doc.createElement(replaceWith);
                    node.setAttribute(__Control, type);
                    node.className = __ViewControl;
                    return {
                        element: node,
                        attributes: {},
                        nodes: [],
                        uiControlNode: {
                            control: control,
                            nodeName: type,
                            expressions: [],
                            injector: injector
                        }
                    };
                };
                /**
                 * Finds the first Viewport in the parent chain. This is useful in order to properly initialize the viewport's
                 * router as a child of the parent viewport's router.
                 */
                Viewport.prototype._getParentViewport = function () {
                    var viewport = this.parent, type = this.type;
                    while (!isNull(viewport) && viewport.type !== type) {
                        viewport = viewport.parent;
                    }
                    return viewport;
                };
                Viewport._inject = {
                    _Router: __RouterStatic,
                    _Promise: __Promise,
                    _Injector: __InjectorStatic,
                    _ElementManagerFactory: __ElementManagerFactory,
                    _document: __Document,
                    _managerCache: __ManagerCache,
                    _animator: __Animator,
                    _navigator: __NavigatorInstance
                };
                return Viewport;
            }(TemplateControl));
            controls_1.Viewport = Viewport;
            register.control(__Viewport, Viewport);
            /**
             * A TemplateControl for easily reusing a
             * defined HTML template.
             */
            var Template = (function (_super) {
                __extends(Template, _super);
                /**
                 * The constructor for a Template. Creates the control cache.
                 */
                function Template() {
                    _super.call(this);
                    /**
                     * Removes the `<plat-template>` node from the DOM
                     */
                    this.replaceWith = null;
                    /**
                     * Whether or not this is the first instance of the control,
                     * specifying that it defines the template to copy.
                     */
                    this.__isFirst = false;
                    var _CacheFactory = acquire(__CacheFactory);
                    this.__templateControlCache = _CacheFactory.create(__TemplateControlCache);
                }
                /**
                 * Initializes the creation of the template.
                 */
                Template.prototype.initialize = function () {
                    var optionsObj = this.options || {}, options = optionsObj.value || {}, id = this._id = options.id;
                    if (isNull(id)) {
                        this._log.warn(this.type + ' instantiated without an id option');
                        return;
                    }
                    this._url = options.templateUrl;
                    var templatePromise = this.__templateControlCache.read(id);
                    if (!isNull(templatePromise)) {
                        this.__templatePromise = templatePromise;
                        return;
                    }
                    this.__isFirst = true;
                    this._initializeTemplate();
                };
                /**
                 * Decides if this is a template definition or
                 * a template instance.
                 */
                Template.prototype.loaded = function () {
                    if (!this.__isFirst) {
                        this._waitForTemplateControl(this.__templatePromise);
                    }
                };
                /**
                 * Removes the template from the template cache.
                 */
                Template.prototype.dispose = function () {
                    if (this.__isFirst) {
                        var cache = this.__templateControlCache;
                        cache.remove(this._id);
                        if (cache.info().size === 0) {
                            cache.dispose();
                        }
                    }
                };
                /**
                 * Determines whether a URL or innerHTML is being used,
                 * creates the bindable template, and stores the template
                 * in a template cache for later use.
                 */
                Template.prototype._initializeTemplate = function () {
                    var _this = this;
                    var id = this._id;
                    if (isNull(id)) {
                        return;
                    }
                    var parentNode = this.endNode.parentNode, url = this._url, template;
                    if (!isNull(url)) {
                        template = this._templateCache.read(url);
                        clearNodeBlock(this.elementNodes, parentNode);
                    }
                    else {
                        template = this._document.createDocumentFragment();
                        appendChildren(this.elementNodes, template);
                    }
                    var controlPromise;
                    if (isPromise(template)) {
                        controlPromise = template.catch(function (error) {
                            if (isNull(error)) {
                                return TemplateControl.determineTemplate(_this, url);
                            }
                        }).then(function (template) {
                            _this.bindableTemplates.add(id, template.cloneNode(true));
                            return _this;
                        });
                    }
                    else {
                        this.bindableTemplates.add(id, template.cloneNode(true));
                        controlPromise = this._Promise.resolve(this);
                    }
                    this.__templateControlCache.put(id, controlPromise);
                };
                /**
                 * Waits for the template promise to resolve, then initializes
                 * the binding of the bindable template and places it into the
                 * DOM.
                 * @param {plat.async.IThenable<plat.ui.controls.Template>} templatePromise The promise
                 * associated with the first instance of the control with this ID.
                 */
                Template.prototype._waitForTemplateControl = function (templatePromise) {
                    var _this = this;
                    if (!isPromise(templatePromise)) {
                        return;
                    }
                    templatePromise.then(function (templateControl) {
                        if (!(isNull(_this._url) || (_this._url === templateControl._url))) {
                            _this._log.warn('The specified url: ' + _this._url +
                                ' does not match the original ' + _this.type + ' with id: ' +
                                '"' + _this._id + '". The original url will be loaded.');
                        }
                        _this.__mapBindableTemplates(templateControl);
                        return _this.bindableTemplates.bind(_this._id);
                    }).then(function (clone) {
                        var endNode = _this.endNode;
                        insertBefore(endNode.parentNode, clone, endNode);
                    }).catch(function (error) {
                        postpone(function () {
                            _this._log.warn('Problem resolving ' + _this.type + ' url: ' +
                                error.response);
                        });
                    });
                };
                /**
                 * Maps the bindable templates cache and html templates of the first
                 * control with the proper ID to this control's bindable templates.
                 * @param {plat.ui.controls.Template} control The first of the controls
                 * with this corresponding ID that defined the HTML template to reuse.
                 */
                Template.prototype.__mapBindableTemplates = function (control) {
                    var bindableTemplates = this.bindableTemplates;
                    bindableTemplates.cache = control.bindableTemplates.cache;
                    bindableTemplates.templates = control.bindableTemplates.templates;
                };
                Template._inject = {
                    _Promise: __Promise,
                    _templateCache: __TemplateCache,
                    _document: __Document
                };
                return Template;
            }(TemplateControl));
            controls_1.Template = Template;
            register.control(__Template, Template);
            /**
             * A TemplateControl for inner HTML that contains controls
             * and/or markup and not having it bind or evaluate.
             */
            var Ignore = (function (_super) {
                __extends(Ignore, _super);
                function Ignore() {
                    _super.apply(this, arguments);
                }
                /**
                 * Removes the innerHTML from the DOM and saves it.
                 */
                Ignore.prototype.setTemplate = function () {
                    this.innerTemplate = appendChildren(this.element.childNodes);
                };
                /**
                 * Places the saved innerHTML back into the DOM.
                 */
                Ignore.prototype.loaded = function () {
                    this.element.appendChild(this.innerTemplate.cloneNode(true));
                };
                return Ignore;
            }(TemplateControl));
            controls_1.Ignore = Ignore;
            register.control(__Ignore, Ignore);
            /**
             * A TemplateControl for repeating a block of
             * DOM nodes bound to an array.
             */
            var ForEach = (function (_super) {
                __extends(ForEach, _super);
                /**
                 * The constructor for a ForEach. Creates the itemsLoaded promise.
                 */
                function ForEach() {
                    var _this = this;
                    _super.call(this);
                    /**
                     * The load priority of the control (needs to load before a Bind control).
                     */
                    this.priority = 120;
                    /**
                     * Used to hold the alias tokens for the built-in foreach aliases. You
                     * can overwrite these with the options for
                     * the ForEach control.
                     */
                    this._aliases = {
                        index: __forEachAliasOptions.index,
                        even: __forEachAliasOptions.even,
                        odd: __forEachAliasOptions.odd,
                        first: __forEachAliasOptions.first,
                        last: __forEachAliasOptions.last
                    };
                    /**
                     * The node length of each item's childNodes (innerHTML).
                     * For the ForEach it should be a
                     * single constant number.
                     */
                    this._blockLength = 0;
                    /**
                     * A queue representing all current add operations.
                     */
                    this._addQueue = [];
                    /**
                     * The number of items currently in the list or in the process of being added
                     * or removed from the list.
                     */
                    this._itemLength = 0;
                    /**
                     * Whether or not the Array listener has been set.
                     */
                    this.__listenerSet = false;
                    this.itemsLoaded = new this._Promise(function (resolve, reject) {
                        _this.__resolveFn = resolve;
                        _this.__rejectFn = reject;
                    }).catch(noop);
                }
                /**
                 * Creates a bindable template with the control element's childNodes (innerHTML).
                 */
                ForEach.prototype.setTemplate = function () {
                    this.bindableTemplates.add('item', this.element.childNodes);
                };
                /**
                 * Re-syncs the ForEach child controls and DOM with the new
                 * array.
                 * @param {Array<any>} newValue The new Array
                 * @param {Array<any>} oldValue The old Array
                 */
                ForEach.prototype.contextChanged = function (newValue, oldValue) {
                    if (isArray(newValue)) {
                        this._setListener();
                    }
                    else {
                        newValue = [];
                    }
                    this._executeEvent([{
                            object: newValue,
                            type: 'splice'
                        }]);
                };
                /**
                 * Observes the Array context for changes and adds initial items to the DOM.
                 */
                ForEach.prototype.loaded = function () {
                    var options = this.options, animating = this._animate = !isUndefined(options) && options.value.animate === true, context = this.context;
                    this._container = this.element;
                    if (animating) {
                        this._animationQueue = [];
                    }
                    this._setAliases();
                    if (!isArray(context)) {
                        return;
                    }
                    var addQueue = this._addQueue, itemCount = context.length;
                    var addPromise = this._addItems(0, itemCount, 0).then(function () {
                        var index = addQueue.indexOf(addPromise);
                        if (index !== -1) {
                            addQueue.splice(index, 1);
                        }
                    });
                    addQueue.push(addPromise);
                    this._setListener();
                };
                /**
                 * Removes any potentially held memory.
                 */
                ForEach.prototype.dispose = function () {
                    if (this.utils.isFunction(this.__rejectFn)) {
                        this.__rejectFn();
                        this.__resolveFn = this.__rejectFn = null;
                    }
                    this._animationQueue = this._addQueue = null;
                };
                /**
                 * Sets the alias tokens to use for all the items in the ForEach context Array.
                 */
                ForEach.prototype._setAliases = function () {
                    var options = this.options;
                    if (isUndefined(options)) {
                        return;
                    }
                    var aliases = options.value.aliases;
                    if (!isObject(aliases)) {
                        return;
                    }
                    var _aliases = this._aliases, keys = Object.keys(_aliases), length = keys.length, value;
                    for (var i = 0; i < length; ++i) {
                        value = aliases[keys[i]];
                        if (isString(value)) {
                            _aliases[keys[i]] = value;
                        }
                    }
                };
                /**
                 * Adds new items to the control's element when items are added to
                 * the array.
                 * @param {number} index The point in the array to start adding items.
                 * @param {number} numberOfItems The number of items to add.
                 * @param {number} animateItems The number of items to animate.
                 */
                ForEach.prototype._addItems = function (index, numberOfItems, animateItems) {
                    var _this = this;
                    var max = +(index + numberOfItems), promises = [], initialIndex = index;
                    this._itemLength += numberOfItems;
                    while (index < max) {
                        promises.push(this._bindItem(index++));
                    }
                    if (promises.length > 0) {
                        this.itemsLoaded = this._Promise.all(promises).then(function (templates) {
                            _this._setBlockLength(templates);
                            if (animateItems > 0) {
                                var length_10 = templates.length, container = _this._container;
                                for (var i = 0; i < length_10; ++i) {
                                    if (i < animateItems) {
                                        _this._appendAnimatedItem(templates[i]);
                                    }
                                    else {
                                        container.insertBefore(templates[i], null);
                                    }
                                }
                            }
                            else {
                                _this._appendItems(templates);
                            }
                            _this._updateResource(initialIndex - 1);
                            if (isFunction(_this.__resolveFn)) {
                                _this.__resolveFn();
                                _this.__resolveFn = _this.__rejectFn = null;
                            }
                        }).catch(function (error) {
                            postpone(function () {
                                if (isString(error)) {
                                    error = new Error(error);
                                }
                                _this._log.error(error);
                            });
                        });
                    }
                    return this.itemsLoaded;
                };
                /**
                 * Adds an Array of items to the element without animating.
                 * @param {Array<Node>} items The Array of items to add.
                 */
                ForEach.prototype._appendItems = function (items) {
                    appendChildren(items, this._container);
                };
                /**
                 * Adds an item to the control's element animating its elements.
                 * @param {DocumentFragment} item The HTML fragment representing a single item.
                 */
                ForEach.prototype._appendAnimatedItem = function (item) {
                    if (!isNode(item)) {
                        return;
                    }
                    var animationQueue = this._animationQueue, animation = {
                        animation: this._animator.enter(item, __Enter, this._container).then(function () {
                            var index = animationQueue.indexOf(animation);
                            if (index === -1) {
                                return;
                            }
                            animationQueue.splice(index, 1);
                        }),
                        op: null
                    };
                    animationQueue.push(animation);
                };
                /**
                 * Removes items from the control's element.
                 * @param {number} index The index to start disposing from.
                 * @param {number} numberOfItems The number of items to remove.
                 */
                ForEach.prototype._removeItems = function (index, numberOfItems) {
                    var dispose = TemplateControl.dispose, controls = this.controls, last = index + numberOfItems;
                    while (last-- > index) {
                        dispose(controls[last]);
                    }
                    this._updateResource(controls.length - 1);
                };
                /**
                 * Binds the item to a template at that index.
                 */
                ForEach.prototype._bindItem = function (index) {
                    return this.bindableTemplates.bind('item', index, this._getAliases(index));
                };
                /**
                 * Sets the corresponding block length for animation.
                 */
                ForEach.prototype._setBlockLength = function (templates) {
                    if (this._blockLength > 0 || templates.length === 0) {
                        return;
                    }
                    this._blockLength = templates[0].childNodes.length;
                };
                /**
                 * Updates a child resource object when
                 * the array changes.
                 * @param {number} index The control whose resources we will update.
                 */
                ForEach.prototype._updateResource = function (index) {
                    var controls = this.controls;
                    if (index < 0 || index >= controls.length) {
                        return;
                    }
                    controls[index].resources.add(this._getAliases(index));
                };
                /**
                 * Sets a listener for the changes to the array.
                 */
                ForEach.prototype._setListener = function () {
                    if (!this.__listenerSet) {
                        this.observeArray(this._executeEvent);
                        this.__listenerSet = true;
                    }
                };
                /**
                 * Receives an event when a method has been called on an array and maps the array
                 * method to its associated method handler.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._executeEvent = function (changes) {
                    var method = '_' + changes[0].type;
                    if (isFunction(this[method])) {
                        this[method](changes);
                    }
                };
                /**
                 * Returns a resource alias object for an item in the array. The
                 * resource object contains index:number, even:boolean, odd:boolean,
                 * first:boolean, and last:boolean.
                 * @param {number} index The index used to create the resource aliases.
                 */
                ForEach.prototype._getAliases = function (index) {
                    var isEven = (index & 1) === 0, aliases = {}, _aliases = this._aliases, type = __LITERAL_RESOURCE;
                    aliases[_aliases.index] = {
                        value: index,
                        type: type
                    };
                    aliases[_aliases.even] = {
                        value: isEven,
                        type: type
                    };
                    aliases[_aliases.odd] = {
                        value: !isEven,
                        type: type
                    };
                    aliases[_aliases.first] = {
                        value: index === 0,
                        type: type
                    };
                    aliases[_aliases.last] = {
                        value: index === (this.context.length - 1),
                        type: type
                    };
                    return aliases;
                };
                /**
                 * Handles items being pushed into the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._push = function (changes) {
                    var change = changes[0], addQueue = this._addQueue, itemCount = change.addedCount;
                    var addPromise = this._addItems(change.index, itemCount, this._animate ? itemCount : 0).then(function () {
                        var index = addQueue.indexOf(addPromise);
                        if (index !== -1) {
                            addQueue.splice(index, 1);
                        }
                    });
                    addQueue.push(addPromise);
                };
                /**
                 * Handles items being popped off the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._pop = function (changes) {
                    var _this = this;
                    var change = changes[0], start = change.object.length;
                    if (change.removed.length === 0) {
                        return;
                    }
                    var removeIndex = change.object.length;
                    if (this._itemLength > 0) {
                        this._itemLength--;
                    }
                    this._Promise.all(this._addQueue).then(function () {
                        if (_this._animate) {
                            _this._animateItems(start, 1, __Leave, 'leave', false).then(function () {
                                _this._removeItems(removeIndex, 1);
                            });
                            return;
                        }
                        _this._removeItems(removeIndex, 1);
                    });
                };
                /**
                 * Handles items being unshifted into the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._unshift = function (changes) {
                    var change = changes[0], addedCount = change.addedCount, addQueue = this._addQueue;
                    if (this._animate) {
                        var animationQueue = this._animationQueue, animationLength = animationQueue.length;
                        this._animateItems(0, addedCount, __Enter, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
                    }
                    var addPromise = this._addItems(change.object.length - addedCount, addedCount, 0).then(function () {
                        var index = addQueue.indexOf(addPromise);
                        if (index !== -1) {
                            addQueue.splice(index, 1);
                        }
                    });
                    addQueue.push(addPromise);
                };
                /**
                 * Handles items being shifted off the array.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._shift = function (changes) {
                    var _this = this;
                    var addQueue = this._addQueue, change = changes[0];
                    if (change.removed.length === 0) {
                        return;
                    }
                    else if (this._animate) {
                        if (addQueue.length === 0) {
                            addQueue = addQueue.concat([this._animateItems(0, 1, __Leave, 'clone', true)]);
                        }
                    }
                    var removeIndex = change.object.length;
                    if (this._itemLength > 0) {
                        this._itemLength--;
                    }
                    this._Promise.all(addQueue).then(function () {
                        _this._removeItems(removeIndex, 1);
                    });
                };
                /**
                 * Handles adding/removing items when an array is spliced.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                ForEach.prototype._splice = function (changes) {
                    var _this = this;
                    var change = changes[0], addCount = change.addedCount, addQueue = this._addQueue, currentLength = this._itemLength, addPromise, animating = this._animate;
                    if (isNull(addCount)) {
                        if (animating) {
                            this._cancelCurrentAnimations();
                        }
                        var newLength = change.object.length, itemCount_1 = currentLength - newLength;
                        if (newLength > currentLength) {
                            // itemCount will be negative 
                            addPromise = this._addItems(currentLength, -itemCount_1, 0).then(function () {
                                var index = addQueue.indexOf(addPromise);
                                if (index !== -1) {
                                    addQueue.splice(index, 1);
                                }
                            });
                            addQueue.push(addPromise);
                        }
                        else if (currentLength > newLength) {
                            if (currentLength >= itemCount_1) {
                                this._itemLength -= itemCount_1;
                            }
                            else {
                                this._itemLength = 0;
                            }
                            this._Promise.all(addQueue).then(function () {
                                _this._removeItems(currentLength - itemCount_1, itemCount_1);
                            });
                        }
                        return;
                    }
                    var removeCount = change.removed.length, animationQueue = this._animationQueue;
                    if (addCount > removeCount) {
                        var itemAddCount = addCount - removeCount, animationCount = void 0;
                        if (animating) {
                            animationCount = addCount;
                            var animationLength = animationQueue.length, startIndex = change.index;
                            if (currentLength < addCount - startIndex) {
                                animationCount = currentLength - startIndex;
                            }
                            this._animateItems(startIndex, animationCount, __Enter, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
                            animationCount = addCount - animationCount;
                        }
                        else {
                            animationCount = 0;
                        }
                        addPromise = this._addItems(change.object.length - itemAddCount, itemAddCount, animationCount).then(function () {
                            var index = addQueue.indexOf(addPromise);
                            if (index !== -1) {
                                addQueue.splice(index, 1);
                            }
                        });
                        addQueue.push(addPromise);
                    }
                    else if (removeCount > addCount) {
                        var adding_1 = addCount > 0;
                        if (animating && !adding_1 && addQueue.length === 0) {
                            addQueue = addQueue.concat([this._animateItems(change.index, removeCount, __Leave, 'clone', true)]);
                        }
                        var deleteCount_1 = removeCount - addCount;
                        if (currentLength >= deleteCount_1) {
                            this._itemLength -= deleteCount_1;
                        }
                        else {
                            this._itemLength = 0;
                        }
                        this._Promise.all(addQueue).then(function () {
                            if (animating && adding_1) {
                                var animLength = animationQueue.length;
                                _this._animateItems(change.index, addCount, __Enter, null, animLength > 0 && animationQueue[animLength - 1].op === 'clone');
                            }
                            _this._removeItems(currentLength - deleteCount_1, deleteCount_1);
                        });
                    }
                };
                /**
                 * Grabs the total blocklength of the specified items.
                 * @param {number} startIndex The starting index of items.
                 * @param {number} numberOfItems The number of consecutive items.
                 */
                ForEach.prototype._calculateBlockLength = function (startIndex, numberOfItems) {
                    return this._blockLength;
                };
                /**
                 * Animates the indicated items.
                 * @param {number} startIndex The starting index of items to animate.
                 * @param {number} numberOfItems The number of consecutive items to animate.
                 * @param {string} key The animation key/type.
                 * @param {string} animationOp Denotes animation operation.
                 * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
                 */
                ForEach.prototype._animateItems = function (startIndex, numberOfItems, key, animationOp, cancel) {
                    var blockLength = this._calculateBlockLength();
                    if (blockLength === 0) {
                        return this._Promise.resolve();
                    }
                    var start = startIndex * blockLength;
                    switch (animationOp) {
                        case 'clone':
                            return this._handleClonedContainerAnimation(start, numberOfItems * blockLength + start, key, cancel === true);
                        case 'leave':
                            return this._handleLeave(start, numberOfItems * blockLength + start, key);
                        default:
                            return this._handleSimpleAnimation(start, numberOfItems * blockLength + start, key, cancel === true);
                    }
                };
                /**
                 * Handles a simple animation of a block of elements.
                 * @param {number} startNode The starting childNode of the ForEach to animate.
                 * @param {number} endNode The ending childNode of the ForEach to animate.
                 * @param {string} key The animation key/type.
                 * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
                 */
                ForEach.prototype._handleSimpleAnimation = function (startNode, endNode, key, cancel) {
                    var container = this._container, nodes = Array.prototype.slice.call(container.childNodes, startNode, endNode);
                    if (nodes.length === 0) {
                        return this._Promise.resolve();
                    }
                    var animationQueue = this._animationQueue, animationCreation = this._animator.create(nodes, key), animationPromise = animationCreation.current.then(function () {
                        var index = animationQueue.indexOf(animation);
                        if (index === -1) {
                            return;
                        }
                        animationQueue.splice(index, 1);
                    }), callback = function () {
                        animationCreation.previous.then(function () {
                            animationPromise.start();
                        });
                        return animationPromise;
                    };
                    var animation = {
                        animation: animationPromise,
                        op: null
                    };
                    if (cancel && animationQueue.length > 0) {
                        var cancelPromise = this._cancelCurrentAnimations().then(callback);
                        animationQueue.push(animation);
                        return cancelPromise;
                    }
                    animationQueue.push(animation);
                    return callback();
                };
                /**
                 * Handles a simple animation of a block of elements.
                 * @param {number} startNode The starting childNode of the ForEach to animate.
                 * @param {number} endNode The ending childNode of the ForEach to animate.
                 * @param {string} key The animation key/type.
                 */
                ForEach.prototype._handleLeave = function (startNode, endNode, key) {
                    var container = this._container, nodes = Array.prototype.slice.call(container.childNodes, startNode, endNode);
                    if (nodes.length === 0) {
                        return this._Promise.resolve();
                    }
                    var animationQueue = this._animationQueue, animationPromise = this._animator.leave(nodes, key).then(function () {
                        var index = animationQueue.indexOf(animation);
                        if (index === -1) {
                            return;
                        }
                        animationQueue.splice(index, 1);
                    });
                    var animation = {
                        animation: animationPromise,
                        op: 'leave'
                    };
                    animationQueue.push(animation);
                    return animationPromise;
                };
                /**
                 * Handles a simple animation of a block of elements.
                 * @param {number} startNode The starting childNode of the ForEach to animate.
                 * @param {number} endNode The ending childNode of the ForEach to animate.
                 * @param {string} key The animation key/type.
                 * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
                 */
                ForEach.prototype._handleClonedContainerAnimation = function (startNode, endNode, key, cancel) {
                    var container = this._container, clonedContainer = container.cloneNode(true), nodes = Array.prototype.slice.call(clonedContainer.childNodes, startNode, endNode);
                    if (nodes.length === 0) {
                        return this._Promise.resolve();
                    }
                    var parentNode, animationQueue = this._animationQueue, animationCreation = this._animator.create(nodes, key), animationPromise = animationCreation.current.then(function () {
                        var index = animationQueue.indexOf(animation);
                        if (index > -1) {
                            animationQueue.splice(index, 1);
                        }
                        if (isNull(parentNode)) {
                            return;
                        }
                        parentNode.replaceChild(container, clonedContainer);
                    }), callback = function () {
                        parentNode = container.parentNode;
                        if (isNull(parentNode) || animationPromise.isCanceled()) {
                            return animationPromise;
                        }
                        parentNode.replaceChild(clonedContainer, container);
                        animationCreation.previous.then(function () {
                            animationPromise.start();
                        });
                        return animationPromise;
                    };
                    var animation = {
                        animation: animationPromise,
                        op: 'clone'
                    };
                    if (cancel && animationQueue.length > 0) {
                        var cancelPromise = this._cancelCurrentAnimations().then(callback);
                        animationQueue.push(animation);
                        return cancelPromise;
                    }
                    animationQueue.push(animation);
                    return callback();
                };
                /**
                 * Cancels all current animations.
                 */
                ForEach.prototype._cancelCurrentAnimations = function () {
                    var animationQueue = this._animationQueue, animations = [], length = animationQueue.length;
                    for (var i = 0; i < length; ++i) {
                        animations.push(animationQueue[i].animation.cancel());
                    }
                    return this._Promise.all(animations);
                };
                ForEach._inject = {
                    _animator: __Animator,
                    _Promise: __Promise
                };
                return ForEach;
            }(TemplateControl));
            controls_1.ForEach = ForEach;
            register.control(__ForEach, ForEach);
            /**
             * A special type of TemplateControl for managing meta tags, useful for SEO. This
             * control will not exist unless you register it as a control with the name 'head'. It is static, so you can inject
             * it into other components and get access to its properties.
             */
            var Head = (function (_super) {
                __extends(Head, _super);
                function Head() {
                    _super.apply(this, arguments);
                    /**
                     * Rather than be replaced by a 'div', this control wants to be a 'head' element.
                     */
                    this.replaceWith = __Head;
                    /**
                     * A reference to all the structured data elements added to the DOM for this page.
                     */
                    this._structuredDataElements = [];
                }
                /**
                 * Registers for the navigating event to know when to remove all the elements so they
                 * don't bleed onto the next page.
                 */
                Head.prototype.initialize = function () {
                    var _this = this;
                    this.on(__navigating, function () {
                        _this._removeAllElements();
                    });
                };
                /**
                 * Makes sure all the elements exist.
                 */
                Head.prototype.setTemplate = function () {
                    var meta = __Meta, title = __Title, link = __MetaLink, author = __Author, type = __MetaType, creator = __Creator, image = __MetaImage, video = __MetaVideo, description = __Description, url = __Url, og = __OpenGraph, article = __Article, twitter = __Twitter;
                    this._titleElement = this._createElement(title);
                    this._ogTitleElement = this._createElement(meta, og + title);
                    this._twitterTitleElement = this._createElement(meta, twitter + title);
                    this._descriptionElement = this._createElement(meta, description);
                    this._ogDescriptionElement = this._createElement(meta, og + description);
                    this._twitterDescriptionElement = this._createElement(meta, twitter + description);
                    this._ogUrlElement = this._createElement(meta, og + url);
                    this._twitterUrlElement = this._createElement(meta, twitter + url);
                    this._authorElement = this._createElement(meta, author);
                    this._googleAuthorElement = this._createElement(link, author);
                    this._fbAuthorElement = this._createElement(meta, article + author);
                    this._twitterCreatorElement = this._createElement(meta, twitter + creator);
                    this._ogTypeElement = this._createElement(meta, og + type);
                };
                /**
                 * Gets the title or sets the title elements.
                 * @param {string} title? If supplied, the title elements will be set to this value.
                 */
                Head.prototype.title = function (title) {
                    if (!isString(title)) {
                        return this._getContent(this._titleElement);
                    }
                    this._titleElement.innerText = title;
                    this._setContent([
                        this._ogTitleElement,
                        this._twitterTitleElement
                    ], title);
                    return title;
                };
                /**
                 * Gets the description or sets the description elements.
                 * @param {string} description? If supplied, the description elements will be set to this value.
                 */
                Head.prototype.description = function (description) {
                    if (!isString(description)) {
                        return this._getContent(this._descriptionElement);
                    }
                    this._setContent([
                        this._descriptionElement,
                        this._ogDescriptionElement,
                        this._twitterDescriptionElement
                    ], description);
                    return description;
                };
                /**
                 * Gets the url or sets the url elements.
                 * @param {string} url? If supplied, the url elements will be set to this value.
                 */
                Head.prototype.url = function (url) {
                    if (!isString(url)) {
                        return this._getContent(this._ogUrlElement);
                    }
                    this._setContent([
                        this._ogUrlElement,
                        this._twitterUrlElement
                    ], url);
                    return url;
                };
                /**
                 * Gets the author or sets the author elements.
                 * @param {string} author? If supplied, the author elements will be set to this value. The value should be the
                 * display name of the content author.
                 */
                Head.prototype.author = function (author) {
                    if (!isString(author)) {
                        return this._getContent(this._authorElement);
                    }
                    this._setContent([
                        this._authorElement,
                    ], author);
                    return author;
                };
                /**
                 * Gets the author or sets the author elements.
                 * @param {string} author? If supplied, the author elements will be set to this value. The value should be the
                 * Google+ profile url for the author.
                 */
                Head.prototype.googleAuthor = function (author) {
                    if (!isString(author)) {
                        return this._getContent(this._googleAuthorElement);
                    }
                    this._setContent([
                        this._googleAuthorElement,
                    ], author);
                    return author;
                };
                /**
                 * Gets the author or sets the author elements. This method is for use with the Facebook profile authors.
                 * @param {string} author? If supplied, the author elements will be set to this value. The value should be
                 * the `https://www.facebook.com/username` account, and make sure the user supports followers.
                 */
                Head.prototype.fbAuthor = function (author) {
                    if (!isString(author)) {
                        return this._getContent(this._fbAuthorElement);
                    }
                    this._setContent([
                        this._fbAuthorElement
                    ], author);
                    return author;
                };
                /**
                 * Gets the creator or sets the creator elements
                 * @param {string} creator? If supplied, the creator elements will be set to this value. The
                 * value should be the twitter `@username` of the creator
                 */
                Head.prototype.twitterCreator = function (creator) {
                    if (!isString(creator)) {
                        return this._getContent(this._twitterCreatorElement);
                    }
                    this._setContent([
                        this._twitterCreatorElement
                    ], creator);
                    return creator;
                };
                /**
                 * Gets the type or sets the type elements.
                 * @param {string} type? If supplied, the image elements will be set to this value.
                 */
                Head.prototype.fbType = function (type) {
                    if (!isString(type)) {
                        return this._getContent(this._ogTypeElement);
                    }
                    this._setContent([
                        this._ogTypeElement
                    ], type);
                    return type;
                };
                /**
                 * Sets the image elements.
                 * @param {Array<string>} images For each image, a tag will be created
                 */
                Head.prototype.images = function (images) {
                    var _this = this;
                    if (!isArray(images)) {
                        return;
                    }
                    var meta = __Meta, og = __OpenGraph, twitter = __Twitter, ogElement, twitterElement;
                    forEach(function (image) {
                        ogElement = _this._createElement(meta, og + __MetaImage, true);
                        twitterElement = _this._createElement(meta, twitter + __MetaImage, true);
                        image = _this._browser.urlUtils(image).href;
                        _this._setContent([
                            ogElement,
                            twitterElement
                        ], image);
                    }, images);
                };
                /**
                 * Sets the video elements.
                 * @param {Array<string>} videos For each video, a tag will be created
                 */
                Head.prototype.videos = function (videos) {
                    var _this = this;
                    if (!isArray(videos)) {
                        return;
                    }
                    var meta = __Meta, og = __OpenGraph, metaVideo = __MetaVideo, _browser = this._browser, ogElement;
                    forEach(function (video) {
                        ogElement = _this._createElement(meta, og + metaVideo, true);
                        video = _browser.urlUtils(video).href;
                        _this._setContent([
                            ogElement
                        ], video);
                    }, videos);
                };
                /**
                 * Adds a structured data ld+json element to the DOM.
                 * @param {any} The object, it will be stringified and put in the ld+json tag.
                 */
                Head.prototype.structuredData = function (obj) {
                    if (isEmpty(obj)) {
                        return;
                    }
                    var el = this._document.createElement('script'), sibling = this._titleElement.nextSibling;
                    el.setAttribute('type', 'application/ld+json');
                    el.textContent = JSON.stringify(obj);
                    this._structuredDataElements.push(el);
                    this.dom.insertBefore(this.element, el, sibling);
                };
                /**
                 * Takes in one or more BlogPosting <http://schema.org/BlogPosting> objects and sets them as ld+json tags in the head.
                 * @param {plat.ui.controls.IBlogPosting} The posting object, it will be stringified and put in the ld+json tag.
                 */
                Head.prototype.blogPostings = function () {
                    var postings = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        postings[_i - 0] = arguments[_i];
                    }
                    for (var i = 0, length_11 = postings.length; i < length_11; ++i) {
                        this.structuredData(postings[i]);
                    }
                };
                /**
                 * Sets the url elements initially.
                 */
                Head.prototype.loaded = function () {
                    this.url(this._browser.url());
                };
                /**
                 * Sets the url elements.
                 */
                Head.prototype.navigated = function (url) {
                    this.url(url);
                };
                /**
                 * Gets the innerText/content/href of an element.
                 * @param {HTMLElement} element The element from which to get the content.
                 */
                Head.prototype._getContent = function (element) {
                    var nodeName = element.nodeName.toLowerCase();
                    if (nodeName === __Title) {
                        return element.innerText;
                    }
                    else if (nodeName === __Meta) {
                        return element.getAttribute(__Content);
                    }
                    else if (nodeName === __MetaLink) {
                        return element.getAttribute(__MetaHref);
                    }
                };
                /**
                 * Sets the innerText/content/href of a list elements. If an element is not in the DOM, it
                 * is added to the dom right after the <title /> element.
                 * @param {Array<HTMLElement>} elements The elements for which to set values.
                 */
                Head.prototype._setContent = function (elements, value) {
                    var el = this.element, nodes = Array.prototype.slice.call(el.children), length = elements.length, content = __Content, href = __MetaHref, sibling = this._titleElement.nextSibling, dom = this.dom, nodeName, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        nodeName = element.nodeName.toLowerCase();
                        if (nodeName === __Meta) {
                            element.setAttribute(content, value);
                        }
                        else {
                            element.setAttribute(href, value);
                        }
                        if (nodes.indexOf(element) === -1) {
                            dom.insertBefore(el, element, sibling);
                        }
                    }
                };
                /**
                 * Creates an element with the specified tag and name. The name corresponds to
                 * the type of the meta/link tag (i.e. title/description/author etc), and is also the
                 * value that will be set for the proper attribute. The attribute is determined based on
                 * the tag/name combination.
                 * @param {string} tag The tag name for the element.
                 * @param {string} name? The name corresponding to the type of meta/link tag.
                 * @param {boolean} multiple? Whether or not there can be multiple of this tag/name in the dom
                 */
                Head.prototype._createElement = function (tag, name, multiple) {
                    var el, hasName = isString(name), attr = (hasName && (name.indexOf(__OpenGraph) === 0 || name.indexOf(__Article) === 0)) ? __MetaProperty : __MetaName, element = this.element;
                    if (tag === __MetaLink) {
                        attr = __Rel;
                    }
                    if (!multiple && hasName) {
                        el = element.querySelector(tag + '[' + attr + '="' + name + '"]');
                    }
                    else if (!multiple) {
                        el = element.querySelector(tag);
                    }
                    if (!isNode(el)) {
                        el = this._document.createElement(tag);
                    }
                    if (hasName) {
                        el.setAttribute(attr, name);
                    }
                    return el;
                };
                /**
                 * Removes all the unnecessary elements from the <head /> to avoid having
                 * incorrect tags on the page.
                 */
                Head.prototype._removeAllElements = function () {
                    var slice = Array.prototype.slice, og = this._document.head.querySelectorAll('meta[' + __MetaProperty + '^="' + __OpenGraph + '"]'), twitter = this._document.head.querySelectorAll('meta[' + __MetaName + '^="' + __Twitter + '"]');
                    this._removeElements.apply(this, [
                        this._descriptionElement,
                        this._authorElement,
                        this._googleAuthorElement
                    ].concat(slice.call(og), slice.call(twitter), slice.call(this._structuredDataElements)));
                    this._structuredDataElements = [];
                };
                /**
                 * Removes elements from the <head />
                 */
                Head.prototype._removeElements = function () {
                    var elements = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        elements[_i - 0] = arguments[_i];
                    }
                    var el = this.element, nodes = Array.prototype.slice.call(el.children), length = elements.length, element;
                    for (var i = 0; i < length; ++i) {
                        element = elements[i];
                        if (nodes.indexOf(element) !== -1) {
                            el.removeChild(element);
                        }
                    }
                };
                Head._inject = {
                    _document: __Document,
                    _browser: __Browser
                };
                return Head;
            }(ui.TemplateControl));
            controls_1.Head = Head;
            /**
             * A TemplateControl for adding HTML to the
             * DOM through bound context strings.
             */
            var InnerHtml = (function (_super) {
                __extends(InnerHtml, _super);
                function InnerHtml() {
                    _super.apply(this, arguments);
                }
                /**
                 * Clears the inner template if one exists.
                 */
                InnerHtml.prototype.setTemplate = function () {
                    this.dom.clearNode(this.element);
                };
                /**
                 * Checks options and initializes bindings.
                 */
                InnerHtml.prototype.loaded = function () {
                    var options = this.options;
                    if (!isObject(options)) {
                        return;
                    }
                    this._onOptionsChanged(options.value);
                    options.observe(this._onOptionsChanged);
                };
                /**
                 * The function called when any of the options for this control changes.
                 * @param {IInnerHtmlOptions} newValue The new value of the options property.
                 * @param {IInnerHtmlOptions} oldValue? The old value of the options property.
                 */
                InnerHtml.prototype._onOptionsChanged = function (newValue, oldValue) {
                    var _this = this;
                    if (newValue === oldValue) {
                        return;
                    }
                    else if (!isObject(newValue)) {
                        this._log.debug('plat-options for ' + this.type + ' must be an object.');
                        return;
                    }
                    var html = newValue.html;
                    if (html === this._html) {
                        return;
                    }
                    this._html = html;
                    var htmlIsString = isString(html);
                    if (isNull(html) || (htmlIsString && html.trim() === '')) {
                        if (this.controls.length > 0) {
                            this._TemplateControlFactory.dispose(this.controls[0]);
                        }
                        else {
                            this.dom.clearNode(this.element);
                        }
                        return;
                    }
                    else if (!htmlIsString) {
                        this._log.debug('Trying to bind a non-string value to ' + this.type + '.');
                        return;
                    }
                    else if (newValue.compile === true) {
                        var hasControl_1 = this.controls.length > 0;
                        this.bindableTemplates.once(html).then(function (template) {
                            if (hasControl_1) {
                                _this._TemplateControlFactory.dispose(_this.controls[0]);
                            }
                            else {
                                _this.dom.clearNode(_this.element);
                            }
                            _this.element.insertBefore(template, null);
                        });
                        return;
                    }
                    setInnerHtml(this.element, html);
                };
                InnerHtml._inject = {
                    _TemplateControlFactory: __TemplateControlFactory
                };
                return InnerHtml;
            }(TemplateControl));
            controls_1.InnerHtml = InnerHtml;
            register.control(__Html, InnerHtml);
            /**
             * A BindControl for binding an HTML select element
             * to an Array context.
             */
            var Select = (function (_super) {
                __extends(Select, _super);
                /**
                 * The constructor for a Select. Creates the itemsLoaded promise.
                 */
                function Select() {
                    var _this = this;
                    _super.call(this);
                    /**
                     * Replaces the `<plat-select>` node with
                     * a <select> node.
                     */
                    this.replaceWith = 'select';
                    /**
                     * The load priority of the control (needs to load before a Bind control).
                     */
                    this.priority = 120;
                    /**
                     * An object that keeps track of unique
                     * optgroups.
                     */
                    this.groups = {};
                    this.itemsLoaded = new this._Promise(function (resolve, reject) {
                        _this.__resolveFn = resolve;
                        _this.__rejectFn = reject;
                    }).catch(noop);
                }
                /**
                 * Creates the bindable option template and grouping
                 * template if necessary.
                 */
                Select.prototype.setTemplate = function () {
                    this.bindableTemplates.add('option', this.element.childNodes);
                    var options = this.options || {}, platOptions = options.value || {}, defaultOptionValues = platOptions.default;
                    if (isObject(defaultOptionValues)) {
                        var defaultOption = this._document.createElement('option'), defaultValue = defaultOptionValues.value, defaultTextContent = defaultOptionValues.textContent;
                        defaultOption.value = isUndefined(defaultValue) ? defaultTextContent : defaultValue;
                        defaultOption.textContent = isUndefined(defaultTextContent) ? defaultValue : defaultTextContent;
                        this.element.insertBefore(defaultOption, null);
                    }
                    if (!isNull(platOptions.group)) {
                        var group = this._group = platOptions.group, optionGroup = this._document.createElement('optgroup');
                        optionGroup.label = __startSymbol + group + __endSymbol;
                        this.bindableTemplates.add('group', optionGroup);
                        this._isGrouped = true;
                    }
                    else {
                        this._isGrouped = false;
                    }
                };
                /**
                 * Re-observes the new array context and modifies
                 * the options accordingly.
                 * @param {Array<any>} newValue The new array context.
                 * @param {Array<any>} oldValue The old array context.
                 */
                Select.prototype.contextChanged = function (newValue, oldValue) {
                    var _this = this;
                    if (isEmpty(newValue)) {
                        if (!isEmpty(oldValue)) {
                            this.itemsLoaded.then(function () {
                                _this._removeItems(_this.controls.length);
                            });
                        }
                        return;
                    }
                    else if (!isArray(newValue)) {
                        return;
                    }
                    var newLength = isArray(newValue) ? newValue.length : 0, oldLength = isArray(oldValue) ? oldValue.length : 0;
                    this._setListener();
                    if (newLength > oldLength) {
                        this._addItems(newLength - oldLength, oldLength);
                    }
                    else if (newLength < oldLength) {
                        this._removeItems(oldLength - newLength);
                    }
                };
                /**
                 * Observes the new array context and adds
                 * the options accordingly.
                 */
                Select.prototype.loaded = function () {
                    if (isUndefined(this._isGrouped)) {
                        var options = this.options || {}, platOptions = options.value || {};
                        this._isGrouped = !isNull((this._group = platOptions.group));
                    }
                    this._defaultOption = this.element.firstElementChild;
                    var context = this.context;
                    if (!isArray(context)) {
                        return;
                    }
                    this._addItems(context.length, 0);
                    this._setListener();
                };
                /**
                 * Removes any potentially held memory.
                 */
                Select.prototype.dispose = function () {
                    _super.prototype.dispose.call(this);
                    if (this.utils.isFunction(this.__rejectFn)) {
                        this.__rejectFn();
                        this.__resolveFn = this.__rejectFn = null;
                    }
                    this._defaultOption = null;
                };
                /**
                 * A function that allows this control to observe both the bound property itself as well as
                 * potential child properties if being bound to an object.
                 * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
                 * databinding.
                 */
                Select.prototype.observeProperties = function (binder) {
                    var _this = this;
                    var element = this.element;
                    this._binder = binder;
                    if (element.multiple) {
                        if (isNull(binder.evaluate())) {
                            this.inputChanged([]);
                        }
                        binder.observeProperty(this._setSelectedIndices);
                        binder.observeArrayChange(function () {
                            _this._setSelectedIndices(binder.evaluate(), null, null);
                        });
                    }
                    else {
                        binder.observeProperty(this._setSelectedIndex);
                    }
                    this.addEventListener(element, 'change', this._observeChange, false);
                };
                /**
                 * Updates the selected index if bound to a property.
                 * @param {string} newValue The new value of the bound property.
                 * @param {string} oldValue The old value of the bound property.
                 * @param {string} identifier The child identifier of the bound property.
                 * @param {boolean} firstTime? Whether or not this is the first time being called as a setter.
                 */
                Select.prototype._setSelectedIndex = function (newValue, oldValue, identifier, firstTime) {
                    var _this = this;
                    var element = this.element, value = element.value;
                    if (isNull(newValue)) {
                        if (firstTime === true || !this._document.body.contains(element)) {
                            this.itemsLoaded.then(function () {
                                if (isNull(_this._binder.evaluate())) {
                                    _this.inputChanged(element.value);
                                }
                            });
                            return;
                        }
                        element.selectedIndex = -1;
                        return;
                    }
                    else if (!isString(newValue)) {
                        if (isNumber(newValue)) {
                            this._propertyType = 'number';
                            newValue = newValue.toString();
                        }
                        else if (isBoolean(newValue)) {
                            this._propertyType = 'boolean';
                            newValue = newValue.toString();
                        }
                        else {
                            if (isFunction(newValue.toString)) {
                                newValue = newValue.toString();
                            }
                            else {
                                newValue = Object.prototype.toString.call(newValue);
                            }
                            this._log.info('Trying to bind the invalid value "' + newValue + '" to a ' + this.type + '.');
                        }
                    }
                    if (value === newValue) {
                        return;
                    }
                    this.itemsLoaded.then(function () {
                        if (!_this._document.body.contains(element)) {
                            element.value = newValue;
                            if (element.value !== newValue) {
                                element.value = value;
                                _this.inputChanged(_this._castValue(element.value));
                            }
                            return;
                        }
                        element.value = newValue;
                        // check to make sure the user changed to a valid value 
                        // second boolean argument is an ie fix for inconsistency 
                        if (element.value !== newValue || element.selectedIndex === -1) {
                            element.selectedIndex = -1;
                        }
                    });
                };
                /**
                 * Updates the selected index if bound to a property.
                 * @param {Array<any>} newValue The new value Array of the bound property.
                 * @param {Array<any>} oldValue The old value Array of the bound property.
                 * @param {string} identifier The child identifier of the bound property.
                 * @param {boolean} firstTime? Whether or not this is the first time being called as a setter.
                 */
                Select.prototype._setSelectedIndices = function (newValue, oldValue, identifier, firstTime) {
                    var _this = this;
                    this.itemsLoaded.then(function () {
                        var element = _this.element, options = element.options, length = isNull(options) ? 0 : options.length, option, nullValue = isNull(newValue);
                        if (nullValue || !isArray(newValue)) {
                            if (firstTime === true && isNull(_this._binder.evaluate())) {
                                _this.inputChanged(_this._getSelectedValues());
                            }
                            // unselects the options unless a match is found 
                            while (length-- > 0) {
                                option = options[length];
                                if (!nullValue && option.value === '' + newValue) {
                                    option.selected = true;
                                    return;
                                }
                                option.selected = false;
                            }
                            return;
                        }
                        var value, numberValue, index, highestIndex = Infinity;
                        while (length-- > 0) {
                            option = options[length];
                            value = option.value;
                            if (newValue.indexOf(value) !== -1) {
                                option.selected = true;
                                continue;
                            }
                            numberValue = Number(value);
                            if (isNumber(numberValue) && (index = newValue.indexOf(numberValue)) !== -1) {
                                if (index < highestIndex) {
                                    _this._propertyType = 'number';
                                    highestIndex = index;
                                }
                                option.selected = true;
                                continue;
                            }
                            else if ((value === 'true' && (index = newValue.indexOf(true)) !== -1) ||
                                value === 'false' && (index = newValue.indexOf(false)) !== -1) {
                                if (index < highestIndex) {
                                    _this._propertyType = 'boolean';
                                    highestIndex = index;
                                }
                                option.selected = true;
                                continue;
                            }
                            option.selected = false;
                        }
                    });
                };
                /**
                 * Fires the inputChanged event when the select's value changes.
                 */
                Select.prototype._observeChange = function () {
                    var element = this.element;
                    this.inputChanged(element.multiple ? this._getSelectedValues() : this._castValue(element.value));
                };
                /**
                 * Getter for select-multiple.
                 */
                Select.prototype._getSelectedValues = function () {
                    var options = this.element.options, length = options.length, option, selectedValues = [];
                    for (var i = 0; i < length; ++i) {
                        option = options[i];
                        if (option.selected) {
                            selectedValues.push(this._castValue(option.value));
                        }
                    }
                    return selectedValues;
                };
                /**
                 * Casts a value to the determined initial property type.
                 */
                Select.prototype._castValue = function (value) {
                    var type = this._propertyType;
                    if (isNull(type)) {
                        return value;
                    }
                    var castValue;
                    switch (type) {
                        case 'number':
                            castValue = isEmpty(value) ? undefined : Number(value);
                            break;
                        case 'boolean':
                            switch (value) {
                                case 'true':
                                    castValue = true;
                                    break;
                                case 'false':
                                case '0':
                                case 'null':
                                case 'undefined':
                                    castValue = false;
                                    break;
                                default:
                                    castValue = !!value;
                                    break;
                            }
                            break;
                        default:
                            castValue = value;
                            break;
                    }
                    return castValue;
                };
                /**
                 * Sets a listener for the changes to the array.
                 */
                Select.prototype._setListener = function () {
                    if (!this.__listenerSet) {
                        this.observeArray(this._executeEvent);
                        this.__listenerSet = true;
                    }
                };
                /**
                 * Receives an event when a method has been called on an array and maps the array
                 * method to its associated method handler.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._executeEvent = function (changes) {
                    var method = '_' + changes[0].type;
                    if (isFunction(this[method])) {
                        this[method](changes);
                    }
                };
                /**
                 * Adds the options to the select element.
                 * @param {number} numberOfItems The number of items to add.
                 * @param {number} index The starting index of the next
                 * set of items to add.
                 */
                Select.prototype._addItems = function (numberOfItems, index) {
                    var _this = this;
                    var bindableTemplates = this.bindableTemplates, promises = [], insertOption = this._insertOption;
                    while (numberOfItems-- > 0) {
                        promises.push(bindableTemplates.bind('option', index).then(insertOption.bind(this, index++)));
                    }
                    if (promises.length > 0) {
                        this.itemsLoaded = this._Promise.all(promises).then(function () {
                            if (isFunction(_this.__resolveFn)) {
                                _this.__resolveFn();
                                _this.__resolveFn = _this.__rejectFn = null;
                            }
                            return;
                        }).catch(function (error) {
                            postpone(function () {
                                if (isString(error)) {
                                    error = new Error(error);
                                }
                                _this._log.error(error);
                            });
                        });
                    }
                    return this.itemsLoaded;
                };
                /**
                 * The callback used to add an option after
                 * its template has been bound.
                 * @param {number} index The current index of the item being added.
                 * @param {DocumentFragment} option The bound DocumentFragment to be
                 * inserted into the DOM.
                 */
                Select.prototype._insertOption = function (index, option) {
                    var element = this.element;
                    if (this._isGrouped) {
                        var groups_1 = this.groups, newGroup_1 = (this.context[index] || {})[this._group], optgroup_1 = groups_1[newGroup_1];
                        if (isNull(optgroup_1)) {
                            return (groups_1[newGroup_1] = this.bindableTemplates.bind('group', index)
                                .then(function (groupFragment) {
                                optgroup_1 = groups_1[newGroup_1] = groupFragment.childNodes[1];
                                optgroup_1.insertBefore(option, null);
                                element.insertBefore(groupFragment, null);
                                return optgroup_1;
                            }));
                        }
                        else if (isPromise(optgroup_1)) {
                            return optgroup_1.then(function (group) {
                                group.insertBefore(option, null);
                            });
                        }
                        optgroup_1.insertBefore(option, null);
                        return this._Promise.resolve();
                    }
                    element.insertBefore(option, null);
                    return this._Promise.resolve();
                };
                /**
                 * Removes a specified number of elements.
                 * @param {number} numberOfItems The number of items
                 * to remove.
                 */
                Select.prototype._removeItems = function (numberOfItems) {
                    var dispose = TemplateControl.dispose, controls = this.controls;
                    while (numberOfItems-- > 0) {
                        dispose(controls.pop());
                    }
                };
                /**
                 * The function called when an item has been removed
                 * from the Array context.
                 */
                Select.prototype._removeItem = function () {
                    if (this._isGrouped) {
                        this._resetSelect();
                        return;
                    }
                    this._removeItems(1);
                };
                /**
                 * Resets the select element by removing all its
                 * items and adding them back.
                 */
                Select.prototype._resetSelect = function () {
                    this._removeItems(this.controls.length);
                    this.groups = {};
                    if (!isNull(this._defaultOption)) {
                        this.element.insertBefore(this._defaultOption.cloneNode(true), null);
                    }
                    this._addItems(this.context.length, 0);
                };
                /**
                 * The function called when an element is pushed to
                 * the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._push = function (changes) {
                    var change = changes[0];
                    this._addItems(change.addedCount, change.index);
                };
                /**
                 * The function called when an item is popped
                 * from the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._pop = function (changes) {
                    var _this = this;
                    if (changes[0].removed.length === 0) {
                        return;
                    }
                    this.itemsLoaded.then(function () {
                        _this._removeItem();
                    });
                };
                /**
                 * The function called when an item is unshifted
                 * onto the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._unshift = function (changes) {
                    if (this._isGrouped) {
                        this._resetSelect();
                        return;
                    }
                    var change = changes[0], addedCount = change.addedCount;
                    this._addItems(addedCount, change.object.length - addedCount - 1);
                };
                /**
                 * The function called when an item is shifted
                 * from the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._shift = function (changes) {
                    var _this = this;
                    if (changes[0].removed.length === 0) {
                        return;
                    }
                    this.itemsLoaded.then(function () {
                        _this._removeItem();
                    });
                };
                /**
                 * The function called when items are spliced
                 * from the array context.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._splice = function (changes) {
                    var _this = this;
                    if (this._isGrouped) {
                        this._resetSelect();
                        return;
                    }
                    var change = changes[0], addCount = change.addedCount, removeCount = change.removed.length;
                    if (addCount > removeCount) {
                        this._addItems(addCount - removeCount, change.object.length - addCount - 1);
                    }
                    else if (removeCount > addCount) {
                        this.itemsLoaded.then(function () {
                            _this._removeItems(removeCount - addCount);
                        });
                    }
                };
                /**
                 * The function called when the array context
                 * is sorted.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._sort = function (changes) {
                    if (this._isGrouped) {
                        this._resetSelect();
                    }
                };
                /**
                 * The function called when the array context
                 * is reversed.
                 * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
                 */
                Select.prototype._reverse = function (changes) {
                    if (this._isGrouped) {
                        this._resetSelect();
                    }
                };
                Select._inject = {
                    _Promise: __Promise,
                    _document: __Document
                };
                return Select;
            }(BindControl));
            controls_1.Select = Select;
            register.control(__Select, Select);
            /**
             * A TemplateControl conditionally adding or removing
             * a block of nodes to or from the DOM.
             */
            var If = (function (_super) {
                __extends(If, _super);
                /**
                 * The constructor for a If. Creates the comment node and document fragment storage
                 * used by this control.
                 */
                function If() {
                    _super.call(this);
                    /**
                     * The current evaluated condition (whether or not the
                     * control is visible) of the control.
                     */
                    this.__condition = true;
                    /**
                     * A boolean value stating whether or not the condition has already
                     * been evaluated.
                     */
                    this.__firstTime = true;
                    var _document = this._document;
                    this.commentNode = _document.createComment(__If + __BOUND_PREFIX + 'placeholder');
                    this.fragmentStore = _document.createDocumentFragment();
                }
                /**
                 * Checks the options and initializes the
                 * evaluation.
                 */
                If.prototype.contextChanged = function () {
                    var options = this.options.value;
                    if (isEmpty(options)) {
                        return;
                    }
                    return this._setter(options);
                };
                /**
                 * Creates a bindable template with the control element's childNodes (innerHTML).
                 */
                If.prototype.setTemplate = function () {
                    this.bindableTemplates.add('template', Array.prototype.slice.call(this.element.childNodes));
                };
                /**
                 * Sets the visibility to true if no options are
                 * defined, kicks off the evaluation, and observes
                 * the options for changes.
                 */
                If.prototype.loaded = function () {
                    if (isNull(this.options)) {
                        this._log.warn('No condition specified in ' + __Options + ' for ' + this.type + '.');
                        this.options = {
                            value: {
                                condition: true
                            },
                            observe: noop
                        };
                    }
                    var promise = this.contextChanged();
                    this.__removeListener = this.options.observe(this._setter);
                    return promise;
                };
                /**
                 * Stops listening to the options for changes.
                 */
                If.prototype.dispose = function () {
                    if (isFunction(this.__removeListener)) {
                        this.__removeListener();
                        this.__removeListener = null;
                    }
                    this.commentNode = null;
                    this.fragmentStore = null;
                };
                /**
                 * Checks the condition and decides
                 * whether or not to add or remove
                 * the node from the DOM.
                 */
                If.prototype._setter = function (options) {
                    var _this = this;
                    var value = !!options.condition, promise;
                    if (value === this.__condition && !this.__firstTime) {
                        return this._Promise.resolve(null);
                    }
                    if (value) {
                        if (!isNull(this.__leaveAnimation)) {
                            promise = this.__leaveAnimation.cancel().then(function () {
                                _this.__leaveAnimation = null;
                                return _this._addItem();
                            });
                        }
                        else {
                            promise = this._addItem();
                        }
                    }
                    else {
                        if (!isNull(this.__enterAnimation)) {
                            promise = this.__enterAnimation.cancel().then(function () {
                                _this.__enterAnimation = null;
                                return _this._removeItem();
                            });
                        }
                        else {
                            this._removeItem();
                            promise = this._Promise.resolve(null);
                        }
                    }
                    this.__condition = value;
                    return promise;
                };
                /**
                 * Adds the conditional nodes to the DOM.
                 */
                If.prototype._addItem = function () {
                    var _this = this;
                    if (!isNode(this.commentNode.parentNode) && !this.__firstTime) {
                        return this._Promise.resolve(null);
                    }
                    if (this.__firstTime) {
                        this.__firstTime = false;
                        this.__initialBind = this.bindableTemplates.bind('template').then(function (template) {
                            var element = _this.element;
                            _this.__initialBind = null;
                            if (element.parentNode === _this.fragmentStore) {
                                element.insertBefore(template, null);
                                return _this._animateEntrance();
                            }
                            _this.__enterAnimation = _this._animator.animate(element, __Enter);
                            element.insertBefore(template, null);
                            return _this.__enterAnimation;
                        }).then(function () {
                            _this.__enterAnimation = null;
                        });
                        return this.__initialBind;
                    }
                    if (isPromise(this.__initialBind)) {
                        return this.__initialBind.then(function () {
                            return _this._animateEntrance();
                        });
                    }
                    return this._animateEntrance();
                };
                /**
                 * Animates the template as it enters the DOM.
                 */
                If.prototype._animateEntrance = function () {
                    var _this = this;
                    var commentNode = this.commentNode, parentNode = commentNode.parentNode;
                    if (!isNode(parentNode)) {
                        return this._animator.resolve().then(noop);
                    }
                    return this.__enterAnimation = this._animator.enter(this.element, __Enter, parentNode, commentNode).then(function () {
                        _this.__enterAnimation = null;
                    });
                };
                /**
                 * Removes the conditional nodes from the DOM.
                 */
                If.prototype._removeItem = function () {
                    var _this = this;
                    if (isPromise(this.__initialBind)) {
                        return this.__initialBind.then(function () {
                            return _this._animateLeave();
                        });
                    }
                    return this._animateLeave();
                };
                /**
                 * Animates the template as it leaves the DOM.
                 */
                If.prototype._animateLeave = function () {
                    var _this = this;
                    var element = this.element, parent = element.parentElement, nextSibling = element.nextSibling;
                    if (!isNode(parent)) {
                        return this._animator.resolve().then(noop);
                    }
                    return this.__leaveAnimation = this._animator.leave(element, __Leave).then(function () {
                        _this.__leaveAnimation = null;
                        parent.insertBefore(_this.commentNode, nextSibling);
                        _this.fragmentStore.insertBefore(element, null);
                    });
                };
                If._inject = {
                    _animator: __Animator,
                    _Promise: __Promise,
                    _document: __Document
                };
                return If;
            }(TemplateControl));
            controls_1.If = If;
            register.control(__If, If);
            /**
             * A TemplateControl for adding additonal
             * functionality to a native HTML anchor tag.
             */
            var Link = (function (_super) {
                __extends(Link, _super);
                function Link() {
                    _super.apply(this, arguments);
                    /**
                     * Replaces the Link's element with a native anchor tag.
                     */
                    this.replaceWith = 'a';
                    /**
                     * The router associated with this link.
                     */
                    this._router = this._Router.currentRouter();
                }
                /**
                 * Initializes click event.
                 */
                Link.prototype.initialize = function () {
                    this._removeClickListener = this.dom.addEventListener(this.element, 'click', this._handleClick, false);
                };
                /**
                 * Calls to normalize the href for internal links and initializes the tap event.
                 */
                Link.prototype.loaded = function () {
                    var options = this.options, setHref = this.setHref.bind(this);
                    if (!isObject(options)) {
                        this._log.warn('No options specified for ' + this.type +
                            '. Please send in options of type plat.ui.controls.ILinkOptions.');
                        options = this.options = {};
                        options.value = { view: '' };
                        this.setHref();
                        return;
                    }
                    else if (!isObject(options.value)) {
                        options.value = { view: '' };
                    }
                    this.addEventListener(this.element, __tap, this._handleTap, false);
                    setHref();
                    options.observe(setHref);
                };
                /**
                 * Sets the element href to the one formed using the associated options.
                 */
                Link.prototype.setHref = function () {
                    var href = this.getHref();
                    if (!isEmpty(href)) {
                        var element = this.element;
                        element.href = href;
                    }
                };
                /**
                 * Determines the href based on the input options.
                 */
                Link.prototype.getHref = function () {
                    if (isNull(this._router)) {
                        return;
                    }
                    var value = this.options.value, href = value.view;
                    if (value.isUrl !== true) {
                        var parameters = value.parameters, query = value.query;
                        if (isEmpty(href)) {
                            return href;
                        }
                        href = this._router.generate(href, parameters, query);
                    }
                    return this._browser.formatUrl(href);
                };
                /**
                 * Determines Whether or not the default click behavior should be prevented.
                 */
                Link.prototype._handleClick = function (ev) {
                    var buttons;
                    if (isNumber(ev.buttons) && ev.buttons !== 0) {
                        buttons = ev.buttons;
                    }
                    else if (isNumber(ev.which) && ev.which > 0) {
                        buttons = ev.which;
                    }
                    else {
                        switch (ev.button) {
                            case -1:
                                buttons = 0;
                                break;
                            case 0:
                                buttons = 1;
                                break;
                            case 1:
                                buttons = 4;
                                break;
                            case 2:
                                buttons = 2;
                                break;
                            case 3:
                                buttons = 8;
                                break;
                            case 4:
                                buttons = 16;
                                break;
                            default:
                                buttons = 1;
                                break;
                        }
                    }
                    if (buttons === 1) {
                        ev.preventDefault();
                    }
                };
                /**
                 * Determines the proper link upon $tap.
                 */
                Link.prototype._handleTap = function (ev) {
                    var _this = this;
                    if (ev.buttons !== 1) {
                        return;
                    }
                    var href = this.getHref();
                    if (isUndefined(href)) {
                        return;
                    }
                    ev.preventDefault();
                    requestAnimationFrameGlobal(function () {
                        _this._browser.url(href);
                    });
                };
                /**
                 * Calls to remove the click eater after a delay.
                 */
                Link.prototype.dispose = function () {
                    defer(this._removeClickListener, 3000);
                };
                Link._inject = {
                    _Router: __RouterStatic,
                    _Injector: __InjectorStatic,
                    _browser: __Browser
                };
                return Link;
            }(TemplateControl));
            controls_1.Link = Link;
            register.control(__Link, Link);
        })(controls = ui.controls || (ui.controls = {}));
    })(ui = plat_1.ui || (plat_1.ui = {}));
    /**
     * Holds classes and interfaces related to Document processing in platypus.
     */
    var processing;
    (function (processing) {
        /**
         * Responsible for iterating through the DOM and collecting controls.
         */
        var Compiler = (function () {
            function Compiler() {
            }
            Compiler.prototype.compile = function (node, control) {
                var childNodes = node.childNodes, length, newLength, childNode, hasControl = !isNull(control), manager = (hasControl ? this._managerCache.read(control.uid) : null), create = this._ElementManagerFactory.create;
                if (!isUndefined(childNodes)) {
                    childNodes = Array.prototype.slice.call(childNodes);
                }
                else if (isFunction(node.push)) {
                    childNodes = node;
                }
                else {
                    childNodes = Array.prototype.slice.call(node);
                }
                if (isNull(manager)) {
                    length = childNodes.length;
                    for (var i = 0; i < length; ++i) {
                        childNode = childNodes[i];
                        if (childNode.nodeType === Node.ELEMENT_NODE) {
                            if (!isNull(create(childNode))) {
                                this.compile(childNode);
                            }
                        }
                        newLength = childNodes.length;
                        i += newLength - length;
                        length = newLength;
                    }
                }
                else {
                    this._compileNodes(childNodes, manager);
                }
            };
            /**
             * Iterates through the array of nodes creating ElementManagers on Element
             * nodes, TextManagers on text nodes, and
             * CommentManagers on comment nodes.
             * @param {Array<Node>} nodes The array of nodes to be compiled.
             * @param {plat.processing.ElementManager} manager The parent ElementManagers
             * for the given array of nodes.
             */
            /**
             * @param nodes The NodeList to be compiled.
             * @param manager The parent Element Manager for the given array of nodes.
             */
            Compiler.prototype._compileNodes = function (nodes, manager) {
                var length = nodes.length, node, newManager, newLength, create = this._ElementManagerFactory.create, commentCreate = this._CommentManagerFactory.create, textCreate = this._TextManagerFactory.create;
                for (var i = 0; i < length; ++i) {
                    node = nodes[i];
                    switch (node.nodeType) {
                        case Node.ELEMENT_NODE:
                            newManager = create(node, manager);
                            if (!isNull(newManager)) {
                                this._compileNodes(Array.prototype.slice.call(node.childNodes), newManager);
                            }
                            break;
                        case Node.TEXT_NODE:
                            textCreate(node, manager);
                            break;
                        case Node.COMMENT_NODE:
                            commentCreate(node, manager);
                            break;
                    }
                    newLength = nodes.length;
                    i += newLength - length;
                    length = newLength;
                }
            };
            Compiler._inject = {
                _ElementManagerFactory: __ElementManagerFactory,
                _TextManagerFactory: __TextManagerFactory,
                _CommentManagerFactory: __CommentManagerFactory,
                _managerCache: __ManagerCache
            };
            return Compiler;
        }());
        processing.Compiler = Compiler;
        register.injectable(__Compiler, Compiler);
        /**
         * Responsible for data binding a data context to a Node.
         */
        var NodeManager = (function () {
            function NodeManager() {
                /**
                 * Whether or not this NodeManager is a clone.
                 */
                this.isClone = false;
            }
            /**
             * Determines if a string has the markup notation.
             * @param {string} text The text string in which to search for markup.
             */
            NodeManager.hasMarkup = function (text) {
                return NodeManager._markupRegex.test(text);
            };
            /**
             * Given a string, finds markup in the string and creates an array of
             * IParsedExpression.
             * @param {string} text The text string in which to search for markup.
             */
            NodeManager.findMarkup = function (text) {
                var start, end, parsedExpressions = [], wrapExpression = NodeManager._wrapExpression, substring, expression, _parser = NodeManager._parser;
                text = text.replace(NodeManager._newLineRegex, '');
                while ((start = text.indexOf(__startSymbol)) !== -1 && (end = text.indexOf(__endSymbol)) !== -1) {
                    if (start !== 0) {
                        parsedExpressions.push(wrapExpression(text.slice(0, start)));
                    }
                    // incremement with while loop instead of just += 2 for nested object literal case. 
                    while (text[++end] === '}') { }
                    substring = text.slice(start + 2, end - 2);
                    // check for one-time databinding 
                    if (substring[0] === '=') {
                        expression = _parser.parse(substring.slice(1).trim());
                        expression.oneTime = true;
                        parsedExpressions.push(expression);
                    }
                    else {
                        parsedExpressions.push(_parser.parse(substring.trim()));
                    }
                    text = text.slice(end);
                }
                if (start > -1 && end >= 0) {
                    parsedExpressions.push(wrapExpression(text.slice(end)));
                }
                else if (text !== '') {
                    parsedExpressions.push(wrapExpression(text));
                }
                return parsedExpressions;
            };
            /**
             * Takes in a control with a data context and an array of IParsedExpression
             * and outputs a string of the evaluated expressions.
             * @param {Array<plat.expressions.IParsedExpression>} expressions The composition array to evaluate.
             * @param {plat.ui.TemplateControl} control? The TemplateControl used to parse
             * the expressions.
             */
            NodeManager.build = function (expressions, control) {
                var text = '', length = expressions.length, resources = {}, expression, value, evaluateExpression = NodeManager._TemplateControlFactory.evaluateExpression;
                for (var i = 0; i < length; ++i) {
                    expression = expressions[i];
                    value = evaluateExpression(expression, control, resources);
                    if (isObject(value)) {
                        try {
                            text += JSON.stringify(value, null, 4);
                        }
                        catch (e) {
                            if (!isNull(e.description)) {
                                e.description = 'Cannot stringify object: ' + e.description;
                            }
                            e.message = 'Cannot stringify object: ' + e.message;
                            NodeManager._log.warn(e);
                        }
                    }
                    else if (!isNull(value)) {
                        text += value;
                    }
                }
                return text;
            };
            /**
             * Registers a listener to be notified of a change in any associated identifier.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An Array of
             * IParsedExpressions to observe.
             * @param {plat.ui.TemplateControl} control The TemplateControl associated
             * to the identifiers.
             * @param {(...args: Array<any>) => void} listener The listener to call when any identifier property changes.
             */
            NodeManager.observeExpressions = function (expressions, control, listener) {
                var uniqueIdentifiers = NodeManager.__findUniqueIdentifiers(expressions), identifiers = uniqueIdentifiers.identifiers, oneTimeIdentifiers = uniqueIdentifiers.oneTimeIdentifiers, oneTimeIdentifier, observableCallback = {
                    listener: listener,
                    uid: control.uid
                }, observationDetails, manager, absoluteIdentifier;
                while (identifiers.length > 0) {
                    observationDetails = NodeManager.__getObservationDetails(identifiers.pop(), control);
                    manager = observationDetails.manager;
                    if (!isNull(manager)) {
                        manager.observe(observationDetails.absoluteIdentifier, observableCallback);
                    }
                }
                while (oneTimeIdentifiers.length > 0) {
                    oneTimeIdentifier = oneTimeIdentifiers.pop();
                    observationDetails = NodeManager.__getObservationDetails(oneTimeIdentifier, control);
                    manager = observationDetails.manager;
                    if (!(isNull(manager) || observationDetails.isDefined)) {
                        absoluteIdentifier = observationDetails.absoluteIdentifier;
                        var stopObserving = manager.observe(absoluteIdentifier, observableCallback), stopListening = manager.observe(absoluteIdentifier, {
                            uid: control.uid,
                            listener: function () {
                                stopObserving();
                                stopListening();
                            }
                        });
                    }
                }
            };
            /**
             * Wraps constant text as a static IParsedExpression.
             * @param text The text to wrap into a static expression.
             */
            NodeManager._wrapExpression = function (text) {
                return {
                    evaluate: function () { return text; },
                    identifiers: [],
                    aliases: [],
                    expression: text
                };
            };
            /**
             * Given an IParsedExpression array, creates an array of unique identifers
             * to use with binding. This allows us to avoid creating multiple listeners for the identifier and node.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions to search for identifiers.
             */
            NodeManager.__findUniqueIdentifiers = function (expressions) {
                var length = expressions.length, expression;
                if (length === 1) {
                    expression = expressions[0];
                    if (expression.oneTime === true) {
                        return {
                            identifiers: [],
                            oneTimeIdentifiers: expression.identifiers.slice(0)
                        };
                    }
                    return {
                        identifiers: expression.identifiers.slice(0),
                        oneTimeIdentifiers: []
                    };
                }
                var uniqueIdentifierObject = {}, oneTimeIdentifierObject = {}, uniqueIdentifiers = [], oneTimeIdentifiers = [], identifiers, identifier, j, jLength, oneTime;
                for (var i = 0; i < length; ++i) {
                    expression = expressions[i];
                    oneTime = expression.oneTime;
                    identifiers = expression.identifiers;
                    jLength = identifiers.length;
                    for (j = 0; j < jLength; ++j) {
                        identifier = identifiers[j];
                        if (oneTime) {
                            if (uniqueIdentifierObject[identifier] === true) {
                                continue;
                            }
                            if (!oneTimeIdentifierObject[identifier]) {
                                oneTimeIdentifierObject[identifier] = true;
                                oneTimeIdentifiers.push(identifier);
                            }
                        }
                        else {
                            if (!uniqueIdentifierObject[identifier]) {
                                uniqueIdentifierObject[identifier] = true;
                                uniqueIdentifiers.push(identifier);
                            }
                            if (oneTimeIdentifierObject[identifier] === true) {
                                oneTimeIdentifierObject[identifier] = false;
                                oneTimeIdentifiers.splice(oneTimeIdentifiers.indexOf(identifier), 1);
                            }
                        }
                    }
                }
                return {
                    identifiers: uniqueIdentifiers,
                    oneTimeIdentifiers: oneTimeIdentifiers
                };
            };
            /**
             * Takes in an identifier and returns an object containing both its converted absolute path and the
             * ContextManager needed to observe it.
             * @param {string} identifier The identifier looking to be observed.
             * @param {plat.ui.TemplateControl} control The TemplateControl associated
             * to the identifiers.
             */
            NodeManager.__getObservationDetails = function (identifier, control) {
                var _ContextManager = NodeManager._ContextManager, manager, split = identifier.split('.'), absoluteIdentifier = '', isDefined = false;
                if (identifier[0] === '@') {
                    // we found an alias 
                    var resourceObj = void 0, resources = {}, topIdentifier = split.shift(), alias = topIdentifier.slice(1);
                    if (split.length > 0) {
                        absoluteIdentifier = '.' + split.join('.');
                    }
                    resourceObj = resources[alias];
                    if (isNull(resourceObj)) {
                        resourceObj = resources[alias] = control.findResource(alias);
                    }
                    if (!isNull(resourceObj) && !isNull(resourceObj.resource)) {
                        var type = resourceObj.resource.type;
                        if (alias === __CONTEXT_RESOURCE) {
                            manager = _ContextManager.getManager(Control.getRootControl(control));
                            absoluteIdentifier = control.absoluteContextPath + absoluteIdentifier;
                        }
                        else if (alias === __ROOT_CONTEXT_RESOURCE) {
                            manager = _ContextManager.getManager(resources[alias].control);
                            absoluteIdentifier = 'context' + absoluteIdentifier;
                        }
                        else if (type === __OBSERVABLE_RESOURCE || type === __LITERAL_RESOURCE) {
                            manager = _ContextManager.getManager(resources[alias].control);
                            absoluteIdentifier = 'resources.' + alias + '.value' + absoluteIdentifier;
                        }
                    }
                }
                else {
                    // look on the control.context 
                    isDefined = !isUndefined(_ContextManager.getContext(control.context, split));
                    if (isDefined || isUndefined(_ContextManager.getContext(control, split))) {
                        manager = _ContextManager.getManager(Control.getRootControl(control));
                        absoluteIdentifier = control.absoluteContextPath + '.' + identifier;
                    }
                    else {
                        manager = null;
                    }
                }
                return {
                    absoluteIdentifier: absoluteIdentifier,
                    manager: manager,
                    isDefined: isDefined
                };
            };
            /**
             * Initializes the manager's properties.
             * @param {plat.processing.INodeMap} nodeMap The mapping associated with this manager. We have to use an
             * Used to treat all NodeManagers the same.
             * @param {plat.processing.ElementManager} parent The parent ElementManager.
             */
            NodeManager.prototype.initialize = function (nodeMap, parent) {
                this.nodeMap = nodeMap;
                this.parent = parent;
                if (!isNull(parent)) {
                    this.isClone = parent.isClone;
                    parent.children.push(this);
                }
            };
            /**
             * Retrieves the parent control associated with the parent manager.
             */
            NodeManager.prototype.getParentControl = function () {
                var parent = this.parent, control;
                while (isNull(control)) {
                    if (isNull(parent)) {
                        break;
                    }
                    control = parent.getUiControl();
                    parent = parent.parent;
                }
                return control;
            };
            /**
             * Clones this NodeManager with the new node.
             * @param {Node} newNode The new node associated with the new manager.
             * @param {plat.processing.ElementManager} parentManager The parent
             * ElementManager for the clone.
             */
            NodeManager.prototype.clone = function (newNode, parentManager) {
                return 1;
            };
            /**
             * The function used for data-binding a data context to the DOM.
             */
            NodeManager.prototype.bind = function () { };
            return NodeManager;
        }());
        processing.NodeManager = NodeManager;
        /**
         */
        function INodeManagerStatic(_regex, _ContextManager, _parser, _TemplateControlFactory, _log) {
            // NOTE: This is not advised by TypeScript, but we want to do this. 
            NodeManager._markupRegex = _regex.markupRegex;
            NodeManager._newLineRegex = _regex.newLineRegex;
            NodeManager._ContextManager = _ContextManager;
            NodeManager._parser = _parser;
            NodeManager._TemplateControlFactory = _TemplateControlFactory;
            NodeManager._log = _log;
            return NodeManager;
        }
        processing.INodeManagerStatic = INodeManagerStatic;
        register.injectable(__NodeManagerStatic, INodeManagerStatic, [
            __Regex,
            __ContextManagerStatic,
            __Parser,
            __TemplateControlFactory,
            __Log
        ], __STATIC);
        /**
         * A class used to manage element nodes. Provides a way for compiling and binding the
         * element/template. Also provides methods for cloning an
         * ElementManager.
         */
        var ElementManager = (function (_super) {
            __extends(ElementManager, _super);
            function ElementManager() {
                _super.apply(this, arguments);
                /**
                 * The child managers for this manager.
                 */
                this.children = [];
                /**
                 * Specifies the type for this NodeManager.
                 * It's value is "element".
                 */
                this.type = 'element';
                /**
                 * Specifies whether or not this manager has a TemplateControl which has a
                 * replaceWith property set to null or empty string.
                 */
                this.replace = false;
                /**
                 * Indicates whether the TemplateControl for this manager has its own context
                 * or inherits it from a parent.
                 */
                this.hasOwnContext = false;
            }
            /**
             * Determines if the associated Element has controls that need to be instantiated or Attr nodes
             * containing text markup. If controls exist or markup is found a new
             * ElementManager will be created,
             * else an empty NodeManager will be added to the Array of
             * NodeManagers.
             * @param {Element} element The Element to use to identifier markup and controls.
             * @param {plat.processing.ElementManager} parent? The parent ElementManager
             * used for context inheritance.
             */
            ElementManager.create = function (element, parent) {
                var name = element.nodeName.toLowerCase(), nodeName = name, injector = controlInjectors[name] || viewControlInjectors[name], noControlAttribute = true, hasUiControl = false, uiControlNode;
                if (isNull(injector)) {
                    if (element.hasAttribute(__Control)) {
                        name = element.getAttribute(__Control).toLowerCase();
                        injector = controlInjectors[name] || viewControlInjectors[name];
                        noControlAttribute = false;
                    }
                    else if (element.hasAttribute(__AttributePrefix + __Control)) {
                        name = element.getAttribute(__AttributePrefix + __Control).toLowerCase();
                        injector = controlInjectors[name] || viewControlInjectors[name];
                        noControlAttribute = false;
                    }
                }
                if (!isNull(injector)) {
                    var uiControl = injector.inject(), resourceElement = ElementManager.locateResources(element);
                    uiControlNode = {
                        control: uiControl,
                        resourceElement: resourceElement,
                        nodeName: name,
                        expressions: [],
                        injector: injector
                    };
                    hasUiControl = true;
                    if (noControlAttribute) {
                        element.setAttribute(__Control, name);
                    }
                    var replacementType = uiControl.replaceWith, replaceWithDiv = replacementType === 'any' && noControlAttribute;
                    if (!isEmpty(replacementType) && (replacementType !== 'any' || replaceWithDiv) &&
                        replacementType.toLowerCase() !== nodeName) {
                        if (replaceWithDiv) {
                            replacementType = 'div';
                        }
                        var replacement = ElementManager._document.createElement(replacementType);
                        if (replacement.nodeType === Node.ELEMENT_NODE) {
                            element = replaceWith(element, replacement);
                        }
                    }
                }
                var elementMap = ElementManager._collectAttributes(element.attributes), manager = ElementManager.getInstance();
                elementMap.element = element;
                if (!hasUiControl && isString(elementMap.childContext)) {
                    injector = injectableInjectors[__TemplateControlInstance];
                    hasUiControl = true;
                    elementMap.uiControlNode = {
                        control: injector.inject(),
                        resourceElement: null,
                        nodeName: __TemplateContext,
                        expressions: [],
                        injector: injector
                    };
                }
                else {
                    elementMap.uiControlNode = uiControlNode;
                }
                manager.initialize(elementMap, parent);
                if (!(elementMap.hasControl || hasUiControl)) {
                    manager.bind = function () { return []; };
                }
                else {
                    manager.setUiControlTemplate();
                    return hasUiControl ? null : manager;
                }
                return manager;
            };
            /**
             * Looks through the Node's child nodes to try and find any
             * defined Resources in a <plat-resources> tags.
             * @param {Node} node The node whose child nodes may contain Resources.
             */
            ElementManager.locateResources = function (node) {
                var childNodes = Array.prototype.slice.call(node.childNodes), childNode, nodeName;
                while (childNodes.length > 0) {
                    childNode = childNodes.shift();
                    nodeName = childNode.nodeName.toLowerCase();
                    if (nodeName === __Resources || nodeName === 'x-' + __Resources) {
                        return node.removeChild(childNode);
                    }
                }
                return null;
            };
            /**
             * Clones an ElementManager with a new element.
             * @param {plat.processing.ElementManager} sourceManager The original ElementManager.
             * @param {plat.processing.ElementManager} parent The parent ElementManager
             * for the new clone.
             * @param {Element} element The new element to associate with the clone.
             * @param {plat.ui.TemplateControl} newControl? An optional control to associate with the clone.
             * @param {plat.processing.INodeMap} nodeMap? The {@link plat.processing.INodeMap} used to clone this
             * ElementManager.
             */
            ElementManager.clone = function (sourceManager, parent, element, newControl, nodeMap) {
                if (isNull(nodeMap)) {
                    nodeMap = ElementManager._cloneNodeMap(sourceManager.nodeMap, element, parent.getUiControl() ||
                        parent.getParentControl(), newControl);
                }
                var manager = ElementManager.getInstance(), hasNewControl = !isNull(newControl);
                manager.nodeMap = nodeMap;
                manager.parent = parent;
                if (!isNull(parent)) {
                    parent.children.push(manager);
                }
                manager.replace = sourceManager.replace;
                manager.replaceNodeLength = sourceManager.replaceNodeLength;
                manager.hasOwnContext = sourceManager.hasOwnContext;
                manager.isClone = true;
                if (!(nodeMap.hasControl || hasNewControl)) {
                    manager.bind = function () { return []; };
                }
                if (hasNewControl) {
                    ElementManager._managerCache.put(newControl.uid, manager);
                }
                return manager;
            };
            /**
             * Clones an TemplateControl with a new INodeMap.
             * @param {plat.processing.INodeMap} sourceMap The source INodeMap used to clone the
             * TemplateControl.
             * @param {plat.ui.TemplateControl} parent The parent control of the clone.
             */
            ElementManager.cloneUiControl = function (sourceMap, parent) {
                var uiControlNode = sourceMap.uiControlNode;
                if (isNull(uiControlNode) || isNull(uiControlNode.injector)) {
                    return;
                }
                var uiControl = uiControlNode.control, newUiControl = uiControlNode.injector.inject(), resources = ElementManager._ResourcesFactory.getInstance(), attributes = ElementManager._AttributesFactory.getInstance();
                newUiControl.parent = parent;
                parent.controls.push(newUiControl);
                newUiControl.controls = [];
                attributes.initialize(newUiControl, sourceMap.attributes);
                newUiControl.attributes = attributes;
                resources.initialize(newUiControl, uiControl.resources);
                newUiControl.resources = resources;
                ElementManager._ResourcesFactory.addControlResources(newUiControl);
                if (!isNull(uiControl.innerTemplate)) {
                    newUiControl.innerTemplate = uiControl.innerTemplate.cloneNode(true);
                }
                newUiControl.type = uiControl.type;
                newUiControl.bindableTemplates = ElementManager._BindableTemplatesFactory.create(newUiControl, uiControl.bindableTemplates);
                newUiControl.replaceWith = uiControl.replaceWith;
                return newUiControl;
            };
            /**
             * Creates new INodes corresponding to the element
             * associated with the INodeMap or the passed-in element.
             * @param {plat.processing.INodeMap} nodeMap The INodeMap that contains
             * the attribute nodes.
             * @param {plat.ui.TemplateControl} parent The parent TemplateControl for
             * the newly created controls.
             * @param {plat.ui.TemplateControl} templateControl? The TemplateControl
             * linked to these created controls if one exists.
             * @param {Element} newElement? An optional element to use for attributes (used in cloning).
             * @param {boolean} isClone? Whether or not these controls are clones.
             */
            ElementManager.createAttributeControls = function (nodeMap, parent, templateControl, newElement, isClone) {
                var nodes = nodeMap.nodes, element = isClone === true ? newElement : nodeMap.element, attributes;
                if (isNode(element)) {
                    if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                        return isClone === true ? ElementManager._copyAttributeNodes(nodes) : [];
                    }
                    attributes = element.attributes;
                }
                var attrs = nodeMap.attributes, newAttributes, node, injector, control, newNodes = [], length = nodes.length, nodeName, i;
                for (i = 0; i < length; ++i) {
                    node = nodes[i];
                    nodeName = node.nodeName;
                    injector = node.injector;
                    control = null;
                    if (!isNull(injector)) {
                        control = injector.inject();
                        node.control = control;
                        control.parent = parent;
                        control.element = element;
                        newAttributes = ElementManager._AttributesFactory.getInstance();
                        newAttributes.initialize(control, attrs);
                        control.attributes = newAttributes;
                        control.type = nodeName;
                        if (!isString(control.uid)) {
                            control.uid = uniqueId(__Plat);
                        }
                        control.templateControl = templateControl;
                    }
                    if (isClone === true) {
                        newNodes.push({
                            control: control,
                            expressions: node.expressions,
                            node: !attributes ? null : (attributes.getNamedItem(nodeName) ||
                                attributes.getNamedItem(__AttributePrefix + nodeName)),
                            nodeName: nodeName,
                            injector: injector
                        });
                        if (!isNull(control)) {
                            if (!isNull(parent)) {
                                parent.controls.push(control);
                            }
                            if (isFunction(control.initialize)) {
                                control.initialize();
                            }
                        }
                    }
                }
                if (!isClone) {
                    nodes.sort(function (a, b) {
                        var aControl = a.control, bControl = b.control;
                        if (isNull(aControl)) {
                            return 1;
                        }
                        else if (isNull(bControl)) {
                            return -1;
                        }
                        var aPriority = isNumber(aControl.priority) ? aControl.priority : 0, bPriority = isNumber(bControl.priority) ? bControl.priority : 0;
                        return bPriority - aPriority;
                    });
                    for (i = 0; i < length; ++i) {
                        node = nodes[i];
                        control = node.control;
                        if (!isNull(control)) {
                            if (!isNull(parent)) {
                                parent.controls.push(control);
                            }
                            if (isFunction(control.initialize)) {
                                control.initialize();
                            }
                        }
                    }
                }
                return newNodes;
            };
            /**
             * Returns a new instance of an ElementManager.
             */
            ElementManager.getInstance = function () {
                var manager = new ElementManager();
                manager._Promise = acquire(__Promise);
                manager._ContextManager = NodeManager._ContextManager;
                manager._compiler = acquire(__Compiler);
                manager._CommentManagerFactory = acquire(__CommentManagerFactory);
                manager._ControlFactory = acquire(__ControlFactory);
                manager._TemplateControlFactory = NodeManager._TemplateControlFactory;
                manager._BindableTemplatesFactory = ElementManager._BindableTemplatesFactory;
                manager._log = ElementManager._log;
                return manager;
            };
            /**
             * Iterates over the attributes (NamedNodeMap), creating an INodeMap.
             * This map will contain injectors for all the Controls as well as parsed expressions
             * and identifiers found for each Attribute (useful for data binding).
             * @param {NamedNodeMap} attributes The attributes used to create the INodeMap.
             */
            ElementManager._collectAttributes = function (attributes) {
                var nodes = [], attribute, name, value, childContext, childIdentifier, hasMarkup, hasMarkupFn = NodeManager.hasMarkup, findMarkup = NodeManager.findMarkup, _parser = NodeManager._parser, expressions, hasControl = false, injector, length = attributes.length, controlAttributes = {};
                for (var i = 0; i < length; ++i) {
                    attribute = attributes[i];
                    value = attribute.value;
                    name = attribute.name.replace(/^data-/i, '').toLowerCase();
                    injector = controlInjectors[name] || viewControlInjectors[name];
                    if (name === __Context) {
                        if (value !== '') {
                            childContext = _parser.parse(value);
                            if (childContext.identifiers.length !== 1) {
                                ElementManager._log.warn('Incorrect ' + __Context + ': ' +
                                    value + ', must contain a single identifier.');
                            }
                            childIdentifier = childContext.identifiers[0];
                        }
                    }
                    else if (name !== __Control) {
                        hasMarkup = hasMarkupFn(value);
                        expressions = hasMarkup ? findMarkup(value) : [];
                        if (!hasControl && (hasMarkup || !isNull(injector))) {
                            hasControl = true;
                        }
                        nodes.push({
                            control: null,
                            node: attribute,
                            nodeName: name,
                            expressions: expressions,
                            injector: injector
                        });
                    }
                    controlAttributes[camelCase(name)] = value;
                }
                return {
                    element: null,
                    attributes: controlAttributes,
                    nodes: nodes,
                    childContext: childIdentifier,
                    hasControl: hasControl
                };
            };
            /**
             * Used to copy the attribute nodes during the cloning process.
             * @param {Array<plat.processing.INode>} nodes The compiled INodes
             * to be cloned.
             */
            ElementManager._copyAttributeNodes = function (nodes) {
                var newNodes = [], length = nodes.length, node;
                for (var i = 0; i < length; ++i) {
                    node = nodes[i];
                    newNodes.push({
                        expressions: node.expressions,
                        nodeName: node.nodeName
                    });
                }
                return newNodes;
            };
            /**
             * Clones an INode with a new node.
             * @param {plat.processing.INode} sourceNode The original INode.
             * @param {Node} node The new node used for cloning.
             * @param {plat.ui.TemplateControl} newControl? An optional new control to associate with the cloned node.
             */
            ElementManager._cloneNode = function (sourceNode, node, newControl) {
                return {
                    control: newControl,
                    injector: sourceNode.injector,
                    expressions: sourceNode.expressions,
                    node: node,
                    nodeName: sourceNode.nodeName
                };
            };
            /**
             * Clones an INodeMap with a new element.
             * @param {plat.processing.INodeMap} sourceMap The original INodeMap.
             * @param {Element} element The new Element used for cloning.
             * @param {plat.ui.TemplateControl} parent The TemplateControl associated
             * with the parent ElementManager.
             * @param {plat.ui.TemplateControl} newControl? An optional new TemplateControl
             * to associate with the element.
             */
            ElementManager._cloneNodeMap = function (sourceMap, element, parent, newControl) {
                var hasControl = sourceMap.hasControl, nodeMap = {
                    attributes: sourceMap.attributes,
                    childContext: sourceMap.childContext,
                    nodes: [],
                    element: element,
                    uiControlNode: !isNull(sourceMap.uiControlNode) ?
                        ElementManager._cloneNode(sourceMap.uiControlNode, element, newControl) : null,
                    hasControl: hasControl
                };
                if (hasControl) {
                    nodeMap.nodes = ElementManager.createAttributeControls(sourceMap, parent, newControl, element, true);
                }
                return nodeMap;
            };
            /**
             * Clones the ElementManager with a new node.
             * @param {Node} newNode The new element used to clone the ElementManager.
             * @param {plat.processing.ElementManager} parentManager The parent manager for the clone.
             * @param {plat.processing.INodeMap} nodeMap? An optional INodeMap to clone a ui control if needed.
             */
            ElementManager.prototype.clone = function (newNode, parentManager, nodeMap) {
                var childNodes, clonedManager, replace = this.replace, children = this.children, newControl = !isNull(nodeMap) ? nodeMap.uiControlNode.control : null, newControlExists = !isNull(newControl), startNodeManager, endNodeManager;
                if (!newControlExists) {
                    // create new control 
                    newControl = ElementManager.cloneUiControl(this.nodeMap, (parentManager.getUiControl() || parentManager.getParentControl()));
                    newControlExists = !isNull(newControl);
                }
                if (replace) {
                    // definitely have newControl 
                    var nodes = newNode.parentNode.childNodes, arrayProto = Array.prototype, startIndex = arrayProto.indexOf.call(nodes, newNode);
                    childNodes = arrayProto.slice.call(nodes, startIndex + 1, startIndex + this.replaceNodeLength);
                    clonedManager = ElementManager.clone(this, parentManager, null, newControl, nodeMap);
                    newControl.elementNodes = childNodes;
                    newControl.startNode = newNode;
                    newControl.endNode = childNodes.pop();
                    startNodeManager = children.shift();
                    endNodeManager = children.shift();
                    startNodeManager.clone(newControl.startNode, clonedManager);
                    endNodeManager.clone(newControl.endNode, clonedManager);
                    if (isFunction(newControl.initialize)) {
                        newControl.initialize();
                    }
                }
                else {
                    childNodes = Array.prototype.slice.call(newNode.childNodes);
                    clonedManager = ElementManager.clone(this, parentManager, newNode, newControl, nodeMap);
                    nodeMap = clonedManager.nodeMap;
                    if (newControlExists) {
                        newControl.element = newNode;
                        if (isFunction(newControl.initialize)) {
                            newControl.initialize();
                        }
                    }
                }
                var length = children.length, childNodeOffset = 0;
                for (var i = 0; i < length; ++i) {
                    // clone children 
                    childNodeOffset += children[i].clone(childNodes[childNodeOffset], clonedManager);
                }
                if (replace) {
                    children.unshift(endNodeManager);
                    children.unshift(startNodeManager);
                    return childNodeOffset + 2;
                }
                return 1;
            };
            /**
             * Initializes both the manager itself and all the controls associated to the manager's
             * INodeMap.
             * @param {plat.processing.INodeMap} nodeMap A map of the nodes (element and attributes)
             * associated with this ElementManager.
             * @param {plat.processing.ElementManager} parent The parent
             * ElementManager.
             * @param {boolean} dontInitialize? Specifies whether or not the initialize method should
             * be called for a TemplateControl if one is attached
             * to this ElementManager.
             */
            ElementManager.prototype.initialize = function (nodeMap, parent, dontInitialize) {
                _super.prototype.initialize.call(this, nodeMap, parent);
                var controlNode = nodeMap.uiControlNode, hasUiControl = !isNull(controlNode), control;
                if (hasUiControl) {
                    this._populateUiControl();
                    control = controlNode.control;
                    this.hasOwnContext = control.hasOwnContext;
                }
                if (nodeMap.hasControl) {
                    ElementManager.createAttributeControls(nodeMap, this.getParentControl(), control);
                }
                if (!dontInitialize && hasUiControl && isFunction(control.initialize)) {
                    control.initialize();
                }
            };
            /**
             * Links the data context to the DOM (data-binding).
             */
            ElementManager.prototype.bind = function () {
                var _this = this;
                var nodeMap = this.nodeMap, parent = this.getParentControl(), controlNode = nodeMap.uiControlNode, controls = [];
                if (!isNull(controlNode)) {
                    var uiControl_1 = controlNode.control, childContext = nodeMap.childContext, getManager = this._ContextManager.getManager, contextManager_1, absoluteContextPath_1 = isNull(parent) ? __CONTEXT : parent.absoluteContextPath, _TemplateControlFactory = this._TemplateControlFactory, inheritsContext = !uiControl_1.hasOwnContext;
                    controls.push(uiControl_1);
                    if (inheritsContext && !isNull(childContext)) {
                        if (childContext[0] === '@') {
                            var split = childContext.split('.'), topIdentifier = split.shift(), alias = topIdentifier.slice(1), resourceObj = _TemplateControlFactory.findResource(uiControl_1, alias);
                            if (isObject(resourceObj)) {
                                var resource = resourceObj.resource;
                                childContext = (split.length > 0 ? ('.' + split.join('.')) : '');
                                if (alias === __CONTEXT_RESOURCE) {
                                    absoluteContextPath_1 += childContext;
                                }
                                else if (alias === __ROOT_CONTEXT_RESOURCE) {
                                    absoluteContextPath_1 = __CONTEXT + childContext;
                                }
                                else if (resource.type === __OBSERVABLE_RESOURCE || resource.type === __LITERAL_RESOURCE) {
                                    absoluteContextPath_1 = 'resources.' + alias + '.value' + childContext;
                                    uiControl_1.root = resourceObj.control;
                                }
                                else {
                                    this._log.warn('Only resources of type "observable" can be set as context.');
                                }
                            }
                            else {
                                this._log.warn('Could not set the context of ' + uiControl_1.type +
                                    ' with the resource specified as "' + childContext + '".');
                            }
                        }
                        else {
                            absoluteContextPath_1 += '.' + childContext;
                        }
                    }
                    if (!isObject(uiControl_1.root)) {
                        uiControl_1.root = this._ControlFactory.getRootControl(uiControl_1) || uiControl_1;
                    }
                    contextManager_1 = getManager(uiControl_1.root);
                    var awaitContext = false;
                    if (inheritsContext) {
                        uiControl_1.context = contextManager_1.getContext(absoluteContextPath_1.split('.'), false);
                        awaitContext = isUndefined(uiControl_1.context) && !this._BindableTemplatesFactory.isBoundControl(uiControl_1);
                    }
                    else {
                        absoluteContextPath_1 = __CONTEXT;
                    }
                    if (awaitContext) {
                        this.contextPromise = new this._Promise(function (resolve, reject) {
                            var removeListener = contextManager_1.observe(absoluteContextPath_1, {
                                uid: uiControl_1.uid,
                                listener: function (newValue, oldValue) {
                                    if (isUndefined(newValue)) {
                                        return;
                                    }
                                    removeListener();
                                    uiControl_1.context = newValue;
                                    _this._beforeLoad(uiControl_1, absoluteContextPath_1);
                                    resolve();
                                }
                            });
                        });
                    }
                    else {
                        this._beforeLoad(uiControl_1, absoluteContextPath_1);
                    }
                }
                this._observeControlIdentifiers(nodeMap.nodes, parent, controls, nodeMap.element);
                return controls;
            };
            /**
             * Sets the template for an manager by obtaining any needed HTML templates and
             * calling its associated TemplateControl's
             * setTemplate method.
             * @param {string} templateUrl? The URL for the associated TemplateControl's
             * HTML template.
             */
            ElementManager.prototype.setUiControlTemplate = function (templateUrl) {
                var _this = this;
                var controlNode = this.nodeMap.uiControlNode;
                if (!isNull(controlNode)) {
                    var control_1 = controlNode.control;
                    this.templatePromise = this._TemplateControlFactory.determineTemplate(control_1, templateUrl).then(function (template) {
                        _this.templatePromise = null;
                        _this._initializeControl(control_1, template.cloneNode(true));
                    }, function (error) {
                        _this.templatePromise = null;
                        if (isNull(error)) {
                            var template = error;
                            if (_this._BindableTemplatesFactory.isBoundControl(control_1)) {
                                template = appendChildren(control_1.element.childNodes);
                            }
                            _this._initializeControl(control_1, template);
                        }
                        else {
                            postpone(function () {
                                if (isString(error)) {
                                    error = new Error(error);
                                }
                                _this._log.error(error);
                            });
                        }
                    });
                    return;
                }
                if (!isNull(this.parent)) {
                    return;
                }
                this.bindAndLoad();
            };
            /**
             * Retrieves the TemplateControl instance
             * associated with this ElementManager.
             */
            ElementManager.prototype.getUiControl = function () {
                var uiControlNode = this.nodeMap.uiControlNode;
                if (isNull(uiControlNode)) {
                    return;
                }
                return uiControlNode.control;
            };
            /**
             * Fullfills any template promises and finishes the compile phase for the HTML template associated
             * with this ElementManager.
             */
            ElementManager.prototype.fulfillTemplate = function () {
                var _this = this;
                if (!isNull(this.templatePromise)) {
                    return this.templatePromise.then(function () {
                        return _this._fulfillChildTemplates();
                    });
                }
                return this._fulfillChildTemplates();
            };
            /**
             * Fulfills the template promise prior to binding and loading the control.
             */
            ElementManager.prototype.fulfillAndLoad = function () {
                var _this = this;
                return this.fulfillTemplate().then(function () {
                    return _this.bindAndLoad();
                }).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            /**
             * Binds context to the DOM and loads controls.
             */
            ElementManager.prototype.bindAndLoad = function () {
                var _this = this;
                var controls = this.bind(), promise;
                if (isPromise(this.contextPromise)) {
                    promise = this.contextPromise.then(function () {
                        return _this._bindChildren();
                    });
                }
                else {
                    promise = this._bindChildren();
                }
                return promise.then(function () {
                    return _this._loadControls(controls, _this.getUiControl());
                }).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            /**
             * Observes the root context for controls that specify their own context, and initiates
             * a load upon a successful set of the context.
             * @param {plat.ui.TemplateControl} root The TemplateControl specifying its own context.
             * @param {() => async.IThenable<void>} loadMethod The function to initiate the loading of the root control and its
             * children.
             */
            ElementManager.prototype.observeRootContext = function (root, loadMethod) {
                var _this = this;
                loadMethod = loadMethod.bind(this);
                if (!isNull(root.context)) {
                    return loadMethod();
                }
                return new this._Promise(function (resolve) {
                    var removeListener = _this._ContextManager.getManager(root).observe(__CONTEXT, {
                        listener: function () {
                            removeListener();
                            loadMethod().then(resolve);
                        },
                        uid: root.uid
                    });
                }).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            /**
             * Finalizes all the properties on an TemplateControl
             * before loading.
             * @param {plat.ui.TemplateControl} uiControl The control to finalize.
             * @param {string} absoluteContextPath The absoluteContextPath of the uiControl.
             */
            ElementManager.prototype._beforeLoad = function (uiControl, absoluteContextPath) {
                var contextManager = this._ContextManager.getManager(uiControl.root), _TemplateControlFactory = this._TemplateControlFactory;
                uiControl.zCC__plat = contextManager.observe(absoluteContextPath, {
                    uid: uiControl.uid,
                    priority: __CONTEXT_CHANGED_PRIORITY,
                    listener: function (newValue, oldValue) {
                        uiControl.context = newValue;
                    }
                });
                _TemplateControlFactory.setAbsoluteContextPath(uiControl, absoluteContextPath);
                _TemplateControlFactory.setContextResources(uiControl);
                ElementManager._ResourcesFactory.bindResources(uiControl.resources);
            };
            /**
             * Binds context to the DOM and calls bindAndLoad on all children.
             */
            ElementManager.prototype._bindChildren = function () {
                var children = this.children, length = children.length, child, promises = [];
                for (var i = 0; i < length; ++i) {
                    child = children[i];
                    if (child.hasOwnContext) {
                        if (this.isClone) {
                            promises.push(child.observeRootContext(child.getUiControl(), child.bindAndLoad));
                        }
                        else {
                            promises.push(child.observeRootContext(child.getUiControl(), child.fulfillAndLoad));
                        }
                    }
                    else if (!isUndefined(child.children)) {
                        promises.push(child.bindAndLoad());
                    }
                    else {
                        child.bind();
                    }
                }
                return this._Promise.all(promises);
            };
            /**
             * Loads the potential attribute based controls associated with this
             * ElementManager and
             * attaches the corresponding TemplateControl if available.
             * @param {Array<plat.AttributeControl>} controls The array of attribute based controls to load.
             * @param {plat.ui.TemplateControl} templateControl The TemplateControl
             * associated with this manager.
             */
            ElementManager.prototype._loadControls = function (controls, templateControl) {
                var length = controls.length, control, load = this._ControlFactory.load, templateControlLoaded = isNull(templateControl), promise, templateControlPriority, i;
                if (templateControlLoaded) {
                    // don't need to set templateControlPriority because it will never be checked. 
                    i = 0;
                }
                else {
                    var priority = templateControl.priority;
                    templateControlPriority = isNumber(priority) ? priority : 100;
                    i = 1;
                }
                for (; i < length; ++i) {
                    control = controls[i];
                    control.templateControl = templateControl;
                    if (!templateControlLoaded && templateControlPriority > control.priority) {
                        templateControlLoaded = true;
                        promise = load(templateControl);
                    }
                    load(control);
                }
                if (!templateControlLoaded) {
                    promise = load(templateControl);
                }
                return promise;
            };
            /**
             * Populates the TemplateControl properties associated with this manager
             * if one exists.
             */
            ElementManager.prototype._populateUiControl = function () {
                var nodeMap = this.nodeMap, parent = this.getParentControl(), controlNode = nodeMap.uiControlNode, uiControl = controlNode.control, uid = uiControl.uid, resources = uiControl.resources, element = nodeMap.element, childNodes = Array.prototype.slice.call(element.childNodes), newAttributes = ElementManager._AttributesFactory.getInstance(), replace = this.replace = (uiControl.replaceWith === null || uiControl.replaceWith === '');
                if (!isString(uid)) {
                    uid = uiControl.uid = uniqueId(__Plat);
                }
                ElementManager._managerCache.put(uid, this);
                if (!isNull(parent) && uiControl.parent !== parent) {
                    parent.controls.push(uiControl);
                    uiControl.parent = parent;
                }
                if (isFunction(element.setAttribute)) {
                    element.setAttribute(__Hide, '');
                }
                uiControl.element = element;
                uiControl.controls = [];
                newAttributes.initialize(uiControl, nodeMap.attributes);
                uiControl.attributes = newAttributes;
                if (isObject(resources) && isFunction(resources.add)) {
                    resources.add(controlNode.resourceElement);
                }
                else {
                    resources = ElementManager._ResourcesFactory.getInstance();
                    resources.initialize(uiControl, controlNode.resourceElement);
                    uiControl.resources = resources;
                }
                ElementManager._ResourcesFactory.addControlResources(uiControl);
                uiControl.type = controlNode.nodeName;
                uiControl.bindableTemplates = uiControl.bindableTemplates || this._BindableTemplatesFactory.create(uiControl);
                if (childNodes.length > 0 && (!isEmpty(uiControl.templateString) || !isEmpty(uiControl.templateUrl))) {
                    uiControl.innerTemplate = appendChildren(childNodes);
                }
                if (replace) {
                    this._replaceElement(uiControl, nodeMap);
                }
            };
            /**
             * Removes the TemplateControl's element. Called if its replaceWith property is
             * null or empty string.
             * @param {plat.ui.TemplateControl} control The TemplateControl whose element
             * will be removed.
             * @param {plat.processing.INodeMap} nodeMap The INodeMap associated with this manager.
             */
            ElementManager.prototype._replaceElement = function (control, nodeMap) {
                var element = nodeMap.element, parentNode = element.parentNode, _document = ElementManager._document, controlType = control.type, controlUid = control.uid, startNode = control.startNode = _document.createComment(controlType + ' ' + controlUid + __START_NODE), endNode = control.endNode = _document.createComment(controlType + ' ' + controlUid + __END_NODE), create = this._CommentManagerFactory.create;
                create(startNode, this);
                create(endNode, this);
                parentNode.insertBefore(startNode, element);
                parentNode.insertBefore(endNode, element.nextSibling);
                control.elementNodes = replace(element);
                control.element = nodeMap.element = null;
            };
            /**
             * Initializes a control's template and compiles the control.
             * @param {plat.ui.TemplateControl} uiControl The TemplateControl
             * associated with this manager.
             * @param {DocumentFragment} template The associated TemplateControl's
             * template.
             */
            ElementManager.prototype._initializeControl = function (uiControl, template) {
                var element = this.nodeMap.element, 
                // have to check if null since isNull checks for undefined case 
                replaceElement = this.replace, endNode;
                if (!isNull(template)) {
                    var resourceElement = ElementManager.locateResources(template);
                    if (!isNull(resourceElement)) {
                        uiControl.resources.add(ElementManager._ResourcesFactory.parseElement(resourceElement));
                    }
                    if (replaceElement) {
                        endNode = uiControl.endNode;
                        uiControl.elementNodes = Array.prototype.slice.call(template.childNodes);
                        insertBefore(endNode.parentNode, template, endNode);
                    }
                    else {
                        insertBefore(element, template, element.lastChild);
                    }
                }
                if (isFunction(uiControl.setTemplate)) {
                    uiControl.setTemplate();
                }
                if (replaceElement) {
                    this._compiler.compile(uiControl.elementNodes, uiControl);
                    var startNode = uiControl.startNode, parentNode = startNode.parentNode, childNodes = Array.prototype.slice.call(parentNode.childNodes);
                    endNode = uiControl.endNode;
                    uiControl.elementNodes = childNodes.slice(childNodes.indexOf(startNode) + 1, childNodes.indexOf(endNode));
                    this.replaceNodeLength = uiControl.elementNodes.length + 2;
                }
                else {
                    this._compiler.compile(element, uiControl);
                }
                if (isNull(uiControl.parent)) {
                    this.fulfillAndLoad();
                }
            };
            /**
             * Observes the identifiers associated with this manager's INodes.
             * @param {Array<plat.processing.INode>} nodes The array of INodes to iterate through.
             * @param {plat.ui.TemplateControl} parent The parent TemplateControl for context.
             * @param {Array<plat.Control>} controls The array of controls whose attributes will need to be updated
             * upon the context changing.
             */
            ElementManager.prototype._observeControlIdentifiers = function (nodes, parent, controls, element) {
                var length = nodes.length, hasParent = !isNull(parent), node, control, i = 0, replace = this.replace, managers = [], manager;
                for (; i < length; ++i) {
                    node = nodes[i];
                    control = node.control;
                    if (hasParent && node.expressions.length > 0) {
                        manager = AttributeManager.getInstance();
                        managers.push(manager);
                        manager.initialize(element, node, parent, controls, replace);
                        NodeManager.observeExpressions(node.expressions, parent, manager.attributeChanged.bind(manager));
                    }
                    if (!isNull(control)) {
                        controls.push(control);
                    }
                }
                length = managers.length;
                for (i = 0; i < length; ++i) {
                    managers[i].attributeChanged();
                }
            };
            /**
             * Runs through all the children of this manager and calls fulfillTemplate.
             */
            ElementManager.prototype._fulfillChildTemplates = function () {
                var _this = this;
                var children = this.children, child, length = children.length, promises = [];
                for (var i = 0; i < length; ++i) {
                    child = children[i];
                    if (!isUndefined(child.children)) {
                        promises.push(child.fulfillTemplate());
                    }
                }
                return this._Promise.all(promises).catch(function (error) {
                    postpone(function () {
                        if (isString(error)) {
                            error = new Error(error);
                        }
                        _this._log.error(error);
                    });
                });
            };
            ElementManager._inject = {
                _Promise: __Promise,
                _ContextManager: __ContextManagerStatic,
                _compiler: __Compiler,
                _CommentManagerFactory: __CommentManagerFactory,
                _ControlFactory: __ControlFactory,
                _TemplateControlFactory: __TemplateControlFactory,
                _BindableTemplatesFactory: __BindableTemplatesFactory,
                _log: __Log
            };
            return ElementManager;
        }(NodeManager));
        processing.ElementManager = ElementManager;
        /**
         */
        function IElementManagerFactory(_document, _managerCache, _ResourcesFactory, _AttributesFactory, _BindableTemplatesFactory, _log) {
            ElementManager._document = _document;
            ElementManager._managerCache = _managerCache;
            ElementManager._ResourcesFactory = _ResourcesFactory;
            ElementManager._AttributesFactory = _AttributesFactory;
            ElementManager._BindableTemplatesFactory = _BindableTemplatesFactory;
            ElementManager._log = _log;
            return ElementManager;
        }
        processing.IElementManagerFactory = IElementManagerFactory;
        register.injectable(__ElementManagerFactory, IElementManagerFactory, [
            __Document,
            __ManagerCache,
            __ResourcesFactory,
            __AttributesFactory,
            __BindableTemplatesFactory,
            __Log
        ], __FACTORY);
        register.injectable(__ElementManagerInstance, ElementManager, null, __INSTANCE);
        /**
         * The class responsible for initializing and data-binding values to text nodes.
         */
        var TextManager = (function (_super) {
            __extends(TextManager, _super);
            function TextManager() {
                _super.apply(this, arguments);
                /**
                 * Specifies the type for this NodeManager.
                 * It's value is "text".
                 */
                this.type = 'text';
            }
            /**
             * Determines if a text node has markup, and creates a TextManager if it does.
             * An TextManager responsible for markup in the passed in node or an empty
             * TextManager if not markup is found will be added to the managers array.
             * @param {Node} node The Node used to find markup.
             * @param {plat.processing.ElementManager} parent The parent ElementManager
             * for the node.
             */
            TextManager.create = function (node, parent) {
                var value = node.nodeValue, manager = new TextManager();
                if (NodeManager.hasMarkup(value)) {
                    var expressions_1 = NodeManager.findMarkup(value), map_1 = {
                        nodes: [{
                                node: node,
                                expressions: expressions_1
                            }]
                    };
                    manager.initialize(map_1, parent);
                    return manager;
                }
                manager.initialize(null, parent);
                manager.bind = noop;
                return manager;
            };
            /**
             * Clones an INodeMap with a new text node.
             * @param {plat.processing.INodeMap} sourceMap The original INodeMap.
             * @param {Node} newNode The new text node used for cloning.
             */
            TextManager._cloneNodeMap = function (sourceMap, newNode) {
                var node = sourceMap.nodes[0], nodeMap = {
                    nodes: [{
                            expressions: node.expressions,
                            nodeName: node.nodeName,
                            node: newNode
                        }]
                };
                return nodeMap;
            };
            /**
             * Clones a TextManager with a new text node.
             * @param {plat.processing.NodeManager} sourceManager The original NodeManager.
             * @param {Node} node The new text node to associate with the clone.
             * @param {plat.processing.ElementManager} parent The parent ElementManager
             * for the new clone.
             */
            TextManager._clone = function (sourceManager, node, parent) {
                var map = sourceManager.nodeMap, manager = new TextManager();
                if (!isNull(map)) {
                    manager.initialize(TextManager._cloneNodeMap(map, node), parent);
                }
                else {
                    manager.initialize(null, parent);
                    manager.bind = noop;
                }
                return manager;
            };
            /**
             * Clones this TextManager with a new node.
             * @param {Node} newNode The new node attached to the cloned TextManager.
             * @param {plat.processing.ElementManager} parentManager The parent ElementManager
             * for the clone.
             */
            TextManager.prototype.clone = function (newNode, parentManager) {
                TextManager._clone(this, newNode, parentManager);
                return 1;
            };
            /**
             * The function used for data-binding a data context to the DOM.
             */
            TextManager.prototype.bind = function () {
                var parent = this.getParentControl(), node = this.nodeMap.nodes[0], textNode = node.node, expressions = node.expressions;
                NodeManager.observeExpressions(node.expressions, parent, this._setText.bind(this, textNode, parent, expressions));
                this._setText(textNode, parent, expressions);
            };
            /**
             * Builds the node expression and sets the value.
             * @param {Node} Node The associated node whose value will be set.
             * @param {plat.ui.TemplateControl} control The control whose context will be used to bind
             * the data.
             * @param {Array<plat.expressions.IParsedExpression>} expressions An array of parsed expressions used to build
             * the node value.
             */
            TextManager.prototype._setText = function (node, control, expressions) {
                node.nodeValue = NodeManager.build(expressions, (control || {}));
            };
            return TextManager;
        }(NodeManager));
        processing.TextManager = TextManager;
        /**
         */
        function ITextManagerFactory() {
            return TextManager;
        }
        processing.ITextManagerFactory = ITextManagerFactory;
        register.injectable(__TextManagerFactory, ITextManagerFactory, null, __FACTORY);
        register.injectable(__TextManagerInstance, TextManager, null, __INSTANCE);
        /**
         * A class used to manage Comment nodes. Provides a way to
         * clone a Comment node.
         */
        var CommentManager = (function (_super) {
            __extends(CommentManager, _super);
            function CommentManager() {
                _super.apply(this, arguments);
                /**
                 * Specifies the type for this NodeManager.
                 * It's value is "comment".
                 */
                this.type = 'comment';
            }
            /**
             * Creates a new CommentManager for the given Comment node.
             * @param {Node} node The Comment to associate with the new manager.
             * @param {plat.processing.ElementManager} parent The parent
             * ElementManager.
             */
            CommentManager.create = function (node, parent) {
                var manager = new CommentManager();
                manager.initialize({
                    nodes: [{
                            node: node
                        }]
                }, parent);
                return manager;
            };
            /**
             * A method for cloning this manager with a new Comment.
             * @param {Node} newNode The new Comment node to associate with the cloned
             * manager.
             * @param {plat.processing.ElementManager} parentManager The parent ElementManager
             * for the clone.
             */
            CommentManager.prototype.clone = function (newNode, parentManager) {
                CommentManager.create(newNode, parentManager);
                return 1;
            };
            return CommentManager;
        }(NodeManager));
        processing.CommentManager = CommentManager;
        /**
         */
        function ICommentManagerFactory() {
            return CommentManager;
        }
        processing.ICommentManagerFactory = ICommentManagerFactory;
        register.injectable(__CommentManagerFactory, ICommentManagerFactory, null, __FACTORY);
        register.injectable(__CommentManagerInstance, CommentManager, null, __INSTANCE);
        /**
         * Used to facilitate observing expressions on attributes. Has the ability to alert Attributes
         * with changes. Handles dynamic and static attributes (dynamic meaning "class"-like attributes).
         */
        var AttributeManager = (function () {
            function AttributeManager() {
                /**
                 * A regular expression for finding markup in a string.
                 */
                this._markupRegex = new RegExp("^" + __startSymbol + "[\\S\\s]*?" + __endSymbol + "\\S*\\s*|\\s*\\S*" + __startSymbol + "[\\S\\s]*?" + __endSymbol + "\\S*", 'g');
                /**
                 * Keeps track of the previous bound values of a "dynamic" attribute.
                 */
                this._lastValues = {};
            }
            /**
             * Returns a new instance of an AttributeManager.
             */
            AttributeManager.getInstance = function () {
                var manager = new AttributeManager();
                manager._NodeManager = acquire(__NodeManagerStatic);
                return manager;
            };
            /**
             * Initializes the manager and determines what method should be used to handle attribute changes.
             * @param {HTMLElement} element The element that contains this attribute.
             * @param {plat.processing.INode} node The INode associated with this attribute.
             * @param {plat.ui.TemplateControl} parent The parent control for all the controls associated with
             * the element.
             * @param {Array<plat.Control>} controls The controls associated with the element.
             * @param {boolean} replace? Whether or not the element is replaced.
             */
            AttributeManager.prototype.initialize = function (element, node, parent, controls, replace) {
                this.element = element;
                this.node = node;
                this.parent = parent;
                this._controls = controls;
                this.replace = replace;
                if (node.nodeName !== 'class') {
                    this.attributeChanged = this._staticAttributeChanged;
                }
                else {
                    this.attributeChanged = this._dynamicAttributeChanged;
                }
            };
            /**
             * Handles changes to dynamic attributes. Takes into account that the attribute may have been changed programmatically, and
             * we need to only mutate the piece of the attribute corresponding to expressions with markup.
             */
            AttributeManager.prototype._dynamicAttributeChanged = function () {
                var node = this.node, attr = node.node, nodeValue = attr.value, classes = this._NodeManager.build(node.expressions, this.parent).trim().split(/\s/), last = this._lastValues, element = this.element, c, length = classes.length, i;
                if (this._NodeManager.hasMarkup(nodeValue)) {
                    attr.value = nodeValue.replace(this._markupRegex, '').trim();
                }
                for (i = 0; i < length; ++i) {
                    last[classes[i]] = true;
                }
                classes = Object.keys(last);
                length = classes.length;
                for (i = 0; i < length; ++i) {
                    c = classes[i];
                    if (last[c]) {
                        addClass(element, c);
                        last[c] = false;
                    }
                    else {
                        deleteProperty(last, c);
                        removeClass(element, c);
                    }
                }
                this._notifyAttributes(node.nodeName, attr.value);
            };
            /**
             * Handles changes to static attributes. Builds a string from the node expressions, then sets the attribute value
             * and notifies the associated Attributes.
             */
            AttributeManager.prototype._staticAttributeChanged = function () {
                var controls = this._controls, node = this.node, key = camelCase(node.nodeName), value = this._NodeManager.build(node.expressions, this.parent);
                this._notifyAttributes(key, value);
                if (!this.replace) {
                    node.node.value = value;
                }
            };
            /**
             * Notifies the necessary Attributes of changes to an attribute.
             */
            AttributeManager.prototype._notifyAttributes = function (key, value) {
                var controls = this._controls, length = controls.length, attributes, oldValue;
                for (var i = 0; i < length; ++i) {
                    attributes = controls[i].attributes;
                    oldValue = attributes[key];
                    attributes[key] = value;
                    attributes._attributeChanged(key, value, oldValue);
                }
            };
            return AttributeManager;
        }());
        processing.AttributeManager = AttributeManager;
    })(processing = plat_1.processing || (plat_1.processing = {}));
    /**
     * Holds all classes and interfaces related to routing components in platypus.
     */
    var routing;
    (function (routing) {
        /**
         * Ties the browser and routers together, facilitating app navigation at every router level.
         * Listens for url changes and responds accordingly. Also contains functionality for generating
         * and changing the url.
         */
        var Navigator = (function () {
            function Navigator() {
                /**
                 * A unique id, created during instantiation and found on every Navigator.
                 */
                this.uid = uniqueId(__Plat);
                /**
                 * States whether or not the Navigator is the root Navigator.
                 */
                this.isRoot = false;
                /**
                 * A method to call to stop listening for url changes, only works on the root navigator.
                 */
                this._removeUrlListener = noop;
                /**
                 * A method to call to stop listening for url changes, only works on the root navigator.
                 */
                this._ignoreOnce = false;
                /**
                 * Whether or not the current navigation is a backward navigation
                 */
                this._backNavigate = false;
            }
            /**
             * Initializes this Navigator with a router.
             * @param {plat.routing.Router} router The router that the navigator should use to match/generate routes.
             */
            Navigator.prototype.initialize = function (router) {
                this._router = router;
                if (isObject(router) && router.isRoot && !isObject(Navigator._root)) {
                    this.isRoot = true;
                    Navigator._root = this;
                    this._observeUrl();
                }
            };
            /**
             * Tells the navigator to navigate to the url registered for a particular view.
             * @param {any} view The view to which the Navigator should navigate.
             * @param {plat.routing.INavigateOptions} options used to generate the url and perform navigation.
             */
            Navigator.prototype.navigate = function (view, options) {
                var _this = this;
                options = isObject(options) ? options : {};
                var url;
                return this.finishNavigating().then(function () {
                    if (options.isUrl) {
                        url = view;
                    }
                    else {
                        url = _this._generate(view, options.parameters, options.query);
                    }
                    if (!isString(url)) {
                        var error = new Error('Cannot serialize url from input parameters, check your view reference.');
                        _this._log.error(error);
                    }
                    return _this._navigate(url, options.replace);
                });
            };
            /**
             * Returns a promise that resolves when all navigation has finished.
             */
            Navigator.prototype.finishNavigating = function () {
                var router = Navigator._root._router;
                if (router.navigating) {
                    return router.finishNavigating.catch(noop);
                }
                return this._Promise.resolve();
            };
            /**
             * Tells the router to go back with the given options.
             */
            Navigator.prototype.goBack = function (options) {
                var _this = this;
                options = isObject(options) ? options : {};
                var length = Number(options.length);
                if (!isNumber(length)) {
                    length = 1;
                }
                if (!this.isRoot) {
                    return Navigator._root.goBack(options);
                }
                return this.finishNavigating().then(function () {
                    _this._backNavigate = true;
                    return _this._goBack(length);
                });
            };
            /**
             * Indicates whether or not the current navigation is a backward navigation.
             */
            Navigator.prototype.isBackNavigation = function () {
                if (!this.isRoot) {
                    return Navigator._root.isBackNavigation();
                }
                return this._backNavigate;
            };
            /**
             * Lets the router dispose of all of the necessary properties.
             */
            Navigator.prototype.dispose = function () {
                this._removeUrlListener();
                deleteProperty(this, 'router');
            };
            /**
             * Internal method for navigating to the specified url.
             */
            Navigator.prototype._navigate = function (url, replace) {
                var _this = this;
                if (!this.isRoot) {
                    return Navigator._root._navigate(url, replace);
                }
                return new this._Promise(function (resolve, reject) {
                    _this._resolveNavigate = resolve;
                    _this._rejectNavigate = reject;
                    var current = _this._browser.url(), next = _this._browser.url(url, replace);
                    if (current === next) {
                        _this._resolveNavigate();
                    }
                });
            };
            /**
             * Internal method for going back a certain length in history
             */
            Navigator.prototype._goBack = function (length) {
                var _this = this;
                return new this._Promise(function (resolve, reject) {
                    _this._resolveNavigate = resolve;
                    _this._rejectNavigate = reject;
                    _this._browser.back(length);
                });
            };
            /**
             * The root navigator will always observe for url changes and handle them accordingly. This means instructing the
             * router to navigate, and determining what to do in the event that navigation is prevented.
             */
            Navigator.prototype._observeUrl = function () {
                var _this = this;
                if (!isObject(this._router)) {
                    return;
                }
                var EventManager = this._EventManager, previousUrl, headControl = acquire(__Head), headExists = isObject(headControl) && isFunction(headControl.navigated), onFailedNavigaton = function (e) {
                    _this._previousUrl = previousUrl;
                    var _history = _this._history, state = _history.state;
                    _this._ignoreOnce = true;
                    if (isNull(state.previousLocation) || state.previousLocation === previousUrl) {
                        _history.go(-1);
                    }
                    else {
                        _history.go(1);
                    }
                    _this._backNavigate = false;
                    if (isFunction(_this._rejectNavigate)) {
                        _this._rejectNavigate(e);
                    }
                    if (!isEmpty(e)) {
                        _this._log.warn(e);
                    }
                };
                this._previousUrl = this._browser.url();
                // Protect against accidentally calling this method twice. 
                EventManager.dispose(this.uid);
                EventManager.on(this.uid, __backButton, function () {
                    var ev = EventManager.dispatch(__backButtonPressed, _this, EventManager.DIRECT);
                    if (ev.defaultPrevented) {
                        return;
                    }
                    _this.goBack();
                });
                EventManager.on(this.uid, __urlChanged, function (ev, utils) {
                    if (_this._ignoreOnce) {
                        _this._ignoreOnce = false;
                        if (isFunction(_this._resolveNavigate)) {
                            _this._backNavigate = false;
                            _this._resolveNavigate();
                        }
                        return;
                    }
                    previousUrl = _this._previousUrl;
                    ev = EventManager.dispatch(__beforeNavigate, _this, EventManager.DIRECT, [utils]);
                    if (ev.defaultPrevented) {
                        onFailedNavigaton(new Error('Navigation prevented during ' + __beforeNavigate + ' event'));
                        return;
                    }
                    _this.finishNavigating()
                        .then(function () {
                        EventManager.dispatch(__navigating, _this, EventManager.DIRECT, [utils]);
                        return _this._router.navigate(utils.pathname, utils.query);
                    }).then(function () {
                        _this._previousUrl = utils.pathname;
                        if (isFunction(_this._resolveNavigate)) {
                            _this._backNavigate = false;
                            _this._resolveNavigate();
                        }
                        if (headExists) {
                            headControl.navigated(utils.href);
                        }
                        EventManager.dispatch(__navigated, _this, EventManager.DIRECT, [utils]);
                    }, onFailedNavigaton);
                });
            };
            /**
             * Generates a url with the given view, parameters, and query.
             */
            Navigator.prototype._generate = function (view, parameters, query) {
                if (isNull(this._router)) {
                    return;
                }
                if (isEmpty(view)) {
                    return view;
                }
                return this._router.generate(view, parameters, query);
            };
            Navigator._inject = {
                _Promise: __Promise,
                _Injector: __InjectorStatic,
                _browserConfig: __BrowserConfig,
                _browser: __Browser,
                _EventManager: __EventManagerStatic,
                _window: __Window,
                _log: __Log,
                _history: __History
            };
            return Navigator;
        }());
        routing.Navigator = Navigator;
        register.injectable(__NavigatorInstance, Navigator, null, __INSTANCE);
        /**
         */
        function History(_window) {
            return _window.history;
        }
        routing.History = History;
        register.injectable(__History, History, [__Window]);
        var specialCharacters = [
            '/', '.', '*', '+', '?', '|',
            '(', ')', '[', ']', '{', '}', '\\'
        ], escapeRegex = new RegExp('(\\' + specialCharacters.join('|\\') + ')', 'g');
        var baseSegment, dynamicSegments = {}, splatSegments = {}, staticSegments = {};
        /**
         * Stores information about a segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var BaseSegment = (function () {
            function BaseSegment() {
                /**
                 * Denotes the type of segment for this instance.
                 */
                this.type = __BASE_SEGMENT_TYPE;
                /**
                 * The name of the segment.
                 */
                this.name = '';
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this.regex = '';
            }
            /**
             * Parses a route into segments, populating an array of names (for dynamic and splat segments) as well as
             * an ISegmentTypeCount object.
             * @param {string} route The route to parse.
             * @param {Array<string>} names An array to populate with dynamic/splat segment names
             * @param {plat.routing.ISegmentTypeCount} types An object to use for counting segment types in the route.
             */
            BaseSegment.parse = function (route, names, types) {
                if (!isString(route) || !isArray(names) || !isObject(types)) {
                    return [];
                }
                else if (route[0] === '/') {
                    route = route.slice(1);
                }
                var segments = route.split('/'), length = segments.length, findSegment = BaseSegment.__findSegment, results = [], segment, name, match, _regex = BaseSegment._regex;
                for (var i = 0; i < length; ++i) {
                    segment = segments[i];
                    if (segment === '') {
                        if (!isObject(baseSegment)) {
                            baseSegment = acquire(__BaseSegmentInstance);
                        }
                        results.push(baseSegment);
                    }
                    else if (match = segment.match(_regex.dynamicSegmentsRegex)) {
                        name = match[1];
                        results.push(findSegment(name, __DynamicSegmentInstance, dynamicSegments));
                        names.push(name);
                        types.dynamics++;
                    }
                    else if (match = segment.match(_regex.splatSegmentRegex)) {
                        name = match[1];
                        results.push(findSegment(name, __SplatSegmentInstance, splatSegments));
                        names.push(name);
                        types.splats++;
                    }
                    else {
                        results.push(findSegment(segment, __StaticSegmentInstance, staticSegments));
                        types.statics++;
                    }
                }
                return results;
            };
            /**
             * Parses a route into segments, populating an array of names (for dynamic and splat segments) as well as
             * an ISegmentTypeCount object.
             * @param {string} name The name of the segment to look for.
             * @param {string} token The token used to acquire a new segment if necessary.
             * @param {plat.IObject<plat.routing.BaseSegment>} cache The cache in which to look for/store the segment.
             */
            BaseSegment.__findSegment = function (name, token, cache) {
                var segment = cache[name];
                if (!isObject(segment)) {
                    segment = cache[name] = acquire(token);
                    segment.initialize(name);
                }
                return segment;
            };
            /**
             * Initializes the segment.
             * @param {string} name? The name for the new segment.
             */
            BaseSegment.prototype.initialize = function (name) {
                this.name = name;
            };
            /**
             * Iterates over the characters in the segment, calling an iterator method and accumulating the result of each call in
             * a defined object.
             * @param {(previousValue: T, spec: plat.routing.ICharacterSpecification) => T} iterator The iterator to call with each character.
             * @param {T} initialValue? An optional initial value with which to start the accumulation.
             */
            BaseSegment.prototype.reduceCharacters = function (iterator, initialValue) {
                if (isObject(this._specification)) {
                    initialValue = iterator(initialValue, this._specification);
                }
                return initialValue;
            };
            /**
             * Generates a new segment, using the input parameters if necessary.
             * @param {plat.IObject<string>} parameters? The input parameters for the segment.
             */
            BaseSegment.prototype.generate = function (parameters) {
                return this.name;
            };
            return BaseSegment;
        }());
        routing.BaseSegment = BaseSegment;
        /**
         */
        function IBaseSegmentFactory(_regex) {
            BaseSegment._regex = _regex;
            return BaseSegment;
        }
        routing.IBaseSegmentFactory = IBaseSegmentFactory;
        register.injectable(__BaseSegmentFactory, IBaseSegmentFactory, [__Regex], __FACTORY);
        register.injectable(__BaseSegmentInstance, BaseSegment, null, __INSTANCE);
        /**
         * Stores information about a static segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var StaticSegment = (function (_super) {
            __extends(StaticSegment, _super);
            function StaticSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a static segment.
                 */
                this.type = __STATIC_SEGMENT_TYPE;
            }
            /**
             * Initializes the segment.
             * @param {string} name? The name for the new segment.
             */
            StaticSegment.prototype.initialize = function (name) {
                _super.prototype.initialize.call(this, name);
                this.regex = this.name.replace(escapeRegex, '\\$1');
            };
            /**
             * Iterates over the characters in the segment, calling an iterator method and accumulating the result of each call in
             * a defined object.
             * @param {(previousValue: T, spec: plat.routing.ICharacterSpecification) => T} iterator The iterator to call with each character.
             * @param {T} initialValue? An optional initial value with which to start the accumulation.
             */
            StaticSegment.prototype.reduceCharacters = function (iterator, initialValue) {
                var name = this.name, length = name.length, value = initialValue;
                for (var i = 0; i < length; ++i) {
                    value = iterator(value, { validCharacters: name[i] });
                }
                return value;
            };
            return StaticSegment;
        }(BaseSegment));
        routing.StaticSegment = StaticSegment;
        register.injectable(__StaticSegmentInstance, StaticSegment, null, __INSTANCE);
        /**
         * Stores information about a variable segment (either dynamic or splat), publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var VariableSegment = (function (_super) {
            __extends(VariableSegment, _super);
            function VariableSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a variable segment.
                 */
                this.type = __VARIABLE_SEGMENT_TYPE;
            }
            /**
             * Generates a new segment, using the input parameters.
             * @param {plat.IObject<string>} parameters? The input parameters for the segment.
             */
            VariableSegment.prototype.generate = function (parameters) {
                if (isObject(parameters)) {
                    return parameters[this.name];
                }
            };
            return VariableSegment;
        }(BaseSegment));
        routing.VariableSegment = VariableSegment;
        register.injectable(__VariableSegmentInstance, VariableSegment, null, __INSTANCE);
        /**
         * Stores information about a splat segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var SplatSegment = (function (_super) {
            __extends(SplatSegment, _super);
            function SplatSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a splat segment.
                 */
                this.type = __SPLAT_SEGMENT_TYPE;
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this.regex = '(.+)';
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this._specification = {
                    invalidCharacters: '',
                    repeat: true
                };
            }
            return SplatSegment;
        }(VariableSegment));
        routing.SplatSegment = SplatSegment;
        register.injectable(__SplatSegmentInstance, SplatSegment, null, __INSTANCE);
        /**
         * Stores information about a dynamic segment, publishes a regex for matching the segment as well as
         * methods for generating the segment and iterating over the characters in the segment.
         */
        var DynamicSegment = (function (_super) {
            __extends(DynamicSegment, _super);
            function DynamicSegment() {
                _super.apply(this, arguments);
                /**
                 * Denotes that this is a dynamic segment.
                 */
                this.type = __DYNAMIC_SEGMENT_TYPE;
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this.regex = '([^/]+)';
                /**
                 * A regular expression string which can be used to match the segment.
                 */
                this._specification = {
                    invalidCharacters: '/',
                    repeat: true
                };
            }
            return DynamicSegment;
        }(VariableSegment));
        routing.DynamicSegment = DynamicSegment;
        register.injectable(__DynamicSegmentInstance, DynamicSegment, null, __INSTANCE);
        /**
         * Route segment matching is done using a state machine. Each state contains
         * a specification indicating valid and invalid characters. Each State has a
         * list of potential next states. When matching a route segment you start with
         * a root state and then iteratively match next states until you complete the
         * segment or invalidate the segment.
         */
        var State = (function () {
            /**
             * The constructor for a State.
             */
            function State() {
                this.initialize();
            }
            /**
             * Compiles a segment into a state tree.
             * @param {plat.routing.BaseSegment} segment The segment to compile.
             * @param {plat.routing.State} state The initial state with which to start compilation.
             */
            State.compile = function (segment, state) {
                return segment.reduceCharacters(function (s, char) {
                    return s.add(char);
                }, state);
            };
            /**
             * Links a path to a compiled state, and returns the result.
             * @param {plat.routing.State} state The state with which to link the result.
             * @param {string} path The path to link to the given state.
             */
            State.link = function (state, path) {
                var delegates = state.delegates, regex = state.regex, length = delegates.length, matches = path.match(regex), matchIndex = 1, result = [], names, parameters, j, jLength, delegate;
                for (var i = 0; i < length; ++i) {
                    delegate = delegates[i];
                    names = delegate.names;
                    parameters = {};
                    for (j = 0, jLength = names.length; j < jLength; ++j) {
                        parameters[names[j]] = matches[matchIndex++];
                    }
                    result.push({
                        delegate: delegate.delegate,
                        parameters: parameters,
                        isDynamic: jLength > 0
                    });
                }
                return result;
            };
            /**
             * Finds all the next states for a given character.
             * @param {string} char The character used to match next states.
             * @param {Array<plat.routing.State>} states The states with which to match the character.
             */
            State.recognize = function (char, states) {
                var nextStates = [], length = states.length, state;
                for (var i = 0; i < length; ++i) {
                    state = states[i];
                    nextStates = nextStates.concat(state.match(char));
                }
                return nextStates;
            };
            /**
             * Sorts states by statics/dynamics/splats.
             * @param {Array<plat.routing.State>} states The states to sort.
             */
            State.sort = function (states) {
                if (!isArray(states)) {
                    return states;
                }
                var aTypes, aSplats, aStatics, aDynamics, bTypes, bSplats, bStatics, bDynamics;
                return states.sort(function (a, b) {
                    aTypes = a.types;
                    bTypes = b.types;
                    aSplats = aTypes.splats;
                    bSplats = bTypes.splats;
                    if (aSplats !== bSplats) {
                        return aSplats - bSplats;
                    }
                    aStatics = aTypes.statics;
                    aDynamics = aTypes.dynamics;
                    bStatics = bTypes.statics;
                    bDynamics = bTypes.dynamics;
                    if (aSplats > 0) {
                        if (aStatics !== bStatics) {
                            return bStatics - aStatics;
                        }
                        if (aDynamics !== bDynamics) {
                            return bDynamics - aDynamics;
                        }
                    }
                    if (aDynamics !== bDynamics) {
                        return aDynamics - bDynamics;
                    }
                    if (aStatics !== bStatics) {
                        return bStatics = aStatics;
                    }
                    return 0;
                });
            };
            /**
             * Initializes the state with the given specification.
             * @param {plat.routing.ICharacterSpecification} specification? The character specification for the state.
             */
            State.prototype.initialize = function (specification) {
                this.specification = specification;
                this.nextStates = [];
            };
            /**
             * Adds a new specification to the next states. If the specification
             * already exists as a next state a new one won't be used.
             * @param {plat.routing.ICharacterSpecification} specification? The character specification used to create
             * the next state if necessary.
             */
            State.prototype.add = function (specification) {
                var state = this._find(specification);
                if (isObject(state)) {
                    return state;
                }
                state = acquire(State);
                state.initialize(specification);
                this.nextStates.push(state);
                if (specification.repeat) {
                    state.nextStates.push(state);
                }
                return state;
            };
            /**
             * Finds next states that match the input character. If the character exists
             * in the state's specification for valid characters, or if it does not
             * exist in the specification for invalid characters, then the state is considered
             * a match.
             * @param {string} char The character with which to match next states.
             */
            State.prototype.match = function (char) {
                var matches = [], spec, chars;
                this._someChildren(function (child) {
                    spec = child.specification;
                    // Check for valid characters first 
                    chars = spec.validCharacters;
                    if (isString(chars) && chars.indexOf(char) > -1) {
                        matches.push(child);
                        return;
                    }
                    // Check for no invalid characters 
                    chars = spec.invalidCharacters;
                    if (isString(chars) && chars.indexOf(char) === -1) {
                        matches.push(child);
                    }
                });
                return matches;
            };
            /**
             * Finds the next state that shares the same specification
             * as the input spec.
             * @param {plat.routing.ICharacterSpecification} spec The character specification used to find
             * the next state.
             */
            State.prototype._find = function (spec) {
                var validChars = spec.validCharacters, invalidChars = spec.invalidCharacters, s, found;
                this._someChildren(function (child) {
                    s = child.specification;
                    if (s.validCharacters === validChars &&
                        s.invalidCharacters === invalidChars) {
                        found = child;
                        return true;
                    }
                });
                return found;
            };
            State.prototype._someChildren = function (iterator) {
                var nextStates = this.nextStates, length = nextStates.length;
                for (var i = 0; i < length; ++i) {
                    if (iterator(nextStates[i]) === true) {
                        return true;
                    }
                }
                return false;
            };
            return State;
        }());
        routing.State = State;
        /**
         */
        function IStateStatic() {
            return State;
        }
        routing.IStateStatic = IStateStatic;
        register.injectable(__StateStatic, IStateStatic, null, __STATIC);
        register.injectable(__StateInstance, State, null, __INSTANCE);
        /**
         * Assists in compiling and linking route strings. You can register route strings using
         * a defined scheme, and it will compile the routes. When you want to match a route, it will
         * find the associated compiled route and link it to the data given with the passed-in route.
         */
        var RouteRecognizer = (function () {
            function RouteRecognizer() {
                /**
                 * All the named routes for this recognizer.
                 */
                this._namedRoutes = {};
            }
            /**
             * A method for registering routes to be identified later. Internally the
             * routes will be compiled into a series of states
             * which will be used to recognize the route later.
             * @param {Array<plat.routing.IRouteDelegate>} routes The routes to register.
             * @param {plat.routing.IRegisterOptions} options? An object containing options for the
             * registered route.
             */
            RouteRecognizer.prototype.register = function (routes, options) {
                if (!isArray(routes)) {
                    return;
                }
                var finalState = this._rootState, length = routes.length, regex = ['^'], types = {
                    statics: 0,
                    dynamics: 0,
                    splats: 0
                }, delegates = [], allSegments = [], segments;
                for (var i = 0; i < length; ++i) {
                    segments = this._parse(routes[i], delegates, types);
                    allSegments = allSegments.concat(segments);
                    finalState = this._compile(segments, finalState, regex);
                }
                finalState = this._finalize(finalState, regex);
                finalState.delegates = delegates;
                finalState.regex = new RegExp(regex.join('') + '$');
                finalState.types = types;
                if (isObject(options) && isString(options.name)) {
                    this._namedRoutes[this._toLowerCase(options.name)] = {
                        segments: allSegments,
                        delegates: delegates
                    };
                }
            };
            /**
             * Searches for a match to the provided path. If a match is found, the path is deconstructed
             * to populate a parameters object (if the registered route was a dynamic/splat route).
             * @param {string} path The path to recognize.
             */
            RouteRecognizer.prototype.recognize = function (path) {
                var isTrailingSlashDropped = false, solutions = [];
                path = this._addLeadingSlash(path);
                isTrailingSlashDropped = this._hasTrailingSlash(path);
                if (isTrailingSlashDropped) {
                    path = path.substr(0, path.length - 1);
                }
                solutions = this._filter(this._findStates(path));
                return this._link(solutions[0], path, isTrailingSlashDropped);
            };
            /**
             * Finds a INamedRoute and generates a string
             * if it exists. Uses the parameters object to generate dynamic routes.
             * @param {string} name The named route with which to generate the route string.
             * @param {plat.IObject<string>} parameters The route parameters, in the case that the
             * named route is dynamic.
             */
            RouteRecognizer.prototype.generate = function (name, parameters) {
                name = this._toLowerCase(name);
                var route = this._namedRoutes[name], output = '', segments, length;
                if (!isObject(route)) {
                    return;
                }
                segments = route.segments;
                length = segments.length;
                for (var i = 0; i < length; i++) {
                    var segment = segments[i];
                    if (segment.type === __BASE_SEGMENT_TYPE) {
                        continue;
                    }
                    output += '/';
                    output += segment.generate(parameters);
                }
                output = this._addLeadingSlash(output);
                return output;
            };
            /**
             * Finds the delegates for an INamedRoute
             * @param {string} name The named route from which to get the delegates.
             */
            RouteRecognizer.prototype.delegatesFor = function (name) {
                name = this._toLowerCase(name);
                var namedRoute = this._namedRoutes[name], delegates;
                if (!isObject(namedRoute)) {
                    return [];
                }
                delegates = namedRoute.delegates;
                if (!isArray(delegates)) {
                    return [];
                }
                return delegates.slice(0);
            };
            /**
             * Determines whether or not an INamedRoute is registered.
             * @param {string} name The named route to search for.
             */
            RouteRecognizer.prototype.exists = function (name) {
                return isObject(this._namedRoutes[this._toLowerCase(name)]);
            };
            /**
             * Safely converts a string to lower case.
             * @param {string} str The string to convert to lower case.
             */
            RouteRecognizer.prototype._toLowerCase = function (str) {
                if (!isString(str)) {
                    return str;
                }
                return str.toLowerCase();
            };
            /**
             * Finalizes a compiled route, adding a final state if necessary. If the state is equal to the
             * root state for the recognizer, a new state will be created. This is because the root state does not
             * represent any route.
             * @param {plat.routing.State} state The state to finalize.
             * @param {string} regex The regular expression string built for the compiled routes. Used to recognize
             * routes and associate them with the compiled routes.
             */
            RouteRecognizer.prototype._finalize = function (state, regex) {
                if (state === this._rootState) {
                    state = state.add({
                        validCharacters: '/'
                    });
                    regex.push('/');
                }
                return state;
            };
            /**
             * Parses a route into different segments;
             * @param {plat.routing.IRouteDelegate} route The route options to be parsed.
             * @param {Array<plat.routing.IDelegateParameterNames>} delegates The delegates and associated names for mapping parameters.
             * @param {plat.routing.ISegmentTypeCount} types A count of all the segment types in the route.
             */
            RouteRecognizer.prototype._parse = function (route, delegates, types) {
                var names = [];
                delegates.push({
                    delegate: route.delegate,
                    names: names
                });
                return this._BaseSegmentFactory.parse(route.pattern, names, types);
            };
            /**
             * Compiles a list of segments into a series of states.
             * @param {Array<plat.routing.BaseSegment>} segments The segments to compile.
             * @param {plat.routing.State} state The initial state used to compile.
             * @param {Array<string>} regex A regular expression string to build in order to match the segments.
             */
            RouteRecognizer.prototype._compile = function (segments, state, regex) {
                var length = segments.length, compile = this._State.compile, segment;
                for (var i = 0; i < length; ++i) {
                    segment = segments[i];
                    if (segment.type === __BASE_SEGMENT_TYPE) {
                        continue;
                    }
                    state = state.add({ validCharacters: '/' });
                    state = compile(segment, state);
                    regex.push('/' + segment.regex);
                }
                return state;
            };
            /**
             * Adds a leading slash to the passed-in string if necessary.
             * @param {string} path The path to which to add the slash.
             */
            RouteRecognizer.prototype._addLeadingSlash = function (path) {
                path = decodeURI(path);
                if (path[0] !== '/') {
                    path = '/' + path;
                }
                return path;
            };
            /**
             * Checks for a trailing slash on a given string.
             * @param {string} path The path on which to look for a trailing slash.
             */
            RouteRecognizer.prototype._hasTrailingSlash = function (path) {
                var length = path.length;
                return length > 1 && path[length - 1] === '/';
            };
            /**
             * Finds the compiled states for a given path.
             * @param {string} path The path with which to look for compiled states.
             */
            RouteRecognizer.prototype._findStates = function (path) {
                var states = [
                    this._rootState
                ], recognize = this._State.recognize, length = path.length;
                for (var i = 0; i < length; ++i) {
                    states = recognize(path[i], states);
                    if (states.length === 0) {
                        break;
                    }
                }
                return states;
            };
            /**
             * Filters out states with no delegates, and sorts the states.
             * @param {Array<plat.routing.State>} states The states to filter.
             */
            RouteRecognizer.prototype._filter = function (states) {
                var length = states.length, solutions = [], state;
                for (var i = 0; i < length; ++i) {
                    state = states[i];
                    if (isArray(state.delegates)) {
                        solutions.push(state);
                    }
                }
                return this._State.sort(solutions);
            };
            /**
             * Links a state to a path, producing an IRecognizeResult.
             * @param {plat.routing.State} states The state to link.
             * @param {string} path The path to link.
             * @param {boolean} isTrailingSlashDropped Whether or not the trailing slash is dropped from the path.
             */
            RouteRecognizer.prototype._link = function (state, path, isTrailingSlashDropped) {
                if (isObject(state) && isArray(state.delegates)) {
                    if (isTrailingSlashDropped && this._isDynamic(state)) {
                        path = path + '/';
                    }
                    return this._State.link(state, path);
                }
            };
            /**
             * Determines whether or not the state is dynamic.
             * @param {plat.routing.State} states The state used to determine if it is dynamic or not.
             */
            RouteRecognizer.prototype._isDynamic = function (state) {
                return state.regex.source.slice(-5) === '(.+)$';
            };
            RouteRecognizer._inject = {
                _BaseSegmentFactory: __BaseSegmentFactory,
                _State: __StateStatic,
                _rootState: __StateInstance
            };
            return RouteRecognizer;
        }());
        routing.RouteRecognizer = RouteRecognizer;
        register.injectable(__RouteRecognizerInstance, RouteRecognizer, null, __INSTANCE);
        ;
        var __CHILD_ROUTE = '/*childRoute', __CHILD_ROUTE_LENGTH = __CHILD_ROUTE.length;
        /**
         * Matches URLs to registered views. Allows for rejecting navigation, as well as
         * processing route and query parameters. When a route is matches, the current view
         * has the opportunity to reject/delay navigation. The next view can also reject navigation,
         * or redirect.
         * This is done asynchronously, giving the application the ability to make web service calls
         * to determing
         */
        var Router = (function () {
            /**
             * Instantiates a new router and sets it as the current router.
             */
            function Router() {
                /**
                 * Whether or not the router is currently navigating.
                 */
                this.navigating = false;
                /**
                 * All the registered children for this router. Useful for generating and matching routes.
                 */
                this.children = [];
                /**
                 * Whether or not this router is the root router (has no parent).
                 */
                this.isRoot = false;
                /**
                 * An object containing transform methods for route parameters.
                 */
                this._paramTransforms = {};
                /**
                 * An object containing transform methods for query parameters.
                 */
                this._queryTransforms = {};
                /**
                 * An object containing interceptor methods for particular routes.
                 */
                this._interceptors = {};
                /**
                 * All the registered Viewports for the router.
                 */
                this._ports = [];
                /**
                 * A shortcut to the Promise.resolve function.
                 */
                this._resolve = this._Promise.resolve.bind(this._Promise);
                /**
                 * A shortcut to the Promise.reject function.
                 */
                this._reject = this._Promise.reject.bind(this._Promise);
                this.uid = uniqueId(__Plat);
                this.isRoot = isNull(Router.currentRouter());
                Router.currentRouter(this);
                this.initialize();
            }
            /**
             * Exposes the current router property. Also provides the
             * ability to set the current router.
             * @param {plat.routing.Router} router Will set the current router.
             */
            Router.currentRouter = function (router) {
                if (!isNull(router)) {
                    Router.__currentRouter = router;
                }
                return Router.__currentRouter;
            };
            /**
             * Initializes a router, giving it a parent router to link to if necessary.
             * @param {plat.routing.Router} parent? The parent router to link.
             */
            Router.prototype.initialize = function (parent) {
                this.parent = parent;
            };
            /**
             * Registers a child router with the current router.
             * @param {plat.routing.Router} child A child router.
             */
            Router.prototype.addChild = function (child) {
                if (isNull(child) || this.children.indexOf(child) > -1) {
                    return child;
                }
                child.initialize(this);
                this.children.push(child);
                return child;
            };
            /**
             * Removes a child from the router's children, if it exists.
             * @param {plat.routing.Router} child The child router to remove.
             */
            Router.prototype.removeChild = function (child) {
                var children = this.children, index = children.indexOf(child);
                if (index < 0) {
                    return;
                }
                children.splice(index, 1);
                var current = Router.currentRouter();
                if (current === child) {
                    Router.currentRouter(this);
                }
            };
            /**
             * Registers a Viewport (or similar object) with the
             * router, and triggers a navigation if possible.
             * @param {plat.routing.ISupportRouteNavigation} port An object that supports all the navigation events.
             */
            Router.prototype.register = function (port) {
                var _this = this;
                var ports = this._ports;
                if (isNull(port) || ports.indexOf(port) > -1) {
                    return this._resolve();
                }
                ports.push(port);
                if (!isObject(this.currentRouteInfo)) {
                    return this._resolve();
                }
                this.navigating = true;
                return this._resolve(this.finishNavigating)
                    .catch(noop)
                    .then(function () {
                    var routeInfo = _clone(_this.currentRouteInfo, true);
                    return _this.finishNavigating = _this._canNavigateTo(routeInfo)
                        .then(function (canNavigateTo) {
                        if (!canNavigateTo) {
                            return;
                        }
                        _this.currentRouteInfo = undefined;
                        return _this._performNavigation(routeInfo);
                    }).then(function () {
                        _this.navigating = false;
                        _this.currentRouteInfo = routeInfo;
                    }, function () {
                        _this.navigating = false;
                    });
                });
            };
            /**
             * Unregisters a Viewport (or similar object) with the
             * router in order to stop receiving navigation events.
             * @param {plat.routing.ISupportRouteNavigation} port An object that supports all the navigation events.
             */
            Router.prototype.unregister = function (port) {
                var ports = this._ports, index = ports.indexOf(port);
                if (index < 0) {
                    return;
                }
                ports.splice(index, 1);
                if (ports.length === 0 && !isNull(this.parent)) {
                    this.parent.removeChild(this);
                }
            };
            Router.prototype.configure = function (routes) {
                var _this = this;
                if (isArray(routes)) {
                    forEach(function (route) {
                        _this._configureRoute(route);
                    }, routes);
                }
                else {
                    this._configureRoute(routes);
                }
                return this._forceNavigate();
            };
            /**
             * Allows for dynamic routing. Call this method in order to register a handler for dynamically determining what view to
             * use when a registered route is not found.
             * @param {(info: IUnknownRouteInfo) => any} handler A method called to determine what view is associated with a route.
             */
            Router.prototype.unknown = function (handler) {
                this._unknownHandler = handler;
                return this;
            };
            Router.prototype.param = function (handler, parameter, view) {
                return this._addHandler(handler, parameter, view, this._paramTransforms);
            };
            Router.prototype.queryParam = function (handler, parameter, view) {
                return this._addHandler(handler, parameter, view, this._queryTransforms);
            };
            Router.prototype.intercept = function (interceptor, view) {
                if (isUndefined(view)) {
                    view = '*';
                }
                var alias = view;
                if (view !== '*') {
                    view = this._Injector.convertDependency(view);
                }
                if (view === __NOOP_INJECTOR) {
                    view = alias;
                }
                var interceptors = this._interceptors[view];
                if (!isArray(interceptors)) {
                    interceptors = this._interceptors[view] = [];
                }
                interceptors.push(interceptor);
                return this;
            };
            /**
             * Tells the router to match a new route. The router will attempt to find the route and if it succeeds it will
             * attempt to navigate to it. If it fails, it will return a Promise that rejects.
             * @param {string} url The new route to match.
             * @param {plat.IObject<any>} query The query parameters for the route.
             * @param {boolean} force Whether or not to force navigation, even if the same url has already been matched.
             */
            Router.prototype.navigate = function (url, query, force, poll) {
                var _this = this;
                if (poll === false) {
                    poll = !isObject(this.currentRouteInfo);
                }
                if (!isObject(query)) {
                    query = {};
                }
                var resolve = this._resolve, queryString = serializeQuery(query);
                if (url === '/') {
                    url = '';
                }
                force = force === true;
                if (!isString(url) || this.navigating || (!force && url === this._previousUrl && queryString === this._previousQuery)) {
                    if (this.navigating) {
                        return this.finishNavigating.then(function () {
                            return _this.navigate(url, query, force);
                        });
                    }
                    return resolve();
                }
                var recognizer = this._recognizer, result = recognizer.recognize(url), routeInfo, emptyResult = isEmpty(result), pattern, segment;
                if (!emptyResult) {
                    routeInfo = result[0];
                    routeInfo.query = query;
                }
                var sameRoute = this._isSameRoute(routeInfo);
                if (emptyResult || sameRoute) {
                    var childUrl_1 = url;
                    if (sameRoute) {
                        segment = recognizer.generate(routeInfo.delegate.alias || routeInfo.delegate.view, routeInfo.parameters);
                        childUrl_1 = childUrl_1.replace(segment, '');
                    }
                    if (childUrl_1 === '/' || childUrl_1 === '') {
                        childUrl_1 = '';
                        some(function (child) {
                            result = child._recognizer.recognize(childUrl_1);
                            return !isEmpty(result);
                        }, this.children);
                    }
                    else {
                        result = this._childRecognizer.recognize(childUrl_1);
                    }
                    if (isEmpty(result)) {
                        if (!emptyResult) {
                            result = recognizer.recognize(url);
                            routeInfo = result[0];
                            routeInfo.query = query;
                            pattern = routeInfo.delegate.pattern;
                        }
                        else {
                            // route has not been matched 
                            this._previousUrl = childUrl_1;
                            this._previousQuery = queryString;
                            this.currentRouteInfo = routeInfo;
                            if (isFunction(this._unknownHandler)) {
                                var unknownRouteConfig_1 = {
                                    segment: url,
                                    view: undefined
                                };
                                return resolve(this._unknownHandler(unknownRouteConfig_1)).then(function () {
                                    var view = unknownRouteConfig_1.view;
                                    if (isUndefined(view)) {
                                        return;
                                    }
                                    return _this.configure({
                                        pattern: url,
                                        view: view
                                    });
                                });
                            }
                            return resolve();
                        }
                    }
                    else {
                        routeInfo = result[0];
                        routeInfo.query = query;
                        pattern = routeInfo.delegate.pattern;
                        pattern = pattern.slice(0, pattern.length - __CHILD_ROUTE_LENGTH);
                        if (!emptyResult || this._isSameRoute(routeInfo)) {
                            // the pattern for this router is the same as the last pattern so 
                            // only navigate child routers. 
                            this.navigating = true;
                            return this.finishNavigating = this._navigateChildren(routeInfo)
                                .then(function () {
                                _this._previousUrl = url;
                                _this._previousQuery = queryString;
                                _this.navigating = false;
                            }, function (e) {
                                _this.navigating = false;
                                throw e;
                            });
                        }
                    }
                }
                else {
                    pattern = routeInfo.delegate.pattern;
                }
                segment = recognizer.generate(routeInfo.delegate.alias || routeInfo.delegate.view, routeInfo.parameters);
                var previousSegment = this._previousSegment;
                this._previousSegment = segment;
                this.navigating = true;
                var routeInfoCopy = this._nextRouteInfo = _clone(routeInfo, true);
                return this.finishNavigating = this._canNavigate(routeInfo, poll)
                    .then(function (canNavigate) {
                    if (!canNavigate) {
                        _this.navigating = false;
                        throw new Error('Not cleared to navigate');
                    }
                    _this._previousUrl = url;
                    _this._previousQuery = queryString;
                    return _this._performNavigation(routeInfo);
                }).then(function () {
                    _this._previousPattern = pattern;
                    _this._previousSegment = segment;
                    _this.currentRouteInfo = routeInfoCopy;
                    _this.navigating = false;
                }, function (e) {
                    _this._previousSegment = previousSegment;
                    _this.navigating = false;
                    throw e;
                });
            };
            Router.prototype.generate = function (name, parameters, query) {
                var alias = name;
                name = this._Injector.convertDependency(name);
                if (name === __NOOP_INJECTOR) {
                    name = alias;
                }
                var router = this, prefix = '';
                while (!(isNull(router) || router._recognizer.exists(name))) {
                    router = router.parent;
                }
                if (isNull(router)) {
                    throw new Error('Route for ' + name + ' does not exist.');
                }
                var path = router._recognizer.generate(name, parameters), previous;
                while (!isNull(router = router.parent)) {
                    previous = router._previousSegment;
                    previous = (!isNull(previous) && previous !== '/') ? previous : '';
                    prefix = previous + prefix;
                }
                return prefix + path + serializeQuery(query);
            };
            /**
             * Configures a route mapping and registers it with the RouteRecognizer and the child
             * RouteRecognizer.
             * @param {plat.routing.IRouteMapping} route The mapping used to configure the route.
             */
            Router.prototype._configureRoute = function (route) {
                var view = this._Injector.convertDependency(route.view), alias = route.alias || view;
                if (view === __NOOP_INJECTOR) {
                    return;
                }
                route.view = view;
                route.alias = alias || view;
                var routeDelegate = {
                    pattern: route.pattern,
                    delegate: route
                }, childPattern = route.pattern + __CHILD_ROUTE, childDelegate = {
                    pattern: childPattern,
                    delegate: {
                        pattern: childPattern,
                        view: view,
                        alias: alias
                    }
                };
                this._recognizer.register([routeDelegate], { name: alias });
                this._childRecognizer.register([childDelegate]);
            };
            /**
             * Generic method for adding a param/queryParam handler to the registered handlers object.
             * @param {(value: any, query: any) => any} handler A method that will manipulate the registered parameter.
             * @param {string} parameter The parameter that the registered handler will modify.
             * @param {any} view The view used to match the route. If undefined, all routes will be matched.
             * @param {plat.IObject<plat.routing.IRouteTransforms>} handlers The object to which to add the handler.
             */
            Router.prototype._addHandler = function (handler, parameter, view, handlers) {
                if (isUndefined(view)) {
                    view = '*';
                }
                var alias = view;
                if (view !== '*') {
                    view = this._Injector.convertDependency(view);
                }
                if (view === __NOOP_INJECTOR) {
                    view = alias;
                }
                if (isEmpty(view) || isEmpty(parameter)) {
                    return this;
                }
                var viewHandlers = handlers[view];
                if (!isObject(viewHandlers)) {
                    viewHandlers = handlers[view] = {};
                }
                var transforms = viewHandlers[parameter];
                if (!isArray(transforms)) {
                    transforms = viewHandlers[parameter] = [];
                }
                transforms.push(handler);
                return this;
            };
            /**
             * Forces a navigation if possible.
             */
            Router.prototype._forceNavigate = function () {
                var _this = this;
                var resolve = this._resolve, query;
                if (this.navigating) {
                    return this.finishNavigating.then(function () {
                        return _this._forceNavigate();
                    });
                }
                if (this.isRoot && isEmpty(this._previousUrl)) {
                    var utils = this._browser.urlUtils();
                    this._previousUrl = utils.pathname;
                    query = utils.query;
                }
                if (!isEmpty(this._previousQuery)) {
                    query = deserializeQuery(this._previousQuery);
                }
                if (!isEmpty(this._previousUrl)) {
                    return this.navigate(this._previousUrl, query, true);
                }
                return resolve();
            };
            /**
             * Navigates the child routers.
             * @param {plat.routing.IRouteInfo} info The information necessary to build the childRoute for the child routers.
             */
            Router.prototype._navigateChildren = function (info, poll) {
                if (poll === void 0) { poll = true; }
                var childRoute = this._getChildRoute(info);
                if (isNull(childRoute)) {
                    return this._resolve();
                }
                return mapAsync(function (child) {
                    return child.navigate(childRoute, info.query, undefined, poll);
                }, this.children).then(noop);
            };
            /**
             * Parses out the child route from route information.
             * @param {plat.routing.IRouteInfo} info The information necessary to get the child route.
             */
            Router.prototype._getChildRoute = function (info) {
                if (isNull(info)) {
                    return;
                }
                var childRoute = info.parameters.childRoute;
                if (!isString(childRoute)) {
                    childRoute = '';
                }
                return '/' + childRoute;
            };
            /**
             * It is safe to navigate, so perform the navigation.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._performNavigation = function (info) {
                var _this = this;
                var sameRoute = this._isSameRoute(this._nextRouteInfo);
                return this._performNavigateFrom(sameRoute).then(function () {
                    if (sameRoute) {
                        return;
                    }
                    return mapAsync(function (port) {
                        return port.navigateTo(info);
                    }, _this._ports);
                }).then(function () {
                    return _this._navigateChildren(info, false);
                });
            };
            /**
             * It is safe to navigate, so fire the navigateFrom events.
             * @param {boolean} ignorePorts? Ignores the ports if necessary.
             */
            Router.prototype._performNavigateFrom = function (ignorePorts) {
                var _this = this;
                return mapAsync(function (child) {
                    return child._performNavigateFrom();
                }, this.children)
                    .then(function () {
                    if (ignorePorts) {
                        return;
                    }
                    return mapAsync(function (port) {
                        return port.navigateFrom();
                    }, _this._ports);
                }).then(noop);
            };
            /**
             * Determines if we can navigate from the current state and navigate to the next state.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._canNavigate = function (info, poll) {
                var _this = this;
                if (poll === void 0) { poll = true; }
                var sameRoute = this._isSameRoute(this._nextRouteInfo);
                if (!poll) {
                    return this._callAllHandlers(info.delegate.alias, info.parameters, info.query).then(function () {
                        return _this._callInterceptors(info);
                    }).then(function () {
                        return true;
                    }, function () {
                        return true;
                    });
                }
                return this._canNavigateFrom(sameRoute)
                    .then(function (canNavigateFrom) {
                    return canNavigateFrom && _this._canNavigateTo(info, sameRoute);
                });
            };
            /**
             * Determines if we can navigate from the current state and navigate to the next state.
             * @param {boolean} ignorePorts Ignores the ports if necessary.
             */
            Router.prototype._canNavigateFrom = function (ignorePorts) {
                var _this = this;
                return this._Promise.all(this.children.reduce(function (promises, child) {
                    return promises.concat(child._canNavigateFrom());
                }, []))
                    .then(booleanReduce)
                    .then(function (canNavigateFrom) {
                    if (!canNavigateFrom || ignorePorts) {
                        return [canNavigateFrom];
                    }
                    return mapAsync(function (port) {
                        return port.canNavigateFrom();
                    }, _this._ports);
                }).then(booleanReduce);
            };
            /**
             * Determines if we can navigate to the next state.
             * @param {plat.routing.IRouteInfo} info The route information.
             * @param {boolean} ignorePorts Ignores the ports if necessary.
             */
            Router.prototype._canNavigateTo = function (info, ignorePorts) {
                var _this = this;
                if (isEmpty(this._ports)) {
                    return this._resolve(true);
                }
                return this._callAllHandlers(info.delegate.alias, info.parameters, info.query).then(function () {
                    return _this._callInterceptors(info);
                }).then(function (canNavigateTo) {
                    if (canNavigateTo === false || ignorePorts) {
                        return [canNavigateTo];
                    }
                    return mapAsync(function (port) {
                        return port.canNavigateTo(info);
                    }, _this._ports);
                }).then(booleanReduce);
            };
            /**
             * Calls all the registered query and param transforms for a route.
             * @param {string} view The associated view for the route.
             * @param {any} parameters The route parameters.
             * @param {any} query? The query parameters.
             */
            Router.prototype._callAllHandlers = function (view, parameters, query) {
                var _this = this;
                return this._callHandlers(this._queryTransforms['*'], query)
                    .then(function () { return _this._callHandlers(_this._queryTransforms[view], query); })
                    .then(function () { return _this._callHandlers(_this._paramTransforms['*'], parameters, query); })
                    .then(function () { return _this._callHandlers(_this._paramTransforms[view], parameters, query); })
                    .then(noop);
            };
            /**
             * Calls the associated transform functions.
             * @param {plat.routing.IRouteTransforms} allHandlers The transform functions
             * @param {any} obj The parameters.
             * @param {any} query? The query parameters.
             */
            Router.prototype._callHandlers = function (allHandlers, obj, query) {
                var resolve = this._resolve;
                if (!isObject(obj)) {
                    obj = {};
                }
                return mapAsync(function (handlers, key) {
                    return mapAsyncInOrder(function (handler) {
                        return resolve(handler(obj[key], obj, query));
                    }, handlers);
                }, allHandlers)
                    .then(noop);
            };
            /**
             * Calls the interceptors for a particular route.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._callInterceptors = function (info) {
                var _this = this;
                var resolve = this._resolve;
                return mapAsyncInOrder(function (handler) {
                    return resolve(handler(info));
                }, this._interceptors['*'])
                    .then(booleanReduce)
                    .then(function (canNavigate) {
                    if (!canNavigate) {
                        return [canNavigate];
                    }
                    return mapAsync(function (handler) {
                        return resolve(handler(info));
                    }, _this._interceptors[info.delegate.alias]);
                })
                    .then(booleanReduce);
            };
            /**
             * Checks a passed-in route against the current route to determine if it is the same.
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._isSameRoute = function (info) {
                var currentRouteInfo = _clone(this.currentRouteInfo, true);
                info = _clone(info, true);
                this._sanitizeRouteInfo(currentRouteInfo);
                this._sanitizeRouteInfo(info);
                if (!(isObject(currentRouteInfo) && isObject(info))) {
                    return false;
                }
                var currentDelegate = currentRouteInfo.delegate, delegate = info.delegate, currentParameters = serializeQuery(currentRouteInfo.parameters), parameters = serializeQuery(info.parameters), currentQuery = serializeQuery(currentRouteInfo.query), query = serializeQuery(info.query);
                return currentDelegate.view === delegate.view &&
                    currentDelegate.alias === delegate.alias &&
                    currentDelegate.pattern === delegate.pattern &&
                    currentParameters === parameters &&
                    currentQuery === query;
            };
            /**
             * Removes childRoute from routeInfo
             * @param {plat.routing.IRouteInfo} info The route information.
             */
            Router.prototype._sanitizeRouteInfo = function (info) {
                if (isObject(info)) {
                    if (info.parameters.hasOwnProperty('childRoute')) {
                        var delegate = info.delegate, pattern = delegate.pattern;
                        delegate.pattern = pattern.slice(0, pattern.length - __CHILD_ROUTE_LENGTH);
                        deleteProperty(info.parameters, 'childRoute');
                    }
                }
            };
            /**
             * Clears all the router information, essentially setting the router back to its initialized state.
             */
            Router.prototype._clearInfo = function () {
                this._previousSegment = undefined;
                this._previousPattern = undefined;
                this._previousUrl = undefined;
                this._previousQuery = undefined;
                this.currentRouteInfo = undefined;
                this.navigating = false;
                forEach(function (child) {
                    child._clearInfo();
                }, this.children);
            };
            Router._inject = {
                _Promise: __Promise,
                _Injector: __InjectorStatic,
                _EventManager: __EventManagerStatic,
                _browser: __Browser,
                _browserConfig: __BrowserConfig,
                _recognizer: __RouteRecognizerInstance,
                _childRecognizer: __RouteRecognizerInstance
            };
            return Router;
        }());
        routing.Router = Router;
        register.injectable(__Router, Router, null, __INSTANCE);
        /**
         */
        function IRouterStatic() {
            return Router;
        }
        routing.IRouterStatic = IRouterStatic;
        register.injectable(__RouterStatic, IRouterStatic);
    })(routing = plat_1.routing || (plat_1.routing = {}));
    /**
     * Holds all classes and interfaces related to attribute control components in platypus.
     */
    var controls;
    (function (controls) {
        /**
         * Allows for assigning a name to an Element or TemplateControl and referencing it
         * from parent controls.
         */
        var Name = (function (_super) {
            __extends(Name, _super);
            function Name() {
                _super.apply(this, arguments);
            }
            /**
             * Defines the property specified by the attribute value as the INamedElement
             * on all the ancestor controls, ignoring those that already have the property defined.
             */
            Name.prototype.initialize = function () {
                var attr = camelCase(this.type), name = this.attributes[attr];
                if (isEmpty(name) || this._isPrecompiled()) {
                    return;
                }
                this._label = name;
                this._define(name);
            };
            /**
             * Removes the INamedElement from the ancestor controls.
             */
            Name.prototype.dispose = function () {
                var name = this._label, control = this.parent;
                while (!isUndefined(name) && isObject(control)) {
                    if (isObject(control[name]) &&
                        isNode(control[name].element) &&
                        control[name].element === this.element) {
                        deleteProperty(control, name);
                    }
                    control = control.parent;
                }
            };
            /**
             * Defines the property specified by the attribute value as the INamedElement
             * on all the ancestor controls, ignoring those that already have the property defined.
             * @param {string} name The name to define on all the ancestor controls.
             */
            Name.prototype._define = function (name) {
                var templateControl = this.templateControl;
                if (!isNull(templateControl)) {
                    templateControl.name = name;
                }
                var control = this.parent, namedElement = {
                    element: this.element,
                    control: templateControl
                };
                while (isObject(control)) {
                    var obj = control[name];
                    if (!isObject(obj)) {
                        control[name] = namedElement;
                    }
                    control = control.parent;
                }
            };
            /**
             * Determines whether or not this control is part of a pre-compiled control tree. In the event
             * that it is, it shouldn't set itself on the ancestor controls.
             * @param {string} name The name to define on all the ancestor controls.
             */
            Name.prototype._isPrecompiled = function () {
                var control = this.parent;
                while (!isNull(control)) {
                    if (control.type.indexOf(__COMPILED) !== -1) {
                        return true;
                    }
                    control = control.parent;
                }
                return false;
            };
            return Name;
        }(AttributeControl));
        controls.Name = Name;
        register.control(__Name, Name);
        /**
         * An AttributeControl that binds to a specified DOM event handler.
         */
        var SimpleEventControl = (function (_super) {
            __extends(SimpleEventControl, _super);
            function SimpleEventControl() {
                _super.apply(this, arguments);
                /**
                 * A parsed form of the expression found in the attribute's value.
                 */
                this._expression = [];
                /**
                 * An array of the aliases used in the expression.
                 */
                this._aliases = [];
            }
            /**
             * Kicks off finding and setting the listener.
             */
            SimpleEventControl.prototype.loaded = function () {
                if (isNull(this.element)) {
                    return;
                }
                this.attribute = camelCase(this.type);
                this._setListener();
            };
            /**
             * Parses function args and sets the event listener.
             */
            SimpleEventControl.prototype._setListener = function () {
                var fn = this.attributes[this.attribute];
                if (isEmpty(this.event) || isEmpty(fn)) {
                    return;
                }
                this._parseArgs(fn);
                this._addEventListeners();
            };
            /**
             * Adds any and all necessary event listeners.
             */
            SimpleEventControl.prototype._addEventListeners = function () {
                this.addEventListener(this.element, this.event, this._onEvent, false);
            };
            /**
             * Constructs the function to evaluate with
             * the evaluated arguments taking resources
             * into account.
             */
            SimpleEventControl.prototype._buildExpression = function () {
                var expression = this._expression.slice(0), _parser = this._parser, parent = this.parent, listenerStr = expression.shift(), listener, context, fn, aliases, argContext;
                if (!isNull(parent)) {
                    aliases = parent.getResources(this._aliases);
                    argContext = parent.context;
                }
                if (listenerStr[0] !== '@') {
                    listener = this.findProperty(listenerStr);
                    if (isNull(listener)) {
                        this._log.warn('Could not find property ' + listenerStr + ' on any parent control.');
                        return {
                            fn: noop,
                            context: {},
                            args: []
                        };
                    }
                    var parsedExpression = listener.expresssion, identifiers = parsedExpression.identifiers;
                    if (identifiers.length > 1) {
                        this._log.warn('Cannot have more than one identifier in a ' + this.type +
                            '\'s expression.');
                        return {
                            fn: noop,
                            context: {},
                            args: []
                        };
                    }
                    var identifier = identifiers[0], split = identifier.split('.');
                    // pop key 
                    split.pop();
                    context = split.length === 0 ? listener.control : _parser.parse(split.join('.')).evaluate(listener.control);
                    fn = listener.value;
                }
                else {
                    fn = isNull(aliases) ? noop : (aliases[listenerStr] || noop);
                    context = undefined;
                }
                var length = expression.length, args = [];
                for (var i = 0; i < length; ++i) {
                    args.push(_parser.parse(expression[i]).evaluate(argContext, aliases));
                }
                return {
                    fn: fn,
                    context: context,
                    args: args
                };
            };
            /**
             * Calls the specified function when the DOM event is fired.
             * @param {Event} ev The event object.
             */
            SimpleEventControl.prototype._onEvent = function (ev) {
                var expression = this._buildExpression(), fn = expression.fn;
                if (!isFunction(fn)) {
                    this._log.warn('Cannot find registered event method ' +
                        this._expression[0] + ' for control: ' + this.type);
                    return;
                }
                fn.apply(expression.context, expression.args.concat(ev));
            };
            /**
             * Finds all alias contained within the expression.
             * @param {Array<string>} args The array of arguments as strings.
             */
            SimpleEventControl.prototype._findAliases = function (args) {
                var length = args.length, arg, hash = {}, aliases = [], parsedAliases = [], _parser = this._parser;
                while (length-- > 0) {
                    arg = args[length].trim();
                    parsedAliases = parsedAliases.concat(_parser.parse(arg).aliases);
                }
                while (parsedAliases.length > 0) {
                    arg = parsedAliases.pop();
                    if (!hash[arg]) {
                        aliases.push(arg);
                        hash[arg] = true;
                    }
                }
                return aliases;
            };
            /**
             * Parses the expression and separates the function
             * from its arguments.
             * @param {string} expression The expression to parse.
             */
            SimpleEventControl.prototype._parseArgs = function (expression) {
                if (isEmpty(expression)) {
                    return;
                }
                var exec = this._regex.argumentRegex.exec(expression);
                if (!isNull(exec)) {
                    this._expression = [expression.slice(0, exec.index)]
                        .concat((exec[1] !== '') ? exec[1].split(',') : []);
                }
                else {
                    this._expression.push(expression);
                }
                this._aliases = this._findAliases(this._expression);
            };
            SimpleEventControl._inject = {
                _parser: __Parser,
                _regex: __Regex
            };
            return SimpleEventControl;
        }(AttributeControl));
        controls.SimpleEventControl = SimpleEventControl;
        /**
         * A SimpleEventControl for the '$tap' event.
         */
        var Tap = (function (_super) {
            __extends(Tap, _super);
            function Tap() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __tap;
            }
            return Tap;
        }(SimpleEventControl));
        controls.Tap = Tap;
        /**
         * A SimpleEventControl for the 'blur' event.
         */
        var Blur = (function (_super) {
            __extends(Blur, _super);
            function Blur() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'blur';
            }
            return Blur;
        }(SimpleEventControl));
        controls.Blur = Blur;
        /**
         * A SimpleEventControl for the 'change' event.
         */
        var Change = (function (_super) {
            __extends(Change, _super);
            function Change() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'change';
            }
            return Change;
        }(SimpleEventControl));
        controls.Change = Change;
        /**
         * A SimpleEventControl for the 'copy' event.
         */
        var Copy = (function (_super) {
            __extends(Copy, _super);
            function Copy() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'copy';
            }
            return Copy;
        }(SimpleEventControl));
        controls.Copy = Copy;
        /**
         * A SimpleEventControl for the 'cut' event.
         */
        var Cut = (function (_super) {
            __extends(Cut, _super);
            function Cut() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'cut';
            }
            return Cut;
        }(SimpleEventControl));
        controls.Cut = Cut;
        /**
         * A SimpleEventControl for the 'paste' event.
         */
        var Paste = (function (_super) {
            __extends(Paste, _super);
            function Paste() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'paste';
            }
            return Paste;
        }(SimpleEventControl));
        controls.Paste = Paste;
        /**
         * A SimpleEventControl for the '$dbltap' event.
         */
        var DblTap = (function (_super) {
            __extends(DblTap, _super);
            function DblTap() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __dbltap;
            }
            return DblTap;
        }(SimpleEventControl));
        controls.DblTap = DblTap;
        /**
         * A SimpleEventControl for the 'focus' event.
         */
        var Focus = (function (_super) {
            __extends(Focus, _super);
            function Focus() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'focus';
            }
            return Focus;
        }(SimpleEventControl));
        controls.Focus = Focus;
        /**
         * A SimpleEventControl for the '$touchstart' event.
         */
        var TouchStart = (function (_super) {
            __extends(TouchStart, _super);
            function TouchStart() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchstart;
            }
            return TouchStart;
        }(SimpleEventControl));
        controls.TouchStart = TouchStart;
        /**
         * A SimpleEventControl for the '$touchend' event.
         */
        var TouchEnd = (function (_super) {
            __extends(TouchEnd, _super);
            function TouchEnd() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchend;
            }
            return TouchEnd;
        }(SimpleEventControl));
        controls.TouchEnd = TouchEnd;
        /**
         * A SimpleEventControl for the '$touchmove' event.
         */
        var TouchMove = (function (_super) {
            __extends(TouchMove, _super);
            function TouchMove() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchmove;
            }
            return TouchMove;
        }(SimpleEventControl));
        controls.TouchMove = TouchMove;
        /**
         * A SimpleEventControl for the '$touchcancel' event.
         */
        var TouchCancel = (function (_super) {
            __extends(TouchCancel, _super);
            function TouchCancel() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __touchcancel;
            }
            return TouchCancel;
        }(SimpleEventControl));
        controls.TouchCancel = TouchCancel;
        /**
         * A SimpleEventControl for the '$hold' event.
         */
        var Hold = (function (_super) {
            __extends(Hold, _super);
            function Hold() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __hold;
            }
            return Hold;
        }(SimpleEventControl));
        controls.Hold = Hold;
        /**
         * A SimpleEventControl for the '$release' event.
         */
        var Release = (function (_super) {
            __extends(Release, _super);
            function Release() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __release;
            }
            return Release;
        }(SimpleEventControl));
        controls.Release = Release;
        /**
         * A SimpleEventControl for the '$swipe' event.
         */
        var Swipe = (function (_super) {
            __extends(Swipe, _super);
            function Swipe() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipe;
            }
            return Swipe;
        }(SimpleEventControl));
        controls.Swipe = Swipe;
        /**
         * A SimpleEventControl for the '$swipeleft' event.
         */
        var SwipeLeft = (function (_super) {
            __extends(SwipeLeft, _super);
            function SwipeLeft() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipeleft;
            }
            return SwipeLeft;
        }(SimpleEventControl));
        controls.SwipeLeft = SwipeLeft;
        /**
         * A SimpleEventControl for the '$swiperight' event.
         */
        var SwipeRight = (function (_super) {
            __extends(SwipeRight, _super);
            function SwipeRight() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swiperight;
            }
            return SwipeRight;
        }(SimpleEventControl));
        controls.SwipeRight = SwipeRight;
        /**
         * A SimpleEventControl for the '$swipeup' event.
         */
        var SwipeUp = (function (_super) {
            __extends(SwipeUp, _super);
            function SwipeUp() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipeup;
            }
            return SwipeUp;
        }(SimpleEventControl));
        controls.SwipeUp = SwipeUp;
        /**
         * A SimpleEventControl for the '$swipedown' event.
         */
        var SwipeDown = (function (_super) {
            __extends(SwipeDown, _super);
            function SwipeDown() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __swipedown;
            }
            return SwipeDown;
        }(SimpleEventControl));
        controls.SwipeDown = SwipeDown;
        /**
         * A SimpleEventControl for the '$track' event.
         */
        var Track = (function (_super) {
            __extends(Track, _super);
            function Track() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __track;
            }
            return Track;
        }(SimpleEventControl));
        controls.Track = Track;
        /**
         * A SimpleEventControl for the '$trackleft' event.
         */
        var TrackLeft = (function (_super) {
            __extends(TrackLeft, _super);
            function TrackLeft() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackleft;
            }
            return TrackLeft;
        }(SimpleEventControl));
        controls.TrackLeft = TrackLeft;
        /**
         * A SimpleEventControl for the '$trackright' event.
         */
        var TrackRight = (function (_super) {
            __extends(TrackRight, _super);
            function TrackRight() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackright;
            }
            return TrackRight;
        }(SimpleEventControl));
        controls.TrackRight = TrackRight;
        /**
         * A SimpleEventControl for the '$trackup' event.
         */
        var TrackUp = (function (_super) {
            __extends(TrackUp, _super);
            function TrackUp() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackup;
            }
            return TrackUp;
        }(SimpleEventControl));
        controls.TrackUp = TrackUp;
        /**
         * A SimpleEventControl for the '$trackdown' event.
         */
        var TrackDown = (function (_super) {
            __extends(TrackDown, _super);
            function TrackDown() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackdown;
            }
            return TrackDown;
        }(SimpleEventControl));
        controls.TrackDown = TrackDown;
        /**
         * A SimpleEventControl for the '$trackend' event.
         */
        var TrackEnd = (function (_super) {
            __extends(TrackEnd, _super);
            function TrackEnd() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = __trackend;
            }
            return TrackEnd;
        }(SimpleEventControl));
        controls.TrackEnd = TrackEnd;
        /**
         * A SimpleEventControl for the 'submit' event.
         */
        var Submit = (function (_super) {
            __extends(Submit, _super);
            function Submit() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'submit';
            }
            /**
             * Prevents the default submit action unless
             * the "action" attribute is present.
             * @param {Event} ev The event object.
             */
            Submit.prototype._onEvent = function (ev) {
                if (!this.element.hasAttribute('action')) {
                    ev.preventDefault();
                }
                _super.prototype._onEvent.call(this, ev);
            };
            return Submit;
        }(SimpleEventControl));
        controls.Submit = Submit;
        /**
         * A SimpleEventControl for the 'input' event. If
         * 'input' is not an event, it will simulate an 'input' using other events like 'keydown',
         * 'cut', 'paste', etc. Also fires on the 'change' event.
         */
        var React = (function (_super) {
            __extends(React, _super);
            function React() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'input';
            }
            /**
             * Adds any and all necessary event listeners.
             */
            React.prototype._addEventListeners = function () {
                var _this = this;
                var element = this.element, _compat = this._compat, composing = false, inputFired = false, input = 'input', timeout, eventListener = function (ev) {
                    if (composing) {
                        return;
                    }
                    _this._onEvent(ev);
                }, postponedEventListener = function (ev) {
                    if (isFunction(timeout)) {
                        return;
                    }
                    timeout = postpone(function () {
                        eventListener(ev);
                        timeout = null;
                    });
                };
                if (isUndefined(_compat.ANDROID)) {
                    this.addEventListener(element, 'compositionstart', function () { composing = true; }, false);
                    this.addEventListener(element, 'compositionend', function (ev) {
                        composing = false;
                        eventListener(ev);
                    }, false);
                }
                this.addEventListener(element, input, function (ev) {
                    inputFired = true;
                    eventListener(ev);
                }, false);
                this.addEventListener(element, 'change', function (ev) {
                    if (inputFired) {
                        inputFired = false;
                        return;
                    }
                    eventListener(ev);
                }, false);
                if (_compat.hasEvent(input)) {
                    return;
                }
                this.addEventListener(element, 'keydown', function (ev) {
                    var key = ev.keyCode, codes = controls.KeyCodes;
                    if (key === codes.lwk ||
                        key === codes.rwk ||
                        (key >= codes.shift && key <= codes.escape) ||
                        (key > codes.space && key <= codes.down)) {
                        return;
                    }
                    postponedEventListener(ev);
                }, false);
                this.addEventListener(element, 'cut', postponedEventListener, false);
                this.addEventListener(element, 'paste', postponedEventListener, false);
            };
            React._inject = {
                _compat: __Compat
            };
            return React;
        }(SimpleEventControl));
        controls.React = React;
        register.control(__Tap, Tap);
        register.control(__Blur, Blur);
        register.control(__Change, Change);
        register.control(__Copy, Copy);
        register.control(__Cut, Cut);
        register.control(__Paste, Paste);
        register.control(__DblTap, DblTap);
        register.control(__Focus, Focus);
        register.control(__Submit, Submit);
        register.control(__TouchStart, TouchStart);
        register.control(__TouchEnd, TouchEnd);
        register.control(__TouchMove, TouchMove);
        register.control(__TouchCancel, TouchCancel);
        register.control(__Hold, Hold);
        register.control(__Release, Release);
        register.control(__Swipe, Swipe);
        register.control(__SwipeLeft, SwipeLeft);
        register.control(__SwipeRight, SwipeRight);
        register.control(__SwipeUp, SwipeUp);
        register.control(__SwipeDown, SwipeDown);
        register.control(__Track, Track);
        register.control(__TrackLeft, TrackLeft);
        register.control(__TrackRight, TrackRight);
        register.control(__TrackUp, TrackUp);
        register.control(__TrackDown, TrackDown);
        register.control(__TrackEnd, TrackEnd);
        register.control(__React, React);
        /**
         * A mapping of all keys to their equivalent keyCode.
         */
        controls.KeyCodes = {
            'backspace': 8,
            'tab': 9,
            'enter': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'pause': 19, 'break': 19,
            'caps lock': 20,
            'escape': 27,
            'space': 32,
            'page up': 33,
            'page down': 34,
            'end': 35,
            'home': 36,
            'left': 37, 'left arrow': 37,
            'up': 38, 'up arrow': 38,
            'right': 39, 'right arrow': 39,
            'down': 40, 'down arrow': 40,
            'insert': 45,
            'delete': 46,
            '0': 48, 'zero': 48,
            ')': 48, 'right parenthesis': 48,
            '1': 49, 'one': 49,
            '!': 49, 'exclamation': 49, 'exclamation point': 49,
            '2': 50, 'two': 50,
            '@': 50, 'at': 50,
            '3': 51, 'three': 51,
            '#': 51, 'number sign': 51,
            'hash': 51, 'pound': 51,
            '4': 52, 'four': 52,
            '$': 52, 'dollar': 52, 'dollar sign': 52,
            '5': 53, 'five': 53,
            '%': 53, 'percent': 53, 'percent sign': 53,
            '6': 54, 'six': 54,
            '^': 54, 'caret': 54,
            '7': 55, 'seven': 55,
            '&': 55, 'ampersand': 55,
            '8': 56, 'eight': 56,
            '*': 56, 'asterisk': 56,
            '9': 57, 'nine': 57,
            '(': 57, 'left parenthesis': 57,
            'a': 65, 'b': 66, 'c': 67, 'd': 68, 'e': 69,
            'f': 70, 'g': 71, 'h': 72, 'i': 73, 'j': 74,
            'k': 75, 'l': 76, 'm': 77, 'n': 78, 'o': 79,
            'p': 80, 'q': 81, 'r': 82, 's': 83, 't': 84,
            'u': 85, 'v': 86, 'w': 87, 'x': 88, 'y': 89,
            'z': 90,
            'lwk': 91, 'left window key': 91,
            'rwk': 92, 'right window key': 92,
            'select': 93, 'select key': 93,
            'numpad 0': 96,
            'numpad 1': 97,
            'numpad 2': 98,
            'numpad 3': 99,
            'numpad 4': 100,
            'numpad 5': 101,
            'numpad 6': 102,
            'numpad 7': 103,
            'numpad 8': 104,
            'numpad 9': 105,
            'multiply': 106,
            'add': 107,
            'subtract': 109,
            'decimal point': 110,
            'divide': 111,
            'f1': 112, 'f2': 113, 'f3': 114, 'f4': 115,
            'f5': 116, 'f6': 117, 'f7': 118, 'f8': 119,
            'f9': 120, 'f10': 121, 'f11': 122, 'f12': 123,
            'num lock': 144,
            'scroll lock': 145,
            ';': 186, 'semi-colon': 186,
            ':': 186, 'colon': 186,
            '=': 187, 'equal': 187, 'equal sign': 187,
            '+': 187, 'plus': 187,
            ',': 188, 'comma': 188,
            '<': 188, 'lt': 188, 'less than': 188,
            'left angle bracket': 188,
            '-': 189, 'dash': 189,
            '_': 189, 'underscore': 189,
            '.': 190, 'period': 190,
            '>': 190, 'gt': 190, 'greater than': 190,
            'right angle bracket': 190,
            '/': 191, 'forward slash': 191,
            '?': 191, 'question mark': 191,
            '`': 192, 'grave accent': 192,
            '~': 192, 'tilde': 192,
            '[': 219, 'open bracket': 219,
            '{': 219, 'open brace': 219,
            '\\': 220, 'back slash': 220,
            '|': 220, 'pipe': 220,
            ']': 221, 'close bracket': 221,
            '}': 221, 'close brace': 221,
            '\'': 222, 'single quote': 222,
            '"': 222, 'double quote': 222
        };
        /**
         * Base class used for filtering keys on KeyboardEvents.
         */
        var KeyCodeEventControl = (function (_super) {
            __extends(KeyCodeEventControl, _super);
            function KeyCodeEventControl() {
                _super.apply(this, arguments);
                /**
                 * Holds the key mappings to filter for in a KeyboardEvent.
                 */
                this.keyCodes = {};
            }
            /**
             * Checks if the IKeyboardEventInput is an expression object
             * and sets the necessary listener.
             */
            KeyCodeEventControl.prototype._setListener = function () {
                var attr = this.attribute;
                if (isEmpty(this.event) || isEmpty(attr)) {
                    return;
                }
                var expression = this.attributes[attr].trim();
                if (expression[0] === '{') {
                    var eventObject = this.evaluateExpression(expression) || { method: '' }, keys = this._filterArgs(eventObject);
                    this._setKeyCodes(keys);
                    this.addEventListener(this.element, this.event, this._onEvent, false);
                    return;
                }
                _super.prototype._setListener.call(this);
            };
            /**
             * Parses the proper method args and finds any key code filters.
             */
            KeyCodeEventControl.prototype._filterArgs = function (input) {
                var key = input.key, keys = input.keys;
                this._parseArgs(input.method);
                if (isArray(keys)) {
                    return keys;
                }
                else if (isString(keys)) {
                    return [keys];
                }
                else if (isArray(key)) {
                    return key;
                }
                else if (isString(key)) {
                    return [key];
                }
                else {
                    if (!(isNull(input.char) && isNull(input.chars))) {
                        this._log.warn(this.type +
                            ' should be using the property key or keys to denote key codes or keys and not char codes or characters.');
                    }
                }
            };
            /**
             * Matches the event's keyCode if necessary and then handles the event if
             * a match is found or if there are no filter keyCodes.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            KeyCodeEventControl.prototype._onEvent = function (ev) {
                if (this._compareKeys(ev)) {
                    _super.prototype._onEvent.call(this, ev);
                }
            };
            /**
             * Matches the event's keyCode if necessary.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            KeyCodeEventControl.prototype._compareKeys = function (ev) {
                var keyCodes = this.keyCodes, keyCode = ev.keyCode || ev.which;
                return isEmpty(keyCodes) || keyCodes[keyCode] === true;
            };
            /**
             * Sets the defined key codes as they correspond to
             * the KeyCodes map.
             * @param {Array<string>} keys? The array of defined keys to satisfy the
             * key press condition.
             */
            KeyCodeEventControl.prototype._setKeyCodes = function (keys) {
                if (!isArray(keys)) {
                    keys = [];
                }
                var length = keys.length, key, keyCodes = this.keyCodes, index;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    index = isNumber(key) ? key : controls.KeyCodes[key.toLowerCase()];
                    keyCodes[index] = true;
                }
            };
            return KeyCodeEventControl;
        }(SimpleEventControl));
        controls.KeyCodeEventControl = KeyCodeEventControl;
        /**
         * Used for filtering keys on keydown events. Does not take capitalization into account.
         */
        var KeyDown = (function (_super) {
            __extends(KeyDown, _super);
            function KeyDown() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keydown';
            }
            return KeyDown;
        }(KeyCodeEventControl));
        controls.KeyDown = KeyDown;
        /**
         * Used for filtering only printing keys (a-z, A-Z, 0-9, and special characters) on keydown events.
         * Does not take capitalization into account.
         */
        var KeyPress = (function (_super) {
            __extends(KeyPress, _super);
            function KeyPress() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keydown';
            }
            /**
             * Filters only 'printing keys' (a-z, A-Z, 0-9, and special characters).
             * @param {KeyboardEvent} ev The KeyboardEvent object.
             */
            KeyPress.prototype._onEvent = function (ev) {
                var _this = this;
                var keyCode = ev.keyCode || ev.which;
                if (_super.prototype._compareKeys.call(this, ev) && ((keyCode >= 48 && keyCode <= 90) ||
                    (keyCode >= 186) || (keyCode >= 96 && keyCode <= 111))) {
                    var remove_1 = this.addEventListener(this.element, 'keypress', function (e) {
                        remove_1();
                        _super.prototype._onEvent.call(_this, e);
                    }, false);
                }
            };
            /**
             * Matches the event's keyCode if necessary.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            KeyPress.prototype._compareKeys = function (ev) {
                return true;
            };
            return KeyPress;
        }(KeyCodeEventControl));
        controls.KeyPress = KeyPress;
        /**
         * Used for filtering keys on keyup events. Does not take capitalization into account.
         */
        var KeyUp = (function (_super) {
            __extends(KeyUp, _super);
            function KeyUp() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keyup';
            }
            return KeyUp;
        }(KeyCodeEventControl));
        controls.KeyUp = KeyUp;
        /**
         * Used for filtering keys on keypress events. Takes capitalization into account.
         */
        var CharPress = (function (_super) {
            __extends(CharPress, _super);
            function CharPress() {
                _super.apply(this, arguments);
                /**
                 * The event name.
                 */
                this.event = 'keypress';
            }
            /**
             * Parses the proper method args and finds any char code filters.
             */
            CharPress.prototype._filterArgs = function (input) {
                var char = input.char, chars = input.chars;
                this._parseArgs(input.method);
                if (isArray(chars)) {
                    return chars;
                }
                else if (isString(chars)) {
                    return [chars];
                }
                else if (isArray(char)) {
                    return char;
                }
                else if (isString(char)) {
                    return [char];
                }
                else {
                    if (!(isNull(input.key) && isNull(input.keys))) {
                        this._log.warn(this.type +
                            ' should be using the property key or keys to denote key codes or keys and not char codes or characters.');
                    }
                }
            };
            /**
             * Matches the event's keyCode if necessary and then handles the event if
             * a match is found or if there are no filter keyCodes.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            CharPress.prototype._onEvent = function (ev) {
                var keyCodes = this.keyCodes, keyCode = ev.charCode || ev.which, key;
                if (!keyCode) {
                    key = ev.key;
                    if (!key) {
                        return;
                    }
                }
                else {
                    key = String.fromCharCode(keyCode);
                }
                if (isEmpty(keyCodes) || keyCodes[key] === true) {
                    _super.prototype._onEvent.call(this, ev);
                }
            };
            /**
             * Matches the event's keyCode if necessary.
             * @param {KeyboardEvent} ev The keyboard event object.
             */
            CharPress.prototype._compareKeys = function (ev) {
                return true;
            };
            /**
             * Sets the defined key codes as they correspond to
             * the KeyCodes map.
             * @param {Array<string>} keys? The array of defined keys to satisfy the
             * key press condition.
             */
            CharPress.prototype._setKeyCodes = function (keys) {
                if (!isArray(keys)) {
                    keys = [];
                }
                var length = keys.length, key, keyCodes = this.keyCodes, index;
                for (var i = 0; i < length; ++i) {
                    key = keys[i];
                    index = isNumber(key) ? String.fromCharCode(key) : key;
                    keyCodes[index] = true;
                }
            };
            return CharPress;
        }(KeyCodeEventControl));
        controls.CharPress = CharPress;
        register.control(__KeyDown, KeyDown);
        register.control(__KeyPress, KeyPress);
        register.control(__KeyUp, KeyUp);
        register.control(__CharPress, CharPress);
        /**
         * An AttributeControl that deals with binding to a specified property on its element.
         */
        var SetAttributeControl = (function (_super) {
            __extends(SetAttributeControl, _super);
            function SetAttributeControl() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated element.
                 */
                this.property = '';
                /**
                 * The function to stop listening for the delayed attribute set.
                 */
                this._stopSetter = noop;
            }
            /**
             * Sets the corresponding attribute {property} value and
             * observes the attribute for changes.
             */
            SetAttributeControl.prototype.loaded = function () {
                if (isNull(this.element)) {
                    return;
                }
                this.attribute = camelCase(this.type);
                this.setter();
                this.__removeListener = this.attributes.observe(this.setter, this.attribute);
            };
            /**
             * Resets the corresponding attribute property value upon
             * a change of context.
             */
            SetAttributeControl.prototype.contextChanged = function () {
                if (isNull(this.element)) {
                    return;
                }
                this.setter();
            };
            /**
             * Stops listening to attribute changes.
             */
            SetAttributeControl.prototype.dispose = function () {
                this._stopSetter();
                if (isFunction(this.__removeListener)) {
                    this.__removeListener();
                    this.__removeListener = null;
                }
            };
            /**
             * The function for setting the corresponding
             * attribute property value.
             */
            SetAttributeControl.prototype.setter = function () {
                var _this = this;
                this._stopSetter();
                this._stopSetter = requestAnimationFrameGlobal(function () {
                    var element = _this.element, property = _this.property;
                    if (!isNode(element)) {
                        return;
                    }
                    switch (_this.attributes[_this.attribute]) {
                        case 'false':
                        case '0':
                        case 'null':
                        case '':
                            element.setAttribute(property, '');
                            element[property] = false;
                            element.removeAttribute(property);
                            break;
                        default:
                            element.setAttribute(property, property);
                            element[property] = true;
                            break;
                    }
                });
            };
            return SetAttributeControl;
        }(AttributeControl));
        controls.SetAttributeControl = SetAttributeControl;
        /**
         * A SetAttributeControl for the 'checked' attribute.
         */
        var Checked = (function (_super) {
            __extends(Checked, _super);
            function Checked() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'checked';
            }
            return Checked;
        }(SetAttributeControl));
        controls.Checked = Checked;
        /**
         * A SetAttributeControl for the 'disabled' attribute.
         */
        var Disabled = (function (_super) {
            __extends(Disabled, _super);
            function Disabled() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'disabled';
            }
            return Disabled;
        }(SetAttributeControl));
        controls.Disabled = Disabled;
        /**
         * A SetAttributeControl for the 'selected' attribute.
         */
        var Selected = (function (_super) {
            __extends(Selected, _super);
            function Selected() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'selected';
            }
            return Selected;
        }(SetAttributeControl));
        controls.Selected = Selected;
        /**
         * A SetAttributeControl for the 'readonly' attribute.
         */
        var ReadOnly = (function (_super) {
            __extends(ReadOnly, _super);
            function ReadOnly() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'readonly';
            }
            return ReadOnly;
        }(SetAttributeControl));
        controls.ReadOnly = ReadOnly;
        /**
         * A SetAttributeControl for the 'plat-hide' attribute.
         */
        var Visible = (function (_super) {
            __extends(Visible, _super);
            function Visible() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated element.
                 */
                this.property = 'display';
                /**
                 * The value to associate with the property.
                 */
                this.value = 'none';
                /**
                 * The importance to set on the property.
                 */
                this.importance = 'important';
                /**
                 * The initial value of the property to be set.
                 */
                this._initialValue = '';
            }
            /**
             * Hides the element.
             */
            Visible.prototype.initialize = function () {
                var style = this.element.style || { getPropertyValue: noop }, initialValue = style.getPropertyValue(this.property);
                this._setValue(this.value, this.importance);
                if (isEmpty(initialValue) || initialValue === 'none') {
                    return;
                }
                this._initialValue = initialValue;
            };
            /**
             * Hides or shows the element depending upon the attribute value
             */
            Visible.prototype.setter = function () {
                var _this = this;
                this._stopSetter();
                this._stopSetter = requestAnimationFrameGlobal(function () {
                    if (!isNode(_this.element)) {
                        return;
                    }
                    switch (_this.attributes[_this.attribute]) {
                        case 'false':
                        case '0':
                        case 'null':
                        case '':
                            _this._setValue(_this.value, _this.importance);
                            break;
                        default:
                            _this._setValue(_this._initialValue);
                            break;
                    }
                });
            };
            /**
             * Sets the value of the property element with the given importance. If the
             * value is null or empty string, the property will be removed.
             * @param {string} value The value to set.
             * @param {string} importance? The priority or importance level to set.
             */
            Visible.prototype._setValue = function (value, importance) {
                var property = this.property, style = this.element.style || {
                    setProperty: noop,
                    removeProperty: noop,
                    getPropertyValue: noop,
                    getPropertyPriority: noop
                }, currentVal = style.getPropertyValue(property), currentPriority = style.getPropertyPriority(property);
                if (value === currentVal && importance === currentPriority) {
                    return;
                }
                else if (isEmpty(value)) {
                    style.removeProperty(property);
                    return;
                }
                style.setProperty(property, value, importance);
            };
            return Visible;
        }(SetAttributeControl));
        controls.Visible = Visible;
        /**
         * A SetAttributeControl for the 'style' attribute.
         */
        var Style = (function (_super) {
            __extends(Style, _super);
            function Style() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'style';
                /**
                 * A regular expression for separating style properties from style values in
                 * individual style declarations.
                 */
                this._styleRegex = /(.*?):(.*)/;
                /**
                 * A regular expression for temporarily finding and removing url declarations in the style attribute.
                 */
                this._urlRegex = /url\([^\)]*\)/gi;
                /**
                 * The temporary replace value of urls found in the style attribute.
                 */
                this._urlReplace = '[PLAT-STYLE-URL]';
                /**
                 * An object storing all the added styles.
                 */
                this.__addedStyles = [];
                /**
                 * An object storing all the old style values.
                 */
                this.__oldStyles = {};
            }
            /**
             * Sets the evaluated styles on the element.
             */
            Style.prototype.setter = function () {
                var _this = this;
                this._stopSetter();
                var element = this.element, expression = this.attributes[this.attribute];
                if (isEmpty(expression) || isNull(element)) {
                    return;
                }
                this._stopSetter = requestAnimationFrameGlobal(function () {
                    var urls = [], urlReplace = _this._urlReplace;
                    expression = expression.replace(_this._urlRegex, function (match) {
                        urls.push(match);
                        return urlReplace;
                    });
                    var style = element.style, addedStyles = _this.__addedStyles, oldStyles = _this.__oldStyles, newStyles = [], props = expression.split(';'), length = props.length, prop, val, styleRegex = _this._styleRegex, exec, styleChanges = {}, i;
                    for (i = 0; i < length; ++i) {
                        exec = styleRegex.exec(props[i]);
                        if (isNull(exec) || exec.length < 3) {
                            continue;
                        }
                        prop = exec[1].trim();
                        if (prop.length === 0 || isUndefined(style[prop])) {
                            continue;
                        }
                        else if (addedStyles.indexOf(prop) === -1) {
                            oldStyles[prop] = style[prop];
                        }
                        newStyles.push(prop);
                        val = exec[2].trim();
                        if (urls.length > 0 && val.indexOf(urlReplace) !== -1) {
                            val = val.replace(urlReplace, urls.shift());
                        }
                        styleChanges[prop] = val;
                    }
                    length = addedStyles.length;
                    while (length-- > 0) {
                        prop = addedStyles[length];
                        if (newStyles.indexOf(prop) === -1) {
                            styleChanges[prop] = oldStyles[prop];
                            addedStyles.splice(length, 1);
                        }
                    }
                    var keys = Object.keys(styleChanges);
                    length = keys.length;
                    while (length-- > 0) {
                        prop = keys[length];
                        style[prop] = styleChanges[prop];
                    }
                    _this.__addedStyles = addedStyles.concat(newStyles);
                });
            };
            return Style;
        }(SetAttributeControl));
        controls.Style = Style;
        register.control(__Checked, Checked);
        register.control(__Disabled, Disabled);
        register.control(__Selected, Selected);
        register.control(__ReadOnly, ReadOnly);
        register.control(__Visible, Visible);
        register.control(__Style, Style);
        /**
         * Base class used for setting the property of an element (e.g. href for anchor elements).
         */
        var ElementPropertyControl = (function (_super) {
            __extends(ElementPropertyControl, _super);
            function ElementPropertyControl() {
                _super.apply(this, arguments);
            }
            /**
             * The function for setting the corresponding
             * attribute property value to the evaluated expression.
             */
            ElementPropertyControl.prototype.setter = function () {
                var element = this.element, elementProperty = this.property, expression = this.attributes[this.attribute];
                if (isEmpty(expression) || isNull(element)) {
                    return;
                }
                if (!isUndefined(element[elementProperty])) {
                    element[elementProperty] = expression;
                }
            };
            return ElementPropertyControl;
        }(SetAttributeControl));
        controls.ElementPropertyControl = ElementPropertyControl;
        /**
         * A type of ElementPropertyControl used to set 'href' on an anchor tag.
         */
        var Href = (function (_super) {
            __extends(Href, _super);
            function Href() {
                _super.apply(this, arguments);
                /**
                 * Used to set the element's href property.
                 */
                this.property = 'href';
            }
            return Href;
        }(ElementPropertyControl));
        controls.Href = Href;
        /**
         * A type of ElementPropertyControl used to set 'src' on an anchor tag.
         */
        var Src = (function (_super) {
            __extends(Src, _super);
            function Src() {
                _super.apply(this, arguments);
                /**
                 * Used to set the element's src property.
                 */
                this.property = 'src';
            }
            /**
             * The function for setting the corresponding
             * attribute property value to the evaluated expression.
             */
            Src.prototype.setter = function () {
                var element = this.element, elementProperty = this.property, expression = this.attributes[this.attribute];
                if (isEmpty(expression) || isNull(element)) {
                    return;
                }
                if (!isUndefined(element[elementProperty])) {
                    element[elementProperty] = this._browser.urlUtils(expression);
                }
            };
            Src._inject = {
                _browser: __Browser
            };
            return Src;
        }(ElementPropertyControl));
        controls.Src = Src;
        register.control(__Href, Href);
        register.control(__Src, Src);
        /**
         * Facilitates two-way databinding for HTMLInputElements, HTMLSelectElements, and HTMLTextAreaElements.
         */
        var Bind = (function (_super) {
            __extends(Bind, _super);
            function Bind() {
                _super.apply(this, arguments);
                /**
                 * The priority of Bind is set high to precede
                 * other controls that may be listening to the same
                 * event.
                 */
                this.priority = 100;
                /**
                 * Whether or not Bind is being used in conjunction
                 * with a TemplateControl that implements the
                 * interface ISupportTwoWayBinding.
                 */
                this._supportsTwoWayBinding = false;
                /**
                 * Whether or not the File API is supported.
                 */
                this.__fileSupported = acquire(__Compat).fileSupported;
                /**
                 * Used to grab a filename from input[type="file"].
                 */
                this.__fileNameRegex = acquire(__Regex).fileNameRegex;
                /**
                 * Used to denote that a property change happened from within this control.
                 */
                this.__isSelf = false;
            }
            /**
             * Determines the type of Element being bound to
             * and sets the necessary handlers.
             */
            Bind.prototype.initialize = function () {
                this._determineType();
            };
            /**
             * Parses and watches the expression being bound to.
             */
            Bind.prototype.loaded = function () {
                var parent = this.parent;
                if (isNull(parent) || isNull(this.element)) {
                    return;
                }
                var attr = camelCase(this.type), _parser = this._parser, expression = this._expression = _parser.parse(this.attributes[attr]);
                var identifiers = expression.identifiers;
                if (identifiers.length !== 1) {
                    this._log.warn('Only 1 identifier allowed in a ' + this.type + ' expression.');
                    this._contextExpression = null;
                    return;
                }
                var split = identifiers[0].split('.');
                this._property = split.pop();
                if (expression.aliases.length > 0) {
                    var alias = expression.aliases[0], resourceObj_1 = parent.findResource(alias), type = void 0;
                    if (isObject(resourceObj_1)) {
                        type = resourceObj_1.resource.type;
                        if (type !== __OBSERVABLE_RESOURCE && type !== __LITERAL_RESOURCE) {
                            return;
                        }
                    }
                    else {
                        resourceObj_1 = { resource: {} };
                    }
                    if (alias === __CONTEXT_RESOURCE || alias === __ROOT_CONTEXT_RESOURCE) {
                        this._contextExpression = _parser.parse(split.join('.'));
                    }
                    else {
                        this._property = 'value';
                        this._contextExpression = {
                            evaluate: function () {
                                return resourceObj_1.resource;
                            },
                            aliases: [],
                            identifiers: [],
                            expression: ''
                        };
                    }
                }
                else if (split.length > 0) {
                    this._contextExpression = _parser.parse(split.join('.'));
                }
                else {
                    this._contextExpression = {
                        evaluate: function () {
                            return parent.context;
                        },
                        aliases: [],
                        identifiers: [],
                        expression: ''
                    };
                }
                if (this._supportsTwoWayBinding) {
                    this.templateControl.observeProperties(this);
                }
                this._watchExpression();
                if (isNull(this._addEventType)) {
                    return;
                }
                this._addEventType();
            };
            /**
             * Re-observes the expression with the new context.
             */
            Bind.prototype.contextChanged = function () {
                this._watchExpression();
            };
            /**
             * Removes all of the element's event listeners.
             */
            Bind.prototype.dispose = function () {
                this._addEventType = null;
            };
            /**
             * Gets the current value of the bound property.
             */
            Bind.prototype.evaluate = function () {
                var expression = this._expression;
                if (isUndefined(expression)) {
                    return;
                }
                return this.evaluateExpression(expression);
            };
            Bind.prototype.observeProperty = function (listener, identifier, autocast) {
                return this._observeProperty(listener, identifier, autocast);
            };
            Bind.prototype.observeArrayChange = function (listener, identifier) {
                return this._observeProperty(listener, identifier, false, true);
            };
            /**
             * Adds a text event as the event listener.
             * Used for textarea and input[type="text"].
             */
            Bind.prototype._addTextEventListener = function () {
                var _this = this;
                var element = this.element, _compat = this._compat, composing = false, input = 'input', timeout, eventListener = function () {
                    if (composing) {
                        return;
                    }
                    _this._propertyChanged();
                }, postponedEventListener = function () {
                    if (isFunction(timeout)) {
                        return;
                    }
                    timeout = postpone(function () {
                        eventListener();
                        timeout = null;
                    });
                };
                if (isUndefined(_compat.ANDROID)) {
                    this.addEventListener(element, 'compositionstart', function () { composing = true; }, false);
                    this.addEventListener(element, 'compositionend', function () {
                        composing = false;
                        eventListener();
                    }, false);
                }
                if (_compat.hasEvent(input)) {
                    this.addEventListener(element, input, eventListener, false);
                }
                else {
                    this.addEventListener(element, 'keydown', function (ev) {
                        var key = ev.keyCode || ev.which, codes = controls.KeyCodes;
                        if (key === codes.lwk ||
                            key === codes.rwk ||
                            (key >= codes.shift && key <= codes.escape) ||
                            (key > codes.space && key <= codes.down)) {
                            return;
                        }
                        postponedEventListener();
                    }, false);
                    this.addEventListener(element, 'cut', postponedEventListener, false);
                    this.addEventListener(element, 'paste', postponedEventListener, false);
                }
                this.addEventListener(element, 'change', eventListener, false);
            };
            /**
             * Adds a change event as the event listener.
             * Used for select, input[type="radio"], and input[type="range"].
             */
            Bind.prototype._addChangeEventListener = function () {
                this.addEventListener(this.element, 'change', this._propertyChanged, false);
            };
            /**
             * Adds a $tap event as the event listener.
             * Used for input[type="button"] and button.
             */
            Bind.prototype._addButtonEventListener = function () {
                this.addEventListener(this.element, __tap, this._propertyChanged, false);
            };
            /**
             * Adds a change event as the event listener.
             * Used for select, input[type="radio"], and input[type="range"].
             */
            Bind.prototype._addRangeEventListener = function () {
                var element = this.element, input = 'input';
                if (this._compat.hasEvent(input)) {
                    this.addEventListener(element, input, this._propertyChanged, false);
                }
                this.addEventListener(element, 'change', this._propertyChanged, false);
            };
            /**
             * Getter for input[type="checkbox"] and input[type="radio"].
             */
            Bind.prototype._getChecked = function () {
                return this.element.checked;
            };
            /**
             * Getter for input[type="text"], input[type="range"],
             * textarea, and select.
             */
            Bind.prototype._getValue = function () {
                return this.element.value;
            };
            /**
             * Getter for button.
             */
            Bind.prototype._getTextContent = function () {
                return this.element.textContent;
            };
            /**
             * Getter for input[type="file"]. Creates a partial IFile
             * element if file is not supported.
             */
            Bind.prototype._getFile = function () {
                var element = this.element, value = element.value;
                if (this.__fileSupported) {
                    if (element.files.length > 0) {
                        return element.files[0];
                    }
                    return null;
                }
                return {
                    name: value.replace(this.__fileNameRegex, ''),
                    path: value,
                    lastModifiedDate: undefined,
                    type: undefined,
                    size: undefined,
                    msDetachStream: noop,
                    msClose: noop,
                    slice: function () { return {}; }
                };
            };
            /**
             * Getter for input[type="file"]-multiple.
             */
            Bind.prototype._getFiles = function () {
                var element = this.element;
                if (this.__fileSupported) {
                    return Array.prototype.slice.call(element.files);
                }
                // this case should never be hit since ie9 does not support multi-file uploads, 
                // but kept in here for now for consistency's sake 
                var filelist = element.value.split(/,|;/g), length = filelist.length, files = [], fileValue, blobSlice = function () { return {}; };
                for (var i = 0; i < length; ++i) {
                    fileValue = filelist[i];
                    files.push({
                        name: fileValue.replace(this.__fileNameRegex, ''),
                        path: fileValue,
                        lastModifiedDate: undefined,
                        type: undefined,
                        size: undefined,
                        msDetachStream: noop,
                        msClose: noop,
                        slice: blobSlice
                    });
                }
                return files;
            };
            /**
             * Getter for select-multiple.
             */
            Bind.prototype._getSelectedValues = function () {
                var options = this.element.options, length = options.length, option, selectedValues = [];
                for (var i = 0; i < length; ++i) {
                    option = options[i];
                    if (option.selected) {
                        selectedValues.push(option.value);
                    }
                }
                return selectedValues;
            };
            /**
             * Setter for textarea, input[type="text"],
             * and input[type="button"], and select.
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setText = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                if (isNull(newValue)) {
                    newValue = '';
                    if (firstTime === true) {
                        if (isNull(this.element.value)) {
                            this._setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }
                this._setValue(newValue);
            };
            /**
             * Setter for input[type="range"].
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setRange = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                if (isEmpty(newValue)) {
                    newValue = newValue === '' ? '0' : 0;
                    if (firstTime === true) {
                        if (isEmpty(this.element.value)) {
                            this._setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }
                this._setValue(newValue);
            };
            /**
             * Setter for input[type="hidden"].
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setHidden = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                if (isEmpty(newValue)) {
                    newValue = '';
                    if (firstTime === true) {
                        if (isEmpty(this.element.value)) {
                            this._setValue(newValue);
                        }
                        this._propertyChanged();
                        return;
                    }
                }
                this._setValue(newValue);
            };
            /**
             * Sets the value on an element.
             * @param {any} newValue The new value to set
             */
            Bind.prototype._setValue = function (newValue) {
                var element = this.element;
                if (!isString(newValue)) {
                    if (isNumber(newValue)) {
                        this._propertyType = 'number';
                        newValue = newValue.toString();
                    }
                    else if (isBoolean(newValue)) {
                        this._propertyType = 'boolean';
                        newValue = newValue.toString();
                    }
                }
                if (element.value === newValue) {
                    return;
                }
                element.value = newValue;
            };
            /**
             * Setter for input[type="checkbox"]
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setChecked = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                else if (!isBoolean(newValue)) {
                    newValue = !!newValue;
                    if (firstTime === true) {
                        this.element.checked = newValue;
                        this._propertyChanged();
                        return;
                    }
                }
                this.element.checked = newValue;
            };
            /**
             * Setter for input[type="radio"]
             * @param {any} newValue The new value to set
             */
            Bind.prototype._setRadio = function (newValue) {
                var element = this.element;
                if (this.__isSelf) {
                    return;
                }
                else if (isNull(newValue)) {
                    if (element.checked) {
                        this._propertyChanged();
                    }
                    return;
                }
                else if (!isString(newValue)) {
                    if (isNumber(newValue)) {
                        this._propertyType = 'number';
                        newValue = newValue.toString();
                    }
                    else if (isBoolean(newValue)) {
                        this._propertyType = 'boolean';
                        newValue = newValue.toString();
                    }
                }
                element.checked = (element.value === newValue);
            };
            /**
             * Setter for select
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setSelectedIndex = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                var element = this.element, value = element.value;
                if (isNull(newValue)) {
                    if (firstTime === true || !this._document.body.contains(element)) {
                        this._propertyChanged();
                        return;
                    }
                    element.selectedIndex = -1;
                    return;
                }
                else if (!isString(newValue)) {
                    if (isNumber(newValue)) {
                        this._propertyType = 'number';
                        newValue = newValue.toString();
                    }
                    else if (isBoolean(newValue)) {
                        this._propertyType = 'boolean';
                        newValue = newValue.toString();
                    }
                    else {
                        this._log.info('Trying to bind an invalid value to a <select> element using a ' + this.type + '.');
                    }
                }
                if (value === newValue) {
                    return;
                }
                else if (!this._document.body.contains(element)) {
                    element.value = newValue;
                    if (element.value !== newValue) {
                        element.value = value;
                        this._propertyChanged();
                    }
                    return;
                }
                element.value = newValue;
                // check to make sure the user changed to a valid value 
                // second boolean argument is an ie fix for inconsistency 
                if (element.value !== newValue || element.selectedIndex === -1) {
                    element.selectedIndex = -1;
                }
            };
            /**
             * Setter for select-multiple
             * @param {any} newValue The new value to set
             * @param {any} oldValue The previously bound value
             * @param {boolean} firstTime? The context is being evaluated for the first time and
             * should thus change the property if null
             */
            Bind.prototype._setSelectedIndices = function (newValue, oldValue, firstTime) {
                if (this.__isSelf) {
                    return;
                }
                var options = this.element.options, length = isNull(options) ? 0 : options.length, option, nullValue = isNull(newValue);
                if (nullValue || !isArray(newValue)) {
                    if (firstTime === true) {
                        this._propertyChanged();
                    }
                    // unselects the options unless a match is found 
                    while (length-- > 0) {
                        option = options[length];
                        if (!nullValue && option.value === '' + newValue) {
                            option.selected = true;
                            return;
                        }
                        option.selected = false;
                    }
                    return;
                }
                var value, numberValue, index, highestIndex = Infinity;
                while (length-- > 0) {
                    option = options[length];
                    value = option.value;
                    if (newValue.indexOf(value) !== -1) {
                        option.selected = true;
                        continue;
                    }
                    numberValue = Number(value);
                    if (isNumber(numberValue) && (index = newValue.indexOf(numberValue)) !== -1) {
                        if (index < highestIndex) {
                            this._propertyType = 'number';
                            highestIndex = index;
                        }
                        option.selected = true;
                        continue;
                    }
                    else if ((value === 'true' && (index = newValue.indexOf(true)) !== -1) ||
                        value === 'false' && (index = newValue.indexOf(false)) !== -1) {
                        if (index < highestIndex) {
                            this._propertyType = 'boolean';
                            highestIndex = index;
                        }
                        option.selected = true;
                        continue;
                    }
                    option.selected = false;
                }
            };
            /**
             * Determines the type of Element being bound to
             * and sets the necessary handlers.
             */
            Bind.prototype._determineType = function () {
                if (this._observingBindableProperty()) {
                    return;
                }
                var element = this.element;
                if (isNull(element)) {
                    return;
                }
                switch (element.nodeName.toLowerCase()) {
                    case 'input':
                        switch (element.type) {
                            case 'button':
                            case 'submit':
                            case 'reset':
                            case 'image':
                                this._addEventType = this._addButtonEventListener;
                                this._getter = this._getValue;
                                break;
                            case 'checkbox':
                                this._addEventType = this._addChangeEventListener;
                                this._getter = this._getChecked;
                                this._setter = this._setChecked;
                                break;
                            case 'radio':
                                this._initializeRadio();
                                break;
                            case 'range':
                                this._addEventType = this._addRangeEventListener;
                                this._getter = this._getValue;
                                this._setter = this._setRange;
                                break;
                            case 'file':
                                var multi = element.multiple;
                                this._addEventType = this._addChangeEventListener;
                                this._getter = multi ? this._getFiles : this._getFile;
                                break;
                            case 'hidden':
                                this._getter = this._getValue;
                                this._setter = this._setHidden;
                                break;
                            default:
                                this._addEventType = this._addTextEventListener;
                                this._getter = this._getValue;
                                this._setter = this._setText;
                                break;
                        }
                        break;
                    case 'textarea':
                        this._addEventType = this._addTextEventListener;
                        this._getter = this._getValue;
                        this._setter = this._setText;
                        break;
                    case 'select':
                        this._initializeSelect();
                        break;
                    case 'button':
                        this._addEventType = this._addButtonEventListener;
                        this._getter = this._getTextContent;
                        break;
                }
            };
            /**
             * Observes the expression to bind to.
             */
            Bind.prototype._watchExpression = function () {
                var _this = this;
                var contextExpression = this._contextExpression, context = this.evaluateExpression(contextExpression);
                if (!isObject(context)) {
                    if (isNull(context) && contextExpression.identifiers.length > 0) {
                        context = this._createContext(contextExpression.identifiers[0]);
                    }
                    else {
                        this._log.warn(this.type + ' is trying to index into a primitive type. ' +
                            this._contextExpression.expression + ' is already defined and not ' +
                            'an object when trying to evaluate ' + this.type + '="' +
                            this._expression.expression + '"');
                        return;
                    }
                }
                var property;
                if (!isFunction(this._setter)) {
                    return;
                }
                else if (this._setter === this._setSelectedIndices) {
                    property = this._property;
                    if (isNull(context[property])) {
                        context[property] = [];
                    }
                    this.observeArray(function (arrayInfo) {
                        _this._setter(arrayInfo[0].object, null, true);
                    }, contextExpression + '.' + property);
                }
                var expression = this._expression;
                this.observeExpression(function (newValue, oldValue) {
                    _this._setter(newValue, oldValue);
                }, expression);
                this._setter(this.evaluateExpression(expression), undefined, true);
            };
            /**
             * Handles creating context with an identifier.
             * @param {string} identifier The identifier to base the created context off of.
             */
            Bind.prototype._createContext = function (identifier) {
                var split = identifier.split('.'), start = split.shift().slice(1), parent = this.parent;
                if (start === __ROOT_CONTEXT_RESOURCE) {
                    identifier = split.join('.');
                    parent = this.parent.root;
                }
                else if (start === __CONTEXT) {
                    identifier = split.join('.');
                }
                return this._ContextManager.createContext(parent, identifier);
            };
            /**
             * Handles casting the bound property back to its initial type if necessary.
             * @param {any} value The value to cast.
             * @param {any} type? The optional type to cast the value to.
             */
            Bind.prototype._castProperty = function (value, type) {
                var castValue;
                type = type || this._propertyType;
                if (isNull(type)) {
                    return value;
                }
                else if (isObject(value)) {
                    if (isArray(value)) {
                        var length_12 = value.length;
                        castValue = [];
                        for (var i = 0; i < length_12; ++i) {
                            castValue.push(this._castProperty(value[i], type));
                        }
                    }
                    else if (isDate(value) || isFile(value) || isPromise(value) || isWindow(value) || isNode(value)) {
                        castValue = value;
                    }
                    else {
                        var keys = Object.keys(value), key = void 0;
                        castValue = {};
                        while (keys.length > 0) {
                            key = keys.pop();
                            castValue[key] = value[key];
                        }
                    }
                }
                else {
                    switch (type) {
                        case 'string':
                            if (isString(value)) {
                                castValue = value;
                            }
                            else if (isFunction(value.toString)) {
                                castValue = value.toString();
                            }
                            else {
                                castValue = Object.prototype.toString.call(value);
                            }
                            break;
                        case 'number':
                            castValue = isEmpty(value) ? undefined : Number(value);
                            break;
                        case 'boolean':
                            switch (value) {
                                case 'true':
                                    castValue = true;
                                    break;
                                case 'false':
                                case '0':
                                case 'null':
                                case 'undefined':
                                    castValue = false;
                                    break;
                                default:
                                    castValue = !!value;
                                    break;
                            }
                            break;
                        default:
                            castValue = value;
                            break;
                    }
                }
                return castValue;
            };
            /**
             * Sets the context property being bound to when the
             * element's property is changed.
             */
            Bind.prototype._propertyChanged = function () {
                if (isNull(this._contextExpression)) {
                    return;
                }
                var context = this.evaluateExpression(this._contextExpression);
                if (!isObject(context)) {
                    return;
                }
                var property = this._property, newValue = this._castProperty(this._getter());
                if (context[property] === newValue) {
                    return;
                }
                // set flag to let setter functions know we changed the property 
                this.__isSelf = true;
                context[property] = newValue;
                this.__isSelf = false;
            };
            /**
             * Normalizes input[type="radio"] for cross-browser compatibility.
             */
            Bind.prototype._initializeRadio = function () {
                var element = this.element;
                this._addEventType = this._addChangeEventListener;
                this._getter = this._getValue;
                this._setter = this._setRadio;
                if (!element.hasAttribute('name')) {
                    var attr = camelCase(this.type), expression = this.attributes[attr];
                    element.setAttribute('name', expression);
                }
                if (element.hasAttribute('value')) {
                    return;
                }
                element.setAttribute('value', '');
            };
            /**
             * Normalizes HTMLSelectElements for cross-browser compatibility.
             */
            Bind.prototype._initializeSelect = function () {
                var element = this.element, multiple = element.multiple, options = element.options, length = options.length, option;
                this._addEventType = this._addChangeEventListener;
                if (multiple) {
                    this._getter = this._getSelectedValues;
                    this._setter = this._setSelectedIndices;
                }
                else {
                    this._getter = this._getValue;
                    this._setter = this._setSelectedIndex;
                }
                for (var i = 0; i < length; ++i) {
                    option = options[i];
                    if (!option.hasAttribute('value')) {
                        option.setAttribute('value', option.textContent);
                    }
                }
            };
            /**
             * Checks if the associated TemplateControl is implementing
             * ISupportTwoWayBinding and initializes all listeners accordingly.
             */
            Bind.prototype._observingBindableProperty = function () {
                var _this = this;
                var templateControl = this.templateControl;
                if (isObject(templateControl) && isFunction(templateControl.onInput) && isFunction(templateControl.observeProperties)) {
                    templateControl.onInput(function (newValue) {
                        _this._getter = function () { return newValue; };
                        _this._propertyChanged();
                    });
                    return (this._supportsTwoWayBinding = true);
                }
                return false;
            };
            /**
             * A function that allows a ISupportTwoWayBinding to observe either the
             * bound property specified by the identifier (as well as potential child properties if being bound to an object) or
             * Array mutations.
             * @param {Function} listener The listener function.
             * @param {any} identifier? The index off of the bound object to listen to for changes if the bound object is an Array.
             * If undefined or empty the listener will listen for changes to the bound Array itself.
             * @param {boolean} autocast? Will cast a primitive value to whatever it was set to in code.
             * @param {boolean} arrayMutations? Whether or not this is for Array mutation changes.
             */
            Bind.prototype._observeProperty = function (listener, identifier, autocast, arrayMutations) {
                var _this = this;
                var parsedIdentifier;
                if (isEmpty(identifier)) {
                    parsedIdentifier = this._expression.expression;
                }
                else if (isNumber(identifier)) {
                    parsedIdentifier = this._expression.expression + '.' + identifier;
                }
                else {
                    var _parser = this._parser, identifierExpression = _parser.parse(identifier), identifiers = identifierExpression.identifiers;
                    if (identifiers.length !== 1) {
                        this._log.warn('Only 1 identifier path allowed when observing changes to a bound property\'s child with a control ' +
                            'implementing observable.ISupportTwoWayBinding and working with ' + this.type);
                        return;
                    }
                    var expression = _parser.parse(this._expression.expression + '.' + identifiers[0]);
                    parsedIdentifier = expression.identifiers[0];
                    var split = parsedIdentifier.split('.');
                    split.pop();
                    var contextExpression = split.join('.'), context = this.evaluateExpression(contextExpression);
                    if (!isObject(context)) {
                        if (isNull(context)) {
                            context = this._ContextManager.createContext(this.parent, contextExpression);
                        }
                        else {
                            this._log.warn('A control implementing observable.ISupportTwoWayBinding is trying to index into a primitive type ' +
                                'when trying to evaluate ' + this.type + '="' + this._expression.expression + '"');
                            return;
                        }
                    }
                }
                listener = listener.bind(this.templateControl);
                autocast = autocast === true;
                var removeListener;
                if (arrayMutations === true) {
                    removeListener = this.observeArray(function (changes) {
                        listener(changes, identifier);
                    }, parsedIdentifier);
                }
                else {
                    removeListener = this.observe(function (newValue, oldValue) {
                        if (_this.__isSelf || newValue === oldValue) {
                            return;
                        }
                        else if (autocast) {
                            _this._propertyType = _this._getPropertyType(newValue);
                        }
                        listener(newValue, oldValue, identifier);
                    }, parsedIdentifier);
                    var value = this.evaluateExpression(parsedIdentifier);
                    if (autocast) {
                        this._propertyType = this._getPropertyType(value);
                    }
                    listener(value, undefined, identifier, true);
                }
                return removeListener;
            };
            /**
             * Gets the property type of the passed in argument.
             * @param {any} value The value to grab the property type from.
             */
            Bind.prototype._getPropertyType = function (value) {
                if (isObject(value)) {
                    return value;
                }
                else if (isString(value)) {
                    return 'string';
                }
                else if (isNumber(value)) {
                    return 'number';
                }
                else if (isBoolean(value)) {
                    return 'boolean';
                }
            };
            Bind._inject = {
                _parser: __Parser,
                _ContextManager: __ContextManagerStatic,
                _compat: __Compat,
                _document: __Document
            };
            return Bind;
        }(AttributeControl));
        controls.Bind = Bind;
        register.control(__Bind, Bind);
        /**
         * An AttributeControl that deals with observing changes for a specified property.
         */
        var ObservableAttributeControl = (function (_super) {
            __extends(ObservableAttributeControl, _super);
            function ObservableAttributeControl() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = '';
                /**
                 * This control needs to load before its templateControl
                 */
                this.priority = 200;
                /**
                 * The set of functions added by the Template Control that listens
                 * for property changes.
                 */
                this._listeners = [];
                /**
                 * The _addListener function bound to this control.
                 */
                this._boundAddListener = this._addListener.bind(this);
            }
            /**
             * Sets the initial value of the property on
             * the Template Control.
             */
            ObservableAttributeControl.prototype.initialize = function () {
                this.attribute = camelCase(this.type);
                this._setProperty(this._getValue());
            };
            /**
             * Observes the property and resets the value.
             */
            ObservableAttributeControl.prototype.loaded = function () {
                this._observeProperty();
                this._setProperty(this._getValue());
            };
            /**
             * Stops listening for changes to the evaluated
             * expression and removes references to the listeners
             * defined by the Template Control.
             */
            ObservableAttributeControl.prototype.dispose = function () {
                if (isFunction(this._removeListener)) {
                    this._removeListener();
                }
                this._listeners = [];
            };
            /**
             * Sets the property on the Template Control.
             * @param {any} value The new value of the evaluated expression.
             * @param {any} oldValue? The old value of the evaluated expression.
             */
            ObservableAttributeControl.prototype._setProperty = function (value, oldValue) {
                var templateControl = this.templateControl;
                if (isNull(templateControl)) {
                    return;
                }
                this._ContextManager.defineGetter(templateControl, this.property, {
                    value: value,
                    observe: this._boundAddListener
                }, true, true);
                this._callListeners(value, oldValue);
            };
            /**
             * Calls the listeners defined by the Template Control.
             * @param {any} value The new value of the evaluated expression.
             * @param {any} oldValue The old value of the evaluated expression.
             */
            ObservableAttributeControl.prototype._callListeners = function (newValue, oldValue) {
                var listeners = this._listeners, length = listeners.length;
                for (var i = 0; i < length; ++i) {
                    listeners[i](newValue, oldValue);
                }
            };
            /**
             * Adds a listener as defined by the Template Control.
             * @param {plat.IPropertyChangedListener} listener The listener added by the Template Control.
             */
            ObservableAttributeControl.prototype._addListener = function (listener) {
                var listeners = this._listeners;
                listener = listener.bind(this.templateControl);
                listeners.push(listener);
                return function () {
                    var index = listeners.indexOf(listener);
                    if (index === -1) {
                        return;
                    }
                    listeners.splice(index, 1);
                };
            };
            /**
             * Evaluates the attribute's value.
             */
            ObservableAttributeControl.prototype._getValue = function () {
                if (isNull(this.templateControl)) {
                    return;
                }
                return this.evaluateExpression(this.attributes[this.attribute]);
            };
            /**
             * Observes the attribute's value.
             */
            ObservableAttributeControl.prototype._observeProperty = function () {
                if (isNull(this.templateControl)) {
                    return;
                }
                this._removeListener = this.observeExpression(this._setProperty, this.attributes[this.attribute]);
            };
            ObservableAttributeControl._inject = {
                _ContextManager: __ContextManagerStatic
            };
            return ObservableAttributeControl;
        }(AttributeControl));
        controls.ObservableAttributeControl = ObservableAttributeControl;
        /**
         * An ObservableAttributeControl that sets 'options' as the
         * associated property.
         */
        var Options = (function (_super) {
            __extends(Options, _super);
            function Options() {
                _super.apply(this, arguments);
                /**
                 * The property to set on the associated template control.
                 */
                this.property = 'options';
            }
            return Options;
        }(ObservableAttributeControl));
        controls.Options = Options;
        register.control(__Options, Options);
    })(controls = plat_1.controls || (plat_1.controls = {}));
    /**
     * Class for every app. This class contains hooks for Application Lifecycle Events
     * as well as error handling.
     */
    var App = (function () {
        /**
         * Class for every app. This class contains hooks for Application Lifecycle Management (ALM)
         * as well as error handling and navigation events.
         */
        function App() {
            /**
             * A unique id, created during instantiation.
             */
            this.uid = uniqueId(__Plat);
            /**
             * Reference to the Log injectable.
             */
            this._log = App._log;
            var navigator = this.navigator = acquire(__NavigatorInstance);
            navigator.initialize(acquire(__RouterStatic).currentRouter());
        }
        /**
         * A static method for initiating the app startup.
         */
        App.start = function () {
            if (!App._compat.isCompatible) {
                return App._log.error(new Error('PlatypusTS only supports modern browsers where ' +
                    'Object.defineProperty is defined'));
            }
            App.__addPlatCss();
            var _EventManager = App._EventManager;
            _EventManager.dispose(__APP);
            _EventManager.on(__APP, __ready, App.__ready);
            _EventManager.on(__APP, __shutdown, App.__shutdown);
            _EventManager.initialize();
        };
        /**
         * A static method called upon app registration. Primarily used
         * to initiate a ready state in the case that amd is being used.
         * @param {plat.dependency.Injector<plat.App>} appInjector The injector for
         * injecting the app instance.
         */
        App.registerApp = function (appInjector) {
            if (!isNull(App.app) && isString(App.app.uid)) {
                App._EventManager.dispose(App.app.uid);
            }
            App.__injector = appInjector;
        };
        /**
         * Kicks off compilation of the DOM from the specified node. If no node is specified,
         * the default start node is document.body.
         * @param {Node} node The node at which DOM compilation begins.
         */
        App.load = function (node) {
            var _LifecycleEvent = App._LifecycleEvent, _compiler = App._compiler, body = App._document.body, head = App._document.head;
            _LifecycleEvent.dispatch(__beforeLoad, App);
            if (isNull(node)) {
                body.setAttribute(__Hide, '');
                postpone(function () {
                    _compiler.compile([head]);
                    _compiler.compile([body]);
                    body.removeAttribute(__Hide);
                });
                return;
            }
            if (isFunction(node.setAttribute)) {
                node.setAttribute(__Hide, '');
                postpone(function () {
                    _compiler.compile([node]);
                    node.removeAttribute(__Hide);
                });
                return;
            }
            postpone(function () {
                _compiler.compile([node]);
            });
        };
        /**
         * A static method called when the application is ready. It calls the app instance's
         * ready function as well as checks for the presence of a module loader. If one exists,
         * loading the DOM falls back to the app developer. If it doesn't, the DOM is loaded from
         * document.body.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent for the app ready.
         */
        App.__ready = function (ev) {
            dependency.Injector.initialize();
            App.__registerAppEvents(ev);
            if (!ev.defaultPrevented) {
                App.load();
            }
        };
        /**
         * A static method called when the application wants to programmatically shutdown.
         */
        App.__shutdown = function () {
            var app = navigator.app, _LifecycleEvent = App._LifecycleEvent, ev;
            if (!isNull(app) && isFunction(app.exitApp)) {
                ev = _LifecycleEvent.dispatch(__exiting, App);
                if (ev.defaultPrevented) {
                    return;
                }
                app.exitApp();
            }
        };
        /**
         * A static method called to register all the LifecycleEvents for an app instance.
         */
        App.__registerAppEvents = function (ev) {
            var appInjector = App.__injector;
            if (isNull(appInjector) || !isFunction(appInjector.inject)) {
                return;
            }
            var app = App.app = appInjector.inject();
            app.on(__suspend, app.suspend);
            app.on(__resume, app.resume);
            app.on(__online, app.online);
            app.on(__offline, app.offline);
            app.on(__error, app.error);
            app.on(__exiting, app.exiting);
            if (isFunction(app.ready)) {
                app.ready(ev);
            }
        };
        /**
         * We need to add [plat-hide] as a css property if platypus.css doesn't exist so we can use it to temporarily
         * hide elements.
         */
        App.__addPlatCss = function () {
            var _document = App._document;
            if (App._compat.platCss) {
                return;
            }
            else if (!isNull(_document.styleSheets) && _document.styleSheets.length > 0) {
                _document.styleSheets[0].insertRule('[plat-hide] { display: none !important; }', 0);
                return;
            }
            var style = document.createElement('style');
            style.textContent = '[plat-hide] { display: none !important; }';
            document.head.appendChild(style);
        };
        /**
         * Event fired when the app is suspended.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.suspend = function (ev) { };
        /**
         * Event fired when the app resumes from the suspended state.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.resume = function (ev) { };
        /**
         * Event fired when an internal error occures.
         * @param {plat.events.ErrorEvent<Error>} ev The ErrorEvent object.
         */
        App.prototype.error = function (ev) { };
        /**
         * Event fired when the app is ready.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.ready = function (ev) { };
        /**
         * Event fired when the app has been programatically shutdown. This event is cancelable.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.exiting = function (ev) { };
        /**
         * Event fired when the app regains connectivity and is now in an online state.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.online = function (ev) { };
        /**
         * Event fired when the app loses connectivity and is now in an offline state.
         * @param {plat.events.LifecycleEvent} ev The LifecycleEvent object.
         */
        App.prototype.offline = function (ev) { };
        /**
         * Creates a new DispatchEvent and propagates it to all
         * listeners based on the DIRECT method. Propagation
         * will always start with the sender, so the sender can both produce and consume the same event.
         * @param {string} name The name of the event to send, cooincides with the name used in the
         * app.on() method.
         * @param {Array<any>} ...args Any number of arguments to send to all the listeners.
         */
        App.prototype.dispatchEvent = function (name) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _EventManager = App._EventManager || acquire(__EventManagerStatic);
            _EventManager.dispatch(name, this, _EventManager.DIRECT, args);
        };
        /**
         * Registers a listener for a DispatchEvent. The listener will be called when
         * a DispatchEvent is propagating over the app. Any number of listeners can exist for a single event name.
         * @param {string} name The name of the event, cooinciding with the DispatchEvent name.
         * @param {(ev: plat.events.DispatchEvent, ...args: Array<any>) => void} listener The method called when
         * the DispatchEvent is fired.
         */
        App.prototype.on = function (name, listener) {
            var _EventManager = App._EventManager || acquire(__EventManagerStatic);
            return _EventManager.on(this.uid, name, listener, this);
        };
        /**
         * Kicks off compilation of the DOM from the specified node. If no node is specified,
         * the default start node is document.body. This method should be called from the app when
         * using module loaders. If a module loader is in use, the app will delay loading until
         * this method is called.
         * @param {Node} node The node where at which DOM compilation begins.
         */
        App.prototype.load = function (node) {
            App.load(node);
        };
        /**
         * Calls to exit the application. Makes the necessary calls to the device is possible.
         */
        App.prototype.exit = function () {
            this.dispatchEvent(__shutdown);
        };
        /**
         * The instance of the registered IApp.
         */
        App.app = null;
        return App;
    }());
    plat_1.App = App;
    /**
     */
    function IAppStatic(_compat, _EventManager, _document, _compiler, _LifecycleEvent, _log) {
        App._compat = _compat;
        App._EventManager = _EventManager;
        App._document = _document;
        App._compiler = _compiler;
        App._LifecycleEvent = _LifecycleEvent;
        App._log = _log;
        return App;
    }
    plat_1.IAppStatic = IAppStatic;
    register.injectable(__AppStatic, IAppStatic, [
        __Compat,
        __EventManagerStatic,
        __Document,
        __Compiler,
        __LifecycleEventStatic,
        __Log
    ], __STATIC);
    /**
     */
    function IApp(_AppStatic) {
        return _AppStatic.app;
    }
    plat_1.IApp = IApp;
    register.injectable(__App, IApp, [__AppStatic], __INSTANCE);
})(plat || (plat = {}));
module.exports = plat;

},{}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/* tslint:disable */
/**
 * PlatypusUI v0.14.7 (https://platypi.io)
 * Copyright 2015 Platypi, LLC. All rights reserved.
 *
 * PlatypusUI is licensed under the MIT license found at
 * https://github.com/Platypi/platypusui/blob/master/LICENSE
 *
 */
/**
 * The entry point into the platypus UI controls library.
 */
var platui;
(function (platui) {
    'use strict';
    /* tslint:disable:no-unused-variable */
    /*
     */
    var __prefix = '$', __Promise = __prefix + "Promise", __Compat = __prefix + "Compat", __Regex = __prefix + "Regex", __Window = __prefix + "Window", __Document = __prefix + "Document", __Utils = __prefix + "Utils", __Animator = __prefix + "Animator", __DomEventInstance = __prefix + "DomEventInstance", __TemplateControlFactory = __prefix + "TemplateControlFactory", __NodeManagerStatic = __prefix + "NodeManagerStatic", 
    /**
     */
    __CONTEXT = 'context', 
    /**
     */
    __PlatPrefix = 'plat', __Plat = __PlatPrefix + "-", __Button = __Plat + "button", __Checkbox = __Plat + "checkbox", __Drawer = __Plat + "drawer", __DrawerController = __Drawer + "-controller", __Modal = __Plat + "modal", __ProgressBar = __Plat + "progress", __ProgressRing = __Plat + "ring", __Radio = __Plat + "radio", __Toggle = __Plat + "toggle", __Slider = __Plat + "slider", __Range = __Plat + "range", __Select = __Plat + "select", __Input = __Plat + "input", __File = __Plat + "file", __Carousel = __Plat + "carousel", __Listview = __Plat + "listview", __Navbar = __Plat + "navbar", __Image = __Plat + "image", 
    /**
     */
    __Hide = __Plat + "hide", __Hidden = __Plat + "hidden", __Context = __Plat + __CONTEXT, __ForEach = __Plat + "foreach", __Html = __Plat + "html", __Disabled = __Plat + "disabled", __Readonly = __Plat + "readonly", __CamelContext = __PlatPrefix + "Context", __CamelChecked = __PlatPrefix + "Checked", __CamelBind = __PlatPrefix + "Bind", __CamelSrc = __PlatPrefix + "Src", 
    /**
     */
    __listviewAliasOptions = {
        index: 'index',
        even: 'even',
        odd: 'odd',
        first: 'first',
        last: 'last',
        group: 'group'
    }, 
    /**
     */
    __Transition = __Plat + "transition", __Enter = __Plat + "enter", __Leave = __Plat + "leave", 
    /**
     */
    __$tap = '$tap', __$touchstart = '$touchstart', __$touchend = '$touchend', __$touchcancel = '$touchcancel', __$swipe = '$swipe', __$track = '$track', __$trackend = '$trackend', __ButtonPrefix = '__plat-button-', __RadioPrefix = '__plat-radio-', __DrawerControllerInitEvent = '__platDrawerControllerInit', __DrawerControllerFetchEvent = '__platDrawerControllerFetch', __DrawerFoundEvent = '__platDrawerFound', 
    /**
     */
    __Reversed = '-reversed', __LITERAL_RESOURCE = 'literal', __transitionNegate = {
        right: 'left',
        left: 'right',
        up: 'down',
        down: 'up'
    }, __src = 'src', __preventDefault = function (ev) {
        ev.preventDefault();
        return false;
    }, noop = function () { };
    /* tslint:enable:no-unused-variable */
    if (typeof window !== 'undefined') {
        if (typeof window.platui === 'undefined') {
            window.platui = platui;
        }
        if (typeof window.module === 'undefined') {
            window.module = {};
        }
    }
    /**
     * An BindControl that standardizes an HTML5 button.
     */
    var Button = (function (_super) {
        __extends(Button, _super);
        function Button() {
            _super.apply(this, arguments);
            /**
             * Replaces the <plat-button> node with
             * a <button> node.
             */
            this.replaceWith = 'button';
            /**
             * A boolean value showing the selected state of this Button.
             */
            this._isSelected = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Button.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Button + " " + (className || ''));
        };
        /**
         * Sets default classes.
         */
        Button.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Wrap all inner text nodes in spans.
         */
        Button.prototype.setTemplate = function () {
            var _document = this._document, element = this.element, childNodes = Array.prototype.slice.call(element.childNodes), childNode, span, isEmpty = this.utils.isEmpty;
            while (childNodes.length > 0) {
                childNode = childNodes.shift();
                if (childNode.nodeType === Node.TEXT_NODE) {
                    if (!isEmpty(childNode.textContent.trim().match(/[^\r\n]/g))) {
                        span = _document.createElement('span');
                        span.insertBefore(childNode, null);
                        element.insertBefore(span, null);
                    }
                }
                else {
                    element.insertBefore(childNode, null);
                }
            }
        };
        /**
         * Determine the button style and apply the proper classes.
         */
        Button.prototype.loaded = function () {
            var element = this.element, optionObj = this.options || {}, options = optionObj.value || {}, group = options.group, isString = this.utils.isString;
            if (!isString(group)) {
                group = this.attributes[__CamelBind];
                if (isString(group)) {
                    this._group = group;
                    if (this.dom.hasClass(element, __Plat + "selected")) {
                        this._onTap();
                    }
                    this._addEventListeners();
                }
                return;
            }
            this._group = group;
            if (this.dom.hasClass(element, __Plat + "selected")) {
                this._onTap();
            }
            this._addEventListeners();
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Button.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {string} newValue The new value of the bindable property.
         * @param {string} oldValue The old value of the bindable property.
         * @param {string} identifier The identifier of the property being observed.
         * @param {boolean} firstTime? A boolean value indicating whether this is the first time its being set.
         */
        Button.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            if (!this.utils.isString(newValue) || newValue !== this.element.textContent) {
                return;
            }
            this._onTap();
        };
        /**
         * Add event listeners for selection.
         */
        Button.prototype._addEventListeners = function () {
            var _this = this;
            this.addEventListener(this.element, __$tap, this._onTap, false);
            this.on(__ButtonPrefix + this._group, function () {
                if (_this._isSelected) {
                    _this.dom.removeClass(_this.element, __Plat + "selected");
                    _this._isSelected = false;
                }
            });
        };
        /**
         * Place the pushed button in a selected state.
         */
        Button.prototype._onTap = function () {
            if (this._isSelected) {
                return;
            }
            var element = this.element;
            this.dom.addClass(element, __Plat + "selected");
            this.dispatchEvent(__ButtonPrefix + this._group, plat.events.EventManager.DIRECT);
            this._isSelected = true;
            this.inputChanged(element.textContent);
        };
        Button._inject = {
            _document: __Document
        };
        return Button;
    }(plat.ui.BindControl));
    platui.Button = Button;
    plat.register.control(__Button, Button);
    /**
     * An BindControl that simulates a toggle switch.
     */
    var Toggle = (function (_super) {
        __extends(Toggle, _super);
        function Toggle() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-toggle-container">\n' +
                '    <div class="plat-knob"></div>\n' +
                '</div>\n';
            /**
             * A boolean value indicating whether the control is actively selected.
             */
            this.isActive = false;
            /**
             * The type of the control's activated element.
             */
            this._targetType = 'slide';
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Toggle.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Toggle + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Toggle.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Adds a listener for the tap event.
         */
        Toggle.prototype.loaded = function () {
            var element = this.element;
            this._targetElement = element.firstElementChild;
            this.addEventListener(element, __$tap, this._onTap);
            this._convertChecked();
        };
        /**
         * Toggles the active state of the control.
         */
        Toggle.prototype.toggle = function () {
            this._toggle(true);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Toggle.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {any} newValue The new value of the bindable property.
         * @param {any} oldValue The old value of the bindable property.
         * @param {string} identifier The identifier of the property being observed.
         * @param {boolean} setProperty? A boolean value indicating whether we should set
         * the property if we need to toggle the state.
         */
        Toggle.prototype._setBoundProperty = function (newValue, oldValue, identifier, setProperty) {
            if (newValue === oldValue) {
                return;
            }
            else if (setProperty === true && this.utils.isNull(newValue)) {
                this.inputChanged(this.isActive);
                return;
            }
            var isActive = !!newValue;
            if (isActive === this.isActive) {
                return;
            }
            this._toggle(setProperty);
        };
        /**
         * A function for checking "checked" attributes and handling them accordingly.
         * @param {any} newValue The newValue of the attribute to convert.
         * @param {any} oldValue? The oldValue of the attribute to convert.
         */
        Toggle.prototype._convertChecked = function () {
            var element = this.element;
            if (!this.utils.isNull(this.attributes[__CamelChecked])) {
                this._convertAttribute(this.attributes[__CamelChecked]);
                this.attributes.observe(this._convertAttribute, __CamelChecked);
            }
            else if (element.hasAttribute('checked')) {
                this._convertAttribute(true);
            }
        };
        /**
         * A function for handling the attribute value conversion for updating the
         * bound property.
         * @param {any} newValue The newValue of the attribute to convert.
         * @param {any} oldValue? The oldValue of the attribute to convert.
         */
        Toggle.prototype._convertAttribute = function (newValue, oldValue) {
            var utils = this.utils;
            if (utils.isBoolean(newValue)) {
                return this._setBoundProperty(newValue, oldValue, null, true);
            }
            else if (!utils.isString(newValue)) {
                return;
            }
            this._setBoundProperty(newValue === 'true', oldValue === 'true', null, true);
        };
        /**
         * The callback for a tap event.
         * @param {plat.ui.IGestureEvent} ev The tap event object.
         */
        Toggle.prototype._onTap = function (ev) {
            this._toggle(true);
            this._trigger('change');
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        Toggle.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        /**
         * Toggles the mark and updates the bindable property if needed.
         * @param {boolean} setProperty? A boolean value stating whether the bindable
         * property should be updated.
         */
        Toggle.prototype._toggle = function (setProperty) {
            var wasActive = this.isActive, isActive = !wasActive, element = this.element;
            this._activate(this._targetElement || (this._targetElement = element.firstElementChild));
            this.isActive = element.checked = isActive;
            if (isActive) {
                element.setAttribute('checked', 'checked');
            }
            else {
                element.removeAttribute('checked');
            }
            if (setProperty === true) {
                this.inputChanged(isActive, wasActive);
            }
        };
        /**
         * A function to activate the given element by toggling the
         * class specified as the target type.
         * @param {Element} element The element to activate.
         */
        Toggle.prototype._activate = function (element) {
            this.dom.toggleClass(element, __Plat + this._targetType);
        };
        return Toggle;
    }(plat.ui.BindControl));
    platui.Toggle = Toggle;
    plat.register.control(__Toggle, Toggle);
    /**
     * An IBindablePropertyControl that standardizes the HTML5 checkbox.
     */
    var Checkbox = (function (_super) {
        __extends(Checkbox, _super);
        function Checkbox() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-checkbox-container">\n' +
                '    <span class="plat-mark"></span>\n' +
                '</div>\n';
            /**
             * Whether the target type has been set already or not.
             */
            this._targetTypeSet = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Checkbox.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Checkbox + " " + (className || ''));
        };
        /**
         * Adds the inner template to the DOM making sure to wrap text nodes in spans.
         */
        Checkbox.prototype.setTemplate = function () {
            var isNull = this.utils.isNull, innerTemplate = this.innerTemplate;
            if (isNull(innerTemplate)) {
                return;
            }
            var _document = this._document, element = this.element, childNodes = Array.prototype.slice.call(innerTemplate.childNodes), childNode, span, match;
            while (childNodes.length > 0) {
                childNode = childNodes.shift();
                if (childNode.nodeType === Node.TEXT_NODE) {
                    match = childNode.textContent.trim().match(/[^\r\n]/g);
                    if (match !== null && match.length > 0) {
                        span = _document.createElement('span');
                        span.insertBefore(childNode, null);
                        element.insertBefore(span, null);
                    }
                }
                else {
                    element.insertBefore(childNode, null);
                }
            }
        };
        /**
         * Checks for checked attributes and handles them accordingly. Also,
         * initializes the mark and adds a listener for the tap event.
         */
        Checkbox.prototype.loaded = function () {
            _super.prototype.loaded.call(this);
            var optionObj = this.options || {}, options = optionObj.value || {}, previousType = this._targetType, mark = this._targetType = options.mark || 'check';
            switch (mark.toLowerCase()) {
                case 'check':
                case 'x':
                    break;
                default:
                    this._log.debug("Invalid mark option specified for " + this.type + ". Defaulting to checkmark.");
                    this._targetType = 'check';
                    break;
            }
            if (this._targetTypeSet) {
                var target = this._targetElement;
                this.dom.removeClass(target, previousType);
                this._activate(target);
            }
            this._targetTypeSet = true;
        };
        /**
         * A function to activate the given element by toggling the
         * class specified as the target type.
         * @param {Element} element The element to activate.
         */
        Checkbox.prototype._activate = function (element) {
            if (this._targetTypeSet) {
                this.dom.toggleClass(element, __Plat + this._targetType);
                return;
            }
            this._targetTypeSet = true;
        };
        Checkbox._inject = {
            _document: __Document
        };
        return Checkbox;
    }(Toggle));
    platui.Checkbox = Checkbox;
    plat.register.control(__Checkbox, Checkbox);
    /**
     * An IBindablePropertyControl that standardizes the HTML5 radio button.
     */
    var Radio = (function (_super) {
        __extends(Radio, _super);
        function Radio() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-radio-container">\n' +
                '    <div class="plat-mark"></div>\n' +
                '</div>\n';
            /**
             * The radio groups name if a radio group is present.
             */
            this.groupName = '';
            /**
             * The check type to be placed in the element.
             */
            this._targetType = 'bullet';
            /**
             * Whether the target type has been set already or not.
             */
            this._targetTypeSet = true;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Radio.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Radio + " " + (className || ''));
        };
        /**
         * Checks for a radio group and converts "checked" attributes.
         */
        Radio.prototype.loaded = function () {
            var element = this.element;
            this._targetElement = element.firstElementChild;
            this.addEventListener(element, __$tap, this._onTap);
            if (element.hasAttribute('name')) {
                this.groupName = element.getAttribute('name');
            }
            else if (!this.utils.isNull(this.attributes[__CamelBind])) {
                this.groupName = this.attributes[__CamelBind];
            }
            this._convertChecked();
        };
        /**
         * Checks if the radio has been selected and only notifies of a bindable
         * property changed if it has.
         * @param {any} newValue? The new value of the property after the change.
         * @param {any} oldValue? The old value of the property prior to the change.
         */
        Radio.prototype.inputChanged = function (newValue, oldValue) {
            if (this.isActive) {
                _super.prototype.inputChanged.call(this, this._getValue());
            }
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {any} newValue The new value of the bindable property.
         * @param {any} oldValue The old value of the bindable property.
         * @param {string} identifier The identifier of the property being observed.
         * @param {boolean} setProperty? A boolean value indicating whether we should set
         * the property if we need to toggle the mark.
         */
        Radio.prototype._setBoundProperty = function (newValue, oldValue, identifier, setProperty) {
            if (newValue === oldValue) {
                return;
            }
            else if (setProperty === true && this.utils.isNull(newValue)) {
                this.inputChanged();
                return;
            }
            var isChecked = newValue === this._getValue(), wasChecked = this.isActive;
            if (isChecked === wasChecked) {
                return;
            }
            this._toggle(setProperty);
        };
        /**
         * The callback for a tap event. Only fires the event if the Radio
         * has been selected.
         * @param {plat.ui.IGestureEvent} ev The tap event object.
         */
        Radio.prototype._onTap = function (ev) {
            if (this.isActive) {
                return;
            }
            _super.prototype._onTap.call(this, ev);
        };
        /**
         * Toggles the mark and updates the bindable property if needed.
         * @param {boolean} setProperty? A boolean value stating whether the bindable
         * property should be updated.
         */
        Radio.prototype._toggle = function (setProperty) {
            var _this = this;
            _super.prototype._toggle.call(this, setProperty);
            if (this.utils.isFunction(this._removeListener)) {
                this._removeListener();
                this._removeListener = null;
            }
            if (this.isActive) {
                var name_1 = this.groupName;
                this.dispatchEvent(__RadioPrefix + name_1, plat.events.EventManager.DIRECT);
                var remover_1 = this._removeListener = this.on(__RadioPrefix + name_1, function () {
                    _this._toggle();
                    remover_1();
                });
            }
        };
        /**
         * A function for handling the attribute value conversion for updating the
         * bound property.
         * @param {any} newValue The newValue of the attribute to convert.
         * @param {any} oldValue? The oldValue of the attribute to convert.
         */
        Radio.prototype._convertAttribute = function (newValue, oldValue) {
            var utils = this.utils;
            if (utils.isBoolean(newValue)) {
                if (newValue) {
                    this._setBoundProperty(this._getValue(), null, null, true);
                }
                return;
            }
            else if (!utils.isString(newValue)) {
                return;
            }
            if (newValue === 'true') {
                this._setBoundProperty(this._getValue(), null, null, true);
            }
        };
        /**
         * Grabs the value of this Radio's bindable property. It first checks for
         * the "value" attribute, and defaults to the elements textContent if it's unavailable.
         */
        Radio.prototype._getValue = function () {
            var element = this.element;
            return element.hasAttribute('value') ? element.getAttribute('value').trim() : element.textContent.trim();
        };
        return Radio;
    }(Checkbox));
    platui.Radio = Radio;
    plat.register.control(__Radio, Radio);
    /**
     * An ITemplateControl for showing indeterminate progress.
     */
    var ProgressRing = (function (_super) {
        __extends(ProgressRing, _super);
        function ProgressRing() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-animated-ring"></div>';
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        ProgressRing.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __ProgressRing + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        ProgressRing.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set the animation.
         */
        ProgressRing.prototype.loaded = function () {
            var options = this.options, utils = this.utils, isObject = utils.isObject, style = 0;
            if (isObject(options) && isObject(options.value)) {
                style = options.value.style;
                if (!utils.isNumber(style)) {
                    style = 0;
                }
            }
            this.dom.addClass(this.element, __ProgressRing + "-" + style);
            if (style === 0) {
                return;
            }
            this._addAnimatedElements(style);
        };
        /**
         * Adds any needed DOM for the animation.
         */
        ProgressRing.prototype._addAnimatedElements = function (style) {
            var _document = plat.acquire(__Document), fragment = _document.createDocumentFragment(), count = style === 2 ? 12 : 4, div = 'div', classPrefix = __Plat + "animated-child " + __Plat + "animated-child-", child;
            for (var i = 0; i < count; ++i) {
                child = _document.createElement(div);
                child.className = classPrefix + i;
                fragment.insertBefore(child, null);
            }
            this.element.firstElementChild.insertBefore(fragment, null);
        };
        return ProgressRing;
    }(plat.ui.TemplateControl));
    platui.ProgressRing = ProgressRing;
    plat.register.control(__ProgressRing, ProgressRing);
    /**
     * An ITemplateControl for showing incremental progress.
     */
    var ProgressBar = (function (_super) {
        __extends(ProgressBar, _super);
        function ProgressBar() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-progress-container">\n' +
                '    <div class="plat-animated-bar"></div>\n' +
                '</div>\n';
            /**
             * A function that will stop listening for visibility if applicable.
             */
            this._removeVisibilityListener = noop;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        ProgressBar.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __ProgressBar + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        ProgressBar.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Grabs the bar element then sets any initial progress.
         */
        ProgressBar.prototype.loaded = function () {
            var _this = this;
            this._barElement = this.element.firstElementChild.firstElementChild;
            this.addEventListener(this._window, 'resize', function () {
                _this.setProgress(_this.context);
            });
            this.setProgress(this.context);
        };
        /**
         * Removes the visibility listener if applicable.
         */
        ProgressBar.prototype.dispose = function () {
            this._removeVisibilityListener();
        };
        /**
         * Animates the bar on a context changed.
         */
        ProgressBar.prototype.contextChanged = function () {
            this.setProgress(this.context);
        };
        /**
         * Sets the progress bar value.
         * @param {number} value The decimal number between 0 and 1 to set as the
         * bar percentage (e.g. - 0.5 would be 50% complete).
         */
        ProgressBar.prototype.setProgress = function (value) {
            var _this = this;
            return new this._Promise(function (resolve, reject) {
                if (!_this.utils.isNumber(value) || value > 1 || value < 0) {
                    var msg = "The value of a \"" + _this.type + "\" control must be a number between 0 and 1.";
                    _this._log.debug(msg);
                    reject(msg);
                    return;
                }
                var barElement = _this._barElement, barMax = barElement.parentElement.clientWidth;
                if (!barMax) {
                    _this._removeVisibilityListener();
                    _this._removeVisibilityListener = _this.dom.whenVisible(function () {
                        _this.setProgress(value).then(resolve);
                    }, _this.element);
                    return;
                }
                _this._animator.animate(barElement, __Transition, {
                    properties: {
                        width: Math.ceil(barMax * value) + "px"
                    }
                }).then(function () {
                    resolve();
                });
            });
        };
        ProgressBar._inject = {
            _window: __Window,
            _Promise: __Promise,
            _animator: __Animator
        };
        return ProgressBar;
    }(plat.ui.TemplateControl));
    platui.ProgressBar = ProgressBar;
    plat.register.control(__ProgressBar, ProgressBar);
    /**
     * An BindControl that acts as a global drawer.
     */
    var Drawer = (function (_super) {
        __extends(Drawer, _super);
        function Drawer() {
            _super.apply(this, arguments);
            /**
             * A promise that signifies the Drawer is ready for a pairing.
             */
            this.ready = this._Promise.resolve();
            /**
             * References to all the DrawerControllers used to control this Drawer.
             */
            this._controllers = [];
            /**
             * Whether or not the this control has been paired with a corresponding Drawer.
             */
            this._isInitialized = false;
            /**
             * A bound value that may have come through prior to initialization.
             */
            this._preInitializedValue = false;
            /**
             * A private variable that tells the Drawer its last open or closed state.
             */
            this.__state = false;
            /**
             * A private variable that tells the Drawer its next open or closed state.
             */
            this.__nextState = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Drawer.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Drawer + " " + (className || ''));
        };
        /**
         * Set the class name and hides the element and
         * removes the innerHTML from the DOM and saves it.
         */
        Drawer.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Removes the innerHTML from the DOM and saves it.
         */
        Drawer.prototype.setTemplate = function () {
            this.innerTemplate = this.dom.appendChildren(this.element.childNodes);
        };
        /**
         * Check for a position and initialize event handling.
         */
        Drawer.prototype.loaded = function () {
            var _this = this;
            var element = this.element, utils = this.utils, optionObj = this.options || {}, options = optionObj.value || {}, position = this._currentPosition = options.position || 'left', id = options.id || '', templateUrl = options.templateUrl, isElastic = options.elastic === true;
            element.setAttribute(__Hide, '');
            this.dom.addClass(element, __Plat + position);
            if (utils.isString(templateUrl)) {
                plat.ui.TemplateControl.determineTemplate(this, templateUrl).then(function (template) {
                    _this.innerTemplate = template;
                    _this._initializeEvents(id, position, isElastic);
                });
                return;
            }
            this._initializeEvents(id, position, isElastic);
        };
        /**
         * Opens the Drawer.
         */
        Drawer.prototype.open = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to open.");
                return this._Promise.resolve();
            }
            return controller.open();
        };
        /**
         * Closes the Drawer.
         */
        Drawer.prototype.close = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to close.");
                return this._Promise.resolve();
            }
            return controller.close();
        };
        /**
         * Toggles the Drawer's open/closed state.
         */
        Drawer.prototype.toggle = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to toggle.");
                return this._Promise.resolve();
            }
            return controller.toggle();
        };
        /**
         * Indicates whether the Drawer is currently open.
         */
        Drawer.prototype.isOpen = function () {
            var controller = this._controllers[0];
            if (this.utils.isNull(controller)) {
                this._log.debug("No controller, such as a " + __DrawerController + ", found for the " + this.type + " attempting to check if open.");
                return false;
            }
            return controller.isOpen();
        };
        /**
         * Adds and binds the added HTML template to this control's inherited context.
         * @param {string} name The template name to both add and bind.
         * @param {Node} node The node to add as a bindable template.
         */
        Drawer.prototype.bindTemplate = function (name, node) {
            var _this = this;
            var bindableTemplates = this.bindableTemplates;
            bindableTemplates.add(name, node);
            return bindableTemplates.bind(name).then(function (template) {
                var element = _this.element;
                _this.dom.clearNode(element);
                element.appendChild(template);
            }).catch(function (error) {
                _this._log.debug("Error binding template for " + _this.type + ": " + error);
            });
        };
        /**
         * Returns the number of DrawerControllers linked to this
         * Drawer.
         */
        Drawer.prototype.controllerCount = function () {
            return this._controllers.length;
        };
        /**
         * Removes a specified DrawerController from this control's Array of
         * linked DrawerControllers.
         * @param {platui.DrawerController} controller The DrawerController
         * to splice.
         */
        Drawer.prototype.spliceController = function (controller) {
            var controllers = this._controllers, index = controllers.indexOf(controller);
            if (index === -1) {
                return;
            }
            this.__state = this.__nextState = controllers[index].isOpen();
            controllers.splice(index, 1);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Drawer.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {boolean} newValue The new value of the control state.
         * @param {boolean} oldValue The old value of the bindable control state.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Drawer.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var utils = this.utils, controller = this._controllers[0];
            if (firstTime === true && utils.isNull(newValue)) {
                this.inputChanged(utils.isNull(controller) ? false : controller.isOpen());
                return;
            }
            var drawerState = !!newValue;
            if (drawerState !== newValue) {
                this.inputChanged(drawerState);
            }
            if (!this._isInitialized) {
                this._preInitializedValue = drawerState;
            }
            else if (utils.isNull(controller)) {
                this.__nextState = drawerState;
            }
            else if (drawerState) {
                if (controller.isOpen()) {
                    return;
                }
                controller.open();
            }
            else if (controller.isOpen()) {
                controller.close();
            }
        };
        /**
         * Changes the placement and implied position of the Drawer.
         * @param {string} position The new position to change to.
         */
        Drawer.prototype._changeDirection = function (position) {
            if (this.utils.isNull(position) || position === this._currentPosition) {
                return;
            }
            var dom = this.dom, element = this.element;
            dom.removeClass(element, __Plat + this._currentPosition);
            dom.addClass(element, __Plat + position);
            this._currentPosition = position;
        };
        /**
         * Initializes and dispatches pub sub events.
         * @param {string} id The ID of this Drawer if used.
         * @param {string} position The position.
         * @param {boolean} isElastic Whether or not the Drawer has an
         * elastic transition effect.
         */
        Drawer.prototype._initializeEvents = function (id, position, isElastic) {
            var _this = this;
            var utils = this.utils, innerTemplate = this.innerTemplate;
            this.on(__DrawerControllerFetchEvent + "_" + id, function (event, controllerArg) {
                var control = controllerArg.control;
                if (utils.isNull(control)) {
                    return;
                }
                if (utils.isString(controllerArg.position)) {
                    position = controllerArg.position;
                    _this._changeDirection(position);
                }
                _this._controllers.unshift(control);
                if (!controllerArg.received) {
                    _this.ready.then(function () {
                        _this.dispatchEvent(__DrawerFoundEvent + "_" + id, plat.events.EventManager.DIRECT, {
                            control: _this,
                            received: true,
                            position: position,
                            template: utils.isNode(innerTemplate) ? innerTemplate.cloneNode(true) : null,
                            elastic: isElastic,
                            state: _this.__state,
                            nextState: _this.__nextState
                        });
                    });
                }
                _this._isInitialized = true;
                if (!controllerArg.useContext) {
                    _this.bindTemplate('drawer', innerTemplate.cloneNode(true)).then(function () {
                        _this._checkPreInit();
                    });
                    return;
                }
                _this._checkPreInit();
            });
            this.dispatchEvent(__DrawerFoundEvent + "_" + id, plat.events.EventManager.DIRECT, {
                control: this,
                received: false,
                position: position,
                template: utils.isNode(innerTemplate) ? innerTemplate.cloneNode(true) : null,
                elastic: isElastic,
                state: this.__state,
                nextState: this.__nextState
            });
        };
        /**
         * Checks the pre-initialized value and handles accordingly.
         */
        Drawer.prototype._checkPreInit = function () {
            var _this = this;
            if (this._preInitializedValue) {
                var utils_1 = this.utils;
                utils_1.postpone(function () {
                    var controller = _this._controllers[0];
                    if (!utils_1.isNull(controller)) {
                        controller.open();
                    }
                });
            }
        };
        Drawer._inject = {
            _Promise: __Promise
        };
        return Drawer;
    }(plat.ui.BindControl));
    platui.Drawer = Drawer;
    plat.register.control(__Drawer, Drawer);
    /**
     * An BindControl that manipulates and controls a global drawer.
     */
    var DrawerController = (function (_super) {
        __extends(DrawerController, _super);
        function DrawerController() {
            _super.apply(this, arguments);
            /**
             * Whether or not the user has swiped.
             */
            this._hasSwiped = false;
            /**
             * Whether or not the user has tapped.
             */
            this._hasTapped = false;
            /**
             * Whether or not the Drawer is open.
             */
            this._isOpen = false;
            /**
             * An enum denoting the current touch state of the user.
             */
            this._touchState = 0;
            /**
             * Whether the corresponding Drawer is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * A function for removing the click eater scroll listening event.
             */
            this._removeClickEaterListener = noop;
            /**
             * A function to remove the toggle delay if present.
             */
            this._toggleDelay = noop;
            /**
             * Whether or not the this control has been paired with a corresponding Drawer.
             */
            this._isInitialized = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        DrawerController.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __DrawerController + " " + (className || ''));
        };
        /**
         * Sets the class name on the element.
         */
        DrawerController.prototype.initialize = function () {
            this.dom.addClass(this.element, __DrawerController);
        };
        /**
         * Initialize the track events on the element.
         */
        DrawerController.prototype.loaded = function () {
            var optionObj = this.options || {}, options = optionObj.value || {}, position = options.position, id = options.id || '';
            this._type = options.type || 'tap track';
            this._isElastic = options.elastic;
            this._useContext = options.useContext === true;
            this._templateUrl = options.templateUrl;
            this._initializeEvents(id, position);
        };
        /**
         * Remove the transition classes off the root element and reset the position and
         * zIndex properties if modified and only if this is the last DrawerController
         * referencing this Drawer.
         */
        DrawerController.prototype.dispose = function () {
            var _this = this;
            _super.prototype.dispose.call(this);
            var drawer = this._drawer;
            if (this.utils.isNull(drawer)) {
                return;
            }
            if (drawer.controllerCount() > 1) {
                drawer.spliceController(this);
                return;
            }
            else if (this._isOpen) {
                drawer.ready = this.close().then(function () {
                    drawer.spliceController(_this);
                    if (drawer.controllerCount() > 0) {
                        return;
                    }
                    _this._cleanRootElement();
                });
                return;
            }
            drawer.ready.then(function () {
                drawer.spliceController(_this);
                if (drawer.controllerCount() > 0) {
                    return;
                }
                _this._cleanRootElement();
            });
        };
        /**
         * Opens the Drawer.
         */
        DrawerController.prototype.open = function () {
            var _this = this;
            var wasClosed = !this._isOpen, utils = this.utils;
            this._toggleDelay();
            var promise = new this._Promise(function (resolve) {
                _this._toggleDelay = utils.requestAnimationFrame(function () {
                    _this._open().then(resolve);
                });
            });
            if (wasClosed) {
                var drawer = this._drawer;
                this.inputChanged(true);
                if (!utils.isNull(drawer)) {
                    drawer.inputChanged(true);
                }
            }
            return promise;
        };
        /**
         * Closes the Drawer.
         */
        DrawerController.prototype.close = function () {
            var _this = this;
            var wasOpen = this._isOpen, utils = this.utils;
            this._toggleDelay();
            var promise = new this._Promise(function (resolve) {
                _this._toggleDelay = utils.requestAnimationFrame(function () {
                    _this._close().then(resolve);
                });
            });
            if (wasOpen) {
                var drawer = this._drawer;
                this.inputChanged(false);
                if (!utils.isNull(drawer)) {
                    drawer.ready = promise;
                    drawer.inputChanged(false);
                }
            }
            return promise;
        };
        /**
         * Toggles the Drawer's open/closed state.
         */
        DrawerController.prototype.toggle = function () {
            if (this._isOpen) {
                return this.close();
            }
            return this.open();
        };
        /**
         * Indicates whether the Drawer is currently open.
         */
        DrawerController.prototype.isOpen = function () {
            return this._isOpen;
        };
        /**
         * Binds the added HTML template to this control's inherited context and
         * places the node into the Drawer.
         * @param {string} name The template name to bind.
         * @param {Node} node The node to add as a bindable template.
         */
        DrawerController.prototype.bindTemplate = function (name, node) {
            var _this = this;
            var bindableTemplates = this.bindableTemplates;
            bindableTemplates.add(name, node);
            return bindableTemplates.bind(name).then(function (template) {
                var element = _this._drawerElement;
                _this.dom.clearNode(element);
                element.appendChild(template);
            }).catch(function (error) {
                _this._log.debug("Error binding template for " + _this.type + ": " + error);
            });
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        DrawerController.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {boolean} newValue The new value of the control's state.
         * @param {boolean} oldValue The old value of the bindable control state.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        DrawerController.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var _this = this;
            var utils = this.utils;
            if (firstTime === true && utils.isNull(newValue)) {
                this.inputChanged(this._isOpen);
                return;
            }
            var drawerState = !!newValue;
            if (drawerState !== newValue) {
                this.inputChanged(drawerState);
            }
            if (!this._isInitialized) {
                this._preInitializedValue = drawerState;
            }
            else if (drawerState) {
                if (this._isOpen) {
                    return;
                }
                this._toggleDelay();
                this._toggleDelay = utils.requestAnimationFrame(function () {
                    _this._open();
                });
            }
            else if (this._isOpen) {
                this._toggleDelay();
                var promise = new this._Promise(function (resolve) {
                    _this._toggleDelay = utils.requestAnimationFrame(function () {
                        resolve(_this._close());
                    });
                }), drawer = this._drawer;
                if (!utils.isNull(drawer)) {
                    drawer.ready = promise;
                }
            }
        };
        /**
         * Opens the Drawer.
         * @param {boolean} reset? Whether the open is being called to reset the open state.
         */
        DrawerController.prototype._open = function (reset) {
            var _this = this;
            var rootElement = this._rootElement, isNode = this.utils.isNode, isOpen = this._isOpen, offset = this._getOffset();
            if ((isOpen && !reset) || !(offset && isNode(rootElement) && isNode(this._drawerElement))) {
                return this._Promise.resolve();
            }
            var translation;
            switch (this._position) {
                case 'left':
                    translation = "translate3d(" + offset + "px,0,0)";
                    break;
                case 'right':
                    translation = "translate3d(" + (-offset) + "px,0,0)";
                    break;
                case 'top':
                    translation = "translate3d(0," + offset + "px,0)";
                    break;
                case 'bottom':
                    translation = "translate3d(0," + (-offset) + "px,0)";
                    break;
                default:
                    return this._Promise.resolve();
            }
            this._isOpen = true;
            this.dom.addClass(rootElement, this._directionalTransitionPrep);
            if (!isOpen) {
                this._addClickEater();
            }
            var animationOptions = {};
            animationOptions[this._transform] = translation;
            return this._animationThenable = this._animator.animate(rootElement, __Transition, {
                properties: animationOptions
            }).then(function () {
                _this._animationThenable = null;
                _this._drawerElement.removeEventListener('selectstart', __preventDefault, false);
            });
        };
        /**
         * Closes the Drawer.
         * @param {boolean} reset? Whether the open is being called to reset the open state.
         */
        DrawerController.prototype._close = function (reset) {
            var _this = this;
            var rootElement = this._rootElement, isNode = this.utils.isNode, isClosed = !this._isOpen;
            if ((isClosed && !reset) || !(isNode(rootElement) && isNode(this._drawerElement))) {
                return this._Promise.resolve();
            }
            this._isOpen = false;
            var animationOptions = {};
            animationOptions[this._transform] = this._preTransform;
            return this._animationThenable = this._animator.animate(rootElement, __Transition, {
                properties: animationOptions
            }).then(function () {
                _this._animationThenable = null;
                _this._drawerElement.removeEventListener('selectstart', __preventDefault, false);
                if (_this._isOpen) {
                    return;
                }
                else if (_this._touchState < 2) {
                    _this._removeClickEater();
                }
            });
        };
        /**
         * Resets the Drawer to it's current open/closed state.
         */
        DrawerController.prototype._reset = function () {
            if (this._isOpen) {
                return this._open(true);
            }
            var promise = this._close(true), drawer = this._drawer;
            if (!this.utils.isNull(drawer)) {
                drawer.ready = promise;
            }
            return promise;
        };
        /**
         * Adds a click eater when tracking and closing an open Drawer.
         */
        DrawerController.prototype._addClickEater = function () {
            var _this = this;
            var clickEater = this._clickEater, style = clickEater.style, rootElement = this._rootElement;
            if (rootElement.contains(clickEater)) {
                return;
            }
            // align clickEater to fill the rootElement 
            style.top = rootElement.scrollTop + "px";
            style.left = rootElement.scrollLeft + "px";
            rootElement.insertBefore(clickEater, null);
            this.dom.addClass(this._rootElement, this._directionalTransitionPrep);
            var removeScroll, removeRequest = noop, ready = true;
            removeScroll = this.addEventListener(rootElement, 'scroll', function () {
                if (!ready) {
                    return;
                }
                ready = false;
                removeRequest = _this.utils.requestAnimationFrame(function () {
                    var style = clickEater.style;
                    ready = true;
                    // align clickEater to fill the rootElement 
                    style.top = rootElement.scrollTop + "px";
                    style.left = rootElement.scrollLeft + "px";
                });
            });
            this._removeClickEaterListener = function () {
                removeRequest();
                removeScroll();
            };
        };
        /**
         * Removes the click eater after closing an open Drawer.
         */
        DrawerController.prototype._removeClickEater = function () {
            var rootElement = this._rootElement, clickEater = this._clickEater;
            this._removeClickEaterListener();
            if (rootElement.contains(clickEater)) {
                rootElement.removeChild(clickEater);
            }
            this.dom.removeClass(rootElement, this._directionalTransitionPrep);
        };
        /**
         * Adds swipe events to the controller element.
         */
        DrawerController.prototype._addSwipeToggle = function () {
            var _this = this;
            var element = this.element, removeSwipeOpen = this.addEventListener(element, __$swipe + __transitionNegate[this._position], function () {
                _this._hasSwiped = true;
                _this.open();
            }, false), removeSwipeClose = this.addEventListener(element, __$swipe + this._position, function () {
                _this._hasSwiped = true;
                _this.close();
            }, false);
            this._removeSwipeToggle = function () {
                removeSwipeOpen();
                removeSwipeClose();
            };
        };
        /**
         * Adds swipe close event to the root element.
         */
        DrawerController.prototype._addSwipeClose = function () {
            var _this = this;
            this._openSwipeRemover = this.addEventListener(this._clickEater, __$swipe + this._position, function () {
                _this._hasSwiped = true;
                _this.close();
            }, false);
        };
        /**
         * Adds tap toggle event to the controller element.
         */
        DrawerController.prototype._addTapToggle = function () {
            var _this = this;
            this._removeTap = this.addEventListener(this.element, __$tap, function () {
                _this._hasTapped = true;
                _this.toggle();
            }, false);
        };
        /**
         * Adds tap close event to the root element.
         */
        DrawerController.prototype._addTapClose = function () {
            var _this = this;
            this._openTapRemover = this.addEventListener(this._clickEater, __$tap, function () {
                _this._hasTapped = true;
                _this.close();
            }, false);
        };
        /**
         * Adds primary and secondary tracking events to the DrawerController element.
         */
        DrawerController.prototype._addEventListeners = function () {
            var element = this.element, isNull = this.utils.isNull, types = this._type.split(' '), position = this._position;
            // remove event listeners here first if we want to later be able to dynamically change position of drawer. 
            // this._removeEventListeners(); 
            if (this._isTap = (types.indexOf('tap') !== -1)) {
                this._addTapToggle();
                this._addTapClose();
            }
            if (this._isSwipe = (types.indexOf('swipe') !== -1)) {
                this._addSwipeToggle();
                this._addSwipeClose();
            }
            if (this._isTrack = (types.indexOf('track') !== -1)) {
                var trackFn = this._track, trackDirection = void 0, clickEater = this._clickEater;
                switch (position) {
                    case 'left':
                    case 'right':
                        trackDirection = position;
                        break;
                    case 'top':
                        trackDirection = 'up';
                        break;
                    case 'bottom':
                        trackDirection = 'down';
                        break;
                    default:
                        return;
                }
                var primaryTrack = __$track + __transitionNegate[trackDirection], secondaryTrack = __$track + trackDirection, removePrimaryTrack_1 = this.addEventListener(element, primaryTrack, trackFn, false), removeSecondaryTrack_1 = this.addEventListener(element, secondaryTrack, trackFn, false), openTrackPrimaryRemover_1 = this.addEventListener(clickEater, primaryTrack, trackFn, false), openTrackSecondaryRemover_1 = this.addEventListener(clickEater, secondaryTrack, trackFn, false);
                this._removeTrack = function () {
                    removePrimaryTrack_1();
                    removeSecondaryTrack_1();
                };
                this._openTrackRemover = function () {
                    openTrackPrimaryRemover_1();
                    openTrackSecondaryRemover_1();
                };
                if (isNull(this._lastTouch)) {
                    var touchStart = this._touchStart, touchEnd = this._touchEnd;
                    this._lastTouch = { x: 0, y: 0 };
                    this.addEventListener(element, __$touchstart, touchStart, false);
                    this.addEventListener(element, __$touchend, touchEnd, false);
                    this.addEventListener(element, __$trackend, touchEnd, false);
                    this.addEventListener(clickEater, __$touchstart, touchStart, false);
                    this.addEventListener(clickEater, __$trackend, touchEnd, false);
                    this.addEventListener(clickEater, __$touchend, touchEnd, false);
                }
            }
            this.addEventListener(this._window, 'resize', this._handleResize, false);
        };
        /**
         * Handles a Window resize event by closing the Drawer immediately.
         */
        DrawerController.prototype._handleResize = function () {
            if (!this._isOpen) {
                return;
            }
            var isNull = this.utils.isNull, rootElement = this._rootElement, drawer = this._drawer;
            this._isOpen = false;
            this.inputChanged(false);
            if (!isNull(rootElement)) {
                rootElement.style[this._transform] = this._preTransform;
            }
            if (!isNull(drawer)) {
                drawer.inputChanged(false);
                this._drawerElement.removeEventListener('selectstart', __preventDefault, false);
            }
            if (this._touchState < 2) {
                this._removeClickEater();
            }
        };
        /**
         * Removes all event listeners.
         */
        DrawerController.prototype._removeEventListeners = function () {
            var isFunction = this.utils.isFunction;
            if (this._isTap) {
                if (isFunction(this._removeTap)) {
                    this._removeTap();
                    this._removeTap = null;
                }
                if (isFunction(this._openTapRemover)) {
                    this._openTapRemover();
                    this._openTapRemover = null;
                }
            }
            if (this._isTrack) {
                if (isFunction(this._removeTrack)) {
                    this._removeTrack();
                    this._removeTrack = null;
                }
                if (isFunction(this._openTrackRemover)) {
                    this._openTrackRemover();
                    this._openTrackRemover = null;
                }
            }
            if (this._isSwipe) {
                if (isFunction(this._removeSwipeToggle)) {
                    this._removeSwipeToggle();
                    this._removeSwipeToggle = null;
                }
                if (isFunction(this._openSwipeRemover)) {
                    this._openSwipeRemover();
                    this._openSwipeRemover = null;
                }
            }
        };
        /**
         * Log when the user touches the DrawerController.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        DrawerController.prototype._touchStart = function (ev) {
            if (this._touchState === 1) {
                return;
            }
            this._touchState = 1;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY
            };
        };
        /**
         * The $touchend and $trackend event handler.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        DrawerController.prototype._touchEnd = function (ev) {
            var noTouch = this._touchState === 0, hasSwiped = this._hasSwiped, hasTapped = this._hasTapped;
            this._hasSwiped = this._hasTapped = false;
            this._touchState = 0;
            if (hasTapped || noTouch || hasSwiped) {
                return;
            }
            var distanceMoved = this._isVertical ? ev.clientY - this._lastTouch.y : ev.clientX - this._lastTouch.x;
            if (this._isRightDirection(distanceMoved)) {
                var offset = this._getOffset();
                if (!offset) {
                    return;
                }
                else if (Math.abs(distanceMoved) > Math.ceil(offset / 2)) {
                    this.toggle();
                    return;
                }
                this._reset();
            }
            else if (this._isElastic) {
                if (Math.abs(distanceMoved) > 0) {
                    this._reset();
                }
            }
            else if (!this._isOpen) {
                this._removeClickEater();
            }
        };
        /**
         * The $track event handler. Used for tracking only horizontal or vertical tracking motions
         * depending on the defined position.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        DrawerController.prototype._track = function (ev) {
            var _this = this;
            var touchState = this._touchState;
            if (touchState === 0) {
                return;
            }
            else if (touchState === 1) {
                if (!this.utils.isNull(this._animationThenable)) {
                    this._animationThenable.cancel().then(function () {
                        _this._addClickEater();
                        if (_this.utils.isNode(_this._drawerElement)) {
                            _this._drawerElement.addEventListener('selectstart', __preventDefault, false);
                        }
                    });
                }
                else {
                    this._addClickEater();
                    if (this.utils.isNode(this._drawerElement)) {
                        this._drawerElement.addEventListener('selectstart', __preventDefault, false);
                    }
                }
                this._touchState = 2;
            }
            this.utils.requestAnimationFrame(function () {
                _this._rootElement.style[_this._transform] = _this._calculateTranslation(ev);
            });
        };
        /**
         * Checks to make sure the user has been tracking in the right direction to
         * toggle.
         * @param {number} distanceMoved The distance the user's pointer has moved.
         */
        DrawerController.prototype._isRightDirection = function (distanceMoved) {
            switch (this._position) {
                case 'left':
                case 'top':
                    return this._isOpen ? distanceMoved < 0 : distanceMoved > 0;
                case 'right':
                case 'bottom':
                    return this._isOpen ? distanceMoved > 0 : distanceMoved < 0;
                default:
                    return false;
            }
        };
        /**
         * Calculates the translation value for setting the transform value.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        DrawerController.prototype._calculateTranslation = function (ev) {
            var offset = this._getOffset(), distanceMoved;
            if (!offset) {
                return this._preTransform;
            }
            switch (this._position) {
                case 'left':
                    distanceMoved = this._checkElasticity(offset, ev.clientX - this._lastTouch.x);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(" + distanceMoved + "px,0,0)";
                case 'right':
                    distanceMoved = this._checkElasticity(offset, this._lastTouch.x - ev.clientX);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(" + (-distanceMoved) + "px,0,0)";
                case 'top':
                    distanceMoved = this._checkElasticity(offset, ev.clientY - this._lastTouch.y);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(0," + distanceMoved + "px,0)";
                case 'bottom':
                    distanceMoved = this._checkElasticity(offset, this._lastTouch.y - ev.clientY);
                    if (distanceMoved === 0) {
                        return this._preTransform;
                    }
                    return "translate3d(0," + (-distanceMoved) + "px,0)";
                default:
                    return this._preTransform;
            }
        };
        /**
         * Checks for elasticity and potentially readjusts the user's
         * distance moved.
         * @param {number} maxOffset The maximum distance the corresponding Drawer can translate.
         * @param {number} delta The distance the user's finger moved.
         */
        DrawerController.prototype._checkElasticity = function (maxOffset, delta) {
            var distanceMoved = this._isOpen ? maxOffset + delta : delta;
            if (this._isElastic) {
                return distanceMoved;
            }
            if (distanceMoved < 0) {
                distanceMoved = 0;
            }
            else if (distanceMoved > maxOffset) {
                distanceMoved = maxOffset;
            }
            return distanceMoved;
        };
        /**
         * Initializes and dispatches pub sub events.
         * @param {string} id The ID of this DrawerController if used.
         * @param {string} position The position of the Drawer.
         */
        DrawerController.prototype._initializeEvents = function (id, position) {
            var _this = this;
            var useContext = this._useContext, eventRemover = this.on(__DrawerFoundEvent + "_" + id, function (event, drawerArg) {
                eventRemover();
                var utils = _this.utils, isString = utils.isString, isUndefined = utils.isUndefined, drawer = (_this._drawer = drawerArg.control) || {}, drawerElement = _this._drawerElement = drawer.element;
                if (!isString(position)) {
                    if (isString(drawerArg.position)) {
                        position = drawerArg.position;
                    }
                    else {
                        _this._log.debug(("\"position\" is incorrectly defined for a control such as \"" + __Drawer + "\" ") +
                            ("or \"" + _this.type + ".\" Please ensure it is a string."));
                        return;
                    }
                }
                drawerElement.removeAttribute(__Hide);
                if (!_this._controllerIsValid(position.toLowerCase())) {
                    return;
                }
                _this._setTransform();
                _this._addEventListeners();
                if (isUndefined(_this._isElastic)) {
                    _this._isElastic = drawerArg.elastic === true;
                }
                if (!drawerArg.received) {
                    _this.dispatchEvent(__DrawerControllerFetchEvent + "_" + id, plat.events.EventManager.DIRECT, {
                        control: _this,
                        received: true,
                        position: position,
                        useContext: useContext
                    });
                }
                if (drawerArg.state) {
                    _this._isOpen = true;
                    _this.inputChanged(true);
                    if (!drawerArg.nextState && utils.isNull(_this._preInitializedValue)) {
                        _this._preInitializedValue = false;
                    }
                }
                else if (drawerArg.nextState && utils.isNull(_this._preInitializedValue)) {
                    _this._preInitializedValue = true;
                }
                var finish = function () {
                    _this._isInitialized = true;
                    _this._checkPreInit();
                };
                if (!useContext) {
                    finish();
                    return;
                }
                _this._determineTemplate(drawerArg.template).then(finish);
            });
            this.dispatchEvent(__DrawerControllerFetchEvent + "_" + id, plat.events.EventManager.DIRECT, {
                control: this,
                received: false,
                position: position,
                useContext: useContext
            });
        };
        /**
         * Checks the pre-initialized value and handles accordingly.
         */
        DrawerController.prototype._checkPreInit = function () {
            var _this = this;
            var value = this._preInitializedValue, utils = this.utils, isNull = utils.isNull;
            if (isNull(value)) {
                return;
            }
            var isOpen = this._isOpen;
            if (isOpen && value || !(isOpen || value)) {
                return;
            }
            this._toggleDelay();
            if (value) {
                this._toggleDelay = utils.requestAnimationFrame(this._open.bind(this));
                return;
            }
            var promise = new this._Promise(function (resolve) {
                _this._toggleDelay = utils.requestAnimationFrame(function () {
                    resolve(_this._close());
                });
            }), drawer = this._drawer;
            if (!isNull(drawer)) {
                drawer.ready = promise;
            }
        };
        /**
         * Determines the proper HTML template, binds it, and inserts it if needed.
         * @param {Node} fragment? A Node to insert as the Drawer's HTML template
         * if no templateUrl is present on this DrawerController.
         */
        DrawerController.prototype._determineTemplate = function (fragment) {
            var _this = this;
            var utils = this.utils;
            if (utils.isString(this._templateUrl)) {
                return plat.ui.TemplateControl.determineTemplate(this, this._templateUrl).then(function (template) {
                    return _this.bindTemplate('drawer', template);
                });
            }
            else if (utils.isNode(fragment)) {
                return this.bindTemplate('drawer', fragment);
            }
            return this._Promise.resolve();
        };
        /**
         * Obtains the current browser's transform property value.
         */
        DrawerController.prototype._setTransform = function () {
            var style = this._rootElement.style, isUndefined = this.utils.isUndefined;
            var vendorPrefix = this._compat.vendorPrefix;
            if (!isUndefined(this._preTransform = style[(vendorPrefix.lowerCase + "Transform")])) {
                this._transform = vendorPrefix.lowerCase + "Transform";
            }
            else if (!isUndefined(this._preTransform = style[(vendorPrefix.upperCase + "Transform")])) {
                this._transform = vendorPrefix.upperCase + "Transform";
            }
            else {
                this._transform = 'transform';
            }
        };
        /**
         * Checks if this control has all valid properties.
         * @param {string} position The position of the Drawer.
         */
        DrawerController.prototype._controllerIsValid = function (position) {
            var utils = this.utils, isNull = utils.isNull;
            if (isNull(this._drawerElement)) {
                this._log.debug("Could not find a corresponding control such as \"" + __Drawer + "\" for this \"" + this.type + ".\"");
                return false;
            }
            switch (position) {
                case 'top':
                case 'bottom':
                    this._isVertical = true;
                case 'left':
                case 'right':
                    this._position = position;
                    break;
                default:
                    this._log.debug("Incorrect position: \"" + position + "\" defined for the a control such as a \"" + __Drawer + "\", or \"" + this.type + ".\"");
                    return false;
            }
            var rootElement = this._rootElement = this._getRootElement();
            if (isNull(rootElement)) {
                this._log.debug("Cannot have a \"" + this.type + "\" in a hierarchy above the corresponding control such as \"" + __Drawer + ".\"");
                return false;
            }
            var dom = this.dom;
            dom.addClass(rootElement, __Drawer + "-root");
            dom.addClass(this.element, (this._isVertical ? __Plat + "vertical" : __Plat + "horizontal"));
            this._directionalTransitionPrep = __Drawer + "-transition-" + position;
            this._clickEater = this._document.createElement('div');
            this._clickEater.className = __Plat + "clickeater";
            this._styleRootElement();
            return true;
        };
        /**
         * Obtains the root element to translate.
         */
        DrawerController.prototype._getRootElement = function () {
            var drawer = this._drawer, utils = this.utils;
            if (!utils.isNull(drawer.storedProperties)) {
                return drawer.storedProperties.rootElement;
            }
            var isNode = utils.isNode, root = this.root, element = utils.isObject(root) && isNode(root.element) ? root.element : this.element, drawerEl = this._drawerElement, parent;
            while (isNode(parent = element.parentElement) && !parent.contains(drawerEl)) {
                element = parent;
            }
            return element;
        };
        /**
         * Handles root element styling
         */
        DrawerController.prototype._styleRootElement = function () {
            var _window = this._window, utils = this.utils, drawer = this._drawer, rootElement = this._rootElement, parent = rootElement.parentElement, computedStyle = _window.getComputedStyle(rootElement), style = rootElement.style, position = computedStyle.position, zIndex = Number(computedStyle.zIndex), rootElementStyle = {
                rootElement: rootElement
            };
            if (position === 'static') {
                rootElementStyle.position = style.position;
                style.position = 'relative';
            }
            if (!utils.isNumber(zIndex) || zIndex < 1) {
                rootElementStyle.zIndex = style.zIndex;
                style.zIndex = '1';
            }
            if (utils.isNode(parent)) {
                var computedParentStyle = _window.getComputedStyle(parent), overflow = computedParentStyle.overflow;
                if (overflow !== 'hidden') {
                    var computedDirectionalOverflow = void 0, key = void 0;
                    if (this._isVertical) {
                        key = 'overflowY';
                        computedDirectionalOverflow = computedParentStyle.overflowY;
                    }
                    else {
                        key = 'overflowX';
                        computedDirectionalOverflow = computedParentStyle.overflowX;
                    }
                    if (computedDirectionalOverflow !== 'hidden') {
                        var parentStyle = parent.style;
                        rootElementStyle.parentOverflow = {
                            key: key,
                            value: parentStyle[key]
                        };
                        parentStyle[key] = 'hidden';
                    }
                }
            }
            drawer.storedProperties = rootElementStyle;
        };
        /**
         * Uninitializes the root element.
         */
        DrawerController.prototype._cleanRootElement = function () {
            var utils = this.utils, isObject = utils.isObject, isNode = utils.isNode, rootElement = this._rootElement, drawer = this._drawer;
            if (!isNode(rootElement)) {
                return;
            }
            this.dom.removeClass(rootElement, __Drawer + "-root " + this._directionalTransitionPrep);
            if (utils.isNull(drawer)) {
                return;
            }
            var storedStyle = drawer.storedProperties;
            if (!isObject(storedStyle)) {
                return;
            }
            var rootElementStyle = rootElement.style, parent = rootElement.parentElement, overflow = storedStyle.parentOverflow;
            rootElementStyle.position = storedStyle.position;
            rootElementStyle.zIndex = storedStyle.zIndex;
            if (isObject(overflow) && isNode(parent)) {
                parent.style[overflow.key] = overflow.value;
            }
            delete drawer.storedProperties;
            this._drawerElement.setAttribute(__Hide, '');
        };
        /**
         * Sets the max offset to translate the corresponding Drawer.
         */
        DrawerController.prototype._getOffset = function () {
            return this._isVertical ? this._drawerElement.offsetHeight : this._drawerElement.offsetWidth;
        };
        DrawerController._inject = {
            _document: __Document,
            _window: __Window,
            _compat: __Compat,
            _animator: __Animator,
            _Promise: __Promise
        };
        return DrawerController;
    }(plat.ui.BindControl));
    platui.DrawerController = DrawerController;
    plat.register.control(__DrawerController, DrawerController);
    /**
     * An BindControl for showing a templated and animated overlay.
     */
    var Modal = (function (_super) {
        __extends(Modal, _super);
        /**
         * The constructor for a Modal. Creates the modalLoaded Promise.
         */
        function Modal() {
            var _this = this;
            _super.call(this);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = this.__templateString;
            /**
             * Whether or not the modal is currently visible.
             */
            this._isVisible = false;
            /**
             * A function to stop listening to scroll events.
             */
            this._scrollRemover = noop;
            /**
             * A function to stop listening for DOM presence.
             */
            this._presenceRemover = noop;
            /**
             * The current scroll position of the modal.
             */
            this._scrollTop = 0;
            /**
             * A hash for validating available transitions.
             */
            this._transitionHash = {
                up: true,
                down: true,
                left: true,
                right: true,
                fade: true
            };
            /**
             * The private template string used to check for a template overwrite.
             */
            this.__templateString = '<div class="plat-modal-container"></div>\n';
            this.modalLoaded = new this._Promise(function (resolve, reject) {
                _this.__resolveFn = resolve;
                _this.__rejectFn = reject;
            }).catch(noop);
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Modal.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Modal + " " + __Hide + " " + (className || ''));
        };
        /**
         * Check for templateUrl and set if needed then hide the control.
         */
        Modal.prototype.initialize = function () {
            var optionObj = this.options || (this.options = {}), options = optionObj.value || (optionObj.value = {});
            this.templateUrl = options.templateUrl || this.templateUrl;
            this.setClasses();
        };
        /**
         * Add the innerTemplate to the control's element.
         */
        Modal.prototype.setTemplate = function () {
            if (this.templateString !== this.__templateString || this.utils.isString(this.templateUrl)) {
                var dom = this.dom, fragment = dom.serializeHtml(this.__templateString), element = this.element, modalContainer = this._container = fragment.firstChild;
                this.innerTemplate = dom.appendChildren(element.childNodes);
                element.appendChild(fragment);
            }
        };
        /**
         * Check for a transition and initialize it if necessary.
         */
        Modal.prototype.loaded = function () {
            var options = this.options.value, transition = options.transition, element = this.element;
            // in case of cloning 
            this._container = this._container || element.firstElementChild;
            this._presenceRemover = this.dom.whenPresent(this._injectElement.bind(this), element);
            if (!this.utils.isString(transition) || transition === 'none') {
                this.dom.addClass(this._container, __Plat + "no-transition");
                return;
            }
            else if (!this._transitionHash[transition]) {
                this._log.debug("Custom transition: \"" + transition + "\" defined for \"" + this.type + ".\" Please ensure the transition is defined to avoid errors.");
            }
            var animationEvents = this._compat.animationEvents;
            if (this.utils.isNull(animationEvents)) {
                this._log.debug('This browser does not support CSS3 animations.');
                this.dom.addClass(this._container, __Plat + "no-transition");
                return;
            }
            this._transitionEnd = animationEvents.$transitionEnd;
            this.dom.addClass(this._container, (__Plat + transition) + " " + __Plat + "modal-transition");
        };
        /**
         * Clean up the auto scroll.
         */
        Modal.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._scrollRemover();
            this._presenceRemover();
            if (this.utils.isFunction(this.__rejectFn)) {
                this.__rejectFn();
                this.__rejectFn = this.__resolveFn = null;
            }
        };
        /**
         * Shows the Modal.
         */
        Modal.prototype.show = function () {
            var wasHidden = !this._isVisible, promise = this._show();
            if (wasHidden) {
                this.inputChanged(true);
            }
            return promise;
        };
        /**
         * Hides the Modal.
         */
        Modal.prototype.hide = function () {
            var wasVisible = this.isVisible, promise = this._hide();
            if (wasVisible) {
                this.inputChanged(false);
            }
            return promise;
        };
        /**
         * Toggles the visibility of the Modal.
         */
        Modal.prototype.toggle = function () {
            if (this._isVisible) {
                return this.hide();
            }
            return this.show();
        };
        /**
         * Whether or not the Modal is currently visible.
         */
        Modal.prototype.isVisible = function () {
            return this._isVisible;
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Modal.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable property is set externally.
         * @param {boolean} modalState The new value of the control state.
         * @param {boolean} oldValue The old value of the control state.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Modal.prototype._setBoundProperty = function (modalState, oldValue, identifier, firstTime) {
            var utils = this.utils;
            if (firstTime === true && utils.isNull(modalState)) {
                this.inputChanged(this._isVisible);
                return;
            }
            if (utils.isBoolean(modalState)) {
                if (modalState) {
                    if (this._isVisible) {
                        return;
                    }
                    this._show();
                    return;
                }
                if (this._isVisible) {
                    this._hide();
                }
                return;
            }
            this._log.debug("Attempting to show or hide a " + this.type + " with a bound value that is something other than a boolean.");
        };
        /**
         * Shows the Modal.
         */
        Modal.prototype._show = function () {
            var _this = this;
            var dom = this.dom, utils = this.utils;
            if (!utils.isNull(this.innerTemplate)) {
                return this._bindInnerTemplate();
            }
            this._isVisible = true;
            return new this._Promise(function (resolve) {
                utils.requestAnimationFrame(function () {
                    _this._alignModal();
                    dom.removeClass(_this.element, __Hide);
                    utils.defer(function () {
                        utils.requestAnimationFrame(function () {
                            dom.addClass(_this._container, __Plat + "activate");
                            resolve();
                        });
                    }, 20);
                });
            });
        };
        /**
         * Aligns the control to the top of the viewport.
         * @param {Event} ev? The scroll event object.
         */
        Modal.prototype._alignModal = function (ev) {
            var _this = this;
            var utils = this.utils, isNull = utils.isNull, _document = this._document, documentEl = _document.documentElement, scrollEl = isNull(documentEl) || !documentEl.scrollTop ? _document.body : documentEl, scrollTop = scrollEl.scrollTop;
            if (this._scrollTop === scrollTop) {
                return;
            }
            if (!isNull(ev)) {
                utils.requestAnimationFrame(function () {
                    _this.element.style.top = scrollTop + "px";
                });
            }
            else {
                this.element.style.top = scrollTop + "px";
                this._scrollRemover = this.addEventListener(this._window, 'scroll', this._alignModal, false);
            }
            this._scrollTop = scrollTop;
        };
        /**
         * Hides the Modal.
         */
        Modal.prototype._hide = function () {
            var _this = this;
            var dom = this.dom, utils = this.utils, promise;
            this._scrollRemover();
            this._scrollRemover = noop;
            this._isVisible = false;
            if (utils.isString(this._transitionEnd)) {
                promise = this._addHideOnTransitionEnd();
                utils.requestAnimationFrame(function () {
                    dom.removeClass(_this._container, __Plat + "activate");
                });
            }
            else {
                promise = new this._Promise(function (resolve) {
                    utils.requestAnimationFrame(function () {
                        dom.addClass(_this.element, __Hide);
                        dom.removeClass(_this._container, __Plat + "activate");
                        resolve();
                    });
                });
            }
            return promise;
        };
        /**
         * Adds the innerTemplate to BindableTemplates, binds it,
         * and adds it to the DOM.
         */
        Modal.prototype._bindInnerTemplate = function () {
            var _this = this;
            var innerTemplate = this.innerTemplate, bindableTemplates = this.bindableTemplates, modal = 'modal';
            bindableTemplates.add(modal, innerTemplate);
            this.innerTemplate = null;
            return bindableTemplates.bind(modal).then(function (template) {
                _this._container.insertBefore(template, null);
                if (_this.utils.isFunction(_this.__resolveFn)) {
                    _this.__resolveFn();
                    _this.__resolveFn = _this.__rejectFn = null;
                }
                return _this._show();
            });
        };
        /**
         * Removes itself from the DOM and inserts itself into the body to work with
         * absolute positioning.
         */
        Modal.prototype._injectElement = function () {
            var element = this.element, parentElement = element.parentElement, body = this._document.body;
            if (!this.utils.isNode(parentElement) || parentElement === body) {
                return;
            }
            body.insertBefore(element, null);
        };
        /**
         * Listens for the transition to end and hides the element after it is finished.
         */
        Modal.prototype._addHideOnTransitionEnd = function () {
            var _this = this;
            return new this._Promise(function (resolve) {
                var element = _this.element, remove = _this.addEventListener(element, _this._transitionEnd, function () {
                    remove();
                    _this.dom.addClass(element, __Hide);
                    resolve();
                }, false);
            });
        };
        Modal._inject = {
            _window: __Window,
            _document: __Document,
            _compat: __Compat,
            _Promise: __Promise
        };
        return Modal;
    }(plat.ui.BindControl));
    platui.Modal = Modal;
    plat.register.control(__Modal, Modal);
    /**
     * An BindControl that standardizes an HTML5 input[type="range"].
     */
    var Slider = (function (_super) {
        __extends(Slider, _super);
        function Slider() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-slider-container">\n' +
                '    <div class="plat-slider-track">\n' +
                '        <div class="plat-knob"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * The current knob offset.
             */
            this._knobOffset = 0;
            /**
             * An enum denoting the current touch state of the user.
             */
            this._touchState = 0;
            /**
             * A function that will stop listening for visibility if applicable.
             */
            this._removeVisibilityListener = noop;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Slider.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Slider + " " + (className || ''));
        };
        /**
         * Set the proper classes for the control.
         */
        Slider.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Determine the button type and apply the proper classes.
         */
        Slider.prototype.loaded = function () {
            var element = this.element, slider = this._slider = element.firstElementChild.firstElementChild, isNumber = this.utils.isNumber, optionObj = this.options || {}, options = optionObj.value || {}, optionValue = Number(options.value), optionMin = options.min, optionMax = options.max, step = options.step, reversed = this._reversed = (options.reverse === true), min = this.min = isNumber(optionMin) ? Math.floor(optionMin) : 0, max = this.max = isNumber(optionMax) ? Math.ceil(optionMax) : 100, value = isNumber(optionValue) ? Math.round(optionValue) : min, className = __Plat + this._validateOrientation(options.orientation);
            this._knob = slider.firstElementChild;
            if (reversed) {
                className += __Reversed;
            }
            this.dom.addClass(element, className);
            // reset value to minimum in case Bind set it to a value 
            this.value = min;
            this._step = isNumber(step) ? (step > 0 ? Math.round(step) : 1) : 1;
            if (min >= max) {
                this._log.debug("\"" + this.type + "'s\" min is greater than or equal to its max. Setting max to min + 1.");
                this.max = min + 1;
            }
            this._setLength();
            this._initializeEvents();
            this.setValue(value);
        };
        /**
         * Removes the visibility listener if applicable.
         */
        Slider.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._removeVisibilityListener();
            this._sliderVisible = null;
        };
        /**
         * Set the value of the Slider. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Slider to.
         */
        Slider.prototype.setValue = function (value) {
            this._setValue(value, true);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Slider.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable value is set externally.
         * @param {number} newValue The new value of the bindable value.
         * @param {number} oldValue The old value of the bindable index.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Slider.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            this._setValue(newValue, false);
        };
        /**
         * Sets the value of the Slider.
         * @param {number} value The value to set.
         * @param {boolean} propertyChanged Whether or not we need to fire a propertyChanged event.
         */
        Slider.prototype._setValue = function (value, propertyChanged) {
            var utils = this.utils;
            if (this._touchState === 1) {
                this._log.debug("Cannot set the value of " + this.type + " while the user is manipulating it.");
                return;
            }
            else if (utils.isNull(value)) {
                value = this.min;
                propertyChanged = true;
            }
            if (!utils.isNumber(value)) {
                var numberVal = Number(value);
                if (utils.isNumber(numberVal)) {
                    value = numberVal;
                    propertyChanged = true;
                }
                else {
                    this._log.warn(this.type + " has its value bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            this._setValueProperty(value, true, propertyChanged);
        };
        /**
         * Initialize the proper tracking events.
         */
        Slider.prototype._initializeEvents = function () {
            var _this = this;
            var element = this.element, trackFn = this._track, touchEnd = this._touchEnd, track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "down";
                reverseTrack = __$track + "up";
            }
            else {
                track = __$track + "right";
                reverseTrack = __$track + "left";
            }
            this.addEventListener(element, __$touchstart, this._touchStart, false);
            this.addEventListener(element, track, trackFn, false);
            this.addEventListener(element, reverseTrack, trackFn, false);
            this.addEventListener(element, __$touchend, touchEnd, false);
            this.addEventListener(element, __$trackend, touchEnd, false);
            this.addEventListener(this._window, 'resize', function () {
                if (!_this.utils.isNull(_this._sliderVisible)) {
                    return;
                }
                _this._setLength();
                _this._setKnob();
            }, false);
        };
        /**
         * Log the first touch.
         * @param {plat.ui.IGestureEvent} ev The touch event object.
         */
        Slider.prototype._touchStart = function (ev) {
            var _this = this;
            if (this._touchState === 1) {
                return;
            }
            this._touchState = 1;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY,
                value: this.value
            };
            var target = ev.target;
            if (target === this._knob) {
                return;
            }
            var offset;
            if (this._isVertical) {
                if (target === this.element) {
                    offset = this._reversed ? ev.offsetY - this._sliderOffset : this._maxOffset - (ev.offsetY - this._sliderOffset);
                }
                else if (target === this._slider) {
                    offset = this._reversed ? ev.offsetY : this._knobOffset - ev.offsetY;
                }
                else {
                    offset = this._reversed ? ev.offsetY : this._maxOffset - ev.offsetY;
                }
            }
            else {
                if (target === this.element) {
                    offset = this._reversed ? this._maxOffset - (ev.offsetX - this._sliderOffset) : ev.offsetX - this._sliderOffset;
                }
                else if (target === this._slider) {
                    offset = this._reversed ? this._knobOffset - ev.offsetX : ev.offsetX;
                }
                else {
                    offset = this._reversed ? this._maxOffset - ev.offsetX : ev.offsetX;
                }
            }
            this.utils.requestAnimationFrame(function () {
                _this._knobOffset = _this._setSliderProperties(offset);
            });
        };
        /**
         * Set the new slider offset.
         * @param {plat.ui.IGestureEvent} ev The $trackend event object.
         */
        Slider.prototype._touchEnd = function (ev) {
            var _this = this;
            if (this._touchState !== 1) {
                this._touchState = 0;
                return;
            }
            this._touchState = 2;
            var newOffset = this._calculateOffset(ev), maxOffset = this._maxOffset;
            this.utils.requestAnimationFrame(function () {
                _this._touchState = 0;
                if (_this._lastTouch.value !== _this.value) {
                    _this._trigger('change');
                }
                if (newOffset < 0) {
                    _this._knobOffset = 0;
                    return;
                }
                else if (newOffset > maxOffset) {
                    _this._knobOffset = maxOffset;
                    return;
                }
                _this._knobOffset = newOffset;
            });
        };
        /**
         * Track the knob movement.
         * @param {plat.ui.IGestureEvent} ev The $track event object.
         */
        Slider.prototype._track = function (ev) {
            var _this = this;
            if (this._touchState === 0) {
                return;
            }
            this.utils.requestAnimationFrame(function () {
                _this._setSliderProperties(_this._calculateOffset(ev));
            });
        };
        /**
         * Set the Slider's knob position and corresponding value.
         * @param {number} position The position value to set the knob to prior to
         * normalization.
         */
        Slider.prototype._setSliderProperties = function (position) {
            var maxOffset = this._maxOffset, value;
            if (position <= 0) {
                value = this.min;
                position = 0;
                if (value - this.value >= 0) {
                    return position;
                }
            }
            else if (position >= maxOffset) {
                value = this.max;
                position = maxOffset;
                if (value - this.value <= 0) {
                    return position;
                }
            }
            else {
                value = this._calculateValue(position);
            }
            this._setValueProperty(value, false, true);
            this._slider.style[this._lengthProperty] = position + "px";
            return position;
        };
        /**
         * Calculates the current value based on knob position and slider width.
         * @param {number} width The current width of the slider.
         */
        Slider.prototype._calculateValue = function (width) {
            var step = this._step;
            return (this.min + Math.round(width / this._increment / step) * step);
        };
        /**
         * Calculates knob position based on current value.
         * @param {number} value The current value of the {link platui.Slider|Slider}.
         */
        Slider.prototype._calculateKnobPosition = function (value) {
            return (value - this.min) * this._increment;
        };
        /**
         * Calculates the new offset of the slider based on the old offset and the distance moved.
         * @param {plat.ui.IGestureEvent} ev The $track or $trackend event object.
         */
        Slider.prototype._calculateOffset = function (ev) {
            if (this._isVertical) {
                return this._reversed ?
                    (this._knobOffset + ev.clientY - this._lastTouch.y) :
                    (this._knobOffset + this._lastTouch.y - ev.clientY);
            }
            else {
                return this._reversed ?
                    (this._knobOffset + this._lastTouch.x - ev.clientX) :
                    (this._knobOffset + ev.clientX - this._lastTouch.x);
            }
        };
        /**
         * Sets the property to use for length and sets the max length of the slider.
         */
        Slider.prototype._setLength = function () {
            var _this = this;
            var el = this._slider.parentElement;
            if (this._isVertical) {
                this._lengthProperty = 'height';
                this._maxOffset = el.clientHeight;
                this._sliderOffset = el.offsetTop;
            }
            else {
                this._lengthProperty = 'width';
                this._maxOffset = el.clientWidth;
                this._sliderOffset = el.offsetLeft;
            }
            if (!this._maxOffset) {
                this._sliderVisible = new this._Promise(function (resolve) {
                    _this._removeVisibilityListener = _this.dom.whenVisible(function () {
                        _this._sliderVisible = null;
                        _this._setLength();
                        resolve();
                    }, el);
                });
                return;
            }
            this._setIncrement();
        };
        /**
         * Sets the increment for sliding the {link platui.Slider|Slider}.
         */
        Slider.prototype._setIncrement = function () {
            return (this._increment = this._maxOffset / (this.max - this.min));
        };
        /**
         * Sets the value of the Slider.
         * @param {number} newValue The new value to set.
         * @param {boolean} setKnob Whether or not we need to set the knob position.
         * @param {boolean} propertyChanged Whether or not we need to fire a propertyChanged event.
         */
        Slider.prototype._setValueProperty = function (newValue, setKnob, propertyChanged) {
            var value = this.value;
            if (newValue === value) {
                return;
            }
            else if (newValue >= this.max) {
                newValue = this.max;
            }
            else if (newValue <= this.min) {
                newValue = this.min;
            }
            else if (Math.abs(newValue - value) < this._step) {
                return;
            }
            this.value = this.element.value = newValue;
            if (setKnob) {
                this._setKnob();
            }
            if (propertyChanged) {
                this.inputChanged(newValue, value);
            }
            this._trigger('input');
        };
        /**
         * Animates and sets the knob position.
         * @param {number} value? The value to use to calculate the knob position. If no value is
         * specified, the current Slider's value will be used.
         */
        Slider.prototype._setKnob = function (value) {
            var _this = this;
            this._Promise.resolve(this._sliderVisible).then(function () {
                var animationOptions = {}, length = _this._calculateKnobPosition((value || _this.value));
                if (length === _this._knobOffset) {
                    return;
                }
                animationOptions[_this._lengthProperty] = length + "px";
                _this._animator.animate(_this._slider, __Transition, {
                    properties: animationOptions
                });
                _this._knobOffset = length;
            });
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        Slider.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Slider.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'horizontal';
            }
            var validOrientation;
            if (orientation === 'horizontal') {
                validOrientation = orientation;
            }
            else if (orientation === 'vertical') {
                validOrientation = orientation;
                this._isVertical = true;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"horizontal.\"");
                validOrientation = 'horizontal';
            }
            return validOrientation;
        };
        Slider._inject = {
            _document: __Document,
            _window: __Window,
            _Promise: __Promise,
            _animator: __Animator
        };
        return Slider;
    }(plat.ui.BindControl));
    platui.Slider = Slider;
    plat.register.control(__Slider, Slider);
    /**
     * A BindControl that allows for a lower and upper value,
     * thus creating a variable range of included values.
     */
    var Range = (function (_super) {
        __extends(Range, _super);
        function Range() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-range-container">\n' +
                '    <div class="plat-range-track">\n' +
                '        <div class="plat-lower-knob"></div>\n' +
                '        <div class="plat-upper-knob"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * An enum denoting the current touch state of the user.
             */
            this._touchState = 0;
            /**
             * A function that will stop listening for visibility if applicable.
             */
            this._removeVisibilityListener = noop;
            /**
             * A boolean value that forces a one-time trigger upon the first bound value change.
             */
            this._forceFirstTime = false;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Range.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Range + " " + (className || ''));
        };
        /**
         * Set the proper classes for the control.
         */
        Range.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Determine the button type and apply the proper classes.
         */
        Range.prototype.loaded = function () {
            var element = this.element, slider = this._slider = element.firstElementChild.firstElementChild, isNumber = this.utils.isNumber, optionObj = this.options || {}, options = optionObj.value || {}, optionLower = Number(options.lower), optionUpper = Number(options.upper), identifiers = options.identifiers || {}, optionMin = options.min, optionMax = options.max, step = options.step, reversed = this._reversed = (options.reverse === true), min = this.min = isNumber(optionMin) ? Math.floor(optionMin) : 0, max = this.max = isNumber(optionMax) ? Math.ceil(optionMax) : 100, lower = isNumber(optionLower) ? Math.round(optionLower) : min, upper = isNumber(optionUpper) ? Math.round(optionUpper) : max, className = __Plat + this._validateOrientation(options.orientation);
            this._lowerKnob = slider.firstElementChild;
            this._upperKnob = slider.lastElementChild;
            this._lowerIdentifier = identifiers.lower || 'lower';
            this._upperIdentifier = identifiers.upper || 'upper';
            // if it's a reversed direction, swap knobs. 
            if (reversed) {
                var lowerKnob = this._lowerKnob;
                this._lowerKnob = this._upperKnob;
                this._upperKnob = lowerKnob;
                className += __Reversed;
            }
            this.dom.addClass(element, className);
            // reset value to minimum in case context is already set to a value 
            this.lower = min;
            this.upper = max;
            this._step = isNumber(step) ? (step > 0 ? Math.round(step) : 1) : 1;
            if (min >= max) {
                this._log.debug("\"" + this.type + "'s\" min is greater than or equal to its max. Setting max to min + 1.");
                this.max = min + 1;
            }
            this._setPositionAndLength();
            // must set this in case the value is not set and lower knob is never positioned due to setLower function. 
            this._setLowerKnobPosition(min);
            this._initializeEvents();
            this.setLower(lower);
            this.setUpper(upper);
        };
        /**
         * Sets the lower value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         */
        Range.prototype.setLower = function (value) {
            this._setLower(value, true);
        };
        /**
         * Sets the upper value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         */
        Range.prototype.setUpper = function (value) {
            this._setUpper(value, true);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Range.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setLowerBoundProperty, this._lowerIdentifier);
            binder.observeProperty(this._setUpperBoundProperty, this._upperIdentifier);
        };
        /**
         * The function called when the bindable lower value is set externally.
         * @param {number} newValue The new lower value.
         * @param {number} oldValue The old value of the bindable index.
         * @param {string} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Range.prototype._setLowerBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            this._setLower(newValue, false, firstTime);
        };
        /**
         * The function called when the bindable upper value is set externally.
         * @param {number} newValue The new upper value.
         * @param {number} oldValue The old value of the bindable index.
         * @param {string} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Range.prototype._setUpperBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            this._setUpper(newValue, false, firstTime);
        };
        /**
         * Sets the lower value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} firstTime? Whether or not this is the first call to set the lower value.
         */
        Range.prototype._setLower = function (value, propertyChanged, firstTime) {
            var utils = this.utils;
            if (this._touchState === 2) {
                this._log.debug("Cannot set the value of the " + this.type + "'s lower knob while the user is manipulating it.");
                return;
            }
            else if (utils.isNull(value)) {
                value = this.min;
                if (firstTime === true) {
                    this._forceFirstTime = true;
                }
                else {
                    propertyChanged = true;
                }
            }
            if (!utils.isNumber(value)) {
                var numberVal = Number(value);
                if (utils.isNumber(numberVal)) {
                    value = numberVal;
                    if (firstTime === true) {
                        this._forceFirstTime = true;
                    }
                    else {
                        propertyChanged = true;
                    }
                }
                else {
                    this._log.warn(this.type + " has its lower value bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            this._setLowerValue(value, true, propertyChanged, true);
        };
        /**
         * Sets the uppper value of the Range. If an invalid value is passed in
         * nothing will happen.
         * @param {number} value The value to set the Range to.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} firstTime? Whether or not this is the first call to set the upper value.
         */
        Range.prototype._setUpper = function (value, propertyChanged, firstTime) {
            var utils = this.utils;
            if (this._touchState === 3) {
                this._log.debug("Cannot set the value of the " + this.type + "'s upper knob while the user is manipulating it.");
                return;
            }
            else if (utils.isNull(value)) {
                value = this.max;
                propertyChanged = true;
            }
            if (!utils.isNumber(value)) {
                var numberVal = Number(value);
                if (utils.isNumber(numberVal)) {
                    value = numberVal;
                    propertyChanged = true;
                }
                else {
                    this._log.warn(this.type + " has its upper value bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            this._setUpperValue(value, true, propertyChanged || (firstTime === true && this._forceFirstTime), true);
        };
        /**
         * Initialize the proper tracking events.
         */
        Range.prototype._initializeEvents = function () {
            var _this = this;
            var lowerKnob = this._lowerKnob, upperKnob = this._upperKnob, touchstart = this._touchStart, touchEnd = this._touchEnd, trackLower = this._trackLower, trackUpper = this._trackUpper, track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "down";
                reverseTrack = __$track + "up";
            }
            else {
                track = __$track + "right";
                reverseTrack = __$track + "left";
            }
            this.addEventListener(lowerKnob, __$touchstart, touchstart, false);
            this.addEventListener(upperKnob, __$touchstart, touchstart, false);
            this.addEventListener(lowerKnob, track, trackLower, false);
            this.addEventListener(lowerKnob, reverseTrack, trackLower, false);
            this.addEventListener(upperKnob, track, trackUpper, false);
            this.addEventListener(upperKnob, reverseTrack, trackUpper, false);
            this.addEventListener(lowerKnob, __$touchend, touchEnd, false);
            this.addEventListener(upperKnob, __$touchend, touchEnd, false);
            this.addEventListener(lowerKnob, __$trackend, touchEnd, false);
            this.addEventListener(upperKnob, __$trackend, touchEnd, false);
            this.addEventListener(this._window, 'resize', function () {
                if (!_this.utils.isNull(_this._rangeVisible)) {
                    return;
                }
                _this._setPositionAndLength();
                _this._setLowerKnobPosition();
                _this._setUpperKnobPosition();
            }, false);
        };
        /**
         * Log the first touch.
         * @param {plat.ui.IGestureEvent} ev The touch event object.
         */
        Range.prototype._touchStart = function (ev) {
            var touchState = this._touchState;
            if (touchState === 1 || touchState === 2 || touchState === 3) {
                return;
            }
            this._touchState = 1;
            var target = ev.currentTarget, lastTouch = this._lastTouch;
            if (this.utils.isNull(lastTouch)) {
                this.dom.addClass(target, __Plat + "top");
            }
            else if (lastTouch.target !== target) {
                var dom = this.dom;
                dom.addClass(target, __Plat + "top");
                dom.removeClass(lastTouch.target, __Plat + "top");
            }
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY,
                value: target === this._lowerKnob ? this.lower : this.upper,
                target: target
            };
        };
        /**
         * Set the new slider element offset.
         * @param {plat.ui.IGestureEvent} ev The $trackend event object.
         */
        Range.prototype._touchEnd = function (ev) {
            var _this = this;
            var touchState = this._touchState;
            if (touchState === 0 || touchState === 4) {
                this._touchState = 0;
                return;
            }
            this._touchState = 4;
            var lastTouch = this._lastTouch, target = ev.currentTarget;
            if (this.utils.isNull(lastTouch) || (lastTouch.target !== target)) {
                return;
            }
            this.utils.requestAnimationFrame(function () {
                _this._touchState = 0;
                var isLower = target === _this._lowerKnob, newOffset = _this._calculateOffset(ev, isLower);
                if (isLower) {
                    if (lastTouch.value !== _this.lower) {
                        _this._trigger('change');
                    }
                }
                else if (lastTouch.value !== _this.upper) {
                    _this._trigger('change');
                }
                _this._setOffset(newOffset, isLower);
            });
        };
        /**
         * Sets the designated knob element's offset to the given value.
         * @param {number} offset The new offset.
         * @param {boolean} isLower Whether we're setting the lower or upper knob.
         */
        Range.prototype._setOffset = function (offset, isLower) {
            var maxOffset = this._maxOffset;
            if (offset < 0) {
                return isLower ? (this._lowerKnobOffset = 0) :
                    (this._upperKnobOffset = 0);
            }
            else if (offset > maxOffset) {
                return isLower ? (this._lowerKnobOffset = maxOffset) :
                    (this._upperKnobOffset = maxOffset);
            }
            return isLower ? (this._lowerKnobOffset = offset) :
                (this._upperKnobOffset = offset);
        };
        /**
         * Track the lower knob movement.
         * @param {plat.ui.IGestureEvent} ev The $track event object.
         */
        Range.prototype._trackLower = function (ev) {
            var touchState = this._touchState;
            if (touchState !== 2) {
                if (touchState === 1) {
                    this._touchState = 2;
                }
                else if (touchState === 0 || touchState === 3) {
                    return;
                }
            }
            var maxOffset = this._maxOffset, position = this._calculateOffset(ev, true), value;
            if (position <= 0) {
                value = this.min;
                if (value - this.lower >= 0) {
                    value = null;
                }
                position = 0;
            }
            else if (position >= maxOffset) {
                value = this.max;
                if (value - this.lower <= 0) {
                    value = null;
                }
                position = maxOffset;
            }
            else {
                value = this._calculateValue(position);
                if (value - this.lower === 0) {
                    value = null;
                }
            }
            if (position > this._upperKnobOffset) {
                this._positionTogether(position, value);
                this._setOffset(position, false);
                return;
            }
            this._positionLower(position, value);
        };
        /**
         * Track the upper knob movement.
         * @param {plat.ui.IGestureEvent} ev The $track event object.
         */
        Range.prototype._trackUpper = function (ev) {
            var touchState = this._touchState;
            if (touchState !== 3) {
                if (touchState === 1) {
                    this._touchState = 3;
                }
                else if (touchState === 0 || touchState === 2) {
                    return;
                }
            }
            var maxOffset = this._maxOffset, position = this._calculateOffset(ev, false), value;
            if (position <= 0) {
                value = this.min;
                if (value - this.upper >= 0) {
                    value = null;
                }
                position = 0;
            }
            else if (position >= maxOffset) {
                value = this.max;
                if (value - this.upper <= 0) {
                    value = null;
                }
                position = maxOffset;
            }
            else {
                value = this._calculateValue(position);
                if (value - this.upper === 0) {
                    value = null;
                }
            }
            if (position < this._lowerKnobOffset) {
                this._positionTogether(position, value);
                this._setOffset(position, true);
                return;
            }
            this._positionUpper(position, value);
        };
        /**
         * Positions the slider element and adjusts it's length to account
         * for lower knob movement.
         * @param {number} position The new position of the lower knob.
         * @param {number} value? The new value to set if specified.
         */
        Range.prototype._positionLower = function (position, value) {
            var _this = this;
            this.utils.requestAnimationFrame(function () {
                var style = _this._slider.style;
                style[_this._positionProperty] = position + "px";
                style[_this._lengthProperty] = (_this._upperKnobOffset - position) + "px";
                if (value === null) {
                    return;
                }
                _this._setLowerValue(value, false, true, true);
            });
        };
        /**
         * Positions the slider element and adjusts it's length to account
         * for upper knob movement.
         * @param {number} position The new position of the upper knob.
         * @param {number} value? The new value to set if specified.
         */
        Range.prototype._positionUpper = function (position, value) {
            var _this = this;
            this.utils.requestAnimationFrame(function () {
                _this._slider.style[_this._lengthProperty] = (position - _this._lowerKnobOffset) + "px";
                if (value === null) {
                    return;
                }
                _this._setUpperValue(value, false, true, true);
            });
        };
        /**
         * Positions the slider element and adjusts it's length to account
         * for synchronized knob movement.
         * @param {number} position The new position of the knobs.
         * @param {number} value? The new value to set if specified.
         */
        Range.prototype._positionTogether = function (position, value) {
            var _this = this;
            this.utils.requestAnimationFrame(function () {
                var style = _this._slider.style;
                style[_this._positionProperty] = position + "px";
                style[_this._lengthProperty] = '0px';
                if (value === null) {
                    return;
                }
                _this._setLowerValue(value, false, false, false);
                _this._setUpperValue(value, false, true, true);
            });
        };
        /**
         * Calculates the current value based on knob position and slider element width.
         * @param {number} width The current width of the slider element.
         */
        Range.prototype._calculateValue = function (width) {
            var step = this._step;
            return (this.min + Math.round(width / this._increment / step) * step);
        };
        /**
         * Calculates the new offset of the slider element based on the old offset and the distance moved.
         * @param {plat.ui.IGestureEvent} ev The $track or $trackend event object.
         * @param {boolean} isLower Whether the current knob is the lower or the upper knob.
         */
        Range.prototype._calculateOffset = function (ev, isLower) {
            var currentOffset = isLower ? this._lowerKnobOffset : this._upperKnobOffset, displacement;
            if (this._isVertical) {
                displacement = this._reversed ? ev.clientY - this._lastTouch.y : this._lastTouch.y - ev.clientY;
            }
            else {
                displacement = this._reversed ? this._lastTouch.x - ev.clientX : ev.clientX - this._lastTouch.x;
            }
            return currentOffset + displacement;
        };
        /**
         * Calculates knob position based on current value.
         * @param {number} value The current value of the {link platui.Range|Range}.
         */
        Range.prototype._calculateKnobPosition = function (value) {
            return (value - this.min) * this._increment;
        };
        /**
         * Sets the lower value of the Range.
         * @param {number} newValue The new value to set.
         * @param {boolean} setKnob Whether or not we need to set the knob position.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} trigger Whether or not to trigger the 'input' event.
         */
        Range.prototype._setLowerValue = function (newValue, setKnob, propertyChanged, trigger) {
            var lower = this.lower;
            if (newValue === lower) {
                return;
            }
            else if (newValue >= this.max) {
                newValue = this.max;
            }
            else if (newValue <= this.min) {
                newValue = this.min;
            }
            else if (Math.abs(newValue - lower) < this._step) {
                return;
            }
            this.lower = newValue;
            if (setKnob) {
                this._setLowerKnobPosition();
            }
            if (propertyChanged) {
                this._fireChange();
            }
            if (trigger) {
                this._trigger('input');
            }
        };
        /**
         * Sets the value of the Range.
         * @param {number} newValue The new value to set.
         * @param {boolean} setKnob Whether or not we need to set the knob position.
         * @param {boolean} propertyChanged Whether or not the property was changed by the user.
         * @param {boolean} trigger Whether or not to trigger the 'input' event.
         */
        Range.prototype._setUpperValue = function (newValue, setKnob, propertyChanged, trigger) {
            var upper = this.upper;
            if (newValue === upper) {
                return;
            }
            else if (newValue >= this.max) {
                newValue = this.max;
            }
            else if (newValue <= this.min) {
                newValue = this.min;
            }
            else if (Math.abs(newValue - upper) < this._step) {
                return;
            }
            this.upper = newValue;
            if (setKnob) {
                this._setUpperKnobPosition();
            }
            if (propertyChanged) {
                this._fireChange();
            }
            if (trigger) {
                this._trigger('input');
            }
        };
        /**
         * Sets the increment for sliding the {link platui.Range|Range}.
         */
        Range.prototype._setIncrement = function () {
            return (this._increment = this._maxOffset / (this.max - this.min));
        };
        /**
         * Sets the properties to use for length and position and sets the max length of the sliding element.
         */
        Range.prototype._setPositionAndLength = function () {
            var _this = this;
            var el = this._slider.parentElement;
            if (this._isVertical) {
                this._lengthProperty = 'height';
                this._positionProperty = this._reversed ? 'top' : 'bottom';
                this._maxOffset = el.clientHeight;
            }
            else {
                this._lengthProperty = 'width';
                this._positionProperty = this._reversed ? 'right' : 'left';
                this._maxOffset = el.clientWidth;
            }
            if (!this._maxOffset) {
                this._rangeVisible = new this._Promise(function (resolve) {
                    _this._removeVisibilityListener = _this.dom.whenVisible(function () {
                        _this._rangeVisible = null;
                        _this._setPositionAndLength();
                        resolve();
                    }, el);
                });
                return;
            }
            this._setIncrement();
        };
        /**
         * Animates and sets the knob position.
         * @param {number} value? The value to use to calculate the knob position. If no value is
         * specified, the current Range's value will be used.
         */
        Range.prototype._setLowerKnobPosition = function (value) {
            var _this = this;
            this._Promise.resolve(this._rangeVisible).then(function () {
                var animationOptions = {}, upperKnobOffset = _this._upperKnobOffset, upperOffset = _this.utils.isNumber(upperKnobOffset) ?
                    upperKnobOffset :
                    _this._setOffset(_this._calculateKnobPosition(_this.upper), false), position = _this._calculateKnobPosition((value || _this.lower));
                if (position === _this._lowerKnobOffset) {
                    return;
                }
                animationOptions[_this._positionProperty] = position + "px";
                animationOptions[_this._lengthProperty] = (upperOffset - position) + "px";
                _this._animator.animate(_this._slider, __Transition, {
                    properties: animationOptions
                });
                _this._lowerKnobOffset = position;
            });
        };
        /**
         * Animates and sets the knob position.
         * @param {number} value? The value to use to calculate the knob position. If no value is
         * specified, the current Range's value will be used.
         */
        Range.prototype._setUpperKnobPosition = function (value) {
            var _this = this;
            this._Promise.resolve(this._rangeVisible).then(function () {
                var animationOptions = {}, length = _this._calculateKnobPosition((value || _this.upper));
                if (length === _this._upperKnobOffset) {
                    return;
                }
                animationOptions[_this._lengthProperty] = (length - _this._lowerKnobOffset) + "px";
                _this._animator.animate(_this._slider, __Transition, {
                    properties: animationOptions
                });
                _this._upperKnobOffset = length;
            });
        };
        /**
         * Fires an inputChanged event with the new bound value.
         */
        Range.prototype._fireChange = function () {
            var newProperty = {};
            newProperty[this._lowerIdentifier] = this.lower;
            newProperty[this._upperIdentifier] = this.upper;
            this.inputChanged(newProperty);
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        Range.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Range.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'horizontal';
            }
            var validOrientation;
            if (orientation === 'horizontal') {
                validOrientation = orientation;
            }
            else if (orientation === 'vertical') {
                validOrientation = orientation;
                this._isVertical = true;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"horizontal.\"");
                validOrientation = 'horizontal';
            }
            return validOrientation;
        };
        Range._inject = {
            _document: __Document,
            _window: __Window,
            _Promise: __Promise,
            _animator: __Animator
        };
        return Range;
    }(plat.ui.BindControl));
    platui.Range = Range;
    plat.register.control(__Range, Range);
    /**
     * An ITemplateControl that allows for databinding a select box and adds
     * custom styling to make it look consistent across all platforms.
     */
    var Select = (function (_super) {
        __extends(Select, _super);
        function Select() {
            _super.apply(this, arguments);
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Select.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Select + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Select.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.setClasses();
        };
        return Select;
    }(plat.ui.controls.Select));
    platui.Select = Select;
    plat.register.control(__Select, Select);
    /**
     * An BindControl that standardizes and styles
     * an HTML input element of various types.
     */
    var Input = (function (_super) {
        __extends(Input, _super);
        function Input() {
            _super.apply(this, arguments);
            /**
             * Replaces the control's element with an HTMLInputElement.
             */
            this.replaceWith = 'input';
            /**
             * The current value.
             */
            this.value = '';
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Input.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Input + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Input.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set all HTMLElement references and potential attribute controls.
         */
        Input.prototype.setTemplate = function () {
            this.dom.clearNode(this.element);
        };
        /**
         * Set the style and initialize the action.
         */
        Input.prototype.loaded = function () {
            var optionObj = this.options || {}, options = optionObj.value || {}, pattern = options.pattern, validation = options.validation, isString = this.utils.isString;
            this._type = this.attributes['type'] || options.type || 'text';
            if (isString(pattern) && pattern !== '') {
                if (pattern[0] === '/' && pattern[pattern.length - 1] === '/') {
                    pattern = pattern.slice(1, -1);
                }
                this._pattern = new RegExp(pattern);
            }
            if (isString(validation) && validation !== '') {
                if (validation[0] === '/' && validation[validation.length - 1] === '/') {
                    validation = validation.slice(1, -1);
                }
                this._validation = new RegExp(validation);
            }
            this._initializeType();
        };
        /**
         * A function to validate the user's input. For action="email" it returns
         * true if the email can be a valid email address. For all other
         * actions it returns true if the input is not empty.
         */
        Input.prototype.validate = function () {
            return this._validation.test(this.element.value);
        };
        /**
         * Clears the user's input.
         */
        Input.prototype.clear = function () {
            var element = this.element, value = element.value;
            if (value === '') {
                return;
            }
            element.value = this.value = '';
            this.inputChanged(this.value, value);
        };
        /**
         * Focuses the input.
         */
        Input.prototype.focus = function () {
            this.element.focus();
        };
        /**
         * Blurs the input.
         */
        Input.prototype.blur = function () {
            this.element.blur();
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Input.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty, null, true);
        };
        /**
         * The function called when the bindable text is set externally.
         * @param {string} newValue The new value of the bindable text.
         * @param {string} oldValue The old value of the bindable text.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Input.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var value = this.element.value;
            if (this.utils.isNull(newValue)) {
                newValue = '';
                if (firstTime === true) {
                    if (this.utils.isNull(value)) {
                        this._onInputChanged(newValue);
                    }
                    return;
                }
            }
            else if (newValue === value) {
                return;
            }
            this._onInputChanged(newValue);
        };
        /**
         * Initializes the type.
         */
        Input.prototype._initializeType = function () {
            var inputType = this._type;
            switch (inputType) {
                case 'text':
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._pattern;
                    break;
                case 'email':
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._regex.validateEmail;
                    break;
                case 'password':
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._pattern;
                    break;
                case 'telephone':
                    inputType = 'tel';
                case 'tel':
                    this._pattern = this._pattern || this._regex.validateTelephone;
                    this._validation = this._validation || this._pattern;
                    break;
                case 'number':
                    this._pattern = this._pattern || /^[0-9\.,]*$/;
                    this._validation = this._validation || this._pattern;
                    inputType = 'tel';
                    break;
                case 'hidden':
                    this.element.setAttribute(__Hide, '');
                    return;
                case 'radio':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __Radio + " instead.");
                    return;
                case 'checkbox':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __Checkbox + " instead.");
                    return;
                case 'range':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __Slider + " instead.");
                    return;
                case 'file':
                    this._log.debug(inputType + " is not supported by " + this.type + ". Please use a " + __File + " instead.");
                    return;
                default:
                    this._log.debug(inputType + " is not yet fully supported by " + this.type + ". Defaulting to type=\"text\".");
                    inputType = 'text';
                    this._pattern = this._pattern || /[\S\s]*/;
                    this._validation = this._validation || this._pattern;
                    break;
            }
            this._addTextEventListener();
        };
        /**
         * Adds a text event listener to the input element.
         */
        Input.prototype._addTextEventListener = function () {
            var _this = this;
            var input = this.element, compat = this._compat, utils = this.utils, composing = false, timeout, eventListener = function () {
                if (composing) {
                    return;
                }
                _this._onInput();
            }, postponedEventListener = function () {
                if (utils.isFunction(timeout)) {
                    return;
                }
                timeout = utils.postpone(function () {
                    eventListener();
                    timeout = null;
                });
            };
            if (utils.isUndefined(compat.ANDROID)) {
                this.addEventListener(input, 'compositionstart', function () { return (composing = true); }, false);
                this.addEventListener(input, 'compositionend', function () {
                    composing = false;
                    eventListener();
                }, false);
            }
            if (compat.hasEvent('input')) {
                this.addEventListener(input, 'input', eventListener, false);
            }
            else {
                this.addEventListener(input, 'keydown', function (ev) {
                    var key = ev.keyCode;
                    if (key === 91 ||
                        key === 92 ||
                        (key > 15 && key < 28) ||
                        (key > 32 && key < 41)) {
                        return;
                    }
                    var pattern = _this._pattern, char = ev.char;
                    if (!(pattern.test(char) && pattern.test(input.value + char))) {
                        ev.preventDefault();
                        return;
                    }
                    postponedEventListener();
                }, false);
                this.addEventListener(input, 'cut', postponedEventListener, false);
                this.addEventListener(input, 'paste', postponedEventListener, false);
            }
            this.addEventListener(input, 'change', eventListener, false);
        };
        /**
         * The event handler upon user text input.
         */
        Input.prototype._onInput = function () {
            var element = this.element, value = element.value, strippedValue = this._stripInput(element.value);
            if (value !== strippedValue) {
                value = element.value = strippedValue;
            }
            if (value === this.value) {
                return;
            }
            this.value = element.value;
            this.inputChanged(this.value);
        };
        /**
         * The event handler upon bound text being changed.
         * @param {string} newValue The new value of the bound text.
         */
        Input.prototype._onInputChanged = function (newValue) {
            var element = this.element;
            newValue = this._stripInput(newValue);
            element.value = newValue;
            this.value = element.value;
        };
        /**
         * Parses the input and strips it of characters that don't fit its pattern.
         * @param {string} value The current value to parse.
         */
        Input.prototype._stripInput = function (value) {
            var newValue = '', revert = newValue, char, pattern = this._pattern, length = value.length;
            for (var i = 0; i < length; ++i) {
                char = value[i];
                if (pattern.test(char)) {
                    newValue += char;
                    if (pattern.test(newValue)) {
                        revert = newValue;
                    }
                    else {
                        newValue = revert;
                    }
                }
            }
            return newValue;
        };
        Input._inject = {
            _compat: __Compat,
            _regex: __Regex
        };
        return Input;
    }(plat.ui.BindControl));
    platui.Input = Input;
    plat.register.control(__Input, Input);
    /**
     * An BindControl that standardizes and styles
     * an HTML input[type="file"] element.
     */
    var File = (function (_super) {
        __extends(File, _super);
        function File() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-file-container">\n' +
                '    <input type="file" class="plat-file-hidden" />\n' +
                '    <input type="text" class="plat-file-input" plat-keydown="_onKeyDown" />\n' +
                '    <button class="plat-file-button" plat-tap="_selectFiles"></button>\n' +
                '</div>\n';
            /**
             * A function for removing the 'change' event listener.
             */
            this._removeListener = noop;
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        File.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __File + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        File.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set all HTMLElement references and potential attribute controls.
         */
        File.prototype.setTemplate = function () {
            var element = this.element, hiddenInput = this._hiddenInput = element.firstElementChild.firstElementChild, visibleInput = this._visibleInput = hiddenInput.nextElementSibling, buttonInput = visibleInput.nextElementSibling, attributes = this.attributes, keys = Object.keys(attributes), length = keys.length, controlInjectors = plat.dependency.injectors.control, attrRegex = /plat-(?:control|hide|context)|class|style/, hasMultiple = false, utils = this.utils, isNull = utils.isNull, delimit = utils.delimit, isString = utils.isString, key, name, value;
            for (var i = 0; i < length; ++i) {
                key = keys[i];
                name = delimit(key, '-');
                value = attributes[key];
                if (!isString(value) || attrRegex.test(name) || !isNull(controlInjectors[name])) {
                    if (name === __Disabled) {
                        hiddenInput.setAttribute(name, value);
                        visibleInput.setAttribute(name, value);
                        buttonInput.setAttribute(name, value);
                    }
                    continue;
                }
                else if (name === 'id') {
                    element.removeAttribute(name);
                    hiddenInput.setAttribute(name, value);
                }
                else if (name === 'multiple') {
                    hasMultiple = true;
                    hiddenInput.setAttribute(name, value);
                }
                else if (name === 'disabled') {
                    hiddenInput.setAttribute(name, value);
                    visibleInput.setAttribute(name, value);
                    buttonInput.setAttribute(name, value);
                }
                else {
                    hiddenInput.setAttribute(name, value);
                }
            }
            if (isNull(this.innerTemplate)) {
                buttonInput.textContent = hasMultiple ? 'Select files' : 'Select a file';
                return;
            }
            var buttonText = this.innerTemplate.textContent.replace(/\r|\n/g, '');
            if (utils.isEmpty(buttonText)) {
                buttonInput.textContent = hasMultiple ? 'Select files' : 'Select a file';
                return;
            }
            buttonInput.textContent = buttonText;
        };
        /**
         * Set the style and initialize the action.
         */
        File.prototype.loaded = function () {
            var hiddenInput = this._hiddenInput = this._hiddenInput || this.element.firstElementChild.firstElementChild;
            this._visibleInput = this._visibleInput || hiddenInput.nextElementSibling;
            this._addChangeListener();
        };
        /**
         * A function to validate the user's input. Returns true if the input is not empty.
         */
        File.prototype.validate = function () {
            return !this.utils.isEmpty(this._hiddenInput.value);
        };
        /**
         * Clears the user's input.
         */
        File.prototype.clear = function () {
            var hiddenInput = this._hiddenInput;
            if (this.utils.isEmpty(hiddenInput.value)) {
                return;
            }
            hiddenInput.value = null;
            var clone = this._hiddenInput = hiddenInput.cloneNode(true);
            this.element.firstElementChild.replaceChild(clone, hiddenInput);
            this._addChangeListener();
            this._visibleInput.value = '';
            this.inputChanged(null);
            this._trigger('change');
        };
        /**
         * Acts as a programmatic click for file selection.
         */
        File.prototype.click = function () {
            this._selectFiles();
        };
        /**
         * Returns the current value of File control.
         */
        File.prototype.value = function () {
            var hiddenInput = this._hiddenInput, files = hiddenInput.files;
            if (this.utils.isNull(files)) {
                return;
            }
            else if (!hiddenInput.multiple) {
                return files[0];
            }
            return Array.prototype.slice.call(files);
        };
        /**
         * Disables the control.
         */
        File.prototype.disable = function () {
            var disabled = 'disabled', visibleInput = this._visibleInput;
            this._hiddenInput.setAttribute(disabled, disabled);
            visibleInput.setAttribute(disabled, disabled);
            visibleInput.nextElementSibling.setAttribute(disabled, disabled);
            this.element.setAttribute(disabled, disabled);
        };
        /**
         * Enables the control.
         */
        File.prototype.enable = function () {
            var disabled = 'disabled', visibleInput = this._visibleInput;
            this._hiddenInput.removeAttribute(disabled);
            visibleInput.removeAttribute(disabled);
            visibleInput.nextElementSibling.removeAttribute(disabled);
            this.element.removeAttribute(disabled);
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        File.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable text is set externally.
         * @param {any} newValue The new value of the bindable file(s).
         * @param {any} oldValue The old value of the bindable file(s).
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        File.prototype._setBoundProperty = function (newValue, oldValue, identifier, firstTime) {
            var utils = this.utils;
            if (!utils.isFile(newValue)) {
                this.clear();
                return;
            }
            var hiddenInput = this._hiddenInput, files = hiddenInput.files;
            if (utils.isNull(files)) {
                return;
            }
            if (!hiddenInput.multiple) {
                if (newValue !== files[0]) {
                    this.inputChanged(files[0]);
                    this._trigger('change');
                }
                return;
            }
            this.inputChanged(Array.prototype.slice.call(files));
            this._trigger('change');
        };
        /**
         * Adds the 'change' event listener to the hidden input[type=file].
         */
        File.prototype._addChangeListener = function () {
            this._removeListener();
            this._removeListener = this.addEventListener(this._hiddenInput, 'change', this._filesSelected, false);
        };
        /**
         * An event listener to handle a "keydown" event on the visible input.
         * @param {KeyboardEvent} ev The "keydown" event.
         */
        File.prototype._onKeyDown = function (ev) {
            var key = ev.keyCode, keyCodes = plat.controls.KeyCodes;
            if (key === keyCodes.tab) {
                return true;
            }
            else if (key === keyCodes.backspace || key === keyCodes.delete) {
                this.clear();
            }
            ev.preventDefault();
            return false;
        };
        /**
         * Kicks off the file selection process.
         */
        File.prototype._selectFiles = function () {
            this._hiddenInput.click();
        };
        /**
         * An event indicating that files have been selected.
         */
        File.prototype._filesSelected = function () {
            var hiddenInput = this._hiddenInput, visibleInput = this._visibleInput, files = hiddenInput.files;
            if (this.utils.isEmpty(files)) {
                this.clear();
                return;
            }
            else if (!hiddenInput.multiple) {
                var file = files[0];
                visibleInput.value = file.name;
                this.inputChanged(file);
            }
            else {
                var fileNames = [], length_1 = files.length;
                for (var i = 0; i < length_1; ++i) {
                    fileNames.push(files[i].name);
                }
                visibleInput.value = fileNames.join(', ');
                this.inputChanged(Array.prototype.slice.call(files));
            }
            this._trigger('change');
        };
        /**
         * Triggers an event starting from this control's element.
         * @param {string} event The event name to trigger.
         */
        File.prototype._trigger = function (event) {
            var domEvent = plat.acquire(__DomEventInstance);
            domEvent.initialize(this.element, event);
            domEvent.trigger();
        };
        File._inject = {
            _compat: __Compat
        };
        return File;
    }(plat.ui.BindControl));
    platui.File = File;
    plat.register.control(__File, File);
    /**
     * An extension of the ForEach that acts as a HTML template carousel
     * and can bind the selected index to a value.
     */
    var Carousel = (function (_super) {
        __extends(Carousel, _super);
        function Carousel() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-carousel-viewport">\n' +
                '    <div class="plat-carousel-container"></div>\n' +
                '</div>\n';
            /**
             * The set of functions added externally that listens
             * for property changes.
             */
            this._listeners = [];
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = false;
            /**
             * Whether or not the user has swiped.
             */
            this._hasSwiped = false;
            /**
             * Whether or not the user is currently touching the screen.
             */
            this._inTouch = false;
            /**
             * Whether or not the user is currently touching the screen and has moved.
             */
            this._hasMoved = false;
            /**
             * The last touch start recorded.
             */
            this._lastTouch = { x: 0, y: 0 };
            /**
             * Whether or not the control has been loaded based on its context being an Array.
             */
            this._loaded = false;
            /**
             * The current index seen in the Carousel.
             */
            this._index = -1;
            /**
             * The previous index of the Carousel in relation to the item nodes.
             */
            this._previousIndex = -1;
            /**
             * The next index of the Carousel in relation to the item nodes.
             */
            this._nextIndex = -1;
            /**
             * The current offset of the translated Carousel's sliding element.
             */
            this._currentOffset = 0;
            /**
             * The function used to clear the auto scroll interval.
             */
            this._removeInterval = noop;
            /**
             * The function used to clear the suspended auto scroll interval.
             */
            this._removeSuspend = noop;
            /**
             * Whether or not automatic scrolling is enabled.
             */
            this._isAuto = false;
            /**
             * Whether or not automatic scrolling is currently paused.
             */
            this._isPaused = false;
            /**
             * Whether or not the control is responsible for pausing itself.
             */
            this._selfPause = false;
            /**
             * An Array of all the current nodes in the control.
             */
            this._itemNodes = [];
            /**
             * A collection of remove listeners to stop listening for events.
             */
            this._removeListeners = [];
            /**
             * Whether or not the start outer item node has been initialized.
             */
            this._outerStart = false;
            /**
             * Whether or not the end outer item node has been initialized.
             */
            this._outerEnd = false;
            /**
             * An interval constant used to regulate the speed of the auto scroll
             * when the goToIndex function is called and is not direct.
             */
            this._goToIntervalConstant = 125;
        }
        Object.defineProperty(Carousel.prototype, "index", {
            /**
             * The current index of the Carousel.
             */
            get: function () {
                return this._index;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Carousel.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Carousel + " " + (className || ''));
        };
        /**
         * Checks if the control has been initialized, otherwise it does so.
         * @param {Array<any>} newValue The new array context.
         * @param {Array<any>} oldValue The old array context.
         */
        Carousel.prototype.contextChanged = function (newValue, oldValue) {
            var utils = this.utils;
            if (utils.isFunction(this._onLoad)) {
                if (utils.isArray(newValue)) {
                    this._setListener();
                }
                else {
                    this._log.debug(this.type + " context set to something other than an Array.");
                    newValue = [];
                }
                this._executeEvent([{
                        object: newValue,
                        type: 'splice'
                    }]);
                this._initializeIndex(0);
                return;
            }
            this.loaded();
        };
        /**
         * Set the class name.
         */
        Carousel.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Inserts the innerHTML of this control into a child ForEach control.
         */
        Carousel.prototype.setTemplate = function () {
            var itemContainer = this._document.createElement('div');
            itemContainer.className = __Carousel + "-item";
            itemContainer.appendChild(this.innerTemplate);
            this.bindableTemplates.add('item', itemContainer);
        };
        /**
         * Checks context and warns if not an Array, then initializes.
         */
        Carousel.prototype.loaded = function () {
            var _this = this;
            var utils = this.utils, context = this.context;
            if (!utils.isArray(context)) {
                this._log.warn("The context of a " + this.type + " must be an Array.");
                return;
            }
            // since we're extending the ForEach, we must set this animate to false as it refers to item manipulation. 
            this._animate = false;
            var optionObj = this.options || {}, options = optionObj.value || {}, index = options.index, isNumber = utils.isNumber, orientation = this._validateOrientation(options.orientation), interval = options.interval, intervalNum = this._interval = isNumber(interval) ? Math.abs(interval) : 3000, suspend = options.suspend, dom = this.dom, element = this.element, viewport = this._viewport = element.firstElementChild;
            this._container = viewport.firstElementChild;
            this._type = options.type || 'track swipe';
            this._isInfinite = options.infinite === true;
            this._suspend = Math.abs(isNumber(suspend) ? intervalNum - suspend : intervalNum - 3000);
            dom.addClass(element, __Plat + orientation);
            this._onLoad = function () {
                var setIndex = _this._index;
                index = isNumber(index) && index >= 0 ? index < context.length ? index : (context.length - 1) : null;
                _this._index = 0;
                dom.whenVisible(function () {
                    _this._initializeIndex(index === null ? setIndex : index);
                    _this._addEventListeners();
                    _this._loaded = true;
                }, element);
            };
            this._init();
        };
        /**
         * Advances the position of the Carousel to the next state.
         */
        Carousel.prototype.goToNext = function () {
            return this._goToNext(false);
        };
        /**
         * Changes the position of the Carousel to the previous state.
         */
        Carousel.prototype.goToPrevious = function () {
            return this._goToPrevious(false);
        };
        /**
         * Changes the position of the Carousel to the state
         * specified by the input index.
         * @param {number} index The new index of the Carousel.
         * @param {boolean} direct? If true, will go straight to the specified index without transitioning.
         */
        Carousel.prototype.goToIndex = function (index, direct) {
            return this._goToIndex(index, false, direct);
        };
        /**
         * Stops auto scrolling if auto scrolling is enabled.
         */
        Carousel.prototype.pause = function () {
            this._selfPause = false;
            if (!this._isAuto || this._isPaused) {
                return;
            }
            this._isPaused = true;
            this._removeSuspend();
            this._removeSuspend = noop;
            this._removeInterval();
            this._removeInterval = noop;
        };
        /**
         * Resumes auto scrolling if auto scrolling is enabled.
         */
        Carousel.prototype.resume = function () {
            if (!(this._isAuto && this._isPaused)) {
                return;
            }
            this._isPaused = this._selfPause = false;
            this._initiateInterval();
        };
        /**
         * Clean up the auto scroll interval if necessary.
         */
        Carousel.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._listeners = [];
            this._removeEventListeners();
        };
        /**
         * Adds a listener to be called when the bindable property changes.
         * @param {plat.IPropertyChangedListener<any>} listener The function that acts as a listener.
         */
        Carousel.prototype.onInput = function (listener) {
            var listeners = this._listeners;
            listeners.push(listener);
            return function () {
                var index = listeners.indexOf(listener);
                if (index === -1) {
                    return;
                }
                listeners.splice(index, 1);
            };
        };
        /**
         * A function that signifies when this control's bindable property has changed.
         * @param {any} newValue The new value of the property after the change.
         * @param {any} oldValue? The old value of the property prior to the change.
         */
        Carousel.prototype.inputChanged = function (newValue, oldValue) {
            if (newValue === oldValue) {
                return;
            }
            var listeners = this._listeners, length = listeners.length;
            for (var i = 0; i < length; ++i) {
                listeners[i](newValue, oldValue);
            }
        };
        /**
         * A function that allows this control to observe both the bound property itself as well as
         * potential child properties if being bound to an object.
         * @param {plat.observable.IImplementTwoWayBinding} binder The control that facilitates the
         * databinding.
         */
        Carousel.prototype.observeProperties = function (binder) {
            binder.observeProperty(this._setBoundProperty);
        };
        /**
         * The function called when the bindable index is set externally.
         * @param {number} index The new value of the bindable index.
         * @param {number} oldValue The old value of the bindable index.
         * @param {void} identifier The child identifier of the property being observed.
         * @param {boolean} firstTime? Whether or not this is the first call to bind the property.
         */
        Carousel.prototype._setBoundProperty = function (index, oldValue, identifier, firstTime) {
            var utils = this.utils;
            if (utils.isNull(index)) {
                if (firstTime === true) {
                    this._index = 0;
                    this.inputChanged(0, index);
                    return;
                }
            }
            else if (!utils.isNumber(index)) {
                index = Number(index);
                if (!utils.isNumber(index)) {
                    this._log.warn(this.type + " has its index bound to a property that cannot be interpreted as a Number.");
                    return;
                }
            }
            else if (index < 0) {
                this._index = 0;
                this.inputChanged(0, index);
                this._initializeIndex(0);
                return;
            }
            if (!this._loaded) {
                this._index = index;
                return;
            }
            this._goToIndex(index, true, firstTime === true);
        };
        /**
         * Resets the position of the Carousel to its current state.
         */
        Carousel.prototype._reset = function () {
            var animationOptions = {};
            animationOptions[this._transform] = this._calculateStaticTranslation(0);
            this._initiateAnimation({ properties: animationOptions });
        };
        /**
         * Verifies that the current length of the context aligns with the position of the Carousel.
         */
        Carousel.prototype._verifyLength = function () {
            var context = this.context, index = this._index;
            if (!this.utils.isArray(context) || context.length === 0) {
                if (!this.utils.isUndefined(index)) {
                    this.inputChanged((this._index = undefined), index);
                }
                this._container.style[this._transform] = this._calculateStaticTranslation(-this._currentOffset);
                this._removeEventListeners();
                this._checkArrows();
                return;
            }
            var maxIndex = context.length - 1;
            if (index > maxIndex) {
                this.goToIndex(maxIndex);
                return;
            }
            this._checkArrows();
        };
        /**
         * Sets the previous and next indices in relation to item nodes according to the current index.
         */
        Carousel.prototype._setIndexWindow = function () {
            var index = this._index, lastIndex = this._itemNodes.length - 1;
            if (lastIndex < 0) {
                this._previousIndex = this._nextIndex = lastIndex;
            }
            else if (index >= lastIndex) {
                if (index > lastIndex) {
                    index = this._index = lastIndex;
                }
                this._previousIndex = index - 1;
                this._nextIndex = this._isInfinite ? 0 : -1;
            }
            else if (index <= 0) {
                if (index < 0) {
                    index = this._index = 0;
                }
                this._previousIndex = this._isInfinite ? lastIndex : -1;
                this._nextIndex = index + 1;
            }
            else {
                this._previousIndex = index - 1;
                this._nextIndex = index + 1;
            }
        };
        /**
         * Advances the position of the Carousel to the next state.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         */
        Carousel.prototype._goToNext = function (inputChanged) {
            var _this = this;
            return this._Promise.all(this._addQueue).then(function () {
                var index = _this._index, reset = false;
                if ((index >= _this._itemNodes.length - 1) && !(reset = _this._isInfinite)) {
                    if (_this._isAuto && !_this._isPaused) {
                        _this.pause();
                        _this._selfPause = true;
                    }
                    return _this._Promise.resolve(false);
                }
                var length = _this._getLength();
                if (!length) {
                    return _this.goToIndex(_this._nextIndex, true);
                }
                return _this._cancelCurrentAnimations().then(function () {
                    if (!_this._outerEnd) {
                        _this._initializeOuterNodes();
                    }
                    var animationOptions = {};
                    animationOptions[_this._transform] = _this._calculateStaticTranslation(-length);
                    var animation = _this._initiateAnimation({ properties: animationOptions }), nextIndex;
                    if (reset) {
                        _this._index = nextIndex = 0;
                    }
                    else {
                        nextIndex = ++_this._index;
                    }
                    if (!inputChanged) {
                        _this.inputChanged(_this._index, index);
                    }
                    return animation.then(function () {
                        _this._handleNext(nextIndex, length);
                        _this._checkArrows();
                        return true;
                    });
                });
            });
        };
        /**
         * Changes the position of the Carousel to the previous state.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         */
        Carousel.prototype._goToPrevious = function (inputChanged) {
            var _this = this;
            return this._Promise.all(this._addQueue).then(function () {
                var index = _this._index, reset = false;
                if (index <= 0 && !(reset = _this._isInfinite)) {
                    return _this._Promise.resolve(false);
                }
                else if (_this._selfPause) {
                    _this.resume();
                }
                var length = _this._getLength();
                if (!length) {
                    return _this.goToIndex(_this._previousIndex, true);
                }
                return _this._cancelCurrentAnimations().then(function () {
                    if (!_this._outerStart) {
                        _this._initializeOuterNodes();
                    }
                    var animationOptions = {};
                    animationOptions[_this._transform] = _this._calculateStaticTranslation(length);
                    var animation = _this._initiateAnimation({ properties: animationOptions }), previousIndex;
                    if (reset) {
                        _this._index = previousIndex = _this._itemNodes.length - 1;
                    }
                    else {
                        previousIndex = --_this._index;
                    }
                    if (!inputChanged) {
                        _this.inputChanged(_this._index, index);
                    }
                    return animation.then(function () {
                        _this._handlePrevious(previousIndex, -length);
                        _this._checkArrows();
                        return true;
                    });
                });
            });
        };
        /**
         * Changes the position of the Carousel to the state
         * specified by the input index.
         * @param {number} index The new index of the Carousel.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         * @param {boolean} direct? If true, will go straight to the specified index without transitioning.
         */
        Carousel.prototype._goToIndex = function (index, inputChanged, direct) {
            var _this = this;
            return this._Promise.all(this._addQueue).then(function () {
                var oldIndex = _this._index;
                if (_this.utils.isUndefined(oldIndex)) {
                    _this._initializeIndex(0);
                    _this.inputChanged(_this._index, index);
                    if (!_this._isInfinite) {
                        if (index < _this.context.length - 1) {
                            if (_this._selfPause) {
                                _this.resume();
                            }
                        }
                        else if (_this._isAuto && !_this._isPaused) {
                            _this.pause();
                            _this._selfPause = true;
                        }
                    }
                    return _this._Promise.resolve(true);
                }
                else if (index === oldIndex) {
                    return _this._Promise.resolve(false);
                }
                else if (direct === true) {
                    _this._initializeIndex(index);
                    _this.inputChanged(_this._index, index);
                    if (!_this._isInfinite) {
                        if (index < _this.context.length - 1) {
                            if (_this._selfPause) {
                                _this.resume();
                            }
                        }
                        else if (_this._isAuto && !_this._isPaused) {
                            _this.pause();
                            _this._selfPause = true;
                        }
                    }
                    return _this._Promise.resolve(true);
                }
                else if (index - oldIndex > 0 && index === _this._nextIndex) {
                    return _this._goToNext(inputChanged);
                }
                else if (index === _this._previousIndex) {
                    return _this._goToPrevious(inputChanged);
                }
                return _this._handleGoToIndex(index, inputChanged);
            });
        };
        /**
         * Changes the position of the Carousel to the state
         * specified by the input index.
         * @param {number} index The new index of the Carousel.
         * @param {boolean} inputChanged Whether or not this was the result of a bound input change.
         */
        Carousel.prototype._handleGoToIndex = function (index, inputChanged) {
            var oldIndex = this._index;
            if (index === oldIndex || index < 0 || index >= this.context.length) {
                return this._Promise.resolve(false);
            }
            else if (this._selfPause) {
                this.resume();
            }
            if (!this._getLength()) {
                this._initializeIndex(index);
                return this._Promise.resolve(true);
            }
            var _Promise = this._Promise, defer = this.utils.defer, move, diff, reverseDiff;
            if (index > oldIndex) {
                move = this._goToNext;
                diff = index - oldIndex;
                if (this._isInfinite) {
                    reverseDiff = this._itemNodes.length - index + oldIndex;
                    if (reverseDiff < diff) {
                        move = this._goToPrevious;
                        diff = reverseDiff;
                    }
                }
            }
            else {
                move = this._goToPrevious;
                diff = oldIndex - index;
                if (this._isInfinite) {
                    reverseDiff = this._itemNodes.length - oldIndex + index;
                    if (reverseDiff < diff) {
                        move = this._goToNext;
                        diff = reverseDiff;
                    }
                }
            }
            move = move.bind(this);
            var promises = [], removeListeners = this._removeListeners, constant = this._goToIntervalConstant, interval = 0, mover = function (resolve) {
                var remove = defer(function () {
                    var removeIndex = removeListeners.indexOf(remove);
                    if (removeIndex !== -1) {
                        removeListeners.splice(removeIndex, 1);
                    }
                    resolve(move(inputChanged));
                }, interval += Math.round(constant / diff));
                removeListeners.push(remove);
            };
            while (--diff > 0) {
                promises.push(new _Promise(mover));
            }
            promises.push(move(inputChanged));
            return _Promise.all(promises).then(function (results) {
                var result = false;
                while (results.length > 0) {
                    result = result || results.pop();
                    if (result) {
                        break;
                    }
                }
                return result;
            });
        };
        /**
         * Handles swapping and translating nodes for a "next" operation.
         * @param {number} index The new index at the time of the animation.
         * @param {number} length The length to statically transition back to.
         */
        Carousel.prototype._handleNext = function (index, length) {
            var isInfinite = this._isInfinite, itemNodes = this._itemNodes, nodeLength = itemNodes.length, isNode = this.utils.isNode;
            if (isInfinite && (nodeLength < 3 || isNode(this._preClonedNode) || isNode(this._postClonedNode))) {
                this._initializeIndex(index);
                return;
            }
            var container = this._container;
            if (this._outerStart) {
                if (isInfinite || index > 1) {
                    this.dom.insertBefore(itemNodes[this._previousIndex], Array.prototype.slice.call(container.childNodes, 0, 3));
                    container.style[this._transform] = this._calculateStaticTranslation(length);
                    this._forceRepaint(container);
                }
            }
            else {
                this._outerStart = true;
            }
            this._setIndexWindow();
            if (!(isInfinite || index < nodeLength - 1)) {
                return;
            }
            container.insertBefore(itemNodes[this._nextIndex], null);
        };
        /**
         * Handles swapping and translating nodes for a "previous" operation.
         * @param {number} index The new index at the time of the animation.
         * @param {number} length The length to statically transition back to.
         */
        Carousel.prototype._handlePrevious = function (index, length) {
            var isInfinite = this._isInfinite, itemNodes = this._itemNodes, nodeLength = itemNodes.length, isNode = this.utils.isNode;
            if (isInfinite && (nodeLength < 3 || isNode(this._preClonedNode) || isNode(this._postClonedNode))) {
                this._initializeIndex(index);
                return;
            }
            var container = this._container;
            if (this._outerEnd) {
                if (isInfinite || index < nodeLength - 2) {
                    this.dom.insertBefore(itemNodes[this._nextIndex], Array.prototype.slice.call(container.childNodes, -3));
                }
            }
            else {
                this._outerEnd = true;
            }
            this._setIndexWindow();
            if (!(isInfinite || index > 0)) {
                return;
            }
            container.insertBefore(itemNodes[this._previousIndex], container.firstChild);
            container.style[this._transform] = this._calculateStaticTranslation(length);
            this._forceRepaint(container);
        };
        /**
         * Clears all the inner nodes of the control.
         */
        Carousel.prototype._clearInnerNodes = function () {
            this._removeClones();
            this._outerStart = this._outerEnd = false;
            var itemNodes = this._itemNodes;
            if (itemNodes.length === 0) {
                return false;
            }
            var childNodes = Array.prototype.slice.call(this._container.childNodes), insertBefore = this.dom.insertBefore;
            switch (childNodes.length) {
                case 9:
                    insertBefore(itemNodes[this._previousIndex], childNodes.splice(0, 3));
                    insertBefore(itemNodes[this._nextIndex], childNodes.splice(-3, 3));
                    insertBefore(itemNodes[this._index], childNodes);
                    break;
                case 6:
                    var next = this._nextIndex, index = this._index;
                    if (next < 0 || next === index) {
                        insertBefore(itemNodes[index], childNodes.splice(-3, 3));
                        insertBefore(itemNodes[index === 0 ? this._previousIndex + 1 : index - 1], childNodes);
                        break;
                    }
                    insertBefore(itemNodes[next], childNodes.splice(-3, 3));
                    insertBefore(itemNodes[index], childNodes);
                    break;
                case 3:
                    insertBefore(itemNodes[this._index], childNodes);
                    break;
            }
            return true;
        };
        /**
         * Initializes item nodes at the given index.
         * @param {number} index The new index at the time of the animation.
         */
        Carousel.prototype._initializeIndex = function (index) {
            var innerNodesCleared = this._clearInnerNodes();
            if (this._itemNodes.length === 0) {
                index = -1;
            }
            else if (index < 0) {
                index = 0;
            }
            this._index = index;
            this._setIndexWindow();
            if (!innerNodesCleared) {
                return false;
            }
            var container = this._container;
            container.insertBefore(this._itemNodes[index], null);
            container.style[this._transform] = this._calculateStaticTranslation(-this._currentOffset);
            this._forceRepaint(container);
            this._initializeOuterNodes();
            this._checkArrows();
            return true;
        };
        /**
         * Initializes pre and post item nodes for the current index.
         */
        Carousel.prototype._initializeOuterNodes = function () {
            var length = this._getLength();
            if (!length) {
                this._outerStart = this._outerEnd = false;
                return;
            }
            var itemNodes = this._itemNodes, container = this._container, nodeLength = itemNodes.length, nodeToInsert;
            if (nodeLength <= 1) {
                if (this._isInfinite) {
                    this._cloneForInfinite(-length);
                    return;
                }
            }
            else {
                var isNode = this.utils.isNode;
                if (!this._outerEnd) {
                    nodeToInsert = itemNodes[this._nextIndex];
                    if (isNode(nodeToInsert)) {
                        container.insertBefore(nodeToInsert, null);
                        this._outerEnd = true;
                    }
                }
                if (nodeLength > 2) {
                    if (!this._outerStart && (this._isInfinite || this._index > 0)) {
                        nodeToInsert = itemNodes[this._previousIndex];
                        if (isNode(nodeToInsert)) {
                            container.insertBefore(nodeToInsert, container.firstChild);
                            container.style[this._transform] = this._calculateStaticTranslation(-length);
                            this._forceRepaint(container);
                            this._outerStart = true;
                        }
                    }
                }
                else if (this._isInfinite) {
                    this._cloneForInfinite(-length);
                }
            }
        };
        /**
         * Animates the carousel with a set of characteristics passed in as an argument.
         * @param {plat.IObject<string>} animationOptions An object containing key-value pairs
         * of properties to animate.
         */
        Carousel.prototype._initiateAnimation = function (animationOptions) {
            return this._animationThenable =
                this._animator.animate(this._container, __Transition, animationOptions);
        };
        /**
         * Initializes the control and adds all event listeners.
         */
        Carousel.prototype._init = function () {
            var _this = this;
            var addQueue = this._addQueue, itemCount = this.context.length;
            this._setAliases();
            var addPromise = this._addItems(0, itemCount, 0).then(function () {
                var index = addQueue.indexOf(addPromise);
                if (index !== -1) {
                    addQueue.splice(index, 1);
                }
                _this._onLoad();
            }).catch(function () {
                _this._log.debug("An error occurred while processing the " + _this.type + ". Please ensure you're context is correct.");
                _this._loaded = false;
                return;
            });
            addQueue.push(addPromise);
            this._setListener();
            this._setTransform();
        };
        /**
         * Adds all event listeners on this control's element.
         */
        Carousel.prototype._addEventListeners = function () {
            var _this = this;
            var types = this._type.split(' ');
            if (types.indexOf('tap') !== -1) {
                this._initializeTap();
            }
            if (types.indexOf('swipe') !== -1) {
                this._initializeSwipe();
            }
            if (types.indexOf('track') !== -1) {
                this._initializeTrack();
            }
            if (types.indexOf('auto') !== -1) {
                this._initializeAuto();
            }
            var fired = false;
            this.addEventListener(this._window, 'resize', function () {
                if (fired) {
                    return;
                }
                fired = true;
                _this.utils.requestAnimationFrame(function () {
                    fired = false;
                    var currentLength = _this._length, length = _this._getLength();
                    if (!length || currentLength === length || (!_this._isInfinite && _this._index === 0)) {
                        return;
                    }
                    _this._container.style[_this._transform] = _this._calculateStaticTranslation(currentLength - length);
                });
            }, false);
        };
        /**
         * Removes all event listeners on this control's element.
         */
        Carousel.prototype._removeEventListeners = function () {
            var removeListeners = this._removeListeners;
            while (removeListeners.length > 0) {
                removeListeners.pop()();
            }
            this._removeInterval();
            this._removeSuspend();
            if (this._isInfinite) {
                this._removeClones();
            }
            this._onLoad = noop;
        };
        /**
         * Create the clones case where item length is less than 3.
         * @param {number} length The length to translate the offset clone.
         */
        Carousel.prototype._cloneForInfinite = function (length) {
            this._removeClones();
            var context = this.context;
            if (!this.utils.isArray(context) || context.length === 0) {
                return;
            }
            var outerStart = this._outerStart, outerEnd = this._outerEnd;
            if (outerStart && outerEnd) {
                return;
            }
            var container = this._container;
            if (!outerEnd) {
                var postClone = this._postClonedNode = container.firstElementChild.cloneNode(true);
                container.insertBefore(postClone, null);
                this._outerEnd = true;
            }
            if (!outerStart) {
                var preClone = this._preClonedNode = container.lastElementChild.cloneNode(true);
                container.insertBefore(preClone, container.firstChild);
                container.style[this._transform] = this._calculateStaticTranslation(length);
                this._forceRepaint(container);
                this._outerStart = true;
            }
        };
        /**
         * Removes the clones for infinite scrolling.
         */
        Carousel.prototype._removeClones = function () {
            var container = this._container, preClone = this._preClonedNode, postClone = this._postClonedNode, isNode = this.utils.isNode;
            if (isNode(preClone) && container.contains(preClone)) {
                container.removeChild(preClone);
            }
            if (isNode(postClone) && container.contains(postClone)) {
                container.removeChild(postClone);
            }
            this._preClonedNode = this._postClonedNode = null;
        };
        /**
         * Adds all necessary elements and event listeners to setup auto scroll.
         */
        Carousel.prototype._initializeAuto = function () {
            this._isAuto = true;
            this._initiateInterval();
        };
        /**
         * Begins auto scrolling.
         */
        Carousel.prototype._initiateInterval = function () {
            this._removeInterval = this.utils.setInterval(this.goToNext, this._interval, null, this);
        };
        /**
         * Checks for automatic scrolling and suspends if necessary.
         */
        Carousel.prototype._suspendInterval = function () {
            var _this = this;
            if (!this._isAuto || this._isPaused) {
                return;
            }
            this._removeSuspend();
            this._removeInterval();
            this._removeSuspend = this.utils.defer(function () {
                _this._initiateInterval();
                _this._removeSuspend = noop;
            }, this._suspend);
        };
        /**
         * Adds all necessary elements and event listeners to handle tap events.
         */
        Carousel.prototype._initializeTap = function () {
            var _this = this;
            if (!this.utils.isNode(this._forwardArrow)) {
                this._createArrowElements();
            }
            var removeListeners = this._removeListeners;
            removeListeners.push(this.addEventListener(this._backArrow, __$tap, function () {
                _this._suspendInterval();
                _this.goToPrevious();
            }, false));
            removeListeners.push(this.addEventListener(this._forwardArrow, __$tap, function () {
                _this._suspendInterval();
                _this.goToNext();
            }, false));
            this._checkArrows();
        };
        /**
         * Creates the arrow elements for type `tap` and places them in the DOM.
         */
        Carousel.prototype._createArrowElements = function () {
            var _document = this._document, viewport = this._viewport, backArrowContainer = this._backArrow = _document.createElement('div'), forwardArrowContainer = this._forwardArrow = _document.createElement('div'), backArrow = _document.createElement('span'), forwardArrow = _document.createElement('span');
            if (this._isVertical) {
                backArrow.className = __Plat + "icon-arrow-up";
                forwardArrow.className = __Plat + "icon-arrow-down";
            }
            else {
                backArrow.className = __Plat + "icon-arrow-left";
                forwardArrow.className = __Plat + "icon-arrow-right";
            }
            backArrowContainer.className = __Plat + "back-arrow";
            forwardArrowContainer.className = __Plat + "forward-arrow";
            backArrowContainer.appendChild(backArrow);
            forwardArrowContainer.appendChild(forwardArrow);
            viewport.appendChild(backArrowContainer);
            viewport.appendChild(forwardArrowContainer);
        };
        /**
         * Checks the validity of the visibility of the forward and back arrows.
         */
        Carousel.prototype._checkArrows = function () {
            var utils = this.utils, isNode = utils.isNode;
            if (this._isInfinite || !(isNode(this._forwardArrow) && isNode(this._backArrow))) {
                return;
            }
            var contextLength = this.context.length, index = this._index;
            if (utils.isNull(index)) {
                this._backArrow.setAttribute(__Hide, '');
                this._forwardArrow.setAttribute(__Hide, '');
                return;
            }
            if (index <= 0) {
                this._backArrow.setAttribute(__Hide, '');
            }
            else {
                this._backArrow.removeAttribute(__Hide);
            }
            if (index >= contextLength - 1) {
                this._forwardArrow.setAttribute(__Hide, '');
            }
            else {
                this._forwardArrow.removeAttribute(__Hide);
            }
        };
        /**
         * Adds all event listeners to handle swipe events.
         */
        Carousel.prototype._initializeSwipe = function () {
            var container = this._viewport, swipeFn = this._handleSwipe, swipe, reverseSwipe;
            if (this._isVertical) {
                swipe = __$swipe + "up";
                reverseSwipe = __$swipe + "down";
            }
            else {
                swipe = __$swipe + "left";
                reverseSwipe = __$swipe + "right";
            }
            var removeListeners = this._removeListeners;
            removeListeners.push(this.addEventListener(container, swipe, swipeFn, false));
            removeListeners.push(this.addEventListener(container, reverseSwipe, swipeFn, false));
        };
        /**
         * Adds all event listeners to handle tracking events.
         */
        Carousel.prototype._initializeTrack = function () {
            var viewport = this._viewport, trackFn = this._track, touchEnd = this._touchEnd, track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "up";
                reverseTrack = __$track + "down";
            }
            else {
                track = __$track + "left";
                reverseTrack = __$track + "right";
            }
            var removeListeners = this._removeListeners;
            removeListeners.push(this.addEventListener(viewport, track, trackFn, false));
            removeListeners.push(this.addEventListener(viewport, reverseTrack, trackFn, false));
            removeListeners.push(this.addEventListener(viewport, __$touchstart, this._touchStart, false));
            removeListeners.push(this.addEventListener(viewport, __$trackend, touchEnd, false));
            removeListeners.push(this.addEventListener(viewport, __$touchend, touchEnd, false));
        };
        /**
         * Handles a swipe event.
         */
        Carousel.prototype._handleSwipe = function (ev) {
            var direction = ev.direction.primary, hasSwiped = false;
            switch (direction) {
                case 'left':
                    if (!this._isVertical && (this._isInfinite || this._index < this.context.length - 1)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToNext();
                    }
                    break;
                case 'right':
                    if (!this._isVertical && (this._isInfinite || this._index > 0)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToPrevious();
                    }
                    break;
                case 'up':
                    if (this._isVertical && (this._isInfinite || this._index < this.context.length - 1)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToNext();
                    }
                    break;
                case 'down':
                    if (this._isVertical && (this._isInfinite || this._index > 0)) {
                        this._suspendInterval();
                        hasSwiped = true;
                        this.goToPrevious();
                    }
                    break;
                default:
                    return;
            }
            this._hasSwiped = hasSwiped;
        };
        /**
         * Log when the user touches the Carousel.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        Carousel.prototype._touchStart = function (ev) {
            if (this._inTouch) {
                return;
            }
            else if (this._isAuto) {
                this._removeInterval();
                this._removeInterval = noop;
            }
            this._inTouch = true;
            this._hasMoved = false;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY
            };
        };
        /**
         * The $touchend and $trackend event handler.
         * @param {plat.ui.IGestureEvent} ev The touch event.
         */
        Carousel.prototype._touchEnd = function (ev) {
            var _this = this;
            var inTouch = this._inTouch, hasMoved = this._hasMoved, hasSwiped = this._hasSwiped;
            this._inTouch = this._hasSwiped = this._hasMoved = false;
            if (!inTouch || hasSwiped) {
                return;
            }
            else if (this._isAuto && !this._isPaused) {
                this._initiateInterval();
            }
            if (!hasMoved) {
                return;
            }
            var distanceMoved = this._isVertical ? (ev.clientY - this._lastTouch.y) : (ev.clientX - this._lastTouch.x), length = this._getLength();
            if (!length) {
                this._reset();
                return;
            }
            else if (Math.abs(distanceMoved) > Math.ceil(length / 2)) {
                if (distanceMoved < 0) {
                    this.goToNext().then(function (success) {
                        if (!success) {
                            _this._reset();
                        }
                    });
                    return;
                }
                this.goToPrevious().then(function (success) {
                    if (!success) {
                        _this._reset();
                    }
                });
                return;
            }
            this._reset();
        };
        /**
         * The $track event handler. Used for tracking only horizontal or vertical tracking motions
         * depending on the defined orientation.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        Carousel.prototype._track = function (ev) {
            var _this = this;
            if (!this._inTouch) {
                return;
            }
            else if (!this._hasMoved) {
                this._cancelCurrentAnimations().then(function () {
                    if (!(_this._outerStart && _this._outerEnd)) {
                        _this._initializeOuterNodes();
                    }
                });
            }
            this._hasMoved = true;
            this.utils.requestAnimationFrame(function () {
                var translation = _this._calculateDynamicTranslation(ev);
                if (translation === null) {
                    return;
                }
                _this._container.style[_this._transform] = translation;
            });
        };
        /**
         * Calculates the translation value for setting the transform value during a static index set.
         * @param {number} interval The interval change.
         */
        Carousel.prototype._calculateStaticTranslation = function (interval) {
            return this._isVertical ? "translate3d(0," + (this._currentOffset += interval) + "px,0)" :
                "translate3d(" + (this._currentOffset += interval) + "px,0,0)";
        };
        /**
         * Calculates the translation value for setting the transform value during tracking.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         */
        Carousel.prototype._calculateDynamicTranslation = function (ev) {
            var offset;
            if (this._isVertical) {
                offset = ev.clientY - this._lastTouch.y;
                if (Math.abs(offset) > this._getLength()) {
                    this._touchEnd(ev);
                    return null;
                }
                return "translate3d(0," + (this._currentOffset + offset) + "px,0)";
            }
            offset = ev.clientX - this._lastTouch.x;
            if (Math.abs(offset) > this._getLength()) {
                this._touchEnd(ev);
                return null;
            }
            return "translate3d(" + (this._currentOffset + offset) + "px,0,0)";
        };
        /**
         * Obtains the current browser's transform property value.
         */
        Carousel.prototype._setTransform = function () {
            var style = this._container.style, isUndefined = this.utils.isUndefined;
            var vendorPrefix = this._compat.vendorPrefix;
            if (!isUndefined(style[(vendorPrefix.lowerCase + "Transform")])) {
                this._transform = vendorPrefix.lowerCase + "Transform";
            }
            else if (!isUndefined(style[(vendorPrefix.upperCase + "Transform")])) {
                this._transform = vendorPrefix.upperCase + "Transform";
            }
            else {
                this._transform = 'transform';
            }
        };
        /**
         * Gets the interval length of the sliding container.
         */
        Carousel.prototype._getLength = function () {
            return this._length = (this._isVertical ? this._viewport.offsetHeight : this._viewport.offsetWidth);
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Carousel.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'horizontal';
            }
            var validOrientation;
            if (orientation === 'horizontal') {
                validOrientation = orientation;
            }
            else if (orientation === 'vertical') {
                validOrientation = orientation;
                this._isVertical = true;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"horizontal.\"");
                validOrientation = 'horizontal';
            }
            return validOrientation;
        };
        /**
         * Adds an Array of items to the element without animating.
         * @param {Array<Node>} items The Array of items to add.
         */
        Carousel.prototype._appendItems = function (items) {
            this._itemNodes = this._itemNodes.concat(items);
            if (this._loaded) {
                var index = this._index;
                // if no remove listeners exist we know that we had previously removed them. 
                if (this._removeListeners.length === 0) {
                    this._addEventListeners();
                    this._initializeIndex(0);
                    this.inputChanged(0, index);
                    return;
                }
                if (index >= this._itemNodes.length - 2) {
                    this._initializeIndex(index);
                }
            }
        };
        /**
         * Removes items from the control's element.
         * @param {number} index The index to start disposing from.
         * @param {number} numberOfItems The number of items to remove.
         */
        Carousel.prototype._removeItems = function (index, numberOfItems) {
            var dispose = this._TemplateControlFactory.dispose, controls = this.controls, itemNodes = this._itemNodes, last = index + numberOfItems;
            while (last-- > index) {
                dispose(controls[last]);
                itemNodes.pop();
            }
            this._updateResource(controls.length - 1);
            this._verifyLength();
        };
        /**
         * Cancels the current animation.
         */
        Carousel.prototype._cancelCurrentAnimations = function () {
            if (this.utils.isNull(this._animationThenable)) {
                return this._Promise.resolve();
            }
            return this._animationThenable.cancel();
        };
        /**
         * Forces a repaint / reflow.
         * @param {HTMLElement} element The element to force the repaint / reflow on.
         */
        Carousel.prototype._forceRepaint = function (element) {
            var style = element.style, display = style.display, none = 'none';
            if (style.display === none) {
                element.offsetWidth;
                return;
            }
            style.display = none;
            element.offsetWidth;
            style.display = display;
        };
        Carousel._inject = {
            _document: __Document,
            _window: __Window,
            _compat: __Compat,
            _TemplateControlFactory: __TemplateControlFactory
        };
        return Carousel;
    }(plat.ui.controls.ForEach));
    platui.Carousel = Carousel;
    plat.register.control(__Carousel, Carousel);
    /**
     * An ITemplateControl for creating a complex list of items with
     * extensive functionality.
     */
    var Listview = (function (_super) {
        __extends(Listview, _super);
        /**
         * The constructor for a Listview. Creates the itemsLoaded Promise.
         */
        function Listview() {
            var _this = this;
            _super.call(this);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = this.__templateString;
            /**
             * Used to hold the alias tokens for the built-in aliases. You
             * can overwrite these with the options for
             * the Listview control.
             */
            this._aliases = {
                index: __listviewAliasOptions.index,
                even: __listviewAliasOptions.even,
                odd: __listviewAliasOptions.odd,
                first: __listviewAliasOptions.first,
                last: __listviewAliasOptions.last,
                group: __listviewAliasOptions.group
            };
            /**
             * An object containing the node names of the Listview's defined templates and
             * their corresponding template node.
             */
            this._templates = {};
            /**
             * Whether the control is vertical or horizontal.
             */
            this._isVertical = true;
            /**
             * Whether or not the scroll function is ready to be handled.
             */
            this._scrollReady = true;
            /**
             * Whether or not the user is currently performing a load operation.
             */
            this._isLoading = false;
            /**
             * The current scroll position of the container.
             */
            this._scrollPosition = 0;
            /**
             * A function that removes the scroll event listener.
             */
            this._removeScroll = noop;
            /**
             * Whether or not the user is currently performing a refresh operation.
             */
            this._isRefreshing = false;
            /**
             * An enumeration value signifying the current touch state.
             */
            this._touchState = 0;
            /**
             * Whether the user is tracking in a fashion that attempts to refresh the list.
             */
            this._hasMoved = false;
            /**
             * The last touch start recorded.
             */
            this._lastTouch = { x: 0, y: 0 };
            /**
             * A regular expression for normalizing a node name by removing potential special characters.
             */
            this._nodeNormalizeRegex = /-|\.|_/g;
            /**
             * Whether or not the select is grouped.
             */
            this._isGrouped = false;
            /**
             * A set of functions to remove all visibility listeners.
             */
            this._visibilityRemoveListeners = [];
            /**
             * The private template string used to check for a template overwrite.
             */
            this.__templateString = '<div class="plat-listview-viewport">\n' +
                '    <div class="plat-scroll-container">\n' +
                '        <div class="plat-listview-container"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * Whether or not the main Array listener has been set.
             */
            this.__listenerSet = false;
            this.itemsLoaded = new this._Promise(function (resolve, reject) {
                _this.__resolveFn = resolve;
                _this.__rejectFn = reject;
            }).catch(noop);
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Listview.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Listview + " " + (className || ''));
        };
        /**
         * Check for templateUrl and set if needed.
         */
        Listview.prototype.initialize = function () {
            var optionObj = this.options || (this.options = {}), options = optionObj.value || (optionObj.value = {});
            this.templateUrl = options.templateUrl || this.templateUrl;
            this.setClasses();
        };
        /**
         * Parse the innerTemplate and add it to the control's element.
         */
        Listview.prototype.setTemplate = function () {
            if (this.templateString !== this.__templateString || this.utils.isString(this.templateUrl)) {
                var fragment = this.dom.serializeHtml(this.__templateString), element = this.element;
                this.innerTemplate = this.dom.appendChildren(element.childNodes);
                element.appendChild(fragment);
            }
        };
        /**
         * Re-syncs the Listview child controls and DOM with the new
         * array.
         * @param {Array<any>} newValue? The new Array
         * @param {Array<any>} oldValue? The old Array
         */
        Listview.prototype.contextChanged = function (newValue, oldValue) {
            if (this.utils.isArray(newValue)) {
                this._setListener();
            }
            else {
                this._log.debug(this.type + " context set to something other than an Array.");
                newValue = [];
            }
            this._executeEvent([{
                    object: newValue,
                    type: 'splice'
                }]);
        };
        /**
         * Determine item templates and kick off rendering.
         */
        Listview.prototype.loaded = function () {
            var options = this.options.value, utils = this.utils, isString = utils.isString, element = this.element, viewport = this._viewport = element.firstElementChild, scrollContainer = this._scrollContainer = viewport.firstElementChild, loading = this._loading = options.loading, animate = this._animate = options.animate === true, requestItems = options.onItemsRequested, refresh = options.onRefresh, itemTemplate = options.itemTemplate, scrollElement = options.scrollElement;
            this._container = scrollContainer.firstElementChild;
            this.dom.addClass(element, __Plat + this._validateOrientation(options.orientation) +
                (animate ? (" " + __Plat + "animated") : ''));
            if (isString(scrollElement)) {
                scrollElement = this._document.querySelector(scrollElement);
            }
            if (utils.isNode(scrollElement)) {
                this._scrollContainer = scrollElement;
                this.dom.addClass(element, __Plat + "no-scroller");
            }
            if (!isString(itemTemplate)) {
                this._log.debug("No item template or item template selector specified for " + this.type + ".");
                return;
            }
            var normalizedItemTemplate = this._normalizeTemplateName(itemTemplate), headerTemplate = options.headerTemplate, normalizedGroupTemplate = isString(headerTemplate) ? this._normalizeTemplateName(headerTemplate) : null;
            this._parseInnerTemplate(normalizedItemTemplate, normalizedGroupTemplate);
            this._determineTemplates(itemTemplate, normalizedItemTemplate, normalizedGroupTemplate);
            this._defaultGroup = {
                name: null,
                control: this,
                itemContainer: this._container,
                element: element,
                index: null,
                itemCount: 0,
                addQueue: [],
                animationQueue: []
            };
            var isRefreshing = false;
            if (isString(loading)) {
                if (isString(requestItems)) {
                    this._determineLoading(requestItems, options.infiniteProgress !== false);
                }
                else {
                    this._log.debug(this.type + " loading type specified as \"" + loading + "\" but no option specifying an onItemsRequested handler.");
                }
            }
            if (isString(refresh)) {
                isRefreshing = true;
                this._initializeRefresh(refresh);
            }
            this._initializeTracking(loading === 'incremental', isRefreshing);
            if (!utils.isArray(this.context)) {
                if (!utils.isNull(this.context)) {
                    this._log.debug(this.type + "'s context must be an Array.");
                }
                return;
            }
            this._setAliases();
            this._setContainerHeight();
            this.render();
            this._setListener();
        };
        /**
         * Removes any potentially held memory.
         */
        Listview.prototype.dispose = function () {
            var visibilityRemovers = this._visibilityRemoveListeners;
            while (visibilityRemovers.length > 0) {
                visibilityRemovers.pop()();
            }
            this._removeScroll();
            if (this.utils.isFunction(this.__rejectFn)) {
                this.__rejectFn();
                this.__resolveFn = this.__rejectFn = null;
            }
        };
        /**
         * Blow out the DOM starting at the index, determine how to render, and render the count accordingly.
         * @param {number} index? The starting index to render. If not specified, it will start at currentCount.
         * @param {number} count? The number of items to render. If not specified, the whole context
         * from the specified index will be rendered.
         * @param {platui.IGroupHash} group? The group we're rendering.
         */
        Listview.prototype.render = function (index, count, group) {
            var isNumber = this.utils.isNumber, opGroup = group || this._defaultGroup, control = opGroup.control, context = this === control ? this.context : control.context.items;
            if (!isNumber(index)) {
                index = 0;
            }
            var maxCount = context.length - index, itemCount = isNumber(count) && maxCount >= count ? count : maxCount;
            this._createItems(index, itemCount, opGroup, 0);
        };
        /**
         * Blow out all the DOM, determine how to render, and render accordingly.
         * @param {platui.IGroupHash} group? The group we're rerendering.
         */
        Listview.prototype.rerender = function (group) {
            this.render(0, null, group);
        };
        /**
         * Re-syncs the Listview child items and DOM with the new items
         * array.
         * @param {string} groupName The group name of the currently changing Array.
         * @param {any} newValue? The new child array of items
         * @param {any} oldValue? The old child array of items
         */
        Listview.prototype._childContextChanged = function (groupName, newValue, oldValue) {
            this._executeChildEvent(groupName, [{
                    object: newValue || [],
                    type: 'splice'
                }]);
        };
        /**
         * Sets a listener for the changes to the array.
         */
        Listview.prototype._setListener = function () {
            if (!this.__listenerSet) {
                this.observeArray(this._executeEvent);
                this.__listenerSet = true;
            }
        };
        /**
         * Sets the alias tokens to use for all the items in the Listview context array.
         */
        Listview.prototype._setAliases = function () {
            var aliases = this.options.value.aliases, utils = this.utils;
            if (!utils.isObject(aliases)) {
                return;
            }
            var _aliases = this._aliases, isString = utils.isString, keys = Object.keys(_aliases), length = keys.length, value;
            for (var i = 0; i < length; ++i) {
                value = aliases[keys[i]];
                if (isString(value)) {
                    _aliases[keys[i]] = value;
                }
            }
        };
        /**
         * Determine the proper item template or method of item template selection.
         * @param {string} itemTemplate The pre-normalized property for indicating either the item template or the
         * item template selector.
         * @param {string} itemTemplateKey The normalized property for indicating the item template.
         * @param {string} headerTemplate The property for indicating the group header template.
         */
        Listview.prototype._determineTemplates = function (itemTemplate, itemTemplateKey, headerTemplate) {
            var utils = this.utils, bindableTemplates = this.bindableTemplates, templates = this._templates, template;
            if (utils.isString(headerTemplate)) {
                this._isGrouped = true;
                this.dom.addClass(this._container, __Plat + "grouped");
                template = templates[headerTemplate];
                if (utils.isNode(template)) {
                    this._headerTemplate = headerTemplate;
                    this.bindableTemplates.add(headerTemplate, template);
                    delete templates[headerTemplate];
                }
                else {
                    this._log.debug(__Listview + " group header template \"" + headerTemplate + "\" was not a template defined in the DOM.");
                }
                this._headerTemplatePromise = this._createGroupTemplate();
            }
            template = templates[itemTemplateKey];
            if (utils.isNode(template)) {
                this._itemTemplate = itemTemplateKey;
                this.bindableTemplates.add(itemTemplateKey, template);
                delete templates[itemTemplateKey];
                return;
            }
            var controlProperty = this.findProperty(itemTemplate) || {};
            if (!utils.isFunction(controlProperty.value)) {
                this._log.debug(__Listview + " item template \"" + itemTemplate + "\" was neither a template defined in the DOM nor a template selector function in its control hiearchy.");
                return;
            }
            this._templateSelector = controlProperty.value.bind(controlProperty.control);
            this._templateSelectorKeys = {};
            var keys = Object.keys(templates), key;
            while (keys.length > 0) {
                key = keys.pop();
                bindableTemplates.add(key, templates[key]);
                delete templates[key];
            }
        };
        /**
         * Construct the group template and add it to bindable templates.
         */
        Listview.prototype._createGroupTemplate = function () {
            var _this = this;
            var _document = this._document, bindableTemplates = this.bindableTemplates, headerTemplate = this._headerTemplate, listviewGroup = __Listview + "-group", group = _document.createElement('div'), itemContainer = _document.createElement('div'), headerPromise;
            group.className = listviewGroup;
            itemContainer.className = __Listview + "-items";
            if (this.utils.isString(headerTemplate)) {
                headerPromise = bindableTemplates.templates[headerTemplate].then(function (headerTemplate) {
                    group.insertBefore(headerTemplate.cloneNode(true), null);
                });
            }
            return this._Promise.resolve(headerPromise).then(function () {
                group.insertBefore(itemContainer, null);
                bindableTemplates.add(listviewGroup, group);
            }).then(null, function (error) {
                _this._log.debug(_this.type + " error: " + error);
            });
        };
        /**
         * Adds new groups to the control's element when items are added to
         * the context.
         * @param {number} numberOfGroups The number of groups to add.
         * @param {number} index The point in the array to start adding groups.
         * @param {number} animateItems The number of groups to animate.
         */
        Listview.prototype._addGroups = function (numberOfGroups, index, animateItems) {
            var _this = this;
            var initialIndex = index, max = +(index + numberOfGroups), promises = [];
            while (index < max) {
                promises.push(this._bindGroup(index++));
            }
            return this._Promise.all(promises).then(function (fragments) {
                var length = fragments.length;
                for (var i = 0; i < length; ++i) {
                    _this._addGroup(i + initialIndex, fragments[i], i < animateItems);
                }
            });
        };
        /**
         * Adds new group to the control's element.
         * @param {number} index The index of the group.
         * @param {DocumentFragment} fragment The group fragment to add to the DOM.
         * @param {boolean} animate Whether or not to animate the group.
         */
        Listview.prototype._addGroup = function (index, fragment, animate) {
            var _this = this;
            var utils = this.utils, context = this.context, groups = this._groups || (this._groups = {}), group = context[index], name = group.group, groupContainer = fragment.childNodes[1], itemContainer = groupContainer.lastElementChild, control = this.controls[index], groupHash = groups[name] = {
                name: name,
                index: index,
                element: groupContainer,
                itemContainer: itemContainer,
                control: control,
                itemCount: 0,
                addQueue: [],
                animationQueue: []
            }, items = 'items', removeArrayListener, removeMutationListener;
            control.dispose = function () {
                _super.prototype.dispose.call(_this);
                delete groups[name];
            };
            control.observe(function (newValue, oldValue) {
                var newName = newValue.group;
                if (newName === name || !utils.isObject(newValue)) {
                    return;
                }
                var temp = groups[name];
                delete groups[name];
                temp.name = newName;
                groups[newName] = temp;
                name = newName;
                removeArrayListener();
                removeMutationListener();
                removeArrayListener = control.observe(_this._childContextChanged.bind(_this, name), items);
                removeMutationListener = control.observeArray(_this._executeChildEvent.bind(_this, name), items);
            });
            removeArrayListener = control.observe(this._childContextChanged.bind(this, name), items);
            removeMutationListener = control.observeArray(this._executeChildEvent.bind(this, name), items);
            this._createItems(0, (group.items || []).length, groupHash, 0);
            if (animate) {
                var animationQueue_1 = this._defaultGroup.animationQueue, animation_1 = {
                    animation: this._animator.enter(fragment, __Enter, this._container).then(function () {
                        var index = animationQueue_1.indexOf(animation_1);
                        if (index > -1) {
                            animationQueue_1.splice(index, 1);
                        }
                        utils.requestAnimationFrame(_this._setGroupContainerPadding.bind(_this, groupContainer));
                    }),
                    op: null
                };
                animationQueue_1.push(animation_1);
                return;
            }
            this._container.insertBefore(fragment, null);
            utils.requestAnimationFrame(this._setGroupContainerPadding.bind(this, groupContainer));
        };
        /**
         * Handle binding of a single group.
         * @param {number} index The index of the group in context.
         */
        Listview.prototype._bindGroup = function (index) {
            return this.bindableTemplates.bind(__Listview + "-group", index, this._getAliases(this.context, index));
        };
        /**
         * Creates a specified number of items.
         * @param {number} index The index to start creating items.
         * @param {number} count The number of items to create.
         * @param {platui.IGroupHash} group The group for which we're creating items.
         * @param {number} animateItems The number of items to animate.
         */
        Listview.prototype._createItems = function (index, count, group, animateItems) {
            var _this = this;
            var utils = this.utils, opGroup = group || this._defaultGroup, control = opGroup.control, isVertical = this._isVertical, isControl = this === control;
            if (isControl) {
                if (this._isGrouped) {
                    this._headerTemplatePromise.then(function () {
                        _this._addGroups(count, index, animateItems);
                    }).then(null, function (error) {
                        _this._log.debug(_this.type + " error: " + error);
                    });
                    return;
                }
            }
            var addQueue = opGroup.addQueue, addPromise, postLoad = function () {
                var indexOf = addQueue.indexOf(addPromise);
                if (indexOf !== -1) {
                    addQueue.splice(indexOf, 1);
                }
                if (isControl) {
                    return;
                }
                opGroup.element.removeAttribute(__Hide);
                if (isVertical || isControl || !_this._isGrouped) {
                    return;
                }
                // set width for flexbox container 
                utils.requestAnimationFrame(_this._setGroupContainerWidth.bind(_this, opGroup.itemContainer));
            }, onError = function (error) {
                _this._log.debug(_this.type + " error: " + (utils.isString(error.message) ? error.message : error));
            };
            if (utils.isFunction(this._templateSelector)) {
                var promises = [];
                opGroup.itemCount += count;
                for (var i = 0; i < count; ++i, ++index) {
                    promises.push(this._renderUsingFunction(index, opGroup));
                }
                var itemsLoaded = this.itemsLoaded = this._Promise.all(promises)
                    .then(function (nodes) {
                    var length = nodes.length;
                    for (var ii = 0; ii < length; ++ii) {
                        _this._appendRenderedItem(nodes[ii], opGroup, ii < animateItems);
                    }
                }).then(postLoad, onError);
                addQueue.push(itemsLoaded);
                return;
            }
            var key = this._itemTemplate;
            if (utils.isUndefined(this.bindableTemplates.templates[key])) {
                return;
            }
            this._disposeFromIndex(index, opGroup);
            opGroup.itemCount += count;
            addPromise = this._addItems(index, count, opGroup, animateItems).then(postLoad, onError);
            addQueue.push(addPromise);
        };
        /**
         * Adds new items to the control's element when items are added to
         * the array.
         * @param {number} index The point in the array to start adding items.
         * @param {number} numberOfItems The number of items to add.
         * @param {platui.IGroupHash} group The group that we're performing this operation on.
         * @param {number} animateItems The number of items to animate.
         */
        Listview.prototype._addItems = function (index, numberOfItems, group, animateItems) {
            var _this = this;
            var opGroup = group || this._defaultGroup, control = opGroup.control, container = opGroup.itemContainer, max = +(index + numberOfItems), promises = [], itemTemplate = this._itemTemplate, bindableTemplates = control.bindableTemplates, initialIndex = index, identifier, context;
            if (this === control) {
                identifier = '';
                context = this.context;
            }
            else {
                identifier = 'items.';
                context = control.context.items;
            }
            while (index < max) {
                promises.push(bindableTemplates.bind(itemTemplate, identifier + index, this._getAliases(context, index++)));
            }
            if (promises.length > 0) {
                this.itemsLoaded = this._Promise.all(promises).then(function (templates) {
                    if (animateItems > 0) {
                        var length_2 = templates.length;
                        for (var i = 0; i < length_2; ++i) {
                            if (i < animateItems) {
                                _this._appendAnimatedItem(templates[i], opGroup);
                            }
                            else {
                                container.insertBefore(templates[i], null);
                            }
                        }
                    }
                    else {
                        _this._appendItems(templates, container);
                    }
                    _this._updateResource(initialIndex - 1, control);
                    if (_this.utils.isFunction(_this.__resolveFn)) {
                        _this.__resolveFn();
                        _this.__resolveFn = _this.__rejectFn = null;
                    }
                }).catch(function (error) {
                    _this.utils.postpone(function () {
                        _this._log.debug(error);
                    });
                });
            }
            return this.itemsLoaded;
        };
        /**
         * Render items using a defined render function starting at a given index and continuing
         * through for a set number of items. If undefined or null is returned from the function,
         * rendering will stop.
         * @param {number} index The starting index to render.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._renderUsingFunction = function (index, group) {
            var _this = this;
            var _Promise = this._Promise, utils = this.utils, opGroup = group || this._defaultGroup, control = opGroup.control, identifier, context, groupName;
            if (this === control) {
                identifier = index;
                context = this.context;
            }
            else {
                identifier = "items." + index;
                context = control.context.items;
                groupName = opGroup.name;
            }
            return _Promise.resolve(this._templateSelectorPromise).then(function () {
                return _this._templateSelectorPromise = _Promise.resolve(_this._templateSelector(context[index], index, groupName));
            }).then(function (selectedTemplate) {
                var bindableTemplates = control.bindableTemplates, templates = bindableTemplates.templates, controls = control.controls, key = _this._normalizeTemplateName(selectedTemplate), name = opGroup.name, templateKeys = _this._templateSelectorKeys[name], controlExists = index < controls.length;
                if (utils.isUndefined(templateKeys)) {
                    templateKeys = _this._templateSelectorKeys[name] = {};
                }
                if (!utils.isUndefined(templates[key])) {
                    if (controlExists) {
                        if (key === templateKeys[index]) {
                            return;
                        }
                        templateKeys[index] = key;
                        return bindableTemplates.replace(index, key, identifier, _this._getAliases(context, index));
                    }
                    templateKeys[index] = key;
                    return bindableTemplates.bind(key, identifier, _this._getAliases(context, index));
                }
                else {
                    _this._log.debug(_this.type + " template \"" + selectedTemplate + "\" was not found.");
                    if (controlExists) {
                        _this._TemplateControlFactory.dispose(controls[index]);
                    }
                }
            });
        };
        /**
         * Appends the rendered item from the defined render function.
         * @param {any} node The node to place into the item container if available.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         * @param {boolean} animate? Whether or not to animate the new item.
         */
        Listview.prototype._appendRenderedItem = function (node, group, animate) {
            var utils = this.utils, opGroup = group || this._defaultGroup;
            if (utils.isNull(node) || utils.isArray(node)) {
                return;
            }
            else if (animate === true) {
                var animationQueue_2 = opGroup.animationQueue, animation_2 = {
                    animation: this._animator.enter(node, __Enter, opGroup.itemContainer).then(function () {
                        var animationIndex = animationQueue_2.indexOf(animation_2);
                        if (animationIndex === -1) {
                            return;
                        }
                        animationQueue_2.splice(animationIndex, 1);
                    }),
                    op: null
                };
                animationQueue_2.push(animation_2);
            }
            else {
                opGroup.itemContainer.insertBefore(node, null);
            }
            if (utils.isFunction(this.__resolveFn)) {
                this.__resolveFn();
                this.__resolveFn = null;
            }
        };
        /**
         * Updates the control's children resource objects when
         * the array changes.
         * @param {number} index? The index to begin updating.
         * @param {number} count? The number of resources to update.
         * @param {plat.ui.TemplateControl} control The control whose resources are to be updated.
         */
        Listview.prototype._updateResource = function (index, control) {
            var controls = control.controls;
            if (index < 0 || index >= controls.length) {
                return;
            }
            controls[index].resources.add(this._getAliases(this === control ? this.context : control.context.items, index));
        };
        /**
         * Returns a resource alias object for an item in the array. The
         * resource object contains index:number, even:boolean, odd:boolean,
         * first:boolean, and last:boolean.
         * @param {any} context The context to get the aliases for.
         * @param {number} index The index used to create the resource aliases.
         */
        Listview.prototype._getAliases = function (context, index) {
            var isEven = (index & 1) === 0, aliases = {}, _aliases = this._aliases, type = __LITERAL_RESOURCE;
            aliases[_aliases.index] = {
                value: index,
                type: type
            };
            aliases[_aliases.even] = {
                value: isEven,
                type: type
            };
            aliases[_aliases.odd] = {
                value: !isEven,
                type: type
            };
            aliases[_aliases.first] = {
                value: index === 0,
                type: type
            };
            aliases[_aliases.last] = {
                value: index === (context.length - 1),
                type: type
            };
            return aliases;
        };
        /**
         * Adds an Array of items to the element without animating.
         * @param {Array<Node>} items The Array of items to add.
         * @param {Element} container THe container to add the items to.
         */
        Listview.prototype._appendItems = function (items, container) {
            this.dom.appendChildren(items, container);
        };
        /**
         * Adds an item to the control's element animating its elements.
         * @param {DocumentFragment} item The HTML fragment representing a single item.
         * @param {platui.IGroupHash} group The group items are being added to.
         */
        Listview.prototype._appendAnimatedItem = function (item, group) {
            if (!this.utils.isNode(item)) {
                return;
            }
            var animationQueue = group.animationQueue, animation = {
                animation: this._animator.enter(item, __Enter, group.itemContainer).then(function () {
                    var index = animationQueue.indexOf(animation);
                    if (index === -1) {
                        return;
                    }
                    animationQueue.splice(index, 1);
                }),
                op: null
            };
            animationQueue.push(animation);
        };
        /**
         * Removes items from the control's element.
         * @param {number} index The index to start disposing from.
         * @param {number} numberOfItems The number of items to remove.
         * @param {platui.IGroupHash} group The group for which we're disposing items.
         */
        Listview.prototype._removeItems = function (index, numberOfItems, group) {
            var dispose = this._TemplateControlFactory.dispose, control = group.control, controls = control.controls, last = index + numberOfItems, controlDisposed = last > index;
            while (last-- > index) {
                dispose(controls[last]);
            }
            this._updateResource(controls.length - 1, control);
            if (this === control) {
                return;
            }
            else if (controls.length === 0) {
                group.element.setAttribute(__Hide, '');
            }
            else if (controlDisposed && this._isGrouped && !this._isVertical) {
                this.utils.requestAnimationFrame(this._setGroupContainerWidth.bind(this, group.itemContainer));
            }
        };
        /**
         * Dispose of the controls and DOM starting at a given index.
         * @param {number} index The starting index to dispose.
         * @param {platui.IGroupHash} group? The group for which we're disposing items.
         */
        Listview.prototype._disposeFromIndex = function (index, group) {
            var opGroup = group || this._defaultGroup, control = opGroup.control, controls = control.controls, dispose = this._TemplateControlFactory.dispose, last = controls.length, controlDisposed = last > index;
            while (last-- > index) {
                dispose(controls[last]);
            }
            if (this === control) {
                return;
            }
            else if (controls.length === 0) {
                group.element.setAttribute(__Hide, '');
            }
            else if (controlDisposed && this._isGrouped && !this._isVertical) {
                this.utils.requestAnimationFrame(this._setGroupContainerWidth.bind(this, group.itemContainer));
            }
        };
        /**
         * Find and determine the proper loading function.
         * @param {string} requestItems The property for indicating the function for requesting more items.
         * @param {boolean} hideRing? Whether or not to hide the progress ring for "incremental" loading.
         */
        Listview.prototype._determineLoading = function (requestItems, showRing) {
            var _this = this;
            var controlProperty = this.findProperty(requestItems) || {};
            if (!this.utils.isFunction(controlProperty.value)) {
                this._log.debug(__Listview + " onItemsRequested function \"" + requestItems + "\" was not found.");
                return;
            }
            this._requestItems = controlProperty.value.bind(controlProperty.control);
            var progressRingContainer;
            switch (this._loading) {
                case 'infinite':
                    var removeScroll_1, removeRequest_1 = noop;
                    removeScroll_1 = this.addEventListener(this._scrollContainer, 'scroll', function () {
                        if (!_this._scrollReady) {
                            return;
                        }
                        _this._scrollReady = false;
                        removeRequest_1 = _this.utils.requestAnimationFrame(function () {
                            _this._scrollReady = true;
                            _this._onScroll();
                        });
                    }, false);
                    this._removeScroll = function () {
                        _this._scrollReady = false;
                        removeRequest_1();
                        removeScroll_1();
                    };
                    if (showRing) {
                        progressRingContainer = this._loadingProgressRing = this._document.createElement('div');
                        progressRingContainer.className = __Plat + "infinite";
                        progressRingContainer.insertBefore(this._generateProgressRing(), null);
                    }
                    this.itemsLoaded.then(this._onScroll.bind(this));
                    break;
                case 'incremental':
                    progressRingContainer = this._loadingProgressRing = this._document.createElement('div');
                    progressRingContainer.className = __Plat + "incremental";
                    progressRingContainer.setAttribute(__Hide, '');
                    progressRingContainer.insertBefore(this._generateProgressRing(), null);
                    this.element.insertBefore(progressRingContainer, null);
                    break;
                default:
                    break;
            }
        };
        /**
         * The scroll event listener.
         */
        Listview.prototype._onScroll = function () {
            var scrollContainer = this._scrollContainer, scrollPos = this._scrollPosition, scrollPosition = this._isVertical ?
                scrollContainer.scrollTop + scrollContainer.offsetHeight :
                scrollContainer.scrollLeft + scrollContainer.offsetWidth;
            if (scrollPos > scrollPosition) {
                this._scrollPosition = scrollPosition;
                return;
            }
            else if (scrollPos + 5 > scrollPosition) {
                // debounce excessive scroll event calls 
                return;
            }
            this._scrollPosition = scrollPosition;
            this._handleScroll();
        };
        /**
         * Checks if the scrolling has hit the proper threshold and requests more items if it has.
         */
        Listview.prototype._handleScroll = function () {
            var _this = this;
            // infinite scrolling set to load items at 80% of scroll length 
            var scrollContainer = this._scrollContainer, scrollLength = 0.8 * (this._isVertical ? scrollContainer.scrollHeight : scrollContainer.scrollWidth);
            if (scrollLength === 0) {
                return;
            }
            else if (this._scrollPosition >= scrollLength) {
                var utils_2 = this.utils, itemsRemain = this._requestItems();
                if (itemsRemain === false) {
                    this._removeScroll();
                }
                else if (utils_2.isPromise(itemsRemain)) {
                    var progressRing_1 = this._loadingProgressRing, showProgress_1 = !utils_2.isNull(progressRing_1), container_1 = this._container;
                    this._scrollReady = false;
                    if (showProgress_1) {
                        utils_2.requestAnimationFrame(function () {
                            container_1.insertBefore(progressRing_1, null);
                        });
                    }
                    itemsRemain.then(function (moreItemsRemain) {
                        if (showProgress_1) {
                            utils_2.requestAnimationFrame(function () {
                                container_1.removeChild(progressRing_1);
                            });
                        }
                        if (moreItemsRemain === false) {
                            return;
                        }
                        _this._scrollReady = true;
                    });
                }
                else {
                    utils_2.postpone(function () {
                        _this.itemsLoaded.then(function () {
                            if (_this._scrollReady) {
                                _this._handleScroll();
                            }
                        });
                    });
                }
            }
        };
        /**
         * Find and determine the pull-to-refresh function.
         * @param {string} pullRefresh The property for indicating the pull-to-refresh function.
         */
        Listview.prototype._initializeRefresh = function (refresh) {
            var controlProperty = this.findProperty(refresh) || {};
            if (!this.utils.isFunction(controlProperty.value)) {
                this._log.debug(__Listview + " onRefresh function \"" + refresh + "\" was not found.");
                return;
            }
            this._refresh = controlProperty.value.bind(controlProperty.control);
            var progressRingContainer = this._refreshProgressRing = this._document.createElement('div');
            progressRingContainer.className = __Plat + "refresh";
            progressRingContainer.setAttribute(__Hide, '');
            progressRingContainer.insertBefore(this._generateProgressRing(), null);
            this.element.insertBefore(progressRingContainer, null);
        };
        /**
         * Initializes the proper tracking events.
         * @param {boolean} loading Whether or not to initialize the loading tracking events.
         * @param {boolean} refresh Whether or not to initialize the refresh tracking events.
         */
        Listview.prototype._initializeTracking = function (loading, refresh) {
            if (!(loading || refresh)) {
                return;
            }
            this._setTransform();
            var track, reverseTrack;
            if (this._isVertical) {
                track = __$track + "down";
                reverseTrack = __$track + "up";
            }
            else {
                track = __$track + "right";
                reverseTrack = __$track + "left";
            }
            var viewport = this._viewport, touchEnd, trackFn;
            this.addEventListener(viewport, __$touchstart, this._touchStart, false);
            if (loading) {
                touchEnd = this._touchEndLoad;
                trackFn = this._trackLoad;
                this.addEventListener(viewport, __$touchend, touchEnd, false);
                this.addEventListener(viewport, __$trackend, touchEnd, false);
                this.addEventListener(viewport, __$touchcancel, touchEnd, false);
                this.addEventListener(viewport, track, trackFn, false);
                this.addEventListener(viewport, reverseTrack, trackFn, false);
            }
            if (refresh) {
                touchEnd = this._touchEndRefresh;
                trackFn = this._trackRefresh;
                this.addEventListener(viewport, __$touchend, touchEnd, false);
                this.addEventListener(viewport, __$trackend, touchEnd, false);
                this.addEventListener(viewport, __$touchcancel, touchEnd, false);
                this.addEventListener(viewport, track, trackFn, false);
                this.addEventListener(viewport, reverseTrack, trackFn, false);
            }
        };
        /**
         * The touch start event listener for when looking for a refresh.
         * @param {plat.ui.IGestureEvent} ev The $touchstart event object.
         */
        Listview.prototype._touchStart = function (ev) {
            var _this = this;
            if (this._touchState !== 0) {
                return;
            }
            else if (!this._isVertical) {
                var pos = Math.ceil(ev.offsetY), 
                // we're going to decrease the threshold by 20 to buffer the scrollbar 
                threshold = this._viewport.offsetHeight - 20;
                if (pos >= threshold) {
                    return;
                }
            }
            this._touchState = 1;
            this._lastTouch = {
                x: ev.clientX,
                y: ev.clientY
            };
            if (!this.utils.isNull(this._touchAnimationThenable)) {
                this._touchAnimationThenable.cancel().then(function () {
                    _this._touchAnimationThenable = null;
                    _this._touchState = 2;
                });
                return;
            }
            this._touchState = 2;
        };
        /**
         * The touch end event listener for when looking for an incremental load.
         * @param {plat.ui.IGestureEvent} ev The $touchend event object.
         */
        Listview.prototype._touchEndLoad = function (ev) {
            var isLoading = this._isLoading;
            this._isLoading = false;
            if (!isLoading) {
                if (!this._isRefreshing) {
                    this._touchState = 0;
                }
                return;
            }
            var scrollContainer = this._scrollContainer, scrollLength, threshold;
            if (this._isVertical) {
                scrollLength = scrollContainer.scrollTop + scrollContainer.offsetHeight;
                threshold = scrollContainer.scrollHeight;
            }
            else {
                scrollLength = scrollContainer.scrollLeft + scrollContainer.offsetWidth;
                threshold = scrollContainer.scrollWidth;
            }
            // do plus 1 here for browser pixel inconsistency 
            if (scrollLength + 1 < threshold) {
                this._touchState = 0;
                return;
            }
            this._touchEnd(ev, false);
        };
        /**
         * The touch end event listener for when looking for a refresh.
         * @param {plat.ui.IGestureEvent} ev The $touchend event object.
         */
        Listview.prototype._touchEndRefresh = function (ev) {
            var isRefreshing = this._isRefreshing;
            this._isRefreshing = false;
            if (!isRefreshing) {
                if (!this._isLoading) {
                    this._touchState = 0;
                }
                return;
            }
            else if ((this._isVertical ? this._scrollContainer.scrollTop : this._scrollContainer.scrollLeft) > 0) {
                this._touchState = 0;
                return;
            }
            this._touchEnd(ev, true);
        };
        /**
         * A common touch end event listener for both refresh and incremental loading.
         * @param {plat.ui.IGestureEvent} ev The $touchend event object.
         * @param {boolean} refreshing Whether this translation is for refresh or incremental loading.
         */
        Listview.prototype._touchEnd = function (ev, refreshing) {
            var _this = this;
            var state = this._touchState, hasMoved = this._hasMoved;
            this._hasMoved = false;
            if (state < 2 || !hasMoved) {
                return;
            }
            var animationOptions = {}, dom = this.dom, viewport = this._viewport, progressRing = refreshing ? this._refreshProgressRing : this._loadingProgressRing, isActionState = state === 3, nextTranslation;
            if (isActionState) {
                var offset = void 0;
                if (this._isVertical) {
                    offset = refreshing ? progressRing.offsetHeight : -progressRing.offsetHeight;
                    nextTranslation = "translate3d(0," + offset + "px,0)";
                }
                else {
                    offset = refreshing ? progressRing.offsetWidth : -progressRing.offsetWidth;
                    nextTranslation = "translate3d(" + offset + "px,0,0)";
                }
            }
            else {
                nextTranslation = this._preTransform;
            }
            animationOptions[this._transform] = nextTranslation;
            this._touchAnimationThenable = this._animator.animate(viewport, __Transition, {
                properties: animationOptions
            }).then(function () {
                _this._touchState = 4;
                _this._hasMoved = false;
                _this._touchAnimationThenable = null;
                if (isActionState) {
                    return _this._Promise.resolve(refreshing ? _this._refresh() : _this._requestItems());
                }
                dom.removeClass(viewport, __Plat + "manipulation-prep");
                progressRing.setAttribute(__Hide, '');
                return _this._Promise.resolve();
            }).then(function () {
                if (!isActionState) {
                    _this._touchState = 0;
                    return;
                }
                dom.removeClass(progressRing, __Plat + "play");
                animationOptions[_this._transform] = _this._preTransform;
                return _this._touchAnimationThenable = _this._animator.animate(viewport, __Transition, {
                    properties: animationOptions
                }).then(function () {
                    _this._touchState = 0;
                    _this._touchAnimationThenable = null;
                    dom.removeClass(viewport, __Plat + "manipulation-prep");
                    progressRing.setAttribute(__Hide, '');
                });
            }).then(null, function (error) {
                _this._touchState = 0;
                _this._log.debug(_this.type + " error: " + error);
            });
        };
        /**
         * The tracking event listener for looking for a load.
         * @param {plat.ui.IGestureEvent} ev The $track[direction] event object.
         */
        Listview.prototype._trackLoad = function (ev) {
            if (this._isRefreshing) {
                return;
            }
            if (!this._isLoading) {
                var scrollContainer = this._scrollContainer, scrollLength = void 0, threshold = void 0;
                if (this._isVertical) {
                    if (ev.direction.y !== 'up') {
                        return;
                    }
                    scrollLength = scrollContainer.scrollTop + scrollContainer.offsetHeight;
                    threshold = scrollContainer.scrollHeight;
                }
                else {
                    if (ev.direction.x !== 'left') {
                        return;
                    }
                    scrollLength = scrollContainer.scrollLeft + scrollContainer.offsetWidth;
                    threshold = scrollContainer.scrollWidth;
                }
                // do plus 1 here for browser pixel inconsistency 
                if (scrollLength + 1 < threshold) {
                    return;
                }
                this._isLoading = true;
            }
            this._track(ev, false);
        };
        /**
         * The tracking event listener for looking for a refresh.
         * @param {plat.ui.IGestureEvent} ev The $track[direction] event object.
         */
        Listview.prototype._trackRefresh = function (ev) {
            if (this._isLoading) {
                return;
            }
            if (!this._isRefreshing) {
                if (this._isVertical) {
                    if (ev.direction.y !== 'down' || this._scrollContainer.scrollTop > 0) {
                        return;
                    }
                }
                else if (ev.direction.x !== 'right' || this._scrollContainer.scrollLeft > 0) {
                    return;
                }
                this._isRefreshing = true;
            }
            this._track(ev, true);
        };
        /**
         * Handles the translation of the viewport while tracking.
         * @param {plat.ui.IGestureEvent} ev The $track[direction] event object.
         * @param {boolean} refreshing Whether this translation is for refresh or incremental loading.
         */
        Listview.prototype._track = function (ev, refreshing) {
            var _this = this;
            var touchState = this._touchState;
            if (!(touchState === 2 || touchState === 3)) {
                return;
            }
            var translation = this._calculateTranslation(ev, refreshing);
            this.utils.requestAnimationFrame(function () {
                _this._viewport.style[_this._transform] = translation;
            });
        };
        /**
         * Calculates the translation value for setting the transform value during tracking.
         * @param {plat.ui.IGestureEvent} ev The $tracking event.
         * @param {boolean} refreshing Whether this translation is for refresh or incremental loading.
         */
        Listview.prototype._calculateTranslation = function (ev, refreshing) {
            var isVertical = this._isVertical, progressRing = refreshing ? this._refreshProgressRing : this._loadingProgressRing, diff, threshold;
            if (isVertical) {
                diff = ev.clientY - this._lastTouch.y;
                threshold = progressRing.offsetHeight;
            }
            else {
                diff = ev.clientX - this._lastTouch.x;
                threshold = progressRing.offsetWidth;
            }
            if ((refreshing && diff < 0) || (!refreshing && diff > 0)) {
                diff = 0;
            }
            else if (!this._hasMoved) {
                this._hasMoved = true;
                this.dom.addClass(this._viewport, __Plat + "manipulation-prep");
                progressRing.removeAttribute(__Hide);
            }
            else if (Math.abs(diff) >= threshold) {
                if (this._touchState < 3) {
                    this._touchState = 3;
                    this.dom.addClass(progressRing, __Plat + "play");
                }
            }
            else if (this._touchState === 3) {
                this._touchState = 2;
                this.dom.removeClass(progressRing, __Plat + "play");
            }
            if (isVertical) {
                return "translate3d(0," + diff + "px,0)";
            }
            return "translate3d(" + diff + "px,0,0)";
        };
        /**
         * Obtains the current browser's transform property value.
         */
        Listview.prototype._setTransform = function () {
            var style = this._viewport.style, isUndefined = this.utils.isUndefined;
            var vendorPrefix = this._compat.vendorPrefix;
            if (!isUndefined(this._preTransform = style[(vendorPrefix.lowerCase + "Transform")])) {
                this._transform = vendorPrefix.lowerCase + "Transform";
            }
            else if (!isUndefined(this._preTransform = style[(vendorPrefix.upperCase + "Transform")])) {
                this._transform = vendorPrefix.upperCase + "Transform";
            }
            else {
                this._preTransform = style.transform;
                this._transform = 'transform';
            }
        };
        /**
         * Clones and parses thes innerTemplate and creates the templates object.
         * @param {string} itemTemplate The normalized item template name from the options.
         * @param {string} headerTemplate? The normalized group header template name from the options.
         */
        Listview.prototype._parseInnerTemplate = function (itemTemplate, headerTemplate) {
            var templates = this._templates, slice = Array.prototype.slice, appendChildren = this.dom.appendChildren, _document = this._document, validGroupTemplate = !this.utils.isNull(headerTemplate), childNodes = slice.call(this.innerTemplate.childNodes), childNode, templateName, container;
            while (childNodes.length > 0) {
                childNode = childNodes.pop();
                if (childNode.nodeType !== Node.ELEMENT_NODE) {
                    continue;
                }
                templateName = this._normalizeTemplateName(childNode.nodeName);
                if (validGroupTemplate && templateName === headerTemplate) {
                    container = _document.createElement('div');
                    container.className = __Plat + "header";
                }
                else {
                    container = _document.createDocumentFragment();
                }
                appendChildren(childNode.childNodes, container);
                templates[templateName] = container;
            }
        };
        /**
         * Receives an event when a method has been called on an array and maps the array
         * method to its associated method handler.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array mutation event information.
         */
        Listview.prototype._executeEvent = function (changes) {
            var method = "_" + changes[0].type;
            if (this.utils.isFunction(this[method])) {
                this[method](changes);
            }
        };
        /**
         * Adds new group to the control's element.
         * @param {string} groupName The group name of the currently changing Array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         */
        Listview.prototype._executeChildEvent = function (groupName, changes) {
            var utils = this.utils, method = "_" + changes[0].type;
            if (utils.isFunction(this[method])) {
                var group = this._groups[groupName];
                if (utils.isNull(group)) {
                    return;
                }
                this[method](changes, group);
            }
        };
        /**
         * First checks if the push will do anything, then handles items being pushed into the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._push = function (changes, group) {
            var change = changes[0], addedCount = change.addedCount;
            this._createItems(change.index, addedCount, group, this._animate ? addedCount : 0);
        };
        /**
         * Handles items being popped off the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._pop = function (changes, group) {
            var _this = this;
            var opGroup = group || this._defaultGroup, addQueue = opGroup.addQueue, change = changes[0], start = change.object.length;
            if (change.removed.length === 0) {
                return;
            }
            var removeIndex = change.object.length;
            if (opGroup.itemCount > 0) {
                opGroup.itemCount--;
            }
            this._Promise.all(addQueue).then(function () {
                if (_this._animate) {
                    _this._animateItems(start, 1, __Leave, opGroup, 'leave', false).then(function () {
                        _this._removeItems(removeIndex, 1, opGroup);
                    });
                    return;
                }
                _this._removeItems(removeIndex, 1, opGroup);
            });
        };
        /**
         * Handles items being unshifted into the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._unshift = function (changes, group) {
            if (this.utils.isFunction(this._templateSelector)) {
                this.rerender(group);
                return;
            }
            var opGroup = group || this._defaultGroup, change = changes[0], addedCount = change.addedCount;
            if (this._animate) {
                var animationQueue = opGroup.animationQueue, animationLength = animationQueue.length;
                this._animateItems(0, addedCount, __Enter, opGroup, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
            }
            this._createItems(change.object.length - addedCount, addedCount, opGroup, 0);
        };
        /**
         * Handles items being shifted off the array.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._shift = function (changes, group) {
            var _this = this;
            var opGroup = group || this._defaultGroup, addQueue = opGroup.addQueue, change = changes[0];
            if (change.removed.length === 0) {
                return;
            }
            else if (this._animate) {
                if (addQueue.length === 0) {
                    addQueue = addQueue.concat([this._animateItems(0, 1, __Leave, opGroup, 'clone', true)]);
                }
            }
            var removeIndex = change.object.length;
            if (opGroup.itemCount > 0) {
                opGroup.itemCount--;
            }
            this._Promise.all(addQueue).then(function () {
                _this._removeItems(removeIndex, 1, opGroup);
            });
        };
        /**
         * Handles adding/removing items when an array is spliced.
         * @param {Array<plat.observable.IArrayChanges<any>>} changes The Array change information.
         * @param {platui.IGroupHash} group? The group that we're performing this operation on.
         */
        Listview.prototype._splice = function (changes, group) {
            var _this = this;
            var utils = this.utils, change = changes[0], opGroup = group || this._defaultGroup, addCount = change.addedCount, currentLength = opGroup.itemCount, control = opGroup.control, addQueue = opGroup.addQueue, animating = this._animate;
            if (utils.isNull(addCount)) {
                if (animating) {
                    this._cancelCurrentAnimations();
                }
                var newLength = change.object.length, itemCount_1 = currentLength - newLength;
                if (newLength > currentLength) {
                    if (utils.isFunction(this._templateSelector)) {
                        if (utils.isNull(change.index)) {
                            this.rerender(opGroup);
                        }
                        else {
                            this.render(change.index, addCount, opGroup);
                        }
                        return;
                    }
                    // itemCount will be negative 
                    this._createItems(currentLength, -itemCount_1, opGroup, 0);
                }
                else if (currentLength > newLength) {
                    if (opGroup.itemCount >= itemCount_1) {
                        opGroup.itemCount -= itemCount_1;
                    }
                    else {
                        opGroup.itemCount = 0;
                    }
                    this._Promise.all(addQueue).then(function () {
                        _this._removeItems(currentLength - itemCount_1, itemCount_1, opGroup);
                    });
                }
                return;
            }
            var removeCount = change.removed.length, animationQueue = opGroup.animationQueue;
            if (addCount > removeCount) {
                var itemAddCount = addCount - removeCount, animationCount = void 0;
                if (utils.isFunction(this._templateSelector)) {
                    if (utils.isNull(change.index)) {
                        this.rerender(opGroup);
                    }
                    else {
                        this.render(change.index, addCount, opGroup);
                    }
                    return;
                }
                if (animating) {
                    animationCount = addCount;
                    var animationLength = animationQueue.length, startIndex = change.index;
                    if (currentLength < addCount - startIndex) {
                        animationCount = currentLength - startIndex;
                    }
                    this._animateItems(startIndex, animationCount, __Enter, opGroup, null, animationLength > 0 && animationQueue[animationLength - 1].op === 'clone');
                    animationCount = addCount - animationCount;
                }
                else {
                    animationCount = 0;
                }
                this._createItems(change.object.length - itemAddCount, itemAddCount, opGroup, animationCount);
            }
            else if (removeCount > addCount) {
                var adding_1 = addCount > 0;
                if (animating && !adding_1 && addQueue.length === 0) {
                    addQueue = addQueue.concat([this._animateItems(change.index, removeCount, __Leave, opGroup, 'clone', true)]);
                }
                var deleteCount_1 = removeCount - addCount;
                if (opGroup.itemCount >= deleteCount_1) {
                    opGroup.itemCount -= deleteCount_1;
                }
                else {
                    opGroup.itemCount = 0;
                }
                this._Promise.all(addQueue).then(function () {
                    if (animating && adding_1) {
                        var animLength = animationQueue.length;
                        _this._animateItems(change.index, addCount, __Enter, opGroup, null, animLength > 0 && animationQueue[animLength - 1].op === 'clone');
                    }
                    _this._removeItems(currentLength - deleteCount_1, deleteCount_1, opGroup);
                });
            }
        };
        /**
         * Animates the indicated items.
         * @param {number} startIndex The starting index of items to animate.
         * @param {number} numberOfItems The number of consecutive items to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         * @param {string} animationOp Denotes animation operation.
         * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
         */
        Listview.prototype._animateItems = function (startIndex, numberOfItems, key, group, animationOp, cancel) {
            switch (animationOp) {
                case 'clone':
                    return this._handleClonedContainerAnimation(this._getAnimatedNodes(startIndex, numberOfItems, group), key, group, cancel === true);
                case 'leave':
                    return this._handleLeave(this._getAnimatedNodes(startIndex, numberOfItems, group), key, group);
                default:
                    return this._handleSimpleAnimation(this._getAnimatedNodes(startIndex, numberOfItems, group), key, group, cancel === true);
            }
        };
        /**
         * Translates the items to be animated into the nodes to be animated.
         * @param {number} startIndex The starting index of items to animate.
         * @param {number} numberOfItems The number of consecutive items to animate.
         * @param {IGroupHash} group The group performing the animation.
         */
        Listview.prototype._getAnimatedNodes = function (startIndex, numberOfItems, group) {
            if (this._isGrouped && group === this._defaultGroup) {
                // we are animating a group so block length === 3 (one element node and two comment nodes) 
                var blockLength = 3, start = startIndex * blockLength;
                return Array.prototype.slice.call(group.itemContainer.childNodes, start, numberOfItems * blockLength + start);
            }
            var utils = this.utils, isNode = utils.isNode, nodes = Array.prototype.slice.call(group.itemContainer.childNodes), endIndex = startIndex + numberOfItems - 1, controls = group.control.controls;
            if (controls.length <= endIndex) {
                endIndex = controls.length - 1;
            }
            var startNode = controls[startIndex].startNode, endNode = controls[endIndex].endNode;
            if (!(isNode(startNode) && isNode(endNode))) {
                return [];
            }
            var startNodeIndex = nodes.indexOf(startNode), endNodeIndex = nodes.indexOf(endNode);
            if (startNodeIndex === -1 || endNodeIndex === -1) {
                return [];
            }
            return nodes.slice(startNodeIndex, endNodeIndex + 1);
        };
        /**
         * Handles a simple animation of a block of elements.
         * @param {Array<Node>} nodes The Array of nodes to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
         */
        Listview.prototype._handleSimpleAnimation = function (nodes, key, group, cancel) {
            if (nodes.length === 0) {
                return this._Promise.resolve();
            }
            var container = group.itemContainer, animationQueue = group.animationQueue, animationCreation = this._animator.create(nodes, key), animation, animationPromise = animationCreation.current.then(function () {
                var index = animationQueue.indexOf(animation);
                if (index === -1) {
                    return;
                }
                animationQueue.splice(index, 1);
            }), callback = function () {
                animationCreation.previous.then(function () {
                    animationPromise.start();
                });
                return animationPromise;
            };
            animation = {
                animation: animationPromise,
                op: null
            };
            if (cancel && animationQueue.length > 0) {
                var cancelPromise = this._cancelCurrentAnimations().then(callback);
                animationQueue.push(animation);
                return cancelPromise;
            }
            animationQueue.push(animation);
            return callback();
        };
        /**
         * Handles a simple animation of a block of elements.
         * @param {Array<Node>} nodes The Array of nodes to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         */
        Listview.prototype._handleLeave = function (nodes, key, group) {
            if (nodes.length === 0) {
                return this._Promise.resolve();
            }
            var container = group.itemContainer, animationQueue = group.animationQueue, animation, animationPromise = this._animator.leave(nodes, key).then(function () {
                var index = animationQueue.indexOf(animation);
                if (index === -1) {
                    return;
                }
                animationQueue.splice(index, 1);
            });
            animation = {
                animation: animationPromise,
                op: 'leave'
            };
            animationQueue.push(animation);
            return animationPromise;
        };
        /**
         * Handles a simple animation of a block of elements.
         * @param {Array<Node>} nodes The Array of nodes to animate.
         * @param {string} key The animation key/type.
         * @param {IGroupHash} group The group performing the animation.
         * @param {boolean} cancel Whether or not to cancel the current animation before beginning this one.
         */
        Listview.prototype._handleClonedContainerAnimation = function (nodes, key, group, cancel) {
            if (nodes.length === 0) {
                return this._Promise.resolve();
            }
            var container = group.itemContainer, clonedContainer = container.cloneNode(true), parentNode, animationQueue = group.animationQueue, isNull = this.utils.isNull, animationCreation = this._animator.create(nodes, key), animation, animationPromise = animationCreation.current.then(function () {
                var index = animationQueue.indexOf(animation);
                if (index > -1) {
                    animationQueue.splice(index, 1);
                }
                if (isNull(parentNode)) {
                    return;
                }
                parentNode.replaceChild(container, clonedContainer);
            }), callback = function () {
                parentNode = container.parentNode;
                if (isNull(parentNode) || animationPromise.isCanceled()) {
                    return animationPromise;
                }
                parentNode.replaceChild(clonedContainer, container);
                animationCreation.previous.then(function () {
                    animationPromise.start();
                });
                return animationPromise;
            };
            animation = {
                animation: animationPromise,
                op: 'clone'
            };
            if (cancel && animationQueue.length > 0) {
                var cancelPromise = this._cancelCurrentAnimations().then(callback);
                animationQueue.push(animation);
                return cancelPromise;
            }
            animationQueue.push(animation);
            return callback();
        };
        /**
         * Cancels all current animations.
         * @param {platui.IGroupHash} The object representing the current group.
         */
        Listview.prototype._cancelCurrentAnimations = function (group) {
            var animationQueue = (group || this._defaultGroup).animationQueue, animations = [], length = animationQueue.length;
            for (var i = 0; i < length; ++i) {
                animations.push(animationQueue[i].animation.cancel());
            }
            return this._Promise.all(animations);
        };
        /**
         * Normalizes template names by removing special characters.
         * @param {string} templateName The name to normalize.
         */
        Listview.prototype._normalizeTemplateName = function (templateName) {
            if (this.utils.isString(templateName)) {
                return templateName.toLowerCase().replace(this._nodeNormalizeRegex, '');
            }
        };
        /**
         * Creates a progress ring element.
         */
        Listview.prototype._generateProgressRing = function () {
            var _document = this._document, control = _document.createElement('div'), ring = _document.createElement('div');
            control.className = __Listview + "-ring " + __Plat + "ring " + __Plat + "ring-0";
            ring.className = __Plat + "animated-ring";
            control.insertBefore(ring, null);
            return control;
        };
        /**
         * Checks the orientation of the control and ensures it is valid.
         * Will default to "horizontal" if invalid.
         * @param {string} orientation The element to base the length off of.
         */
        Listview.prototype._validateOrientation = function (orientation) {
            if (this.utils.isUndefined(orientation)) {
                return 'vertical';
            }
            var validOrientation;
            if (orientation === 'vertical') {
                validOrientation = orientation;
            }
            else if (orientation === 'horizontal') {
                validOrientation = orientation;
                this._isVertical = false;
            }
            else {
                this._log.debug("Invalid orientation \"" + orientation + "\" for " + this.type + ". Defaulting to \"vertical.\"");
                validOrientation = 'vertical';
            }
            return validOrientation;
        };
        /**
         * Sets the height of a horizontally grouped Listview's container.
         */
        Listview.prototype._setContainerHeight = function () {
            if (this._isVertical || !this._isGrouped) {
                return;
            }
            var element = this.element, height = element.offsetHeight;
            if (!height) {
                this._addVisibilityListener(this._setContainerHeight.bind(this), element);
                return;
            }
            // account for scroll bar height even if scroll bar isn't visible 
            // allows for transition of scroll bar in and out of page in browsers where scroll bar affects height 
            height = height - this._getScrollBarWidth();
            if (height < 0) {
                height = 0;
            }
            this._container.style.height = height + "px";
        };
        /**
         * Sets the width of a group container based on the scroll width of the group's item container.
         * @param {HTMLElement} itemContainer The item container element whose parent we're going to set its scroll width on.
         */
        Listview.prototype._setGroupContainerWidth = function (itemContainer) {
            var width = itemContainer.scrollWidth;
            if (!width) {
                this._addVisibilityListener(this._setGroupContainerWidth.bind(this, itemContainer), itemContainer);
                return;
            }
            itemContainer.parentElement.style.width = width + "px";
        };
        /**
         * Sets the padding of a group's element.
         * @param {HTMLElement} element The group container element who we're setting padding on.
         */
        Listview.prototype._setGroupContainerPadding = function (element) {
            var elementHeight = element.offsetHeight;
            if (!elementHeight) {
                this._addVisibilityListener(this._setGroupContainerPadding.bind(this, element), element);
                return;
            }
            var header = element.firstElementChild, headerHeight = header.offsetHeight;
            if (!headerHeight) {
                this._addVisibilityListener(this._setGroupContainerPadding.bind(this, element), header);
                return;
            }
            element.style.paddingTop = headerHeight + "px";
        };
        /**
         * Calcuates the width of the horizontal scroll bar in the current browser.
         */
        Listview.prototype._getScrollBarWidth = function () {
            var _document = this._document, body = _document.body, inner = _document.createElement('div'), outer = _document.createElement('div'), innerStyle = inner.style, outerStyle = outer.style;
            innerStyle.width = innerStyle.height = outerStyle.height = '100px';
            outerStyle.width = '50px';
            outerStyle.position = 'absolute';
            outerStyle.top = outerStyle.left = '0px';
            outerStyle.visibility = outerStyle.overflow = 'hidden';
            outer.insertBefore(inner, null);
            body.insertBefore(outer, null);
            var w1 = inner.offsetHeight;
            outerStyle.overflow = 'scroll';
            var w2 = inner.offsetHeight;
            if (w1 === w2) {
                w2 = outer.clientHeight;
            }
            body.removeChild(outer);
            return (w1 - w2);
        };
        /**
         * Adds a visibility listener and hides and shows element accordingly
         * @param {() => void} listener The listener to fire when visible.
         * @param {HTMLElement} element The element to listen for visibility.
         */
        Listview.prototype._addVisibilityListener = function (listener, element) {
            var _this = this;
            var visibilityRemovers = this._visibilityRemoveListeners, remove, cb = function () {
                listener();
                var i = visibilityRemovers.indexOf(remove);
                if (i !== -1) {
                    visibilityRemovers.splice(i, 1);
                }
                if (visibilityRemovers.length === 0) {
                    _this.element.removeAttribute(__Hidden);
                }
            };
            remove = this.dom.whenVisible(this.utils.requestAnimationFrame.bind(this, cb), element);
            if (visibilityRemovers.length === 0) {
                this.element.setAttribute(__Hidden, '');
            }
            visibilityRemovers.push(remove);
        };
        Listview._inject = {
            _document: __Document,
            _window: __Window,
            _compat: __Compat,
            _animator: __Animator,
            _Promise: __Promise,
            _TemplateControlFactory: __TemplateControlFactory
        };
        return Listview;
    }(plat.ui.TemplateControl));
    platui.Listview = Listview;
    plat.register.control(__Listview, Listview);
    /**
     * An ITemplateControl that acts as a global navigation bar that defines its own context.
     */
    var Navbar = (function (_super) {
        __extends(Navbar, _super);
        function Navbar() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div class="plat-navbar-left">\n' +
                '    <div class="plat-navbar-items" plat-control="' + __ForEach + '" plat-context="left">\n' +
                '        <div class="plat-navbar-item" plat-control="' + __Html + '" plat-options="{ html: content, compile: true }" plat-tap="leftAction(@index)"></div>\n' +
                '    </div>\n' +
                '</div>\n' +
                '<div class="plat-navbar-center">\n' +
                '    <div class="plat-navbar-items" plat-control="' + __ForEach + '" plat-context="center">\n' +
                '        <div class="plat-navbar-item" plat-control="' + __Html + '" plat-options="{ html: content, compile: true }" plat-tap="centerAction(@index)"></div>\n' +
                '    </div>\n' +
                '</div>\n' +
                '<div class="plat-navbar-right">\n' +
                '    <div class="plat-navbar-items" plat-control="' + __ForEach + '" plat-context="right">\n' +
                '        <div class="plat-navbar-item" plat-control="' + __Html + '" plat-options="{ html: content, compile: true }" plat-tap="rightAction(@index)"></div>\n' +
                '    </div>\n' +
                '</div>\n';
            /**
             * The Navbar control's context.
             */
            this.context = {
                left: [{
                        content: '',
                        action: noop
                    }],
                center: [{
                        content: '',
                        action: noop
                    }],
                right: [{
                        content: '',
                        action: noop
                    }]
            };
            /**
             * Specifies that the Navbar defines it's own context.
             */
            this.hasOwnContext = true;
            /**
             * An object specifying whether a particular section of the Navbar
             * has been overridden.
             */
            this._overrides = {
                left: false,
                center: false,
                right: false
            };
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Navbar.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Navbar + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Navbar.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Looks for and applies overwritten components.
         */
        Navbar.prototype.setTemplate = function () {
            var isNull = this.utils.isNull, innerTemplate = this.innerTemplate;
            if (isNull(innerTemplate)) {
                return;
            }
            var doc = this._document, overrides = this._overrides, slice = Array.prototype.slice, appendChildren = this.dom.appendChildren, childNodes = slice.call(innerTemplate.childNodes), childNode, newNode, element = this.element, elementNodes = slice.call(element.children);
            while (childNodes.length > 0) {
                childNode = childNodes.shift();
                if (childNode.nodeType !== Node.ELEMENT_NODE) {
                    continue;
                }
                switch (childNode.nodeName.toLowerCase()) {
                    case 'left':
                        overrides.left = true;
                        newNode = doc.createElement('div');
                        newNode.className = __Navbar + "-left";
                        newNode.setAttribute(__Context, 'left');
                        element.replaceChild(appendChildren(slice.call(childNode.childNodes), newNode), elementNodes[0]);
                        break;
                    case 'center':
                        overrides.center = true;
                        newNode = doc.createElement('div');
                        newNode.className = __Navbar + "-center";
                        newNode.setAttribute(__Context, 'center');
                        element.replaceChild(appendChildren(slice.call(childNode.childNodes), newNode), elementNodes[1]);
                        break;
                    case 'right':
                        overrides.right = true;
                        newNode = doc.createElement('div');
                        newNode.className = __Navbar + "-right";
                        newNode.setAttribute(__Context, 'right');
                        element.replaceChild(appendChildren(slice.call(childNode.childNodes), newNode), elementNodes[2]);
                        break;
                }
            }
        };
        /**
         * Initializes all options.
         */
        Navbar.prototype.loaded = function () {
            var optionObj = this.options || {}, options = optionObj.value || {}, position = this.utils.isString(options.position) && options.position.toLowerCase() === 'bottom' ? '-bottom' : '-top';
            this.dom.addClass(this.element, __Navbar + position);
        };
        Navbar.prototype.setLeft = function (components) {
            this._setComponent('left', components);
        };
        Navbar.prototype.setCenter = function (components) {
            this._setComponent('center', components);
        };
        Navbar.prototype.setRight = function (components) {
            this._setComponent('right', components);
        };
        /**
         * The defined action of the left part of the Navbar when tapped.
         * @param {number} index? The index of the action tapped.
         * @param {plat.ui.IGestureEvent} ev? The "$tap" event.
         */
        Navbar.prototype.leftAction = function (index, ev) {
            this._executeAction(ev, 'left', index);
        };
        /**
         * The defined action of the center part of the Navbar when tapped.
         * @param {number} index? The index of the action tapped.
         * @param {plat.ui.IGestureEvent} ev? The "$tap" event.
         */
        Navbar.prototype.centerAction = function (index, ev) {
            this._executeAction(ev, 'center', index);
        };
        /**
         * The defined action of the right part of the Navbar when tapped.
         * @param {number} index? The index of the action tapped.
         * @param {plat.ui.IGestureEvent} ev? The "$tap" event.
         */
        Navbar.prototype.rightAction = function (index, ev) {
            this._executeAction(ev, 'right', index);
        };
        Navbar.prototype._setComponent = function (position, components) {
            var context = this.context;
            if (!this.utils.isArray(components)) {
                if (this._overrides[position]) {
                    this._parseComponent(components);
                    context[position] = components;
                    return;
                }
                components = [components];
            }
            var curr = components.length;
            while (curr-- > 0) {
                this._parseComponent(components[curr], context[position][curr]);
            }
            context[position] = components;
        };
        /**
         * Sets default component parameters and grabs custom actions from it.
         * @param {platui.INavbarComponent} newComponent The new INavbarComponent
         * to parse.
         * @param {platui.INavbarComponent} oldComponent? The old INavbarComponent
         * whose place is being taken.
         */
        Navbar.prototype._parseComponent = function (newComponent, oldComponent) {
            var utils = this.utils, isObject = utils.isObject, oldComponentExists = isObject(oldComponent), customActions, keys, key, currKey;
            if (oldComponentExists && utils.isUndefined(newComponent.content)) {
                newComponent.content = oldComponent.content;
            }
            if (!utils.isFunction(newComponent.action)) {
                newComponent.action = oldComponentExists ? oldComponent.action : noop;
            }
            customActions = newComponent.customActions;
            if (isObject(customActions)) {
                keys = Object.keys(customActions);
                currKey = keys.length;
                while (currKey-- > 0) {
                    key = keys[currKey];
                    this[key] = customActions[key];
                }
            }
        };
        /**
         * Executes the proper action associated with a Navbar component.
         * @param {plat.ui.IGestureEvent} ev The executed event.
         * @param {string} position The part of the Navbar whose action is being executed.
         * @param {any} property? The indexing property. Will by default be an index into the component Array.
         */
        Navbar.prototype._executeAction = function (ev, position, property) {
            var utils = this.utils, component = this.context[position];
            if (utils.isArray(component) && !utils.isNull(property)) {
                component = component[property];
            }
            if (utils.isFunction(component.action)) {
                component.action(ev);
                return;
            }
            this._log.debug("An action function is not defined for the component " + component + ".");
        };
        Navbar._inject = {
            _document: __Document
        };
        return Navbar;
    }(plat.ui.TemplateControl));
    platui.Navbar = Navbar;
    plat.register.control(__Navbar, Navbar, null, true);
    /**
     * An TemplateControl that keeps track of a loading image.
     */
    var Image = (function (_super) {
        __extends(Image, _super);
        function Image() {
            _super.apply(this, arguments);
            /**
             * The HTML template represented as a string.
             */
            this.templateString = '<div plat-control="' + __ProgressRing + '" class="plat-image-ring"></div>\n';
            /**
             * The image is a CSS background image. Defaults to false.
             */
            this._isBackground = false;
            /**
             * The HTMLImageElement use to source the image.
             */
            this._img = this._document.createElement('img');
        }
        /**
         * Sets the classes on the proper elements.
         * @param {string} className? An optional, additional class name or class names to set on the control
         * in addition to its standard set.
         * @param {Element} element? The element to set the class name on. Should default to
         * the control's element if not specified.
         */
        Image.prototype.setClasses = function (className, element) {
            this.dom.addClass(element || this.element, __Image + " " + (className || ''));
        };
        /**
         * Set the class name.
         */
        Image.prototype.initialize = function () {
            this.setClasses();
        };
        /**
         * Set the style and initialize the action.
         */
        Image.prototype.loaded = function () {
            var element = this.element, utils = this.utils, isString = utils.isString, isObject = utils.isObject, attributes = this.attributes, options = this.options, url;
            if (isString(url = attributes[__CamelSrc])) {
                attributes.observe(this._setSrc, __CamelSrc);
            }
            else if (isString(url = attributes[__src])) {
                attributes.observe(this._setSrc, __src);
            }
            else {
                return;
            }
            if (isObject(options) && isObject(options.value)) {
                this._isBackground = options.value.isBackground === true;
            }
            if (this._isBackground) {
                this.dom.addClass(element, __Plat + "background");
            }
            this._loader = element.firstElementChild;
            if (this._NodeManagerStatic.hasMarkup(url)) {
                return;
            }
            this._setSrc(url);
        };
        /**
         * Sets and sources the image to display.
         * @param {string} url The source URL to display.
         * @param {string} oldUrl? The old source URL that was being displayed.
         */
        Image.prototype._setSrc = function (url, oldUrl) {
            var _this = this;
            var img = this._img, element = this.element, dom = this.dom, imageLoad = __Plat + "load-image", imageError = __Image + "-error", loader = this._loader;
            dom.addClass(img, imageLoad);
            img.src = url;
            img.onload = function () {
                _this.utils.requestAnimationFrame(function () {
                    // remove error class in case image failed and then decides to load 
                    dom.removeClass(element, imageError);
                    if (_this._isBackground) {
                        element.style.backgroundImage = "url(\"" + url + "\")";
                        if (element.contains(img)) {
                            element.removeChild(img);
                        }
                        if (element.contains(loader)) {
                            element.removeChild(loader);
                        }
                        return;
                    }
                    dom.removeClass(img, imageLoad);
                    if (element.contains(loader)) {
                        element.removeChild(loader);
                    }
                });
            };
            img.onerror = function () {
                _this.utils.requestAnimationFrame(function () {
                    dom.addClass(element, imageError);
                    if (element.contains(img)) {
                        element.removeChild(img);
                    }
                    if (element.contains(loader)) {
                        element.removeChild(loader);
                    }
                });
            };
            element.insertBefore(loader, null);
            element.insertBefore(img, null);
        };
        Image._inject = {
            _compat: __Compat,
            _document: __Document,
            _NodeManagerStatic: __NodeManagerStatic
        };
        return Image;
    }(plat.ui.TemplateControl));
    platui.Image = Image;
    plat.register.control(__Image, Image);
})(platui || (platui = {}));
module.exports = platui;

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvc3JjL2FwcC9hcHAuanMiLCJhcHAvc3JjL21haW4uanMiLCJhcHAvc3JjL3JlcG9zaXRvcmllcy9iYXNlL2Jhc2UucmVwby5qcyIsImFwcC9zcmMvcmVwb3NpdG9yaWVzL2VudHJ5L2VudHJ5LnJlcG8uanMiLCJhcHAvc3JjL3NlcnZpY2VzL2Jhc2UvYmFzZS5zdmMuanMiLCJhcHAvc3JjL3NlcnZpY2VzL2VudHJ5L2VudHJ5LnN2Yy5qcyIsImFwcC9zcmMvdmlld2NvbnRyb2xzL2Jhc2UvYmFzZS52Yy5qcyIsImFwcC9zcmMvdmlld2NvbnRyb2xzL2hvbWUvaG9tZS52Yy5odG1sIiwiYXBwL3NyYy92aWV3Y29udHJvbHMvaG9tZS9ob21lLnZjLmpzIiwibm9kZV9tb2R1bGVzL3BsYXR5cHVzL2Rpc3QvcGxhdHlwdXMuanMiLCJub2RlX21vZHVsZXMvcGxhdHlwdXN1aS9kaXN0L3BsYXR5cHVzdWkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzZtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIGhvbWVfdmNfMSA9IHJlcXVpcmUoJy4uL3ZpZXdjb250cm9scy9ob21lL2hvbWUudmMnKTtcbnZhciBNeUFwcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE15QXBwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE15QXBwKHJvdXRlciwgY29uZmlnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICBjb25maWcucm91dGluZ1R5cGUgPSBjb25maWcuU1RBVEU7XG4gICAgICAgIHJvdXRlci5jb25maWd1cmUoW1xuICAgICAgICAgICAgeyBwYXR0ZXJuOiAnJywgdmlldzogaG9tZV92Y18xLmRlZmF1bHQgfVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgTXlBcHAucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2LmVycm9yKTtcbiAgICB9O1xuICAgIHJldHVybiBNeUFwcDtcbn0ocGxhdHlwdXNfMS5BcHApKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IE15QXBwO1xucGxhdHlwdXNfMS5yZWdpc3Rlci5hcHAoJ2FwcCcsIE15QXBwLCBbXG4gICAgcGxhdHlwdXNfMS5yb3V0aW5nLlJvdXRlcixcbiAgICBwbGF0eXB1c18xLndlYi5JQnJvd3NlckNvbmZpZ1xuXSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnJlcXVpcmUoJ3BsYXR5cHVzJyk7XG5yZXF1aXJlKCdwbGF0eXB1c3VpJyk7XG5yZXF1aXJlKCcuL2FwcC9hcHAnKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIEJhc2VSZXBvc2l0b3J5ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlUmVwb3NpdG9yeSgpIHtcbiAgICB9XG4gICAgQmFzZVJlcG9zaXRvcnkuX2luamVjdCA9IHtcbiAgICAgICAgdXRpbHM6IHBsYXR5cHVzXzEuVXRpbHNcbiAgICB9O1xuICAgIHJldHVybiBCYXNlUmVwb3NpdG9yeTtcbn0oKSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCYXNlUmVwb3NpdG9yeTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcGxhdHlwdXNfMSA9IHJlcXVpcmUoJ3BsYXR5cHVzJyk7XG52YXIgYmFzZV9yZXBvXzEgPSByZXF1aXJlKCcuLi9iYXNlL2Jhc2UucmVwbycpO1xudmFyIGVudHJ5X3N2Y18xID0gcmVxdWlyZSgnLi4vLi4vc2VydmljZXMvZW50cnkvZW50cnkuc3ZjJyk7XG52YXIgRW50cnlSZXBvc2l0b3J5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW50cnlSZXBvc2l0b3J5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVudHJ5UmVwb3NpdG9yeShlbnRyeVN2Yykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lbnRyeVN2YyA9IGVudHJ5U3ZjO1xuICAgIH1cbiAgICBFbnRyeVJlcG9zaXRvcnkucHJvdG90eXBlLmdldFJlZGRpdExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJ5U3ZjLmdldFJlZGRpdExpc3QoKTtcbiAgICB9O1xuICAgIHJldHVybiBFbnRyeVJlcG9zaXRvcnk7XG59KGJhc2VfcmVwb18xLmRlZmF1bHQpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVudHJ5UmVwb3NpdG9yeTtcbnBsYXR5cHVzXzEucmVnaXN0ZXIuaW5qZWN0YWJsZSgnZW50cnktcmVwbycsIEVudHJ5UmVwb3NpdG9yeSwgW2VudHJ5X3N2Y18xLmRlZmF1bHRdKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIEJhc2VTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXNlU2VydmljZSgpIHtcbiAgICAgICAgdGhpcy5ob3N0ID0gJ2h0dHBzOi8vd3d3LnJlZGRpdC5jb20vci9TaG93ZXJ0aG91Z2h0cy5qc29uJztcbiAgICB9XG4gICAgQmFzZVNlcnZpY2UuX2luamVjdCA9IHtcbiAgICAgICAgaHR0cDogcGxhdHlwdXNfMS5hc3luYy5IdHRwLFxuICAgICAgICBQcm9taXNlOiBwbGF0eXB1c18xLmFzeW5jLklQcm9taXNlLFxuICAgICAgICB1dGlsczogcGxhdHlwdXNfMS5VdGlsc1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VTZXJ2aWNlO1xufSgpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VTZXJ2aWNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBwbGF0eXB1c18xID0gcmVxdWlyZSgncGxhdHlwdXMnKTtcbnZhciBiYXNlX3N2Y18xID0gcmVxdWlyZSgnLi4vYmFzZS9iYXNlLnN2YycpO1xudmFyIEVudHJ5U2VydmljZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVudHJ5U2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbnRyeVNlcnZpY2UoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBFbnRyeVNlcnZpY2UucHJvdG90eXBlLmdldFJlZGRpdExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh0dHAuanNvbih7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgdXJsOiB0aGlzLmhvc3RcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3MucmVzcG9uc2U7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEVudHJ5U2VydmljZTtcbn0oYmFzZV9zdmNfMS5kZWZhdWx0KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFbnRyeVNlcnZpY2U7XG5wbGF0eXB1c18xLnJlZ2lzdGVyLmluamVjdGFibGUoJ2VudHJ5LXN2YycsIEVudHJ5U2VydmljZSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIEJhc2VWaWV3Q29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VWaWV3Q29udHJvbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlVmlld0NvbnRyb2woKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VWaWV3Q29udHJvbDtcbn0ocGxhdHlwdXNfMS51aS5WaWV3Q29udHJvbCkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZVZpZXdDb250cm9sO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcbjxwbGF0LWZvcmVhY2ggY2xhc3M9XFxcImVudHJ5LWxpc3RcXFwiIHBsYXQtY29udGV4dD1cXFwiZW50cmllc1xcXCI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImVudHJ5XFxcIj5cXG4gICAgICAgIDxwIGNsYXNzPVxcXCJ0aXRsZVxcXCI+e3t0aXRsZX19PC9wPlxcbiAgICAgICAgPHAgY2xhc3M9XFxcImF1dGhvclxcXCI+e3thdXRob3J9fTwvcD5cXG4gICAgPC9kaXY+XFxuPC9wbGF0LWZvcmVhY2g+XFxuXCI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHBsYXR5cHVzXzEgPSByZXF1aXJlKCdwbGF0eXB1cycpO1xudmFyIGJhc2VfdmNfMSA9IHJlcXVpcmUoJy4uL2Jhc2UvYmFzZS52YycpO1xudmFyIGVudHJ5X3JlcG9fMSA9IHJlcXVpcmUoJy4uLy4uL3JlcG9zaXRvcmllcy9lbnRyeS9lbnRyeS5yZXBvJyk7XG52YXIgSG9tZVZpZXdDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG9tZVZpZXdDb250cm9sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvbWVWaWV3Q29udHJvbChlbnRyeVJlcG8pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZW50cnlSZXBvID0gZW50cnlSZXBvO1xuICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gcmVxdWlyZSgnLi9ob21lLnZjLmh0bWwnKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgICAgICAgZW50cmllczogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIEhvbWVWaWV3Q29udHJvbC5wcm90b3R5cGUubmF2aWdhdGVkVG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW50cnlSZXBvLmdldFJlZGRpdExpc3QoKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldlIG1hZGUgaXQgdG8gdGhlIHJlZGRpdC5cIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdWNjZXNzKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRleHQuZW50cmllcyA9IHN1Y2Nlc3M7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVWgsIG9oLiBTb21ldGhpbmcncyBub3QgcmlnaHQuXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSG9tZVZpZXdDb250cm9sO1xufShiYXNlX3ZjXzEuZGVmYXVsdCkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gSG9tZVZpZXdDb250cm9sO1xucGxhdHlwdXNfMS5yZWdpc3Rlci52aWV3Q29udHJvbCgnaG9tZS12YycsIEhvbWVWaWV3Q29udHJvbCwgW2VudHJ5X3JlcG9fMS5kZWZhdWx0XSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxuLyogdHNsaW50OmRpc2FibGUgKi9cclxuLyoqXHJcbiAqIFBsYXR5cHVzVFMgdjAuMjAuNCAoaHR0cHM6Ly9wbGF0eXBpLmlvKVxyXG4gKiBDb3B5cmlnaHQgMjAxNSBQbGF0eXBpLCBMTEMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqXHJcbiAqIFBsYXR5cHVzVFMgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGF0XHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9QbGF0eXBpL3BsYXR5cHVzdHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxyXG4gKlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBlbnRyeSBwb2ludCBpbnRvIHRoZSBwbGF0eXB1cyBsaWJyYXJ5LlxyXG4gKi9cclxudmFyIHBsYXQ7XHJcbihmdW5jdGlvbiAocGxhdF8xKSB7XHJcbiAgICAndXNlIHN0cmljdDsnO1xyXG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICAvKlxyXG4gICAgICovXHJcbiAgICB2YXIgX19wcmVmaXggPSAnJCcsIF9fQ09OVEVYVCA9ICdjb250ZXh0JywgX19BcHBTdGF0aWMgPSBfX3ByZWZpeCArICdBcHBTdGF0aWMnLCBfX0FwcCA9IF9fcHJlZml4ICsgJ0FwcCcsIF9fSHR0cCA9IF9fcHJlZml4ICsgJ0h0dHAnLCBfX0h0dHBSZXF1ZXN0SW5zdGFuY2UgPSBfX3ByZWZpeCArICdIdHRwUmVxdWVzdEluc3RhbmNlJywgX19IdHRwQ29uZmlnID0gX19wcmVmaXggKyAnSHR0cENvbmZpZycsIF9fUHJvbWlzZSA9IF9fcHJlZml4ICsgJ1Byb21pc2UnLCBfX0NvbXBhdCA9IF9fcHJlZml4ICsgJ0NvbXBhdCcsIF9fQ29udHJvbEZhY3RvcnkgPSBfX3ByZWZpeCArICdDb250cm9sRmFjdG9yeScsIF9fQXR0cmlidXRlQ29udHJvbEZhY3RvcnkgPSBfX3ByZWZpeCArICdBdHRyaWJ1dGVDb250cm9sRmFjdG9yeScsIF9fRG9jdW1lbnQgPSBfX3ByZWZpeCArICdEb2N1bWVudCcsIF9fRGlzcGF0Y2hFdmVudEluc3RhbmNlID0gX19wcmVmaXggKyAnRGlzcGF0Y2hFdmVudEluc3RhbmNlJywgX19FcnJvckV2ZW50U3RhdGljID0gX19wcmVmaXggKyAnRXJyb3JFdmVudFN0YXRpYycsIF9fRXZlbnRNYW5hZ2VyU3RhdGljID0gX19wcmVmaXggKyAnRXZlbnRNYW5hZ2VyU3RhdGljJywgX19MaWZlY3ljbGVFdmVudFN0YXRpYyA9IF9fcHJlZml4ICsgJ0xpZmVjeWNsZUV2ZW50U3RhdGljJywgX19MaWZlY3ljbGVFdmVudEluc3RhbmNlID0gX19wcmVmaXggKyAnTGlmZWN5Y2xlRXZlbnRJbnN0YW5jZScsIF9fTG9nID0gX19wcmVmaXggKyAnTG9nJywgX19QYXJzZXIgPSBfX3ByZWZpeCArICdQYXJzZXInLCBfX1JlZ2V4ID0gX19wcmVmaXggKyAnUmVnZXgnLCBfX1Rva2VuaXplciA9IF9fcHJlZml4ICsgJ1Rva2VuaXplcicsIF9fTmF2aWdhdG9ySW5zdGFuY2UgPSBfX3ByZWZpeCArICdOYXZpZ2F0b3JJbnN0YW5jZScsIF9fQ29udGV4dE1hbmFnZXJTdGF0aWMgPSBfX3ByZWZpeCArICdDb250ZXh0TWFuYWdlclN0YXRpYycsIF9fQ29udGV4dE1hbmFnZXJJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0NvbnRleHRNYW5hZ2VySW5zdGFuY2UnLCBfX0NvbXBpbGVyID0gX19wcmVmaXggKyAnQ29tcGlsZXInLCBfX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeSA9IF9fcHJlZml4ICsgJ0NvbW1lbnRNYW5hZ2VyRmFjdG9yeScsIF9fQ29tbWVudE1hbmFnZXJJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0NvbW1lbnRNYW5hZ2VySW5zdGFuY2UnLCBfX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeSA9IF9fcHJlZml4ICsgJ0VsZW1lbnRNYW5hZ2VyRmFjdG9yeScsIF9fRWxlbWVudE1hbmFnZXJJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0VsZW1lbnRNYW5hZ2VySW5zdGFuY2UnLCBfX05vZGVNYW5hZ2VyU3RhdGljID0gX19wcmVmaXggKyAnTm9kZU1hbmFnZXJTdGF0aWMnLCBfX1RleHRNYW5hZ2VyRmFjdG9yeSA9IF9fcHJlZml4ICsgJ1RleHRNYW5hZ2VyRmFjdG9yeScsIF9fVGV4dE1hbmFnZXJJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ1RleHRNYW5hZ2VySW5zdGFuY2UnLCBfX0NhY2hlRmFjdG9yeSA9IF9fcHJlZml4ICsgJ0NhY2hlRmFjdG9yeScsIF9fTWFuYWdlckNhY2hlID0gX19wcmVmaXggKyAnTWFuYWdlckNhY2hlJywgX19UZW1wbGF0ZUNhY2hlID0gX19wcmVmaXggKyAnVGVtcGxhdGVDYWNoZScsIF9fQW5pbWF0b3IgPSBfX3ByZWZpeCArICdBbmltYXRvcicsIF9fQXR0cmlidXRlc0ZhY3RvcnkgPSBfX3ByZWZpeCArICdBdHRyaWJ1dGVzRmFjdG9yeScsIF9fQXR0cmlidXRlc0luc3RhbmNlID0gX19wcmVmaXggKyAnQXR0cmlidXRlc0luc3RhbmNlJywgX19CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgPSBfX3ByZWZpeCArICdCaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnknLCBfX0RvbSA9IF9fcHJlZml4ICsgJ0RvbScsIF9fRG9tRXZlbnRzID0gX19wcmVmaXggKyAnRG9tRXZlbnRzJywgX19JRG9tRXZlbnRzQ29uZmlnID0gX19wcmVmaXggKyAnSURvbUV2ZW50c0NvbmZpZycsIF9fRG9tRXZlbnRJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ0RvbUV2ZW50SW5zdGFuY2UnLCBfX1Jlc291cmNlc0ZhY3RvcnkgPSBfX3ByZWZpeCArICdSZXNvdXJjZXNGYWN0b3J5JywgX19SZXNvdXJjZXNJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ1Jlc291cmNlc0luc3RhbmNlJywgX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gX19wcmVmaXggKyAnVGVtcGxhdGVDb250cm9sRmFjdG9yeScsIF9fVGVtcGxhdGVDb250cm9sSW5zdGFuY2UgPSBfX3ByZWZpeCArICdUZW1wbGF0ZUNvbnRyb2xJbnN0YW5jZScsIF9fVXRpbHMgPSBfX3ByZWZpeCArICdVdGlscycsIF9fQnJvd3NlciA9IF9fcHJlZml4ICsgJ0Jyb3dzZXInLCBfX0Jyb3dzZXJDb25maWcgPSBfX3ByZWZpeCArICdCcm93c2VyQ29uZmlnJywgX19Sb3V0ZXIgPSBfX3ByZWZpeCArICdSb3V0ZXInLCBfX1JvdXRlclN0YXRpYyA9IF9fcHJlZml4ICsgJ1JvdXRlclN0YXRpYycsIF9fVXJsVXRpbHNJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ1VybFV0aWxzSW5zdGFuY2UnLCBfX1dpbmRvdyA9IF9fcHJlZml4ICsgJ1dpbmRvdycsIF9fTG9jYWxTdG9yYWdlID0gX19wcmVmaXggKyAnTG9jYWxTdG9yYWdlJywgX19TZXNzaW9uU3RvcmFnZSA9IF9fcHJlZml4ICsgJ1Nlc3Npb25TdG9yYWdlJywgX19HZW9sb2NhdGlvbiA9IF9fcHJlZml4ICsgJ0dlb2xvY2F0aW9uJywgX19CYXNlU2VnbWVudEZhY3RvcnkgPSBfX3ByZWZpeCArICdCYXNlU2VnbWVudEZhY3RvcnknLCBfX0Jhc2VTZWdtZW50SW5zdGFuY2UgPSBfX3ByZWZpeCArICdCYXNlU2VnbWVudEluc3RhbmNlJywgX19TdGF0aWNTZWdtZW50SW5zdGFuY2UgPSBfX3ByZWZpeCArICdTdGF0aWNTZWdtZW50SW5zdGFuY2UnLCBfX1ZhcmlhYmxlU2VnbWVudEluc3RhbmNlID0gX19wcmVmaXggKyAnVmFyaWFibGVTZWdtZW50SW5zdGFuY2UnLCBfX0R5bmFtaWNTZWdtZW50SW5zdGFuY2UgPSBfX3ByZWZpeCArICdEeW5hbWljU2VnbWVudEluc3RhbmNlJywgX19TcGxhdFNlZ21lbnRJbnN0YW5jZSA9IF9fcHJlZml4ICsgJ1NwbGF0U2VnbWVudEluc3RhbmNlJywgX19TdGF0ZVN0YXRpYyA9IF9fcHJlZml4ICsgJ1N0YXRlU3RhdGljJywgX19TdGF0ZUluc3RhbmNlID0gX19wcmVmaXggKyAnU3RhdGVJbnN0YW5jZScsIF9fUm91dGVSZWNvZ25pemVySW5zdGFuY2UgPSBfX3ByZWZpeCArICdSb3V0ZVJlY29nbml6ZXJJbnN0YW5jZScsIF9fSW5qZWN0b3JTdGF0aWMgPSBfX3ByZWZpeCArICdJbmplY3RvclN0YXRpYycsIF9fSGlzdG9yeSA9IF9fcHJlZml4ICsgJ0hpc3RvcnknLCBfX0xvY2F0aW9uID0gX19wcmVmaXggKyAnTG9jYXRpb24nLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX1BsYXQgPSAncGxhdC0nLCBfX0JpbmQgPSBfX1BsYXQgKyAnYmluZCcsIF9fSHJlZiA9IF9fUGxhdCArICdocmVmJywgX19TcmMgPSBfX1BsYXQgKyAnc3JjJywgX19LZXlEb3duID0gX19QbGF0ICsgJ2tleWRvd24nLCBfX0tleVByZXNzID0gX19QbGF0ICsgJ2tleXByZXNzJywgX19LZXlVcCA9IF9fUGxhdCArICdrZXl1cCcsIF9fQ2hhclByZXNzID0gX19QbGF0ICsgJ2NoYXJwcmVzcycsIF9fTmFtZSA9IF9fUGxhdCArICduYW1lJywgX19PcHRpb25zID0gX19QbGF0ICsgJ29wdGlvbnMnLCBfX0NoZWNrZWQgPSBfX1BsYXQgKyAnY2hlY2tlZCcsIF9fRGlzYWJsZWQgPSBfX1BsYXQgKyAnZGlzYWJsZWQnLCBfX1NlbGVjdGVkID0gX19QbGF0ICsgJ3NlbGVjdGVkJywgX19SZWFkT25seSA9IF9fUGxhdCArICdyZWFkb25seScsIF9fVmlzaWJsZSA9IF9fUGxhdCArICd2aXNpYmxlJywgX19TdHlsZSA9IF9fUGxhdCArICdzdHlsZScsIF9fVGFwID0gX19QbGF0ICsgJ3RhcCcsIF9fQmx1ciA9IF9fUGxhdCArICdibHVyJywgX19DaGFuZ2UgPSBfX1BsYXQgKyAnY2hhbmdlJywgX19Db3B5ID0gX19QbGF0ICsgJ2NvcHknLCBfX0N1dCA9IF9fUGxhdCArICdjdXQnLCBfX1Bhc3RlID0gX19QbGF0ICsgJ3Bhc3RlJywgX19EYmxUYXAgPSBfX1BsYXQgKyAnZGJsdGFwJywgX19Gb2N1cyA9IF9fUGxhdCArICdmb2N1cycsIF9fU3VibWl0ID0gX19QbGF0ICsgJ3N1Ym1pdCcsIF9fVG91Y2hTdGFydCA9IF9fUGxhdCArICd0b3VjaHN0YXJ0JywgX19Ub3VjaEVuZCA9IF9fUGxhdCArICd0b3VjaGVuZCcsIF9fVG91Y2hNb3ZlID0gX19QbGF0ICsgJ3RvdWNobW92ZScsIF9fVG91Y2hDYW5jZWwgPSBfX1BsYXQgKyAndG91Y2hjYW5jZWwnLCBfX0hvbGQgPSBfX1BsYXQgKyAnaG9sZCcsIF9fUmVsZWFzZSA9IF9fUGxhdCArICdyZWxlYXNlJywgX19Td2lwZSA9IF9fUGxhdCArICdzd2lwZScsIF9fU3dpcGVMZWZ0ID0gX19QbGF0ICsgJ3N3aXBlbGVmdCcsIF9fU3dpcGVSaWdodCA9IF9fUGxhdCArICdzd2lwZXJpZ2h0JywgX19Td2lwZVVwID0gX19QbGF0ICsgJ3N3aXBldXAnLCBfX1N3aXBlRG93biA9IF9fUGxhdCArICdzd2lwZWRvd24nLCBfX1RyYWNrID0gX19QbGF0ICsgJ3RyYWNrJywgX19UcmFja0xlZnQgPSBfX1BsYXQgKyAndHJhY2tsZWZ0JywgX19UcmFja1JpZ2h0ID0gX19QbGF0ICsgJ3RyYWNrcmlnaHQnLCBfX1RyYWNrVXAgPSBfX1BsYXQgKyAndHJhY2t1cCcsIF9fVHJhY2tEb3duID0gX19QbGF0ICsgJ3RyYWNrZG93bicsIF9fVHJhY2tFbmQgPSBfX1BsYXQgKyAndHJhY2tlbmQnLCBfX1JlYWN0ID0gX19QbGF0ICsgJ3JlYWN0JywgX19MaW5rID0gX19QbGF0ICsgJ2xpbmsnLCBfX0ZvckVhY2ggPSBfX1BsYXQgKyAnZm9yZWFjaCcsIF9fSHRtbCA9IF9fUGxhdCArICdodG1sJywgX19JZiA9IF9fUGxhdCArICdpZicsIF9fSWdub3JlID0gX19QbGF0ICsgJ2lnbm9yZScsIF9fU2VsZWN0ID0gX19QbGF0ICsgJ3NlbGVjdCcsIF9fVGVtcGxhdGUgPSBfX1BsYXQgKyAndGVtcGxhdGUnLCBfX1JvdXRlcG9ydCA9IF9fUGxhdCArICdyb3V0ZXBvcnQnLCBfX1ZpZXdwb3J0ID0gX19QbGF0ICsgJ3ZpZXdwb3J0JywgX19Db250cm9sID0gX19QbGF0ICsgJ2NvbnRyb2wnLCBfX1ZpZXdDb250cm9sID0gX19QbGF0ICsgJ3ZpZXdjb250cm9sJywgX19SZXNvdXJjZXMgPSBfX1BsYXQgKyAncmVzb3VyY2VzJywgX19Db250ZXh0ID0gX19QbGF0ICsgX19DT05URVhULCBfX1RlbXBsYXRlQ29udGV4dCA9IF9fVGVtcGxhdGUgKyAnLScgKyBfX0NPTlRFWFQsIF9fQ2FsbGJhY2sgPSBfX1BsYXQgKyAnY2FsbGJhY2snLCBfX0F0dHJpYnV0ZVByZWZpeCA9ICdkYXRhLScsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fVGVtcGxhdGVDb250cm9sQ2FjaGUgPSAnX190ZW1wbGF0ZUNvbnRyb2xDYWNoZScsIF9fSGVhZCA9ICdoZWFkJywgX19NZXRhID0gJ21ldGEnLCBfX1RpdGxlID0gJ3RpdGxlJywgX19EZXNjcmlwdGlvbiA9ICdkZXNjcmlwdGlvbicsIF9fQXV0aG9yID0gJ2F1dGhvcicsIF9fQ3JlYXRvciA9ICdjcmVhdG9yJywgX19NZXRhTGluayA9ICdsaW5rJywgX19NZXRhSHJlZiA9ICdocmVmJywgX19NZXRhTmFtZSA9ICduYW1lJywgX19NZXRhUHJvcGVydHkgPSAncHJvcGVydHknLCBfX01ldGFJbWFnZSA9ICdpbWFnZScsIF9fTWV0YVZpZGVvID0gJ3ZpZGVvJywgX19NZXRhVHlwZSA9ICd0eXBlJywgX19SZWwgPSAncmVsJywgX19VcmwgPSAndXJsJywgX19BcnRpY2xlID0gJ2FydGljbGU6JywgX19PcGVuR3JhcGggPSAnb2c6JywgX19Ud2l0dGVyID0gJ3R3aXR0ZXI6JywgX19Db250ZW50ID0gJ2NvbnRlbnQnLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX3JlYWR5ID0gJ3JlYWR5JywgX19zdXNwZW5kID0gJ3N1c3BlbmQnLCBfX3Jlc3VtZSA9ICdyZXN1bWUnLCBfX29ubGluZSA9ICdvbmxpbmUnLCBfX29mZmxpbmUgPSAnb2ZmbGluZScsIF9fZXJyb3IgPSAnZXJyb3InLCBfX3NodXRkb3duID0gJ3NodXRkb3duJywgX19leGl0aW5nID0gJ2V4aXRpbmcnLCBfX2JlZm9yZUxvYWQgPSAnYmVmb3JlTG9hZCcsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fYmVmb3JlTmF2aWdhdGUgPSAnYmVmb3JlTmF2aWdhdGUnLCBfX25hdmlnYXRlZCA9ICduYXZpZ2F0ZWQnLCBfX25hdmlnYXRpbmcgPSAnbmF2aWdhdGluZycsIF9fYmVmb3JlUm91dGVDaGFuZ2UgPSAnYmVmb3JlUm91dGVDaGFuZ2UnLCBfX3JvdXRlQ2hhbmdlZCA9ICdyb3V0ZUNoYW5nZWQnLCBfX3VybENoYW5nZWQgPSAndXJsQ2hhbmdlZCcsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fcGF1c2UgPSAncGF1c2UnLCBfX2RldmljZVJlYWR5ID0gJ2RldmljZVJlYWR5JywgX19iYWNrQnV0dG9uID0gJ2JhY2tidXR0b24nLCBfX2JhY2tDbGljayA9ICdiYWNrY2xpY2snLCBfX2JhY2tCdXR0b25QcmVzc2VkID0gJ2JhY2tCdXR0b25QcmVzc2VkJywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19IaWRlID0gX19QbGF0ICsgJ2hpZGUnLCBfX0FuaW1hdGluZyA9IF9fUGxhdCArICdhbmltYXRpbmcnLCBfX1NpbXBsZUFuaW1hdGlvbiA9IF9fUGxhdCArICdhbmltYXRpb24nLCBfX1NpbXBsZVRyYW5zaXRpb24gPSBfX1BsYXQgKyAndHJhbnNpdGlvbicsIF9fRW50ZXIgPSBfX1BsYXQgKyAnZW50ZXInLCBfX0xlYXZlID0gX19QbGF0ICsgJ2xlYXZlJywgX19Nb3ZlID0gX19QbGF0ICsgJ21vdmUnLCBfX0ZhZGVJbiA9IF9fUGxhdCArICdmYWRlaW4nLCBfX0ZhZGVPdXQgPSBfX1BsYXQgKyAnZmFkZW91dCcsIF9fTmF2aWdhdGluZ0JhY2sgPSBfX1BsYXQgKyAnYmFjay1uYXYnLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX2V2ZW50X3ByZWZpeCA9ICckJywgX190YXAgPSBfX2V2ZW50X3ByZWZpeCArICd0YXAnLCBfX2RibHRhcCA9IF9fZXZlbnRfcHJlZml4ICsgJ2RibHRhcCcsIF9fdG91Y2hzdGFydCA9IF9fZXZlbnRfcHJlZml4ICsgJ3RvdWNoc3RhcnQnLCBfX3RvdWNoZW5kID0gX19ldmVudF9wcmVmaXggKyAndG91Y2hlbmQnLCBfX3RvdWNobW92ZSA9IF9fZXZlbnRfcHJlZml4ICsgJ3RvdWNobW92ZScsIF9fdG91Y2hjYW5jZWwgPSBfX2V2ZW50X3ByZWZpeCArICd0b3VjaGNhbmNlbCcsIF9faG9sZCA9IF9fZXZlbnRfcHJlZml4ICsgJ2hvbGQnLCBfX3JlbGVhc2UgPSBfX2V2ZW50X3ByZWZpeCArICdyZWxlYXNlJywgX19zd2lwZSA9IF9fZXZlbnRfcHJlZml4ICsgJ3N3aXBlJywgX19zd2lwZWxlZnQgPSBfX2V2ZW50X3ByZWZpeCArICdzd2lwZWxlZnQnLCBfX3N3aXBlcmlnaHQgPSBfX2V2ZW50X3ByZWZpeCArICdzd2lwZXJpZ2h0JywgX19zd2lwZXVwID0gX19ldmVudF9wcmVmaXggKyAnc3dpcGV1cCcsIF9fc3dpcGVkb3duID0gX19ldmVudF9wcmVmaXggKyAnc3dpcGVkb3duJywgX190cmFjayA9IF9fZXZlbnRfcHJlZml4ICsgJ3RyYWNrJywgX190cmFja2xlZnQgPSBfX2V2ZW50X3ByZWZpeCArICd0cmFja2xlZnQnLCBfX3RyYWNrcmlnaHQgPSBfX2V2ZW50X3ByZWZpeCArICd0cmFja3JpZ2h0JywgX190cmFja3VwID0gX19ldmVudF9wcmVmaXggKyAndHJhY2t1cCcsIF9fdHJhY2tkb3duID0gX19ldmVudF9wcmVmaXggKyAndHJhY2tkb3duJywgX190cmFja2VuZCA9IF9fZXZlbnRfcHJlZml4ICsgJ3RyYWNrZW5kJywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19lcnJvclN1ZmZpeCA9ICdFcnJvcicsIF9fcGxhdEVycm9yID0gJ1BsYXQnICsgX19lcnJvclN1ZmZpeCwgX19wYXJzZUVycm9yID0gJ1BhcnNpbmcnICsgX19lcnJvclN1ZmZpeCwgX19iaW5kRXJyb3IgPSAnQmluZGluZycgKyBfX2Vycm9yU3VmZml4LCBfX2NvbXBpbGVFcnJvciA9ICdDb21waWxpbmcnICsgX19lcnJvclN1ZmZpeCwgX19uYW1lRXJyb3IgPSAnUGxhdE5hbWUnICsgX19lcnJvclN1ZmZpeCwgX19uYXZpZ2F0aW9uRXJyb3IgPSAnTmF2aWdhdGluZycgKyBfX2Vycm9yU3VmZml4LCBfX3RlbXBsYXRlRXJyb3IgPSAnVGVtcGxhdGluZycgKyBfX2Vycm9yU3VmZml4LCBfX2NvbnRleHRFcnJvciA9ICdDb250ZXh0JyArIF9fZXJyb3JTdWZmaXgsIF9fZXZlbnRFcnJvciA9ICdEaXNwYXRjaEV2ZW50JyArIF9fZXJyb3JTdWZmaXgsIF9faW5qZWN0YWJsZUVycm9yID0gJ0luamVjdGFibGUnICsgX19lcnJvclN1ZmZpeCwgX19Db21wYXRFcnJvciA9ICdDb21wYXRpYmlsaXR5JyArIF9fZXJyb3JTdWZmaXgsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fZm9yRWFjaEFsaWFzT3B0aW9ucyA9IHtcclxuICAgICAgICBpbmRleDogJ2luZGV4JyxcclxuICAgICAgICBldmVuOiAnZXZlbicsXHJcbiAgICAgICAgb2RkOiAnb2RkJyxcclxuICAgICAgICBmaXJzdDogJ2ZpcnN0JyxcclxuICAgICAgICBsYXN0OiAnbGFzdCdcclxuICAgIH0sIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fQkFTRV9TRUdNRU5UX1RZUEUgPSAnYmFzZScsIF9fVkFSSUFCTEVfU0VHTUVOVF9UWVBFID0gJ3ZhcmlhYmxlJywgX19TVEFUSUNfU0VHTUVOVF9UWVBFID0gJ3N0YXRpYycsIF9fU1BMQVRfU0VHTUVOVF9UWVBFID0gJ3NwbGF0JywgX19EWU5BTUlDX1NFR01FTlRfVFlQRSA9ICdkeW5hbWljJywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19DT05URVhUX0NIQU5HRURfUFJJT1JJVFkgPSAxMDAwLCBfX3N0YXJ0U3ltYm9sID0gJ3t7JywgX19lbmRTeW1ib2wgPSAnfX0nLCBfX1NUQVRJQyA9ICdzdGF0aWMnLCBfX1NJTkdMRVRPTiA9ICdzaW5nbGV0b24nLCBfX0lOU1RBTkNFID0gJ2luc3RhbmNlJywgX19GQUNUT1JZID0gJ2ZhY3RvcnknLCBfX0NMQVNTID0gJ2NsYXNzJywgX19DU1MgPSAnY3NzJywgX19DT01QSUxFRCA9ICctY29tcGlsZWQnLCBfX0JPVU5EX1BSRUZJWCA9ICctQCcsIF9fSU5JVF9TVUZGSVggPSAnLWluaXQnLCBfX1NUQVJUX05PREUgPSAnOiBzdGFydCBub2RlJywgX19FTkRfTk9ERSA9ICc6IGVuZCBub2RlJywgX19QT1BTVEFURSA9ICdwb3BzdGF0ZScsIF9fSEFTSENIQU5HRSA9ICdoYXNoY2hhbmdlJywgX19XUkFQUEVEX0lOSkVDVE9SID0gJ3dyYXBwZWQnLCBfX0pTT05QX0NBTExCQUNLID0gJ3BsYXRfY2FsbGJhY2snLCBfX0pTID0gJ2pzJywgX19OT09QX0lOSkVDVE9SID0gJ25vb3AnLCBfX0FQUCA9ICdfX2FwcF9fJywgX19SRVNPVVJDRSA9ICdyZXNvdXJjZScsIF9fUkVTT1VSQ0VTID0gX19SRVNPVVJDRSArICdzJywgX19BTElBUyA9ICdhbGlhcycsIF9fQUxJQVNFUyA9IF9fQUxJQVMgKyAnZXMnLCBfX09CU0VSVkFCTEVfUkVTT1VSQ0UgPSAnb2JzZXJ2YWJsZScsIF9fSU5KRUNUQUJMRV9SRVNPVVJDRSA9ICdpbmplY3RhYmxlJywgX19PQkpFQ1RfUkVTT1VSQ0UgPSAnb2JqZWN0JywgX19GVU5DVElPTl9SRVNPVVJDRSA9ICdmdW5jdGlvbicsIF9fTElURVJBTF9SRVNPVVJDRSA9ICdsaXRlcmFsJywgX19ST09UX1JFU09VUkNFID0gJ3Jvb3QnLCBfX1JPT1RfQ09OVEVYVF9SRVNPVVJDRSA9ICdyb290Q29udGV4dCcsIF9fQ09OVFJPTF9SRVNPVVJDRSA9ICdjb250cm9sJywgX19DT05URVhUX1JFU09VUkNFID0gX19DT05URVhUO1xyXG4gICAgLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbiAgICB2YXIgX19fUHJvbWlzZSwgX19fY29tcGF0LCBfX2NhbWVsQ2FzZVJlZ2V4LCBfX2NhcGl0YWxDYXNlUmVnZXgsIF9fbmF0aXZlSXNBcnJheSA9ICEhQXJyYXkuaXNBcnJheTtcclxuICAgIHZhciBfX3VpZHMgPSB7fSwgX19vYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsIF9fdG9TdHJpbmdDbGFzcyA9ICdbb2JqZWN0ICcsIF9fZXJyb3JDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdFcnJvcl0nLCBfX2ZpbGVDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdGaWxlXScsIF9fYXJyYXlDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdBcnJheV0nLCBfX2Jvb2xDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdCb29sZWFuXScsIF9fZGF0ZUNsYXNzID0gX190b1N0cmluZ0NsYXNzICsgJ0RhdGVdJywgX19mdW5jQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnRnVuY3Rpb25dJywgX19udW1iZXJDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdOdW1iZXJdJywgX19vYmplY3RDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdPYmplY3RdJywgX19yZWdleHBDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdSZWdFeHBdJywgX19zdHJpbmdDbGFzcyA9IF9fdG9TdHJpbmdDbGFzcyArICdTdHJpbmddJywgX19wcm9taXNlQ2xhc3MgPSBfX3RvU3RyaW5nQ2xhc3MgKyAnUHJvbWlzZV0nLCBfX29iamVjdFR5cGVzID0ge1xyXG4gICAgICAgICdib29sZWFuJzogZmFsc2UsXHJcbiAgICAgICAgJ2Z1bmN0aW9uJzogdHJ1ZSxcclxuICAgICAgICAnb2JqZWN0JzogdHJ1ZSxcclxuICAgICAgICAnbnVtYmVyJzogZmFsc2UsXHJcbiAgICAgICAgJ3N0cmluZyc6IGZhbHNlLFxyXG4gICAgICAgICd1bmRlZmluZWQnOiBmYWxzZVxyXG4gICAgfTtcclxuICAgIGZ1bmN0aW9uIG5vb3AoKSB7IH1cclxuICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUsIGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBlbnVtZXJhYmxlID09PSB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZ3VyYWJsZSA9PT0gdHJ1ZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IHdyaXRhYmxlID09PSB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfZGVmaW5lR2V0dGVyKG9iaiwga2V5LCB2YWx1ZSwgZW51bWVyYWJsZSwgY29uZmlndXJhYmxlKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUgPT09IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlndXJhYmxlID09PSB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfZXh0ZW5kKGRlZXAsIHJlZGVmaW5lLCBkZXN0aW5hdGlvbikge1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAzOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgc291cmNlc1tfaSAtIDNdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTnVsbChkZXN0aW5hdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5cywgcHJvcGVydHksIGRlZmluZTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihyZWRlZmluZSkpIHtcclxuICAgICAgICAgICAgZGVmaW5lID0gcmVkZWZpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlZGVmaW5lKSB7XHJcbiAgICAgICAgICAgIGRlZmluZSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRW1wdHkoc291cmNlcykpIHtcclxuICAgICAgICAgICAgc291cmNlcy5wdXNoKGRlc3RpbmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAoc291cmNlLCBrKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgICAgICAgICBmb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gc291cmNlW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kKGRlZXAsIGRlZmluZSwgZGVzdGluYXRpb25ba2V5XSB8fCAoZGVzdGluYXRpb25ba2V5XSA9IFtdKSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0ZShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKGRlc3RpbmF0aW9uLCBrZXksIG5ldyBEYXRlKHByb3BlcnR5LmdldFRpbWUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmUoZGVzdGluYXRpb24sIGtleSwgbmV3IFJlZ0V4cChwcm9wZXJ0eSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTm9kZShwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKGRlc3RpbmF0aW9uLCBrZXksIHByb3BlcnR5LmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGaWxlKHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmUoZGVzdGluYXRpb24sIGtleSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kKGRlZXAsIGRlZmluZSwgZGVzdGluYXRpb25ba2V5XSB8fCAoZGVzdGluYXRpb25ba2V5XSA9IHt9KSwgcHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmaW5lKGRlc3RpbmF0aW9uLCBrZXksIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgfSwga2V5cyk7XHJcbiAgICAgICAgfSwgc291cmNlcyk7XHJcbiAgICAgICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX2Nsb25lKG9iaiwgZGVlcCkge1xyXG4gICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0RhdGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUob2JqLmdldFRpbWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iai5jbG9uZU5vZGUoZGVlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzRmlsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3Iob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IG9iai5jb25zdHJ1Y3RvcihvYmoubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlID0ge307XHJcbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xyXG4gICAgICAgICAgICB0eXBlID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Jvb2xlYW4oZGVlcCkgJiYgZGVlcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZCh0cnVlLCBmYWxzZSwgdHlwZSwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9leHRlbmQoZmFsc2UsIGZhbHNlLCB0eXBlLCBvYmopO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNFcnJvcihvYmopIHtcclxuICAgICAgICByZXR1cm4gX19vYmpUb1N0cmluZy5jYWxsKG9iaikgPT09IF9fZXJyb3JDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xyXG4gICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLmRvY3VtZW50ICYmIG9iai5zZXRJbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0RvY3VtZW50KG9iaikge1xyXG4gICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNOb2RlKG9iaikge1xyXG4gICAgICAgIHJldHVybiAhIShvYmogJiYgdHlwZW9mIG9iai5ub2RlVHlwZSA9PT0gJ251bWJlcicpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KG9iaikge1xyXG4gICAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNGaWxlKG9iaikge1xyXG4gICAgICAgIHJldHVybiBpc09iamVjdChvYmopICYmIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX2ZpbGVDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyB8fCBpc09iamVjdChvYmopICYmIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX3N0cmluZ0NsYXNzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgX19vYmpUb1N0cmluZy5jYWxsKG9iaikgPT09IF9fcmVnZXhwQ2xhc3M7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgKF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX3Byb21pc2VDbGFzcyB8fCBpc0Z1bmN0aW9uKG9iai50aGVuKSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgICAgIGlmIChpc051bGwob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKG9iaikgfHwgaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IGlzT2JqZWN0KG9iaikgJiYgX19vYmpUb1N0cmluZy5jYWxsKG9iaikgPT09IF9fYm9vbENsYXNzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCBpc09iamVjdChvYmopICYmIF9fb2JqVG9TdHJpbmcuY2FsbChvYmopID09PSBfX251bWJlckNsYXNzKSAmJiAhaXNOYU4ob2JqKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc051bGwob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XHJcbiAgICAgICAgaWYgKF9fbmF0aXZlSXNBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX19vYmpUb1N0cmluZy5jYWxsKG9iaikgPT09IF9fYXJyYXlDbGFzcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xyXG4gICAgICAgIGlmIChpc051bGwob2JqKSB8fCBpc1dpbmRvdyhvYmopIHx8IGlzRnVuY3Rpb24ob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc1N0cmluZyhvYmopIHx8IG9iai5sZW5ndGggPj0gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGlzRGF0ZShvYmopIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cmluZy5jYWxsKG9iaikgPT09IF9fZGF0ZUNsYXNzO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gZmlsdGVyKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgaWYgKGlzTnVsbChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iai5maWx0ZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouZmlsdGVyKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSwgb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVyYXRvcih2YWx1ZSwga2V5LCBvYmopKSB7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBvYmopO1xyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB3aGVyZShwcm9wZXJ0aWVzLCBvYmopIHtcclxuICAgICAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXNvbWUoZnVuY3Rpb24gKHByb3BlcnR5LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldICE9PSBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgfSwgcHJvcGVydGllcyk7XHJcbiAgICAgICAgfSwgb2JqKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZvckVhY2goaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgIGlmIChpc051bGwob2JqKSB8fCAhKGlzT2JqZWN0KG9iaikgfHwgaXNBcnJheUxpa2Uob2JqKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGksIGtleSwgbGVuZ3RoO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iai5mb3JFYWNoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWFwKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgYXJyID0gW107XHJcbiAgICAgICAgaWYgKGlzTnVsbChvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iai5tYXApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgICAgICBhcnIucHVzaChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBrZXksIG9iaikpO1xyXG4gICAgICAgIH0sIG9iaik7XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcEFzeW5jKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpIHtcclxuICAgICAgICBfX19Qcm9taXNlID0gX19fUHJvbWlzZSB8fCBwbGF0LmFjcXVpcmUoX19Qcm9taXNlKTtcclxuICAgICAgICByZXR1cm4gX19fUHJvbWlzZS5hbGwobWFwKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcEFzeW5jV2l0aE9yZGVyKGl0ZXJhdG9yLCBhcnJheSwgY29udGV4dCwgZGVzY2VuZGluZykge1xyXG4gICAgICAgIF9fX1Byb21pc2UgPSBfX19Qcm9taXNlIHx8IHBsYXQuYWNxdWlyZShfX1Byb21pc2UpO1xyXG4gICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBfX19Qcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgIGlmICghaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlcmF0b3IgPSBpdGVyYXRvci5iaW5kKGNvbnRleHQpO1xyXG4gICAgICAgIHZhciBpbk9yZGVyID0gZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIG5leHRWYWx1ZSwgbmV4dEluZGV4LCBhcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZS50aGVuKGZ1bmN0aW9uIChpdGVtcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yKG5leHRWYWx1ZSwgbmV4dEluZGV4LCBhcnJheSkudGhlbihmdW5jdGlvbiAobW9yZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLmNvbmNhdChtb3JlSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGRlc2NlbmRpbmcgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5LnJlZHVjZVJpZ2h0KGluT3JkZXIsIGluaXRpYWxWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheS5yZWR1Y2UoaW5PcmRlciwgaW5pdGlhbFZhbHVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcEFzeW5jSW5PcmRlcihpdGVyYXRvciwgYXJyYXksIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gbWFwQXN5bmNXaXRoT3JkZXIoaXRlcmF0b3IsIGFycmF5LCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1hcEFzeW5jSW5EZXNjZW5kaW5nT3JkZXIoaXRlcmF0b3IsIGFycmF5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcEFzeW5jV2l0aE9yZGVyKGl0ZXJhdG9yLCBhcnJheSwgY29udGV4dCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwbHVjayhrZXksIG9iaikge1xyXG4gICAgICAgIHJldHVybiBtYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LCBvYmopO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc29tZShpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChvYmopIHx8IGlzRnVuY3Rpb24ob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpLCBrZXksIGxlbmd0aCwgcmV0O1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9iai5zb21lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLnNvbWUoaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0FycmF5TGlrZShvYmopKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAocmV0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICAgICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IGtleXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHJldCA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwb3N0cG9uZShtZXRob2QsIGFyZ3MsIGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gZGVmZXIobWV0aG9kLCAwLCBhcmdzLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlZmVyKG1ldGhvZCwgdGltZW91dCwgYXJncywgY29udGV4dCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWNEZWZlcigpIHtcclxuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGltZW91dElkID0gc2V0VGltZW91dChleGVjRGVmZXIsIHRpbWVvdXQpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzZXRJbnRlcnZhbEdsb2JhbChtZXRob2QsIGludGVydmFsLCBhcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZXhlY0ludGVydmFsKCkge1xyXG4gICAgICAgICAgICBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoZXhlY0ludGVydmFsLCBpbnRlcnZhbCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKG1ldGhvZCwgY29udGV4dCkge1xyXG4gICAgICAgIF9fX2NvbXBhdCA9IF9fX2NvbXBhdCB8fCAocGxhdC5hY3F1aXJlKF9fQ29tcGF0KSk7XHJcbiAgICAgICAgdmFyIHJlcXVlc3RBbmltRnJhbWUgPSBfX19jb21wYXQucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChyZXF1ZXN0QW5pbUZyYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoY29udGV4dCwgRGF0ZS5ub3coKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYW5pbWF0aW9uSWQgPSByZXF1ZXN0QW5pbUZyYW1lKG1ldGhvZC5iaW5kKGNvbnRleHQpKSwgY2FuY2VsQW5pbUZyYW1lID0gX19fY29tcGF0LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IG5vb3A7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbUZyYW1lKGFuaW1hdGlvbklkKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdW5pcXVlSWQocHJlZml4KSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChwcmVmaXgpKSB7XHJcbiAgICAgICAgICAgIHByZWZpeCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHVpZCA9IF9fdWlkc1twcmVmaXhdO1xyXG4gICAgICAgIGlmIChpc051bGwocHVpZCkpIHtcclxuICAgICAgICAgICAgcHVpZCA9IF9fdWlkc1twcmVmaXhdID0gWycwJywgJy8nXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gcHVpZC5sZW5ndGgsIGNoYXJDb2RlO1xyXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gcHVpZFtpbmRleF0uY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgLy8gJzknIFxyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDU3KSB7XHJcbiAgICAgICAgICAgICAgICBwdWlkW2luZGV4XSA9ICdBJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gJ1onIFxyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDkwKSB7XHJcbiAgICAgICAgICAgICAgICBwdWlkW2luZGV4XSA9ICdhJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gJ3onIFxyXG4gICAgICAgICAgICBpZiAoY2hhckNvZGUgPT09IDEyMikge1xyXG4gICAgICAgICAgICAgICAgcHVpZFtpbmRleF0gPSAnMCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwdWlkW2luZGV4XSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUgKyAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHVpZC51bnNoaWZ0KCcwJyk7XHJcbiAgICAgICAgZnVuY3Rpb24gam9pbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIHB1aWQuam9pbignJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBqb2luKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyKSB7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8IGlzRW1wdHkoc3RyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgX19jYW1lbENhc2VSZWdleCA9IF9fY2FtZWxDYXNlUmVnZXggfHwgcGxhdC5hY3F1aXJlKF9fUmVnZXgpLmNhbWVsQ2FzZVJlZ2V4O1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShfX2NhbWVsQ2FzZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gsIGRlbGltaXRlciwgY2hhciwgaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ID8gY2hhci50b1VwcGVyQ2FzZSgpIDogY2hhcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlbGltaXQoc3RyLCBkZWxpbWl0ZXIpIHtcclxuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgaXNFbXB0eShzdHIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTnVsbChkZWxpbWl0ZXIpKSB7XHJcbiAgICAgICAgICAgIGRlbGltaXRlciA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfX2NhcGl0YWxDYXNlUmVnZXggPSBfX2NhcGl0YWxDYXNlUmVnZXggfHwgcGxhdC5hY3F1aXJlKF9fUmVnZXgpLmNhcGl0YWxDYXNlUmVnZXg7XHJcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKF9fY2FwaXRhbENhc2VSZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXggPyBkZWxpbWl0ZXIgKyBtYXRjaC50b0xvd2VyQ2FzZSgpIDogbWF0Y2gudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGRlbGV0ZVByb3BlcnR5KG9iaiwgcHJvcGVydHkpIHtcclxuICAgICAgICBpZiAoIWlzTnVsbChvYmopKSB7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC1leHByZXNzaW9uICovXHJcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbcHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWNjZXNzKG9iaiwgcHJvcGVydHkpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKG9iaikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9ialtwcm9wZXJ0eV07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZVF1ZXJ5KHNlYXJjaCkge1xyXG4gICAgICAgIGlmIChpc0VtcHR5KHNlYXJjaCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3BsaXQgPSBzZWFyY2guc3BsaXQoJyYnKSwgcXVlcnkgPSB7fSwgbGVuZ3RoID0gc3BsaXQubGVuZ3RoLCBpdGVtO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaXRlbSA9IHNwbGl0W2ldLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIHF1ZXJ5W2l0ZW1bMF1dID0gaXRlbVsxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplUXVlcnkocXVlcnkpIHtcclxuICAgICAgICB2YXIgcSA9ICcnO1xyXG4gICAgICAgIHEgKz0gbWFwKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXkgKyAnPScgKyB2YWx1ZTtcclxuICAgICAgICB9LCBxdWVyeSkuam9pbignJicpO1xyXG4gICAgICAgIGlmICghaXNFbXB0eShxKSkge1xyXG4gICAgICAgICAgICBxID0gJz8nICsgcTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBib29sZWFuUmVkdWNlKHZhbHVlcykge1xyXG4gICAgICAgIGlmICghaXNBcnJheSh2YWx1ZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0Jvb2xlYW4odmFsdWVzKSA/IHZhbHVlcyA6IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICYmIGN1cnJlbnQgIT09IGZhbHNlO1xyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG4gICAgdmFyIF9fX2RvY3VtZW50LCBfX190ZW1wbGF0ZUNhY2hlLCBfX19odHRwLCBfX19sb2c7XHJcbiAgICB2YXIgX19ub2RlTmFtZVJlZ2V4ID0gLzwoW1xcdzpdKykvLCBfX3doaXRlU3BhY2VSZWdleCA9IC9cXHMrL2csIF9fb3B0aW9uID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J10sIF9fdGFibGUgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXSwgX190YWJsZURhdGEgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXSwgX19zdmcgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZlcnNpb249XCIxLjFcIj4nLCAnPC9zdmc+J10sIF9faW5uZXJUYWJsZVdyYXBwZXJzID0ge1xyXG4gICAgICAgIHRoZWFkOiBfX3RhYmxlLFxyXG4gICAgICAgIHRib2R5OiBfX3RhYmxlLFxyXG4gICAgICAgIHRmb290OiBfX3RhYmxlLFxyXG4gICAgICAgIGNvbGdyb3VwOiBfX3RhYmxlLFxyXG4gICAgICAgIGNhcHRpb246IF9fdGFibGUsXHJcbiAgICAgICAgdHI6IFsyLCAnPHRhYmxlPjx0Ym9keT4nLCAnPC90Ym9keT48L3RhYmxlPiddLFxyXG4gICAgICAgIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXHJcbiAgICAgICAgdGQ6IF9fdGFibGVEYXRhLFxyXG4gICAgICAgIHRoOiBfX3RhYmxlRGF0YVxyXG4gICAgfSwgX19pbm5lckh0bWxXcmFwcGVycyA9IF9leHRlbmQoZmFsc2UsIGZhbHNlLCB7fSwgX19pbm5lclRhYmxlV3JhcHBlcnMsIHtcclxuICAgICAgICBvcHRpb246IF9fb3B0aW9uLFxyXG4gICAgICAgIG9wdGdyb3VwOiBfX29wdGlvbixcclxuICAgICAgICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxyXG4gICAgICAgIGFyZWE6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXHJcbiAgICAgICAgcGFyYW06IFsxLCAnPG9iamVjdD4nLCAnPC9vYmplY3Q+J10sXHJcbiAgICAgICAgdGV4dDogX19zdmcsXHJcbiAgICAgICAgY2lyY2xlOiBfX3N2ZyxcclxuICAgICAgICBlbGxpcHNlOiBfX3N2ZyxcclxuICAgICAgICBsaW5lOiBfX3N2ZyxcclxuICAgICAgICBwYXRoOiBfX3N2ZyxcclxuICAgICAgICBwb2x5Z29uOiBfX3N2ZyxcclxuICAgICAgICBwb2x5bGluZTogX19zdmcsXHJcbiAgICAgICAgcmVjdDogX19zdmcsXHJcbiAgICAgICAgX2RlZmF1bHQ6IFswLCAnJywgJyddXHJcbiAgICB9KTtcclxuICAgIGZ1bmN0aW9uIGFwcGVuZENoaWxkcmVuKG5vZGVMaXN0LCByb290LCBjbG9uZSkge1xyXG4gICAgICAgIHZhciBpc0ZyYWdtZW50ID0gaXNEb2N1bWVudEZyYWdtZW50KHJvb3QpLCBudWxsUm9vdCA9ICFpc05vZGUocm9vdCksIGZyYWdtZW50ID0gaXNGcmFnbWVudCA/XHJcbiAgICAgICAgICAgIHJvb3QgOlxyXG4gICAgICAgICAgICAoX19fZG9jdW1lbnQgfHwgKF9fX2RvY3VtZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9jdW1lbnQpKSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgIGlmIChudWxsUm9vdCkge1xyXG4gICAgICAgICAgICByb290ID0gZnJhZ21lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsaXN0ID0gaXNBcnJheShub2RlTGlzdCkgPyBub2RlTGlzdCA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KSwgbGVuZ3RoID0gbGlzdC5sZW5ndGgsIGk7XHJcbiAgICAgICAgaWYgKGNsb25lID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2ldLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZShpdGVtLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5pbnNlcnRCZWZvcmUobGlzdFtpXSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoaXNGcmFnbWVudCB8fCBudWxsUm9vdCkpIHtcclxuICAgICAgICAgICAgcm9vdC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcclxuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNsZWFyTm9kZUJsb2NrKG5vZGVMaXN0LCBwYXJlbnQpIHtcclxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24obm9kZUxpc3QucHVzaCkpIHtcclxuICAgICAgICAgICAgbm9kZUxpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlTGlzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNOdWxsKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgY2xlYXJOb2RlQmxvY2tXaXRoUGFyZW50KG5vZGVMaXN0LCBwYXJlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgIHdoaWxlIChub2RlTGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlTGlzdC5wb3AoKTtcclxuICAgICAgICAgICAgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjbGVhck5vZGVCbG9ja1dpdGhQYXJlbnQobm9kZUxpc3QsIHBhcmVudCkge1xyXG4gICAgICAgIHdoaWxlIChub2RlTGlzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlTGlzdC5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3RyaW5nVG9Ob2RlKGh0bWwpIHtcclxuICAgICAgICAvLyBfX19jb21wYXQgaXMgYSBnbG9iYWwgdmFyaWFibGUgaW4gdXRpbHNnbG9iYWwgXHJcbiAgICAgICAgX19fY29tcGF0ID0gX19fY29tcGF0IHx8IChfX19jb21wYXQgPSBwbGF0LmFjcXVpcmUoX19Db21wYXQpKTtcclxuICAgICAgICBfX19kb2N1bWVudCA9IF9fX2RvY3VtZW50IHx8IChfX19kb2N1bWVudCA9IHBsYXQuYWNxdWlyZShfX0RvY3VtZW50KSk7XHJcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gX19ub2RlTmFtZVJlZ2V4LmV4ZWMoaHRtbCksIGVsZW1lbnQgPSBfX19kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBpZiAoaXNOdWxsKG5vZGVOYW1lKSkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gaW5uZXJIdG1sKGVsZW1lbnQsIGh0bWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5yZW1vdmVDaGlsZChlbGVtZW50Lmxhc3RDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRyaW0gaHRtbCBzdHJpbmcgXHJcbiAgICAgICAgaHRtbCA9IGh0bWwudHJpbSgpO1xyXG4gICAgICAgIHZhciBtYXBUYWcgPSBub2RlTmFtZVsxXTtcclxuICAgICAgICBpZiAoX19fY29tcGF0LnB1c2hTdGF0ZSAmJiBpc1VuZGVmaW5lZChfX2lubmVyVGFibGVXcmFwcGVyc1ttYXBUYWddKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5uZXJIdG1sKGVsZW1lbnQsIGh0bWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXBUYWcgPT09ICdib2R5Jykge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gaW5uZXJIdG1sKF9fX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKSwgaHRtbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQubGFzdENoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdyYXBwZXIgPSBfX2lubmVySHRtbFdyYXBwZXJzW21hcFRhZ10gfHwgX19pbm5lckh0bWxXcmFwcGVycy5fZGVmYXVsdCwgZGVwdGggPSB3cmFwcGVyWzBdLCBwYXJlbnRTdGFydCA9IHdyYXBwZXJbMV0sIHBhcmVudEVuZCA9IHdyYXBwZXJbMl07XHJcbiAgICAgICAgZWxlbWVudCA9IGlubmVySHRtbChlbGVtZW50LCBwYXJlbnRTdGFydCArIGh0bWwgKyBwYXJlbnRFbmQpO1xyXG4gICAgICAgIHdoaWxlIChkZXB0aC0tID4gMCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudC5sYXN0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2V0SW5uZXJIdG1sKG5vZGUsIGh0bWwpIHtcclxuICAgICAgICBjbGVhck5vZGUobm9kZSk7XHJcbiAgICAgICAgaWYgKGlzRW1wdHkoaHRtbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWxlbWVudCA9IHN0cmluZ1RvTm9kZShodG1sKTtcclxuICAgICAgICBpZiAoZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgYXBwZW5kQ2hpbGRyZW4oZWxlbWVudC5jaGlsZE5vZGVzLCBub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGVzLCBlbmROb2RlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChwYXJlbnQpIHx8ICFpc09iamVjdChub2RlcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1VuZGVmaW5lZChlbmROb2RlKSkge1xyXG4gICAgICAgICAgICBlbmROb2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZyYWdtZW50O1xyXG4gICAgICAgIGlmIChpc05vZGUobm9kZXMpKSB7XHJcbiAgICAgICAgICAgIGZyYWdtZW50ID0gbm9kZXM7XHJcbiAgICAgICAgICAgIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJhZ21lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihub2Rlcy5wdXNoKSkge1xyXG4gICAgICAgICAgICBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX19fZG9jdW1lbnQgPSBfX19kb2N1bWVudCB8fCAoX19fZG9jdW1lbnQgPSBwbGF0LmFjcXVpcmUoX19Eb2N1bWVudCkpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBub2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgZnJhZ21lbnQgPSBfX19kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBmcmFnbWVudC5pbnNlcnRCZWZvcmUobm9kZXNbaV0sIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBlbmROb2RlKTtcclxuICAgICAgICByZXR1cm4gbm9kZXM7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXBsYWNlKG5vZGUpIHtcclxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlLCBub2RlcyA9IGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuY2hpbGROb2Rlcywgbm9kZSk7XHJcbiAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlcGxhY2VXaXRoKG5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKG5ld05vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXMsIGxlbmd0aF8xID0gYXR0cmlidXRlcy5sZW5ndGgsIGF0dHJpYnV0ZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICBpbnNlcnRCZWZvcmUobmV3Tm9kZSwgbm9kZS5jaGlsZE5vZGVzKTtcclxuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5ld05vZGUsIG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplSHRtbChodG1sKSB7XHJcbiAgICAgICAgX19fZG9jdW1lbnQgPSBfX19kb2N1bWVudCB8fCAoX19fZG9jdW1lbnQgPSBwbGF0LmFjcXVpcmUoX19Eb2N1bWVudCkpO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZUVsZW1lbnQgPSBfX19kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgaWYgKCFpc0VtcHR5KGh0bWwpKSB7XHJcbiAgICAgICAgICAgIHNldElubmVySHRtbCh0ZW1wbGF0ZUVsZW1lbnQsIGh0bWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGVtcGxhdGVFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlQmV0d2VlbihzdGFydE5vZGUsIGVuZE5vZGUpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKHN0YXJ0Tm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBzdGFydE5vZGUubmV4dFNpYmxpbmcsIHBhcmVudE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZSwgdGVtcE5vZGU7XHJcbiAgICAgICAgaWYgKGlzTnVsbChlbmROb2RlKSkge1xyXG4gICAgICAgICAgICBlbmROb2RlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzTnVsbChwYXJlbnROb2RlKSB8fCAoIWlzTnVsbChlbmROb2RlKSAmJiBlbmROb2RlLnBhcmVudE5vZGUgIT09IHBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgIHRlbXBOb2RlID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHRlbXBOb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbChzdGFydE5vZGUsIGVuZE5vZGUpIHtcclxuICAgICAgICBpZiAoaXNOdWxsKHN0YXJ0Tm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVCZXR3ZWVuKHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XHJcbiAgICAgICAgcmVtb3ZlTm9kZShzdGFydE5vZGUpO1xyXG4gICAgICAgIHJlbW92ZU5vZGUoZW5kTm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW5uZXJIdG1sKGVsZW1lbnQsIGh0bWwpIHtcclxuICAgICAgICBfX19jb21wYXQgPSBfX19jb21wYXQgfHwgKF9fX2NvbXBhdCA9IHBsYXQuYWNxdWlyZShfX0NvbXBhdCkpO1xyXG4gICAgICAgIGlmIChfX19jb21wYXQubXNBcHApIHtcclxuICAgICAgICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcclxuICAgICAgICBpZiAoIWlzTm9kZShub2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xyXG4gICAgICAgIGlmICghaXNOdWxsKHBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgdmFyIGNOYW1lID0gKGVsZW1lbnQgfHwge30pLmNsYXNzTmFtZTtcclxuICAgICAgICBpZiAoIWlzU3RyaW5nKGNOYW1lKSB8fCAhaXNTdHJpbmcoY2xhc3NOYW1lKSB8fCBjbGFzc05hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNwbGl0ID0gY2xhc3NOYW1lLnNwbGl0KF9fd2hpdGVTcGFjZVJlZ2V4KSwgbmFtZSwgY2xhc3NOYW1lUmVnZXg7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NMaXN0KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eShjTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXicgKyBuYW1lICsgJ1xcXFxzK3xcXFxccysnICsgbmFtZSArICckfFxcXFxzKycgKyBuYW1lICsgJ1xcXFxzKycsICdnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGFzc05hbWVSZWdleC50ZXN0KGNOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSAnICcgKyBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBzcGxpdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHZhciBjTmFtZSA9IChlbGVtZW50IHx8IHt9KS5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjTmFtZSkgfHwgIWlzU3RyaW5nKGNsYXNzTmFtZSkgfHwgY2xhc3NOYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzcGxpdCA9IGNsYXNzTmFtZS5zcGxpdChfX3doaXRlU3BhY2VSZWdleCksIG5hbWU7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NMaXN0KSkge1xyXG4gICAgICAgICAgICBpZiAoY05hbWUgPT09IGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSAnJztcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNOYW1lID0gY05hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyBuYW1lICsgJ1xcXFxzK3xcXFxccysnICsgbmFtZSArICckfFxcXFxzKycgKyBuYW1lICsgJ1xcXFxzKycsICdnJyksICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBzcGxpdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHZhciBjTmFtZSA9IChlbGVtZW50IHx8IHt9KS5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjTmFtZSkgfHwgIWlzU3RyaW5nKGNsYXNzTmFtZSkgfHwgY2xhc3NOYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzcGxpdCA9IGNsYXNzTmFtZS5zcGxpdChfX3doaXRlU3BhY2VSZWdleCksIG5hbWU7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NMaXN0KSkge1xyXG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lUmVnZXggPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmIChjTmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNOYW1lID09PSBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBzcGxpdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lUmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIG5hbWUgKyAnXFxcXHMrfFxcXFxzKycgKyBuYW1lICsgJyR8XFxcXHMrJyArIG5hbWUgKyAnXFxcXHMrJywgJ2cnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lUmVnZXgudGVzdChjTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjTmFtZSA9IGNOYW1lLnJlcGxhY2UoY2xhc3NOYW1lUmVnZXgsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIG5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBuYW1lID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXBsYWNlQ2xhc3MoZWxlbWVudCwgb2xkQ2xhc3MsIG5ld0NsYXNzKSB7XHJcbiAgICAgICAgdmFyIGNOYW1lID0gKGVsZW1lbnQgfHwge30pLmNsYXNzTmFtZTtcclxuICAgICAgICBpZiAoIWlzU3RyaW5nKGNOYW1lKSB8fCAhaXNTdHJpbmcobmV3Q2xhc3MpIHx8IG5ld0NsYXNzID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTGlzdCkpIHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIG9sZENsYXNzICsgJ1xcXFxzKycsICdnJyksIG1pZFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXHMrJyArIG9sZENsYXNzICsgJ1xcXFxzKycsICdnJyksIGVuZFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXHMrJyArIG9sZENsYXNzICsgJyQnLCAnZycpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNOYW1lLnJlcGxhY2Uoc3RhcnRSZWdleCwgbmV3Q2xhc3MgKyAnICcpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShtaWRSZWdleCwgJyAnICsgbmV3Q2xhc3MgKyAnICcpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZShlbmRSZWdleCwgJyAnICsgbmV3Q2xhc3MpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuZXdDbGFzcyk7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKG9sZENsYXNzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHZhciBjTmFtZSA9IChlbGVtZW50IHx8IHt9KS5jbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhjTmFtZSkgfHwgIWlzU3RyaW5nKGNsYXNzTmFtZSkgfHwgY2xhc3NOYW1lID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzcGxpdCA9IGNsYXNzTmFtZS5zcGxpdChfX3doaXRlU3BhY2VSZWdleCk7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGVsZW1lbnQuY2xhc3NMaXN0KSkge1xyXG4gICAgICAgICAgICBpZiAoY05hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY05hbWUgPT09IGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5hbWVfMTtcclxuICAgICAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5hbWVfMSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShuYW1lXzEgPT09ICcnIHx8IG5ldyBSZWdFeHAoJ14nICsgbmFtZV8xICsgJ1xcXFxzfFxcXFxzJyArIG5hbWVfMSArICckfFxcXFxzJyArIG5hbWVfMSArICdcXFxccycsICdnJykudGVzdChjTmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBuYW1lID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgaWYgKCEobmFtZSA9PT0gJycgfHwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBnZXRUZW1wbGF0ZSh0ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgIF9fX3RlbXBsYXRlQ2FjaGUgPSBfX190ZW1wbGF0ZUNhY2hlIHx8IChfX190ZW1wbGF0ZUNhY2hlID0gcGxhdC5hY3F1aXJlKF9fVGVtcGxhdGVDYWNoZSkpO1xyXG4gICAgICAgIF9fX2h0dHAgPSBfX19odHRwIHx8IChfX19odHRwID0gcGxhdC5hY3F1aXJlKF9fSHR0cCkpO1xyXG4gICAgICAgIHJldHVybiBfX190ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVVybCwgX19fdGVtcGxhdGVDYWNoZS5yZWFkKHRlbXBsYXRlVXJsKVxyXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19faHR0cC5hamF4KHsgdXJsOiB0ZW1wbGF0ZVVybCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRGcmFnbWVudChzdWNjZXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fX3RlbXBsYXRlQ2FjaGUucHV0KHRlbXBsYXRlVXJsLCBzdWNjZXNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qoc3VjY2VzcykgfHwgIWlzU3RyaW5nKHN1Y2Nlc3MucmVzcG9uc2UpKSB7XHJcbiAgICAgICAgICAgICAgICBfX19sb2cgPSBfX19sb2cgfHwgKF9fX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZykpO1xyXG4gICAgICAgICAgICAgICAgX19fbG9nLndhcm4oJ05vIHRlbXBsYXRlIGZvdW5kIGF0ICcgKyB0ZW1wbGF0ZVVybCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19fdGVtcGxhdGVDYWNoZS5wdXQodGVtcGxhdGVVcmwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVN0cmluZyA9IHN1Y2Nlc3MucmVzcG9uc2U7XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHRlbXBsYXRlU3RyaW5nLnRyaW0oKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX190ZW1wbGF0ZUNhY2hlLnB1dCh0ZW1wbGF0ZVVybCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fX3RlbXBsYXRlQ2FjaGUucHV0KHRlbXBsYXRlVXJsLCB0ZW1wbGF0ZVN0cmluZyk7XHJcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF9fX2xvZyA9IF9fX2xvZyB8fCAoX19fbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKSk7XHJcbiAgICAgICAgICAgICAgICBfX19sb2cuZXJyb3IobmV3IEVycm9yKCdGYWlsdXJlIHRvIGdldCB0ZW1wbGF0ZSBmcm9tICcgKyB0ZW1wbGF0ZVVybCArICcuJykpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdoZW5QcmVzZW50KGNiLCBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgX19fbG9nID0gX19fbG9nIHx8IChfX19sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpKTtcclxuICAgICAgICAgICAgX19fbG9nLmVycm9yKG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBjaGVjayBET00gcHJlc2VuY2Ugb2Ygc29tZXRoaW5nIHRoYXQgaXNuXFwndCBhIE5vZGUuJykpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgX19fZG9jdW1lbnQgPSBfX19kb2N1bWVudCB8fCAoX19fZG9jdW1lbnQgPSBwbGF0LmFjcXVpcmUoX19Eb2N1bWVudCkpO1xyXG4gICAgICAgIHZhciBib2R5ID0gX19fZG9jdW1lbnQuYm9keTtcclxuICAgICAgICBpZiAoaXNOb2RlKGVsZW1lbnQucGFyZW50RWxlbWVudCkgJiYgYm9keS5jb250YWlucyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbW92ZSA9IHNldEludGVydmFsR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGlzTm9kZShlbGVtZW50LnBhcmVudEVsZW1lbnQpICYmIGJvZHkuY29udGFpbnMoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHdoZW5WaXNpYmxlKGNiLCBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgX19fbG9nID0gX19fbG9nIHx8IChfX19sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpKTtcclxuICAgICAgICAgICAgX19fbG9nLmVycm9yKG5ldyBFcnJvcignQXR0ZW1wdGluZyB0byBjaGVjayB2aXNpYmlsaXR5IG9mIHNvbWV0aGluZyB0aGF0IGlzblxcJ3QgYSBOb2RlLicpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjbGllbnRXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIGlmICghKGlzTnVtYmVyKGNsaWVudFdpZHRoKSAmJiBpc051bWJlcihjbGllbnRIZWlnaHQpKSkge1xyXG4gICAgICAgICAgICBfX19sb2cgPSBfX19sb2cgfHwgKF9fX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZykpO1xyXG4gICAgICAgICAgICBfX19sb2cuZXJyb3IobmV3IEVycm9yKCdBdHRlbXB0aW5nIHRvIGNoZWNrIHZpc2liaWxpdHkgb2Ygc29tZXRoaW5nIHRoYXQgaXNuXFwndCBhbiBFbGVtZW50LicpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGllbnRXaWR0aCA+IDAgJiYgY2xpZW50SGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbW92ZSA9IHNldEludGVydmFsR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xpZW50V2lkdGggPiAwICYmIGVsZW1lbnQuY2xpZW50SGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMTAwKTtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlO1xyXG4gICAgfVxyXG4gICAgLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIHZhciBjb250cm9sSW5qZWN0b3JzID0ge30sIHZpZXdDb250cm9sSW5qZWN0b3JzID0ge30sIGluc3RhbmNlSW5qZWN0b3JEZXBlbmRlbmNpZXMgPSB7fSwgaW5qZWN0YWJsZUluamVjdG9ycyA9IHt9LCB1bnJlZ2lzdGVyZWRJbmplY3RvcnMgPSB7fSwgc3RhdGljSW5qZWN0b3JzID0ge30sIGFuaW1hdGlvbkluamVjdG9ycyA9IHt9LCBqc0FuaW1hdGlvbkluamVjdG9ycyA9IHt9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBhbGwgdGhlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byByZWdpc3RlcmluZyBjb21wb25lbnRzIGZvciBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIHJlZ2lzdGVyO1xyXG4gICAgKGZ1bmN0aW9uIChyZWdpc3Rlcikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdlbmVyaWMgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFuIEluamVjdG9yIGFuZFxyXG4gICAgICAgICAqIGFkZGluZyBpdCB0byBhbiBJbmplY3Rvck9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZGVwZW5kZW5jeS5JbmplY3Rvck9iamVjdDxhbnk+fSBvYmogVGhlIEluamVjdG9yT2JqZWN0XHJcbiAgICAgICAgICogdG8gd2hpY2ggdG8gYWRkIGFuIEluamVjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIHVzZWQgdG8gc2V0L2dldCB0aGUgSW5qZWN0b3IgZnJvbSB0aGVcclxuICAgICAgICAgKiBJbmplY3Rvck9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gVHlwZSBUaGUgY29uc3RydWN0b3Igb3IgZnVuY3Rpb24gZGVmaW5pdGlvbiBmb3IgdGhlIEluamVjdG9yLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gZGVwZW5kZW5jaWVzPyBBbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgZGVwZW5kZW5jaWVzIG5lZWRlZCBmb3IgdGhlXHJcbiAgICAgICAgICogSW5qZWN0b3IuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluamVjdGFibGVUeXBlPyBUaGUgaW5qZWN0YWJsZSB0eXBlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdGF0aWMgVGhlIGluamVjdGFibGUgdHlwZSBpcyBhIHN0YXRpYyB0eXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkZChvYmosIG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaW5qZWN0YWJsZVR5cGUsIGlzU3RhdGljKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmplY3RvciA9IG9ialtuYW1lXSA9IG5ldyBkZXBlbmRlbmN5LkluamVjdG9yKG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgaW5qZWN0YWJsZVR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoaXNTdGF0aWMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXRpY0luamVjdG9yc1tuYW1lXSA9IGluamVjdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXJzIHRoZSBJQXBwIHdpdGggdGhlIGZyYW1ld29yay4gVGhlIGZyYW1ld29yayB3aWxsIGluc3RhbnRpYXRlIHRoZSBJQXBwXHJcbiAgICAgICAgICogd2hlbiBuZWVkZWQsIGFuZCB3aXJlIHVwIHRoZSBBcHBsaWNhdGlvbiBMaWZlY3ljbGUgZXZlbnRzLiBUaGUgZGVwZW5kZW5jaWVzIGFycmF5IGNvcnJlc3BvbmRzIHRvIGluamVjdGFibGVzIHRoYXQgd2lsbCBiZVxyXG4gICAgICAgICAqIHBhc3NlZCBpbnRvIHRoZSBDb25zdHJ1Y3RvciBvZiB0aGUgYXBwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHlvdXIgYXBwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gcGxhdC5BcHB9IFR5cGUgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgSUFwcC5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGRlcGVuZGVuY2llcz8gQW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIGRlcGVuZGVuY2llcyBuZWVkZWQgZm9yIHRoZSBhcHAgaW5qZWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gYXBwKG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICB2YXIgX0luamVjdG9yID0gYWNxdWlyZShfX0luamVjdG9yU3RhdGljKSwgX0FwcFN0YXRpYyA9IGFjcXVpcmUoX19BcHBTdGF0aWMpO1xyXG4gICAgICAgICAgICBfQXBwU3RhdGljLnJlZ2lzdGVyQXBwKG5ldyBfSW5qZWN0b3IobmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaXN0ZXIuYXBwID0gYXBwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhbiBDb250cm9sIHdpdGggdGhlIGZyYW1ld29yay4gVGhlIGZyYW1ld29yayB3aWxsIGluc3RhbnRpYXRlIHRoZVxyXG4gICAgICAgICAqIENvbnRyb2wgd2hlbiBuZWVkZWQuIFRoZSBkZXBlbmRlbmNpZXMgYXJyYXkgY29ycmVzcG9uZHMgdG8gaW5qZWN0YWJsZXMgdGhhdFxyXG4gICAgICAgICAqIHdpbGwgYmUgcGFzc2VkIGludG8gdGhlIENvbnN0cnVjdG9yIG9mIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBjb250cm9sIHR5cGUsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEhUTUwgbm90YXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3IENvbnRyb2wgKGUuZy4gJ3BsYXQtZm9yZWFjaCcpLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gcGxhdC5Db250cm9sfSBUeXBlIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIENvbnRyb2wuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBkZXBlbmRlbmNpZXM/IEFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBkZXBlbmRlbmNpZXMgbmVlZGVkIGZvciB0aGUgQ29udHJvbFxyXG4gICAgICAgICAqIGluamVjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnRyb2wobmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzLCBpc1N0YXRpYykge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgQ29udHJvbCBtdXN0IGJlIHJlZ2lzdGVyZWQgd2l0aCBhIHN0cmluZyBuYW1lJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdoZWFkJykge1xyXG4gICAgICAgICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGQoY29udHJvbEluamVjdG9ycywgbmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzLCBpc1N0YXRpYyA/IF9fU1RBVElDIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbCA9IGNvbnRyb2w7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVnaXN0ZXJzIGFuIFZpZXdDb250cm9sIHdpdGggdGhlIGZyYW1ld29yay4gVGhlIGZyYW1ld29yayB3aWxsXHJcbiAgICAgICAgICogaW5zdGFudGlhdGUgdGhlIGNvbnRyb2wgd2hlbiBuZWVkZWQuIFRoZSBkZXBlbmRlbmNpZXMgYXJyYXkgY29ycmVzcG9uZHMgdG8gaW5qZWN0YWJsZXMgdGhhdCB3aWxsIGJlXHJcbiAgICAgICAgICogcGFzc2VkIGludG8gdGhlIENvbnN0cnVjdG9yIG9mIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBjb250cm9sIHR5cGUsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEhUTUwgbm90YXRpb24gZm9yIGNyZWF0aW5nIGEgbmV3XHJcbiAgICAgICAgICogVmlld0NvbnRyb2wuIFVzZWQgZm9yIG5hdmlnYXRpb24gdG8gdGhlIHNwZWNpZmllZCBWaWV3Q29udHJvbC5cclxuICAgICAgICAgKiBAcGFyYW0ge25ldyAoLi4uYXJnczogYW55W10pID0+IHBsYXQudWkuVmlld0NvbnRyb2x9IFR5cGUgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgVmlld0NvbnRyb2wuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBkZXBlbmRlbmNpZXM/IEFuIG9wdGlvbmFsIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBkZXBlbmRlbmNpZXMgbmVlZGVkIGZvciB0aGVcclxuICAgICAgICAgKiBWaWV3Q29udHJvbCBpbmplY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiB2aWV3Q29udHJvbChuYW1lLCBUeXBlLCBkZXBlbmRlbmNpZXMpIHtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIFZpZXdDb250cm9sIG11c3QgYmUgcmVnaXN0ZXJlZCB3aXRoIGEgc3RyaW5nIG5hbWUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWRkKHZpZXdDb250cm9sSW5qZWN0b3JzLCBuYW1lLCBUeXBlLCBkZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWdpc3Rlci52aWV3Q29udHJvbCA9IHZpZXdDb250cm9sO1xyXG4gICAgICAgIGZ1bmN0aW9uIGluamVjdGFibGUobmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzLCBpbmplY3RhYmxlVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGluamVjdGFibGVUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0YWJsZVR5cGUgPSBfX1NJTkdMRVRPTjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGluamVjdGFibGVUeXBlID0gaW5qZWN0YWJsZVR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmplY3RhYmxlVHlwZSA9PT0gX19GQUNUT1JZIHx8IGluamVjdGFibGVUeXBlID09PSBfX1NUQVRJQyB8fCBpbmplY3RhYmxlVHlwZSA9PT0gX19DTEFTUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGQoaW5qZWN0YWJsZUluamVjdG9ycywgbmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzLCBpbmplY3RhYmxlVHlwZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKGluamVjdGFibGVUeXBlID09PSBfX1NJTkdMRVRPTiB8fCBpbmplY3RhYmxlVHlwZSA9PT0gX19JTlNUQU5DRSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5qZWN0YWJsZSB0eXBlICcgKyBpbmplY3RhYmxlVHlwZSArICcgZHVyaW5nIGluamVjdGFibGUgcmVnaXN0cmF0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGQoaW5qZWN0YWJsZUluamVjdG9ycywgbmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzLCBpbmplY3RhYmxlVHlwZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlID0gaW5qZWN0YWJsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBjb25zdGFudHMgZm9yIGluamVjdGFibGUgdHlwZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgaW5qZWN0YWJsZTtcclxuICAgICAgICAoZnVuY3Rpb24gKGluamVjdGFibGUpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN0YXRpYyBpbmplY3RhYmxlcyB3aWxsIGJlIGluamVjdGVkIGJlZm9yZSB0aGUgYXBwbGljYXRpb24gbG9hZHMuIFRoaXMgcHJvdmlkZXMgYSB3YXkgdG8gY3JlYXRlXHJcbiAgICAgICAgICAgICAqIGEgc3RhdGljIGNvbnN0cnVjdG9yIGFuZCBsb2FkIGRlcGVuZGVuY2llcyBpbnRvIHN0YXRpYyBjbGFzcyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0YWJsZS5TVEFUSUMgPSBfX1NUQVRJQztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNpbmdsZXRvbiBpbmplY3RhYmxlcyB3aWxsIGNvbnRhaW4gYSBjb25zdHJ1Y3Rvci4gQSBTaW5nbGV0b24gaW5qZWN0YWJsZSB3aWxsIGJlIGluc3RhbnRpYXRlZCBvbmNlIGFuZFxyXG4gICAgICAgICAgICAgKiB1c2VkIHRocm91Z2hvdXQgdGhlIGFwcGxpY2F0aW9uIGxpZmV0aW1lLiBJdCB3aWxsIGJlIGluc3RhbnRpYXRlZCB3aGVuIGFub3RoZXIgY29tcG9uZW50IGlzIGluamVjdGVkXHJcbiAgICAgICAgICAgICAqIGFuZCBsaXN0cyBpdCBhcyBhIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmplY3RhYmxlLlNJTkdMRVRPTiA9IF9fU0lOR0xFVE9OO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5zdGFuY2UgaW5qZWN0YWJsZXMgd2lsbCBjb250YWluIGEgY29uc3RydWN0b3IuIEFuIEluc3RhbmNlIGluamVjdGFibGUgd2lsbCBiZSBpbnN0YW50aWF0ZWQgbXVsdGlwbGUgdGltZXNcclxuICAgICAgICAgICAgICogdGhyb3VnaG91dCB0aGUgYXBwbGljYXRpb24gbGlmZXRpbWUuIEl0IHdpbGwgYmUgaW5zdGFudGlhdGVkIHdoZW5ldmVyIGFub3RoZXIgY29tcG9uZW50IGlzIGluamVjdGVkXHJcbiAgICAgICAgICAgICAqIGFuZCBsaXN0cyBpdCBhcyBhIGRlcGVuZGVuY3kuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmplY3RhYmxlLklOU1RBTkNFID0gX19JTlNUQU5DRTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZhY3RvcnkgaW5qZWN0YWJsZXMgd2lsbCBub3QgY29udGFpbiBhIGNvbnN0cnVjdG9yIGJ1dCB3aWxsIGluc3RlYWQgY29udGFpbiBhIG1ldGhvZCBmb3Igb2J0YWluaW5nIGFuXHJcbiAgICAgICAgICAgICAqIGluc3RhbmNlLCBzdWNoIGFzIGdldEluc3RhbmNlKCkgb3IgY3JlYXRlKCkuIEl0IHdpbGwgYmUgaW5qZWN0ZWQgYmVmb3JlIHRoZSBhcHBsaWNhdGlvbiBsb2Fkcywgc2ltaWxhciB0byBhIFN0YXRpY1xyXG4gICAgICAgICAgICAgKiBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0YWJsZS5GQUNUT1JZID0gX19GQUNUT1JZO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xhc3MgaW5qZWN0YWJsZXMgYXJlIGVzc2VudGlhbGx5IGEgZGlyZWN0IHJlZmVyZW5jZSB0byBhIGNsYXNzJ3MgY29uc3RydWN0b3IuIEl0IG1heSBjb250YWluIGJvdGhcclxuICAgICAgICAgICAgICogc3RhdGljIGFuZCBpbnN0YW5jZSBtZXRob2RzIGFzIHdlbGwgYXMgYSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmplY3RhYmxlLkNMQVNTID0gX19DTEFTUztcclxuICAgICAgICB9KShpbmplY3RhYmxlID0gcmVnaXN0ZXIuaW5qZWN0YWJsZSB8fCAocmVnaXN0ZXIuaW5qZWN0YWJsZSA9IHt9KSk7XHJcbiAgICAgICAgZnVuY3Rpb24gYW5pbWF0aW9uKG5hbWUsIFR5cGUsIGRlcGVuZGVuY2llcywgYW5pbWF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoYW5pbWF0aW9uVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblR5cGUgPSBhbmltYXRpb25UeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShhbmltYXRpb25UeXBlID09PSBfX0NTUyB8fCBhbmltYXRpb25UeXBlID09PSBfX0pTKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbmltYXRpb25UeXBlIFwiJyArIGFuaW1hdGlvblR5cGUgKyAnXCIgZHVyaW5nIGFuaW1hdGlvbiByZWdpc3RyYXRpb24uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFkZCgoYW5pbWF0aW9uVHlwZSA9PT0gX19KUyA/IGpzQW5pbWF0aW9uSW5qZWN0b3JzIDogYW5pbWF0aW9uSW5qZWN0b3JzKSwgbmFtZSwgVHlwZSwgZGVwZW5kZW5jaWVzLCByZWdpc3Rlci5pbmplY3RhYmxlLklOU1RBTkNFKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVnaXN0ZXIuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRhaW5zIGNvbnN0YW50cyBmb3IgYW5pbWF0aW9uIHR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbjtcclxuICAgICAgICAoZnVuY3Rpb24gKGFuaW1hdGlvbikge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBDU1MgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgYW5pbWF0aW9uLkNTUyA9IF9fQ1NTO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBKYXZhU2NyaXB0IGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbi5KUyA9IF9fSlM7XHJcbiAgICAgICAgfSkoYW5pbWF0aW9uID0gcmVnaXN0ZXIuYW5pbWF0aW9uIHx8IChyZWdpc3Rlci5hbmltYXRpb24gPSB7fSkpO1xyXG4gICAgfSkocmVnaXN0ZXIgPSBwbGF0XzEucmVnaXN0ZXIgfHwgKHBsYXRfMS5yZWdpc3RlciA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBkZXBlbmRlbmN5IGluamVjdGlvbiBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgZGVwZW5kZW5jeTtcclxuICAgIChmdW5jdGlvbiAoZGVwZW5kZW5jeV8xKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIEluamVjdG9yIGNsYXNzIGlzIHVzZWQgZm9yIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBZb3UgY2FuIGNyZWF0ZSBhbiBpbmplY3RvciBvYmplY3QsXHJcbiAgICAgICAgICogc3BlY2lmeSBkZXBlbmRlbmNpZXMgYW5kIGEgY29uc3RydWN0b3IgZm9yIHlvdXIgY29tcG9uZW50LiBXaGVuIHRoZSBpbmplY3RvciBvYmplY3QgaXNcclxuICAgICAgICAgKiAnaW5qZWN0ZWQnIGl0IHdpbGwgY3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHlvdXIgY29tcG9uZW50IGFuZCBwYXNzIGluIHRoZSBkZXBlbmRlbmNpZXNcclxuICAgICAgICAgKiB0byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEluamVjdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYW4gaW5qZWN0b3IuIENvbnZlcnRzIGFueSBub24tc3RyaW5nIGRlcGVuZGVuY2llcyB0byBzdHJpbmdzIHRvIHN1cHBvcnQgbW9ja2luZyBJbmplY3RvcnMgZHVyaW5nIHJ1bnRpbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBpbmplY3RlZCB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge25ldyAoKSA9PiBUfSBDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3IgbWV0aG9kIGZvciB0aGUgY29tcG9uZW50IHJlcXVpcmluZyB0aGUgZGVwZW5kZW5jeVxyXG4gICAgICAgICAgICAgKiBpbmplY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gZGVwZW5kZW5jaWVzIEFuIGFycmF5IG9mIHN0cmluZ3Mgc3BlY2lmeWluZyB0aGUgaW5qZWN0YWJsZSBkZXBlbmRlbmNpZXMgZm9yIHRoZVxyXG4gICAgICAgICAgICAgKiBhc3NvY2lhdGVkIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBpbmplY3RvciwgdXNlZCBmb3IgaW5qZWN0YWJsZXMgc3BlY2lmeWluZyBhIGluamVjdGFibGVUeXBlIG9mXHJcbiAgICAgICAgICAgICAqIFNUQVRJQywgU0lOR0xFVE9OLCBGQUNUT1JZLCBJTlNUQU5DRSwgb3IgQ0xBU1MuIFRoZSBkZWZhdWx0IGlzIFNJTkdMRVRPTi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEluamVjdG9yKG5hbWUsIENvbnN0cnVjdG9yLCBkZXBlbmRlbmNpZXMsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLkNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcHMgPSB0aGlzLmRlcGVuZGVuY2llcyA9IEluamVjdG9yLmNvbnZlcnREZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSwgaW5kZXggPSBkZXBzLmluZGV4T2YoX19OT09QX0lOSkVDVE9SKSwgY2lyY3VsYXJSZWZlcmVuY2U7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsICdfX2luamVjdG9yTmFtZScsIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCAnX19pbmplY3RvckRlcGVuZGVuY2llcycsIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGVwcy5zbGljZSgwKSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jeV8yID0gZGVwZW5kZW5jaWVzW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRlcGVuZGVuY3lfMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGRlcGVuZGVuY3kgZm9yICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArICcgYXQgaW5kZXggJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArICcgaXMgdW5kZWZpbmVkLCBkaWQgeW91IGZvcmdldCB0byBpbmNsdWRlIGEgZmlsZT8nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IHJlc29sdmUgZGVwZW5kZW5jeSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeV8yLnNsaWNlKDksIGRlcGVuZGVuY3lfMi5pbmRleE9mKCcoJykpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiBBcmUgeW91IHVzaW5nIGEgc3RhdGljIGluamVjdGFibGUgVHlwZT8nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNpcmN1bGFyUmVmZXJlbmNlID0gSW5qZWN0b3IuX19maW5kQ2lyY3VsYXJSZWZlcmVuY2VzKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNpcmN1bGFyUmVmZXJlbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCBmcm9tICcgKyB0aGlzLm5hbWUgKyAnIHRvICcgKyBjaXJjdWxhclJlZmVyZW5jZSArICcuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gX19BcHBTdGF0aWMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgQXBwXzEgPSB0aGlzLmluamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gZGVwcztcclxuICAgICAgICAgICAgICAgICAgICBBcHBfMS5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhbGwgc3RhdGljIGluamVjdG9ycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3JzID0gc3RhdGljSW5qZWN0b3JzLCBrZXlzID0gT2JqZWN0LmtleXMoaW5qZWN0b3JzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3JzW2tleXNbaV1dLmluamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhdGljSW5qZWN0b3JzID0ge307XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHYXRoZXJzIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBsaXN0ZWQgZGVwZW5kZW5jaWVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGRlcGVuZGVuY2llcyBUaGUgYXJyYXkgb2YgZGVwZW5kZW5jaWVzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgKiBieSBlaXRoZXIgdGhlaXIgQ29uc3RydWN0b3Igb3IgdGhlaXIgcmVnaXN0ZXJlZCBuYW1lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuZ2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkZXBlbmRlbmNpZXMpIHx8IGlzRW1wdHkoZGVwZW5kZW5jaWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gW10sIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKEluamVjdG9yLmdldERlcGVuZGVuY3koZGVwZW5kZW5jaWVzW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIGFuZCByZXR1cm5zIHRoZSBkZXBlbmRlbmN5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gZGVwZW5kZW5jeSBhbiBvYmplY3Qvc3RyaW5nIHVzZWQgdG8gZmluZCB0aGUgZGVwZW5kZW5jeS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLmdldERlcGVuZGVuY3kgPSBmdW5jdGlvbiAoZGVwZW5kZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChkZXBlbmRlbmN5KSB8fCBkZXBlbmRlbmN5ID09PSBfX05PT1BfSU5KRUNUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW5qZWN0b3IuX19ub29wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChJbmplY3Rvci5pc0luamVjdG9yKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3k7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5qZWN0b3IuX19sb2NhdGVJbmplY3RvcihkZXBlbmRlbmN5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGRlcGVuZGVuY2llcyBzcGVjaWZpZWQgYnkgdGhlaXIgQ29uc3RydWN0b3JzIGludG9cclxuICAgICAgICAgICAgICogZXF1aXZhbGVudCBkZXBlbmRlbmNpZXMgc3BlY2lmaWVkIGJ5IHRoZWlyIHJlZ2lzdGVyZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAqIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gZGVwZW5kZW5jaWVzIFRoZSBhcnJheSBvZiBkZXBlbmRlbmNpZXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgICAqIGJ5IGVpdGhlciB0aGVpciBDb25zdHJ1Y3RvciBvciB0aGVpciByZWdpc3RlcmVkIG5hbWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGRlcGVuZGVuY2llcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udmVydCA9IEluamVjdG9yLmNvbnZlcnREZXBlbmRlbmN5LCBkZXBzID0gW10sIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwcy5wdXNoKGNvbnZlcnQoZGVwZW5kZW5jaWVzW2ldKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENvbnZlcnRzIGEgZGVwZW5kZW5jeSBzcGVjaWZpZWQgYnkgaXRzIENvbnN0cnVjdG9ycyBpbnRvIGFuXHJcbiAgICAgICAgICAgICAqIGVxdWl2YWxlbnQgZGVwZW5kZW5jeSBzcGVjaWZpZWQgYnkgaXRzIHJlZ2lzdGVyZWQgc3RyaW5nXHJcbiAgICAgICAgICAgICAqIG5hbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBkZXBlbmRlbmN5IFRoZSBkZXBlbmRlbmN5IHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgKiBieSBlaXRoZXIgYSBDb25zdHJ1Y3RvciBvciBhIHJlZ2lzdGVyZWQgbmFtZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLmNvbnZlcnREZXBlbmRlbmN5ID0gZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19OT09QX0lOSkVDVE9SO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEluamVjdG9yLl9fZ2V0SW5qZWN0b3JOYW1lKGRlcGVuZGVuY3kpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgYmVpbmcgcGFzc2VkIGluIGZ1bGZpbGxzIHRoZSByZXF1aXJlbWVudHMgZm9yIGJlaW5nIGFuIEluamVjdG9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZGVwZW5kZW5jeS5JbmplY3Rvcjxhbnk+fSBkZXBlbmRlbmN5IFRoZSBvYmplY3QgdG8gY2hlY2suXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5pc0luamVjdG9yID0gZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGRlcGVuZGVuY3kuaW5qZWN0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFpc1VuZGVmaW5lZChkZXBlbmRlbmN5LnR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzVW5kZWZpbmVkKGRlcGVuZGVuY3kubmFtZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhaXNVbmRlZmluZWQoZGVwZW5kZW5jeS5Db25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBzdHJpbmcgbmFtZSByZWxhdGVkIHRvIGFuIGluamVjdG9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gZGVwZW5kZW5jeSBUaGUgb2JqZWN0IHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5fX2dldEluamVjdG9yTmFtZSA9IGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fTk9PUF9JTkpFQ1RPUjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGRlcGVuZGVuY3kpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcGVuZGVuY3k7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBkZXBlbmRlbmN5LCBfaW5qZWN0ID0gaXNPYmplY3QoQ29uc3RydWN0b3IuX2luamVjdCkgPyBDb25zdHJ1Y3Rvci5faW5qZWN0IDoge307XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoQ29uc3RydWN0b3IuX19pbmplY3Rvck5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IENvbnN0cnVjdG9yLl9faW5qZWN0b3JOYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhkZXBlbmRlbmN5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW5qZWN0b3IoZGVwZW5kZW5jeSwgQ29uc3RydWN0b3IsIF9pbmplY3QuZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmaW5kID0gSW5qZWN0b3IuX19maW5kSW5qZWN0b3IuYmluZChJbmplY3RvciwgZGVwZW5kZW5jeSksIGluamVjdG9yID0gZmluZChpbmplY3RhYmxlSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQodW5yZWdpc3RlcmVkSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQoc3RhdGljSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQodmlld0NvbnRyb2xJbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZChjb250cm9sSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQoYW5pbWF0aW9uSW5qZWN0b3JzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmQoanNBbmltYXRpb25JbmplY3RvcnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChpbmplY3RvcikgJiYgaXNTdHJpbmcoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IHVucmVnaXN0ZXJlZEluamVjdG9yc1tkZXBlbmRlbmN5XSA9IG5ldyBJbmplY3RvcihkZXBlbmRlbmN5LCBDb25zdHJ1Y3RvciwgQ29uc3RydWN0b3IuX2luamVjdC5kZXBlbmRlbmNpZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmplY3Rvci5uYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fTk9PUF9JTkpFQ1RPUjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxzIHRoZSBpbmplY3RvcidzIGNvbnN0cnVjdG9yIHdpdGggdGhlIGFzc29jaWF0ZWQgZGVwZW5kZW5jaWVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gQ29uc3RydWN0b3IgVGhlIENvbnN0cnVjdG9yIHRvIGNhbGwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuX19jb25zdHJ1Y3QgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGFyZ3MsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoQ29uc3RydWN0b3IpIHx8IGlzTnVsbChDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUoQ29uc3RydWN0b3IucHJvdG90eXBlKSwgaXNJbnN0YW5jZSA9IHR5cGUgPT09IF9fSU5TVEFOQ0UsIHRvSW5qZWN0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0luamVjdCA9IGluc3RhbmNlSW5qZWN0b3JEZXBlbmRlbmNpZXNbQ29uc3RydWN0b3IuX19pbmplY3Rvck5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdCh0b0luamVjdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0luamVjdCA9IEluamVjdG9yLl9fd2FsayhvYmosIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopLCB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJbmplY3RvckRlcGVuZGVuY2llc1tDb25zdHJ1Y3Rvci5fX2luamVjdG9yTmFtZV0gPSB0b0luamVjdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gYWNxdWlyZShtYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfSwgdG9JbmplY3QpKSwga2V5cyA9IE9iamVjdC5rZXlzKHRvSW5qZWN0KSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleXNbaV1dID0gZGVwZW5kZW5jaWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IG9iai5jb25zdHJ1Y3Rvci5hcHBseShvYmosIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXYWxrcyB1cCBhbiBvYmplY3QncyBwcm90b3R5cGUsIGluamVjdGluZyBkZXBlbmRlbmNpZXMgaWYgdGhleSBhcmVcclxuICAgICAgICAgICAgICogcmVnaXN0ZXJlZCBvbiBzdGF0aWMgJ19pbmplY3QnIG9iamVjdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byB3YWxrLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcHJvdG8gdGhlIHByb3RvdHlwZSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuX193YWxrID0gZnVuY3Rpb24gKG9iaiwgcHJvdG8sIGV4dGVuZFdpdGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yLCBwYXJlbnRJbmplY3QgPSB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChDb25zdHJ1Y3Rvci5faW5qZWN0KSAmJiBDb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5qZWN0ID0gSW5qZWN0b3IuX193YWxrKG9iaiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSwgZXh0ZW5kV2l0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9JbmplY3QgPSBfY2xvbmUoQ29uc3RydWN0b3IuX2luamVjdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZChmYWxzZSwgZmFsc2UsIHt9LCBleHRlbmRXaXRoLCBwYXJlbnRJbmplY3QsIHRvSW5qZWN0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIGFuIGluamVjdG9yIG9iamVjdCB3aXRoIHRoZSBhc3NvY2lhdGVkIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gQ29uc3RydWN0b3IgVGhlIENvbnN0cnVjdG9yIHRvIGxvY2F0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLl9fbG9jYXRlSW5qZWN0b3IgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBDb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhDb25zdHJ1Y3Rvci5fX2luamVjdG9yTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gQ29uc3RydWN0b3IuX19pbmplY3Rvck5hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZmluZCA9IEluamVjdG9yLl9fZmluZEluamVjdG9yLmJpbmQoSW5qZWN0b3IsIGRlcGVuZGVuY3kpLCBpbmplY3RvciA9IGZpbmQoaW5qZWN0YWJsZUluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKHVucmVnaXN0ZXJlZEluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKHN0YXRpY0luamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKGNvbnRyb2xJbmplY3RvcnMpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZCh2aWV3Q29udHJvbEluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKGFuaW1hdGlvbkluamVjdG9ycykgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaW5kKGpzQW5pbWF0aW9uSW5qZWN0b3JzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoaW5qZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoZGVwZW5kZW5jeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgPSB1bmlxdWVJZChfX1BsYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdG9yID0gbmV3IEluamVjdG9yKGRlcGVuZGVuY3ksIENvbnN0cnVjdG9yLCBpc09iamVjdChDb25zdHJ1Y3Rvci5faW5qZWN0KSA/IENvbnN0cnVjdG9yLl9pbmplY3RvckRlcGVuZGVuY2llcyA6IFtdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlcmVkSW5qZWN0b3JzW2RlcGVuZGVuY3ldID0gaW5qZWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IEluamVjdG9yLl9fd3JhcChDb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluamVjdG9yO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgYW4gaW5qZWN0b3Igb2JqZWN0IHdpdGggdGhlIGFzc29jaWF0ZWQgY29uc3RydWN0b3IgaW4gdGhlIGdpdmVuIEluamVjdG9yT2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb25zdHJ1Y3RvciBUaGUgRnVuY3Rpb25cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLl9fZmluZEluamVjdG9yID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBpbmplY3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoQ29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQ29uc3RydWN0b3IgPT09IEluamVjdG9yIHx8IENvbnN0cnVjdG9yID09PSBfX0luamVjdG9yU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IEluamVjdG9yLl9fd3JhcChJbmplY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0Lm5hbWUgPSBfX0luamVjdG9yU3RhdGljO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhDb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0b3JzW0NvbnN0cnVjdG9yXSB8fCBpbmplY3RvcnNbQ29uc3RydWN0b3IudG9Mb3dlckNhc2UoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPbmNlIGFuIGluamVjdG9yIGlzIGluamVjdGVkLCBpdCBpcyB3cmFwcGVkIHRvIHByZXZlbnQgZnVydGhlciBpbmplY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgaW5qZWN0ZWQgdmFsdWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5fX3dyYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX1dSQVBQRURfSU5KRUNUT1IsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBDb25zdHJ1Y3RvcjogdmFsdWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFuIGVtcHR5IGluamVjdG9yIG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLl9fbm9vcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0OiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IF9fTk9PUF9JTkpFQ1RPUixcclxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX05PT1BfSU5KRUNUT1IsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBDb25zdHJ1Y3Rvcjogbm9vcFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgdGhlcmUgaXMgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGluIGEgZGVwZW5kZW5jeSB0cmVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZGVwZW5kZW5jeS5JbmplY3Rvcjxhbnk+fSBpbmplY3RvciBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBkZXBlbmRlbmN5IHRyZWUgc2VhcmNoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSW5qZWN0b3IuX19maW5kQ2lyY3VsYXJSZWZlcmVuY2VzID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc09iamVjdChpbmplY3RvcikgJiYgaXNBcnJheShpbmplY3Rvci5kZXBlbmRlbmNpZXMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBpbmplY3Rvci5uYW1lLCBkZXBlbmRlbmNpZXMgPSBpbmplY3Rvci5kZXBlbmRlbmNpZXMsIG5vZGUsIHN0YWNrID0gW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcy5zbGljZSgwKVxyXG4gICAgICAgICAgICAgICAgICAgIH1dLCBkZXBlbmRlbmN5LCBsb2NhdGUgPSBJbmplY3Rvci5fX2xvY2F0ZUluamVjdG9yLCBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBzdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMgPSBub2RlLmRlcGVuZGVuY2llcztcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IGxvY2F0ZShkZXBlbmRlbmN5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNPYmplY3QoaW5qZWN0b3IpICYmIGlzQXJyYXkoaW5qZWN0b3IuZGVwZW5kZW5jaWVzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaW5qZWN0b3IubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llczogaW5qZWN0b3IuZGVwZW5kZW5jaWVzLnNsaWNlKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdhdGhlcnMgdGhlIGRlcGVuZGVuY2llcyBmb3IgdGhlIEluamVjdG9yIG9iamVjdCBhbmQgY3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGVcclxuICAgICAgICAgICAgICogQ29uc3RydWN0b3IsIHBhc3NpbmcgaW4gdGhlIGRlcGVuZGVuY2llcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIHNwZWNpZmllZC4gSWYgdGhlXHJcbiAgICAgICAgICAgICAqIEluamVjdG9yIGNvbnRhaW5zIGEgQ29uc3RydWN0b3IgZm9yIGFuIGluamVjdGFibGUgYW5kIHRoZSBDb25zdHJ1Y3RvciBpcyByZWdpc3RlcmVkXHJcbiAgICAgICAgICAgICAqIGFzIGEgU0lOR0xFIHR5cGUgaXQgd2lsbCBvbmx5IGluamVjdCB0aGF0IGluamVjdGFibGUgb25jZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEluamVjdG9yLnByb3RvdHlwZS5pbmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9JbmplY3QgPSBbXSwgdHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSB0aGlzLmRlcGVuZGVuY2llcywgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aCwgZGVwZW5kZW5jeSwgaW5qZWN0YWJsZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5ID0gSW5qZWN0b3IuZ2V0RGVwZW5kZW5jeShkZXBlbmRlbmNpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvSW5qZWN0LnB1c2goZGVwZW5kZW5jeS5pbmplY3QoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmplY3RhYmxlID0gSW5qZWN0b3IuX19jb25zdHJ1Y3QodGhpcy5Db25zdHJ1Y3RvciwgdG9JbmplY3QsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHR5cGUpICYmIHR5cGUgIT09IF9fSU5TVEFOQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cmFwSW5qZWN0b3IoaW5qZWN0YWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmplY3RhYmxlLl9faW5qZWN0YWJsZV9fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5qZWN0YWJsZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdyYXBzIHRoZSBpbmplY3RvciB3aXRoIHRoZSBpbnN0YW50aWF0ZWQgdmFsdWUgaW4gdGhlIGNhc2Ugb2YgYVxyXG4gICAgICAgICAgICAgKiBTSU5HTEUgb3IgU1RBVElDIHR5cGUgc28gdGhhdCBpdCBkb2VzIG5vdCByZS1pbnN0YW50aWF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBJbmplY3Rvci5wcm90b3R5cGUuX3dyYXBJbmplY3RvciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gSW5qZWN0b3I7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBkZXBlbmRlbmN5XzEuSW5qZWN0b3IgPSBJbmplY3RvcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQdWJsaWNhbGx5IGV4cG9zZXMgYWxsIHRoZSBkZXBlbmRlbmN5IGluamVjdG9yIG9iamVjdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGluamVjdG9ycztcclxuICAgICAgICAoZnVuY3Rpb24gKGluamVjdG9ycykge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gSW5qZWN0b3JPYmplY3Qgb2YgQ29udHJvbHMuXHJcbiAgICAgICAgICAgICAqIENvbnRhaW5zIGFsbCB0aGUgcmVnaXN0ZXJlZCBjb250cm9scyBmb3IgYW4gYXBwbGljYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpbmplY3RvcnMuY29udHJvbCA9IGNvbnRyb2xJbmplY3RvcnM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBJbmplY3Rvck9iamVjdCBvZiBJQmFzZVZpZXdDb250cm9scy5cclxuICAgICAgICAgICAgICogQ29udGFpbnMgYWxsIHRoZSByZWdpc3RlcmVkIHZpZXcgY29udHJvbHMgZm9yIGFuIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0b3JzLnZpZXdDb250cm9sID0gdmlld0NvbnRyb2xJbmplY3RvcnM7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbiBJbmplY3Rvck9iamVjdCBvZiBvYmplY3RzLiBDb250YWlucyBhbGwgdGhlIHJlZ2lzdGVyZWRcclxuICAgICAgICAgICAgICogaW5qZWN0YWJsZXMgZm9yIGFuIGFwcGxpY2F0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0b3JzLmluamVjdGFibGUgPSBpbmplY3RhYmxlSW5qZWN0b3JzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gSW5qZWN0b3JPYmplY3Qgb2Ygc3RhdGljIG9iamVjdHMuIENvbnRhaW5zIGFsbCB0aGUgcmVnaXN0ZXJlZFxyXG4gICAgICAgICAgICAgKiBzdGF0aWMgaW5qZWN0YWJsZXMgZm9yIGFuIGFwcGxpY2F0aW9uLiBPbmNlIHRoZSBpbmplY3RhYmxlcyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHRoZXkgYXJlIHJlbW92ZWQgZnJvbSB0aGlzIG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdG9ycy5zdGF0aWNJbmplY3RhYmxlID0gc3RhdGljSW5qZWN0b3JzO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gSW5qZWN0b3JPYmplY3Qgb2YgYW5pbWF0aW9ucy4gQ2FuIGJlIGVpdGhlciBDU1Mgb3IgSlMgaW1wbGVtZW50YXRpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaW5qZWN0b3JzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbkluamVjdG9ycztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIEluamVjdG9yT2JqZWN0ICBvZiBhbmltYXRpb25zLiBTaG91bGQgb25seSBjb250YWluIEpTIGltcGxlbWVudGF0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGluamVjdG9ycy5qc0FuaW1hdGlvbiA9IGpzQW5pbWF0aW9uSW5qZWN0b3JzO1xyXG4gICAgICAgIH0pKGluamVjdG9ycyA9IGRlcGVuZGVuY3lfMS5pbmplY3RvcnMgfHwgKGRlcGVuZGVuY3lfMS5pbmplY3RvcnMgPSB7fSkpO1xyXG4gICAgfSkoZGVwZW5kZW5jeSA9IHBsYXRfMS5kZXBlbmRlbmN5IHx8IChwbGF0XzEuZGVwZW5kZW5jeSA9IHt9KSk7XHJcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHdpbmRvdykpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQod2luZG93LnBsYXQpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5wbGF0ID0gcGxhdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHdpbmRvdy5tb2R1bGUpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5tb2R1bGUgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhY3F1aXJlKGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgIHZhciBkZXBzLCBhcnJheSA9IGlzQXJyYXkoZGVwZW5kZW5jaWVzKTtcclxuICAgICAgICBpZiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgZGVwcyA9IGRlcGVuZGVuY3kuSW5qZWN0b3IuZ2V0RGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXBzID0gZGVwZW5kZW5jeS5JbmplY3Rvci5nZXREZXBlbmRlbmNpZXMoW2RlcGVuZGVuY2llc10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVuZ3RoID0gZGVwcy5sZW5ndGgsIG91dHB1dCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goZGVwc1tpXS5pbmplY3QoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYXJyYXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIHBsYXRfMS5hY3F1aXJlID0gYWNxdWlyZTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgYWxsIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBkZWJ1Z2dpbmcgY29tcG9uZW50cyBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIGRlYnVnO1xyXG4gICAgKGZ1bmN0aW9uIChkZWJ1Zykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgYWxsIGxvZ2dpbmcvZGVidWdnaW5nIGZvciB0aGUgZnJhbWV3b3JrLiBBbGwgbG9ncyB3aWxsIGJlIGJ1YmJsZWQgdXAgdG8gdGhlXHJcbiAgICAgICAgICogQXBwLmVycm9yIGV2ZW50IHRvIGFsbG93IGZvciBlYXN5IGRlYnVnZ2luZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTG9nID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTG9nKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgRVJST1IgbG9nIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuRVJST1IgPSA1O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgV0FSTiBsb2cgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5XQVJOID0gNDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIElORk8gbG9nIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuSU5GTyA9IDM7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBERUJVRyBsb2cgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ERUJVRyA9IDI7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBUUkFDRSBsb2cgbGV2ZWxcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5UUkFDRSA9IDE7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgY29uZmlndXJhYmxlIGxvZyBsZXZlbCAoZGVmYXVsdHMgdG8gSU5GTykuIEFueSBsb2dzIHNlbnQgYmVsb3cgdGhpc1xyXG4gICAgICAgICAgICAgICAgICogd2lsbCBiZSBzaWxlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdGhpcy5JTkZPO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb2dzIGZhdGFsIGVycm9ycy4gVGhpcyB3aWxsIHRocm93IHRoZSBlcnJvciBhZnRlciBpdCBpcyBsb2dnZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byBsb2cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMb2cucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2coZXJyb3IsIHRoaXMuRVJST1IpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIExvZy5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cobWVzc2FnZSwgdGhpcy5XQVJOKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTG9nLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhtZXNzYWdlLCB0aGlzLklORk8pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBMb2cucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZyhtZXNzYWdlLCB0aGlzLkRFQlVHKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTG9nLnByb3RvdHlwZS50cmFjZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cobWVzc2FnZSwgdGhpcy5UUkFDRSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIExvZy5wcm90b3R5cGUuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhsZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXNbbGV2ZWwudG9VcHBlckNhc2UoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLkVSUk9SOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5XQVJOOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5JTkZPOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5ERUJVRzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIHRoaXMuVFJBQ0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xldmVsID0gdGhpcy5JTkZPO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBMb2cucHJvdG90eXBlLl9sb2cgPSBmdW5jdGlvbiAobWVzc2FnZSwgbGV2ZWwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2hvdWxkTG9nKGxldmVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX0Vycm9yRXZlbnQgPSB0aGlzLl9FcnJvckV2ZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChfRXJyb3JFdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfRXJyb3JFdmVudCA9IHRoaXMuX0Vycm9yRXZlbnQgPSBhY3F1aXJlKF9fRXJyb3JFdmVudFN0YXRpYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfRXJyb3JFdmVudC5kaXNwYXRjaChfX2Vycm9yLCBMb2csIG1lc3NhZ2UsIGxldmVsKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVtaW5lcyB3aGV0aGVyIG9yIG5vdCBhIGxvZyBsZXZlbCBpcyBhdCBvciBhYm92ZSB0aGUgY3VycmVudCBtaW5pbXVtIGxvZyBsZXZlbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIFRoZSBsb2cgbGV2ZWwgdG8gY2hlY2sgYWdhaW5zdCB0aGUgY3VycmVudCBtaW5pbXVtIGxvZyBsZXZlbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIExvZy5wcm90b3R5cGUuX3Nob3VsZExvZyA9IGZ1bmN0aW9uIChsZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihsZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXZlbCA9IHRoaXMuSU5GTztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZXZlbCA8IGxldmVsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gTG9nO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZGVidWcuTG9nID0gTG9nO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Mb2csIExvZyk7XHJcbiAgICB9KShkZWJ1ZyA9IHBsYXRfMS5kZWJ1ZyB8fCAocGxhdF8xLmRlYnVnID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogQSBjbGFzcyBjb250YWluaW5nIGJvb2xlYW4gdmFsdWVzIHNpZ25pZnlpbmcgYnJvd3NlclxyXG4gICAgICogYW5kL29yIHBsYXRmb3JtIGNvbXBhdGliaWxpdGllcy5cclxuICAgICAqL1xyXG4gICAgdmFyIENvbXBhdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lIGV2ZXJ5dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQ29tcGF0KCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGV2ZW50IGxvb2t1cHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9fZXZlbnRzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVCb29sZWFucygpO1xyXG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lTWFwcGVkRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVWZW5kb3JEZXBlbmRlbmNpZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fX2RldGVybWluZUNzcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayB3aGV0aGVyIG9yIG5vdCBhbiBldmVudCBleGlzdHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCB0byBjaGVjayB0aGUgZXhpc3RlbmNlIG9mLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbXBhdC5wcm90b3R5cGUuaGFzRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX19ldmVudHMsIGV2ZW50RXhpc3RzID0gZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGV2ZW50RXhpc3RzKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudCA9PT0gJ2lucHV0JyAmJiB0aGlzLklFID09PSA5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRFeGlzdHMgPSBldmVudHNbZXZlbnRdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudEV4aXN0cyA9IGV2ZW50c1tldmVudF0gPSAhaXNVbmRlZmluZWQoZWxlbWVudFsoJ29uJyArIGV2ZW50KV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEV4aXN0cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZSBib29sZWFucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb21wYXQucHJvdG90eXBlLl9fZGVmaW5lQm9vbGVhbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfd2luZG93ID0gdGhpcy5fd2luZG93LCBuYXZpZ2F0b3IgPSBfd2luZG93Lm5hdmlnYXRvciB8fCB7fSwgdXNlckFnZW50ID0gKG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJycpLnRvTG93ZXJDYXNlKCksIGhpc3RvcnkgPSB0aGlzLl9oaXN0b3J5LCBkZWYgPSBfd2luZG93LmRlZmluZSwgbXNBID0gX3dpbmRvdy5NU0FwcCwgd2luSnMgPSBfd2luZG93LldpbkpTLCBhbmRyb2lkID0gKC9hbmRyb2lkICgoPzpcXGR8XFwuKSspLy5leGVjKHVzZXJBZ2VudCkgfHwgW10pWzFdO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoYW5kcm9pZCkgJiYgIS9pZW1vYmlsZS9pLnRlc3QodXNlckFnZW50KSkge1xyXG4gICAgICAgICAgICAgICAgYW5kcm9pZCA9IHBhcnNlSW50KGFuZHJvaWQucmVwbGFjZSgvXFwuL2csICcnKSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaXNDb21wYXRpYmxlID0gaXNGdW5jdGlvbihPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIGlzRnVuY3Rpb24odGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3Rvcik7XHJcbiAgICAgICAgICAgIHRoaXMuY29yZG92YSA9ICFpc051bGwoX3dpbmRvdy5jb3Jkb3ZhKTtcclxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUgPSAhKGlzTnVsbChoaXN0b3J5KSB8fCBpc051bGwoaGlzdG9yeS5wdXNoU3RhdGUpKTtcclxuICAgICAgICAgICAgdGhpcy5maWxlU3VwcG9ydGVkID0gIShpc1VuZGVmaW5lZChfd2luZG93LkZpbGUpIHx8IGlzVW5kZWZpbmVkKF93aW5kb3cuRm9ybURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5hbWQgPSBpc0Z1bmN0aW9uKGRlZikgJiYgIWlzTnVsbChkZWYuYW1kKTtcclxuICAgICAgICAgICAgdGhpcy5tc0FwcCA9IGlzT2JqZWN0KG1zQSkgJiYgaXNGdW5jdGlvbihtc0EuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICB0aGlzLndpbkpzID0gaXNPYmplY3Qod2luSnMpICYmIGlzT2JqZWN0KHdpbkpzLkFwcGxpY2F0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5pbmRleGVkRGIgPSAhaXNOdWxsKF93aW5kb3cuaW5kZXhlZERCKTtcclxuICAgICAgICAgICAgdGhpcy5wcm90byA9IGlzT2JqZWN0KHt9Ll9fcHJvdG9fXyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0UHJvdG8gPSBpc0Z1bmN0aW9uKE9iamVjdC5nZXRQcm90b3R5cGVPZik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvdG8gPSBpc0Z1bmN0aW9uKE9iamVjdC5zZXRQcm90b3R5cGVPZik7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzVG91Y2hFdmVudHMgPSAhaXNVbmRlZmluZWQoX3dpbmRvdy5vbnRvdWNoc3RhcnQpO1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BvaW50ZXJFdmVudHMgPSAhIW5hdmlnYXRvci5wb2ludGVyRW5hYmxlZDtcclxuICAgICAgICAgICAgdGhpcy5oYXNNc1BvaW50ZXJFdmVudHMgPSAhIW5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xyXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoYW5kcm9pZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuQU5EUk9JRCA9IGFuZHJvaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGllID0gcGFyc2VJbnQoKC9tc2llIChcXGQrKS8uZXhlYyh1c2VyQWdlbnQpIHx8IFtdKVsxXSwgMTApIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJzZUludCgoL3RyaWRlbnRcXC8uKjsgcnY6KFxcZCspLy5leGVjKHVzZXJBZ2VudCkgfHwgW10pWzFdLCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChpc051bWJlcihpZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuSUUgPSBpZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmaW5lIG1hcHBlZCBldmVudHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBDb21wYXQucHJvdG90eXBlLl9fZGVmaW5lTWFwcGVkRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZEV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hzdGFydDogJ3BvaW50ZXJkb3duJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hlbmQ6ICdwb2ludGVydXAnLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaG1vdmU6ICdwb2ludGVybW92ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoY2FuY2VsOiAncG9pbnRlcmNhbmNlbCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNNc1BvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkRXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaHN0YXJ0OiAnTVNQb2ludGVyRG93bicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoZW5kOiAnTVNQb2ludGVyVXAnLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaG1vdmU6ICdNU1BvaW50ZXJNb3ZlJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hjYW5jZWw6ICdNU1BvaW50ZXJDYW5jZWwnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzVG91Y2hFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkRXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaHN0YXJ0OiAndG91Y2hzdGFydCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoZW5kOiAndG91Y2hlbmQnLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaG1vdmU6ICd0b3VjaG1vdmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGNhbmNlbDogJ3RvdWNoY2FuY2VsJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkRXZlbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hlbmQ6ICdtb3VzZXVwJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hjYW5jZWw6IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmluZSBhbmltYXRpb24gZXZlbnRzIGFuZCBvdGhlciB2ZW5kb3IgcHJlZml4XHJcbiAgICAgICAgICogZGVwZW5kZW5jaWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbXBhdC5wcm90b3R5cGUuX19kZWZpbmVWZW5kb3JEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfd2luZG93ID0gdGhpcy5fd2luZG93LCBkb2N1bWVudEVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHN0eWxlcyA9IF93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudEVsZW1lbnQsICcnKSwgbWF0Y2hlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHN0eWxlcykuam9pbignJykubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLyksIHByZWZpeCwgZG9tLCBjc3MsIGpzU3ludGF4O1xyXG4gICAgICAgICAgICBpZiAoKGlzQXJyYXkobWF0Y2hlcykgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSkge1xyXG4gICAgICAgICAgICAgICAgcHJlZml4ID0gKGlzQXJyYXkobWF0Y2hlcykgJiYgbWF0Y2hlcy5sZW5ndGggPiAxKSA/IG1hdGNoZXNbMV0gOiAnJztcclxuICAgICAgICAgICAgICAgIGpzU3ludGF4ID0gcHJlZml4WzBdLnRvVXBwZXJDYXNlKCkgKyBwcmVmaXguc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICBkb20gPSAoJ1dlYktpdHxNb3p8TVMnKS5tYXRjaChuZXcgUmVnRXhwKCcoJyArIHByZWZpeCArICcpJywgJ2knKSlbMV07XHJcbiAgICAgICAgICAgICAgICBjc3MgPSAnLScgKyBwcmVmaXggKyAnLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKHN0eWxlcy5PTGluaykpIHtcclxuICAgICAgICAgICAgICAgIHByZWZpeCA9ICdvJztcclxuICAgICAgICAgICAgICAgIGpzU3ludGF4ID0gZG9tID0gJ08nO1xyXG4gICAgICAgICAgICAgICAgY3NzID0gJy1vLSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBqc1N5bnRheCA9IGRvbSA9IGNzcyA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmVuZG9yUHJlZml4ID0ge1xyXG4gICAgICAgICAgICAgICAgZG9tOiBkb20sXHJcbiAgICAgICAgICAgICAgICBsb3dlckNhc2U6IHByZWZpeCxcclxuICAgICAgICAgICAgICAgIGNzczogY3NzLFxyXG4gICAgICAgICAgICAgICAgdXBwZXJDYXNlOiBqc1N5bnRheFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IF93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IF93aW5kb3dbcHJlZml4ICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gX3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgX3dpbmRvd1twcmVmaXggKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gfHxcclxuICAgICAgICAgICAgICAgIF93aW5kb3dbcHJlZml4ICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ107XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50RWxlbWVudC5zdHlsZTtcclxuICAgICAgICAgICAgLy8gaGFuZGxlIEFuZHJvaWQgaXNzdWUgd2hlcmUgc3R5bGUudHJhbnNpdGlvbiBleGlzdHMgYnV0IHRyYW5zaXRpb24gZXZlbnRzIHN0aWxsIG5lZWQgdmVuZG9yIHByZWZpeCBcclxuICAgICAgICAgICAgLy8gc2hvdWxkIG9ubHkgYWZmZWN0IHZlcnNpb24gNC4xIGJ1dCB3ZSB3aWxsIGhhbmRsZSBmb3IgPCA0LjQuIFxyXG4gICAgICAgICAgICBpZiAoKGlzVW5kZWZpbmVkKHRoaXMuQU5EUk9JRCkgfHwgTWF0aC5mbG9vcih0aGlzLkFORFJPSUQgLyAxMCkgPj0gNDQpICYmXHJcbiAgICAgICAgICAgICAgICAhKGlzVW5kZWZpbmVkKHN0eWxlLmFuaW1hdGlvbikgfHwgaXNVbmRlZmluZWQoc3R5bGUudHJhbnNpdGlvbikpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkYW5pbWF0aW9uOiAnYW5pbWF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAkYW5pbWF0aW9uU3RhcnQ6ICdhbmltYXRpb25zdGFydCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvbkVuZDogJ2FuaW1hdGlvbmVuZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvbkl0ZXJhdGlvbjogJ2FuaW1hdGlvbml0ZXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zaXRpb246ICd0cmFuc2l0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhbnNpdGlvblN0YXJ0OiAndHJhbnNpdGlvbnN0YXJ0JyxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhbnNpdGlvbkVuZDogJ3RyYW5zaXRpb25lbmQnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCEoaXNVbmRlZmluZWQoc3R5bGVbanNTeW50YXggKyAnQW5pbWF0aW9uJ10pIHx8IGlzVW5kZWZpbmVkKHN0eWxlW2pzU3ludGF4ICsgJ1RyYW5zaXRpb24nXSkpIHx8XHJcbiAgICAgICAgICAgICAgICAhKGlzVW5kZWZpbmVkKHN0eWxlW3ByZWZpeCArICdBbmltYXRpb24nXSkgfHwgaXNVbmRlZmluZWQoc3R5bGVbcHJlZml4ICsgJ1RyYW5zaXRpb24nXSkpIHx8XHJcbiAgICAgICAgICAgICAgICAhKGlzVW5kZWZpbmVkKHN0eWxlW2RvbSArICdBbmltYXRpb24nXSkgfHwgaXNVbmRlZmluZWQoc3R5bGVbZG9tICsgJ1RyYW5zaXRpb24nXSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkV2ZW50cyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkYW5pbWF0aW9uOiBwcmVmaXggKyAnQW5pbWF0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAkYW5pbWF0aW9uU3RhcnQ6IHByZWZpeCArICdBbmltYXRpb25TdGFydCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvbkVuZDogcHJlZml4ICsgJ0FuaW1hdGlvbkVuZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGlvbkl0ZXJhdGlvbjogcHJlZml4ICsgJ0FuaW1hdGlvbkl0ZXJhdGlvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYW5zaXRpb246IHByZWZpeCArICdUcmFuc2l0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhbnNpdGlvblN0YXJ0OiBwcmVmaXggKyAnVHJhbnNpdGlvblN0YXJ0JyxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhbnNpdGlvbkVuZDogcHJlZml4ICsgJ1RyYW5zaXRpb25FbmQnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHBsYXR5cHVzIGNzcyBzdHlsZXMgZXhpc3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29tcGF0LnByb3RvdHlwZS5fX2RldGVybWluZUNzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBoZWFkID0gX2RvY3VtZW50LmhlYWQsIGVsZW1lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICBoZWFkLmluc2VydEJlZm9yZShlbGVtZW50LCBudWxsKTtcclxuICAgICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB0aGlzLl93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSwgZGlzcGxheSA9IGNvbXB1dGVkU3R5bGUuZGlzcGxheSwgdmlzaWJpbGl0eSA9IGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgdGhpcy5wbGF0Q3NzID0gZGlzcGxheSA9PT0gJ25vbmUnIHx8IHZpc2liaWxpdHkgPT09ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29tcGF0Ll9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfaGlzdG9yeTogX19IaXN0b3J5LFxyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBDb21wYXQ7XHJcbiAgICB9KCkpO1xyXG4gICAgcGxhdF8xLkNvbXBhdCA9IENvbXBhdDtcclxuICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Db21wYXQsIENvbXBhdCk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGV4dGVuc2libGUgY2xhc3MgZGVmaW5pbmcgY29tbW9uIHV0aWxpdGllcyBhbmQgaGVscGVyIGZ1bmN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgdmFyIFV0aWxzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBVdGlscygpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZW1wdHkgbWV0aG9kIGZvciBxdWlja2x5IGNyZWF0aW5nIGR1bW15IG9iamVjdHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLm5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsb3dzIHlvdSB0byBleHRlbmQgdGhlIHByb3BlcnRpZXMgb2YgYW4gb2JqZWN0IHdpdGggYW55IG51bWJlclxyXG4gICAgICAgICAqIG9mIG90aGVyIG9iamVjdHMuIElmIG9iamVjdHMgc2hhcmUgcHJvcGVydGllcywgdGhlIGxhc3Qgb2JqZWN0IGluIHRoZVxyXG4gICAgICAgICAqIGFyZ3VtZW50cyB3aWxsIHRha2UgcHJlY2VkZW5jZS4gVGhpcyBtZXRob2QgaXMgb25seSBhIHNoYWxsb3cgY29weSBvZlxyXG4gICAgICAgICAqIGFsbCB0aGUgc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gZGVzdGluYXRpb24gVGhlIGRlc3RpbmF0aW9uIG9iamVjdCB0byBleHRlbmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSAuLi5zb3VyY2VzIEFueSBudW1iZXIgb2Ygb2JqZWN0cyB3aXRoIHdoaWNoIHRvIGV4dGVuZCB0aGVcclxuICAgICAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZC5hcHBseShudWxsLCBbZmFsc2UsIGZhbHNlLCBkZXN0aW5hdGlvbl0uY29uY2F0KHNvdXJjZXMpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFsbG93cyB5b3UgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCB3aXRoIGFueSBudW1iZXJcclxuICAgICAgICAgKiBvZiBvdGhlciBvYmplY3RzLiBJZiBvYmplY3RzIHNoYXJlIHByb3BlcnRpZXMsIHRoZSBsYXN0IG9iamVjdCBpbiB0aGVcclxuICAgICAgICAgKiBhcmd1bWVudHMgd2lsbCB0YWtlIHByZWNlZGVuY2UuIFRoaXMgbWV0aG9kIGlzIGEgZGVlcCBjb3B5IG9mXHJcbiAgICAgICAgICogYWxsIHRoZSBzb3VyY2Ugb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBkZXN0aW5hdGlvbiBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHRvIGV4dGVuZC5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IC4uLnNvdXJjZXMgQW55IG51bWJlciBvZiBvYmplY3RzIHdpdGggd2hpY2ggdG8gZXh0ZW5kIHRoZVxyXG4gICAgICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuZGVlcEV4dGVuZCA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gX2V4dGVuZC5hcHBseShudWxsLCBbdHJ1ZSwgZmFsc2UsIGRlc3RpbmF0aW9uXS5jb25jYXQoc291cmNlcykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhlIHBhc3NlZC1pbiBvYmplY3QuIElmIGRlZXAgaXMgdHJ1ZSBpdCB3aWxsXHJcbiAgICAgICAgICogYmUgYSBkZWVwIGNvcHkgKGR1cGxpY2F0ZSksIGVsc2UgbmVzdGVkIG9iamVjdHMvYXJyYXlzIHdpbGwgYmUgY29waWVkIGJ5IHJlZmVyZW5jZVxyXG4gICAgICAgICAqIGFuZCBub3QgZHVwbGljYXRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge1R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGVlcD8gV2hldGhlciBvciBub3QgaXQgaXMgYSBkZWVwIGNsb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIGRlZXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9jbG9uZShvYmosIGRlZXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSB0eXBlIG9mIE9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIHdpbmRvdyBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNXaW5kb3cgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1dpbmRvdyhvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBkb2N1bWVudCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNEb2N1bWVudCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRG9jdW1lbnQob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgTm9kZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc05vZGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc05vZGUob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgRG9jdW1lbnRGcmFnbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0RvY3VtZW50RnJhZ21lbnQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0RvY3VtZW50RnJhZ21lbnQob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNTdHJpbmcob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGlzIGEgUmVnRXhwIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc1JlZ0V4cCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIFByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUHJvbWlzZShvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgZW1wdHkuIFVzZWZ1bCBmb3JcclxuICAgICAgICAgKiBjaGVja2luZyBmb3IgZW1wdHkgc3RyaW5ncywgYXJyYXlzLCBvciBvYmplY3RzIHdpdGhvdXQga2V5cy5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNFbXB0eShvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBib29sZWFuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzQm9vbGVhbiA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQm9vbGVhbihvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBudW1iZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNOdW1iZXIgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc051bWJlcihvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBGaWxlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzRmlsZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRmlsZShvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYSBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNOdWxsKG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyB1bmRlZmluZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNVbmRlZmluZWQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW55dGhpbmcgYW5kIGRldGVybWluZXMgaWYgaXQgaXMgYW4gQXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBBbnl0aGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuaXNBcnJheSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGFueXRoaW5nIGFuZCBkZXRlcm1pbmVzIGlmIGl0IGhhcyBhcnJheS1saWtlIHF1YWxpdGllcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIEFueXRoaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFV0aWxzLnByb3RvdHlwZS5pc0FycmF5TGlrZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbnl0aGluZyBhbmQgZGV0ZXJtaW5lcyBpZiBpdCBpcyBhIERhdGUgb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogQW55dGhpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmlzRGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRGF0ZShvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXIoaXRlcmF0b3IsIG9iaiwgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhIGxpc3QgYW5kIG9iamVjdCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlycyB0byBzZWFyY2ggZm9yIGluIHRoZSBsaXN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIG9iamVjdCBjb250YWluaW5nIGtleS92YWx1ZSBwYWlycyB0byBtYXRjaCB3aXRoIG9iaidzIHZhbHVlcy5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJheSBUaGUgbGlzdCB1c2VkIGZvciBzZWFyY2hpbmcgZm9yIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIGFycmF5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aGVyZShwcm9wZXJ0aWVzLCBhcnJheSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JFYWNoKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXAoaXRlcmF0b3IsIG9iaiwgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBVdGlscy5wcm90b3R5cGUubWFwQXN5bmMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIG9iaiwgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoaXRlcmF0b3IsIG9iaiwgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbiBhcnJheSBhbmQgYW4gaXRlcmF0b3IgZnVuY3Rpb24uIENhbGxzIHRoZSBpdGVyYXRvciB3aXRoIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlXHJcbiAgICAgICAgICogaXRlcmF0b3IgY2FuIHJldHVybiBhIHByb21pc2UgdGhlIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBtYXBwZWQgdmFsdWUuIFRoZSBuZXh0IHZhbHVlIGluIHRoZSBhcnJheSB3aWxsIG5vdCBiZSBwYXNzZWQgdG9cclxuICAgICAgICAgKiB0aGUgaXRlcmF0b3IgdW50aWwgdGhlIHByZXZpb3VzIHByb21pc2UgZnVsZmlsbHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LklMaXN0SXRlcmF0b3I8VCwgcGxhdC5hc3luYy5JVGhlbmFibGU8Uj4+fSBpdGVyYXRvciBUaGUgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxUPn0gYXJyYXkgQW4gQXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQ/IEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0byB0aGUgaXRlcmF0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLm1hcEFzeW5jSW5PcmRlciA9IGZ1bmN0aW9uIChpdGVyYXRvciwgYXJyYXksIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jSW5PcmRlcihpdGVyYXRvciwgYXJyYXksIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYW4gYXJyYXkgYW5kIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLiBDYWxscyB0aGUgaXRlcmF0b3Igd2l0aCBhbGwgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgaW4gZGVzY2VuZGluZyBvcmRlci4gVGhlXHJcbiAgICAgICAgICogaXRlcmF0b3IgY2FuIHJldHVybiBhIHByb21pc2UgdGhlIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBtYXBwZWQgdmFsdWUuIFRoZSBuZXh0IHZhbHVlIGluIHRoZSBhcnJheSB3aWxsIG5vdCBiZSBwYXNzZWQgdG9cclxuICAgICAgICAgKiB0aGUgaXRlcmF0b3IgdW50aWwgdGhlIHByZXZpb3VzIHByb21pc2UgZnVsZmlsbHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LklMaXN0SXRlcmF0b3I8VCwgcGxhdC5hc3luYy5JVGhlbmFibGU8Uj4+fSBpdGVyYXRvciBUaGUgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxUPn0gYXJyYXkgQW4gQXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQ/IEFuIG9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0byB0aGUgaXRlcmF0b3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLm1hcEFzeW5jSW5EZXNjZW5kaW5nT3JkZXIgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGFycmF5LCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYXBBc3luY0luRGVzY2VuZGluZ09yZGVyKGl0ZXJhdG9yLCBhcnJheSwgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBpbiBhbiBvYmplY3QgYW5kIGEgcHJvcGVydHkgdG8gZXh0cmFjdCBmcm9tIGFsbCBvZiB0aGUgb2JqZWN0J3MgdmFsdWVzLiBSZXR1cm5zIGFuIGFycmF5IG9mXHJcbiAgICAgICAgICogdGhlICdwbHVja2VkJyB2YWx1ZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkgdG8gJ3BsdWNrJyBmcm9tIGVhY2ggdmFsdWUgaW4gdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8VD59IGFycmF5IFRoZSBhcnJheSB0byBwbHVjayB0aGUga2V5IGZyb21cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUucGx1Y2sgPSBmdW5jdGlvbiAoa2V5LCBhcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGx1Y2soa2V5LCBhcnJheSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuc29tZSA9IGZ1bmN0aW9uIChpdGVyYXRvciwgb2JqLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb21lKGl0ZXJhdG9yLCBvYmosIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYSBtZXRob2QgYW5kIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoYXQgbWV0aG9kLiBEZWxheXMgY2FsbGluZyB0aGUgbWV0aG9kIHVudGlsXHJcbiAgICAgICAgICogYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBpcyBjbGVhci4gRXF1aXZhbGVudCB0byBhIHNldFRpbWVvdXQgd2l0aCBhIHRpbWVvdXQgb2YgMC5cclxuICAgICAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB2b2lkfSBtZXRob2QgVGhlIG1ldGhvZCB0byBjYWxsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncz8gVGhlIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBjb250ZXh0PyBBbiBvcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUucG9zdHBvbmUgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWZlcihtZXRob2QsIDAsIGFyZ3MsIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYSBtZXRob2QgYW5kIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoYXQgbWV0aG9kLiBEZWxheXMgY2FsbGluZyB0aGUgbWV0aG9kIHVudGlsXHJcbiAgICAgICAgICogYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBpcyBjbGVhci4gRXF1aXZhbGVudCB0byBhIHNldFRpbWVvdXQgd2l0aCB0aGUgc3BlY2lmaWVkIHRpbWVvdXQgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHsoLi4uYXJnczogQXJyYXk8YW55PikgPT4gdm9pZH0gbWV0aG9kIFRoZSBtZXRob2QgdG8gY2FsbC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaGUgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0byBkZWxheSBiZWZvcmUgY2FsbGluZyB0aGUgcHJvdmlkZWQgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncz8gVGhlIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBjb250ZXh0PyBBbiBvcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuZGVmZXIgPSBmdW5jdGlvbiAobWV0aG9kLCB0aW1lb3V0LCBhcmdzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWZlcihtZXRob2QsIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYSBtZXRob2QgYW5kIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoYXQgbWV0aG9kLiBBZGRzIHRoZSBtZXRob2QgdG8gdGhlIGNhbGwgc3RhY2sgZXZlcnlcclxuICAgICAgICAgKiBpbnRlcnZhbCBhbW91bnQgb2YgdGltZS4gRXF1aXZhbGVudCB0byBhIHNldEludGVydmFsIHdpdGggdGhlIHNwZWNpZmllZCBpbnRlcnZhbCB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0geyguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB2b2lkfSBtZXRob2QgVGhlIG1ldGhvZCB0byBjYWxsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlcnZhbCBUaGUgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBiZXR3ZWVuIGVhY2ggY29uc2VjdXRpdmUgY2FsbCBvZiB0aGUgcHJvdmlkZWQgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncz8gVGhlIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgbWV0aG9kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBjb250ZXh0PyBBbiBvcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gdGhlIG1ldGhvZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAobWV0aG9kLCBpbnRlcnZhbCwgYXJncywgY29udGV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0SW50ZXJ2YWxHbG9iYWwobWV0aG9kLCBpbnRlcnZhbCwgYXJncywgY29udGV4dCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpZiBpdCBpcyBhdmFpbGFibGUsIGVsc2UgaXQgZG9lcyBhIHNldFRpbWVvdXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtGcmFtZVJlcXVlc3RDYWxsYmFja30gbWV0aG9kIFRoZSBtZXRob2QgdG8gY2FsbCB3aGVuIHRoZSByZXF1ZXN0IGlzIGZ1bGZpbGxlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dD8gQW4gb3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIHRoZSBtZXRob2QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChtZXRob2QsIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChtZXRob2QsIGNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZXMgaW4gYSBwcmVmaXggYW5kIHJldHVybnMgYSB1bmlxdWUgaWRlbnRpZmllciBzdHJpbmcgd2l0aCB0aGUgcHJlZml4IHByZXByZW5kZWQuIElmIG5vIHByZWZpeFxyXG4gICAgICAgICAqIGlzIHNwZWNpZmllZCwgbm9uZSB3aWxsIGJlIHByZXBlbmRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4PyBBIHN0cmluZyBwcmVmaXggdG8gcHJlcGVuZCB0b3RoZSB1bmlxdWUgSUQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLnVuaXF1ZUlkID0gZnVuY3Rpb24gKHByZWZpeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5pcXVlSWQocHJlZml4KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGEgc3BpbmFsLWNhc2UsIGRvdC5jYXNlLCBvciBzbmFrZV9jYXNlIHN0cmluZyBhbmQgcmV0dXJuc1xyXG4gICAgICAgICAqIGEgY2FtZWxDYXNlIHN0cmluZy4gQWxzbyBjYW4gdHVybiBhIHN0cmluZyBpbnRvIGNhbWVsQ2FzZSB3aXRoIHNwYWNlXHJcbiAgICAgICAgICogYXMgYSBkZWxpbWV0ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3BpbmFsLWNhc2UsIGRvdC5jYXNlLCBvciBzbmFrZV9jYXNlIHN0cmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBVdGlscy5wcm90b3R5cGUuY2FtZWxDYXNlID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FtZWxDYXNlKHN0cik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYWtlcyBhIGNhbWVsQ2FzZSBzdHJpbmcgYW5kIGRlbGltaXRzIGl0IHVzaW5nIHRoZSBzcGVjaWZpZWQgZGVsaW1pdGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGNhbWVsQ2FzZWQgc3RyaW5nLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxpbWl0ZXIgVGhlIGRlbGltaXRlciB0byBhZGQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVXRpbHMucHJvdG90eXBlLmRlbGltaXQgPSBmdW5jdGlvbiAoc3RyLCBkZWxpbWl0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlbGltaXQoc3RyLCBkZWxpbWl0ZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFV0aWxzO1xyXG4gICAgfSgpKTtcclxuICAgIHBsYXRfMS5VdGlscyA9IFV0aWxzO1xyXG4gICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1V0aWxzLCBVdGlscyk7XHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gV2luZG93KCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuV2luZG93ID0gV2luZG93O1xyXG4gICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1dpbmRvdywgV2luZG93KTtcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBEb2N1bWVudChfd2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuIF93aW5kb3cuZG9jdW1lbnQ7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuRG9jdW1lbnQgPSBEb2N1bWVudDtcclxuICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Eb2N1bWVudCwgRG9jdW1lbnQsIFtfX1dpbmRvd10pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gZXhwcmVzc2lvbiBoYW5kbGluZyBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIGV4cHJlc3Npb25zO1xyXG4gICAgKGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tbW9ubHkgdXNlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSZWdleCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJlZ2V4KCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgZmluZGluZyBtYXJrdXAgaW4gYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubWFya3VwUmVnZXggPSBuZXcgUmVnRXhwKF9fc3RhcnRTeW1ib2wgKyAnW1xcXFxTXFxcXHNdKicgKyBfX2VuZFN5bWJvbCk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIHRoZSBhcmd1bWVudHMgaW4gYSBtZXRob2QgZXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmd1bWVudFJlZ2V4ID0gL1xcKCguKilcXCkvO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyAnLyouaHRtbCcgb3IgJy8qLmh0bScgaW4gYSB1cmwuIFVzZWZ1bCBmb3IgcmVtb3ZpbmdcclxuICAgICAgICAgICAgICAgICAqIHRoZSBodG1sIGZpbGUgb3V0IG9mIHRoZSB1cmwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFVybFJlZ2V4ID0gL1xcL1teXFwvXSpcXC4oPzpodG1sfGh0bSkvO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyBhIHByb3RvY29sIGRlbGltZXRlciBpbiBhIHN0cmluZyAoZS5nLiA6Ly8pLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sUmVnZXggPSAvOlxcL1xcLy87XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIExvb2tzIGZvciBhbnkgaW52YWxpZCB2YXJpYWJsZSBzeW50YXguXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZFZhcmlhYmxlUmVnZXggPSAvW15hLXpBLVowLTlAXyRdLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR3JhYnMgdGhlIGZpbGUgbmFtZSBmcm9tIGEgZmlsZSBwYXRoLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lUmVnZXggPSAvLiooPzpcXC98XFxcXCkvO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY2hhcmFjdGVyIGlzIGNvcnJlbGF0ZWQgd2l0aCBhIHNoaWZ0ZWQga2V5IGNvZGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2hpZnRlZEtleVJlZ2V4ID0gL1tBLVohQCMkJV4mKigpXyt9e1wiOj8+PHx+XS87XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgYSB1cmwgaXMgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZnVsbFVybFJlZ2V4ID0gL14oPzpbYS16MC05XFwtXSs6KSg/OlxcL1xcLyk/fCg/OlxcL1xcLykvaTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhbiBlbWFpbCBhZGRyZXNzIGlzIHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlRW1haWwgPSBuZXcgUmVnRXhwKCdeKChbXjw+KClbXFxcXF1cXFxcXFwuLDs6XFxcXHNAXFxcXFwiXSsoXFxcXC5bXjw+KClbXFxcXF1cXFxcXFwuLDs6XFxcXHNAXFxcXFwiXSspKil8JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyhcXFxcXCIuK1xcXFxcIikpQCgoXFxcXFtbMC05XXsxLDN9XFxcXC5bMC05XXsxLDN9XFxcXC5bMC05XXsxLDN9XFxcXC5bMC05XXsxLDN9XFxcXF0pfCcgK1xyXG4gICAgICAgICAgICAgICAgICAgICcoKFthLXpBLVpcXFxcLTAtOV0rXFxcXC4pK1thLXpBLVpdezIsfSkpJCcpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGEgdGVsZXBob25lIG51bWJlciBpcyB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVRlbGVwaG9uZSA9IC9eXFwrP1swLTlcXC5cXChcXClcXHMtXSokLztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIGR5bmFtaWMgc2VnbWVudHMgaW4gYSByb3V0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljU2VnbWVudHNSZWdleCA9IC9eOihbXlxcL10rKSQvO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgc3BsYXQgc2VnbWVudHMgaW4gYSByb3V0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zcGxhdFNlZ21lbnRSZWdleCA9IC9eXFwqKFteXFwvXSspJC87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2V4LnByb3RvdHlwZSwgXCJuZXdMaW5lUmVnZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgb3IgcmVtb3ZpbmcgYWxsIG5ld2xpbmUgY2hhcmFjdGVycy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXHJ8XFxuL2c7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2V4LnByb3RvdHlwZSwgXCJvcHRpb25hbFJvdXRlUmVnZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyBvcHRpb25hbCBwYXJhbWV0ZXJzIGluIGEgcm91dGUgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gL1xcKCguKj8pXFwpL2c7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2V4LnByb3RvdHlwZSwgXCJuYW1lZFBhcmFtZXRlclJvdXRlUmVnZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyBuYW1lZCBwYXJhbWV0ZXJzIGluIGEgcm91dGUgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyhcXChcXD8pPzpcXHcrL2c7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2V4LnByb3RvdHlwZSwgXCJ3aWxkY2FyZFJvdXRlUmVnZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyBhbiBhbHBoYW51bWVyaWMgd2lsZGNhcmQgbWF0Y2ggaW4gYSByb3V0ZSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBleGVjKCcvZm9vLypiYXIvYmF6Jyk7XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvXFwqXFx3Ki9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwiZXNjYXBlUm91dGVSZWdleFwiLCB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpbmRzIGludmFsaWQgY2hhcmFjdGVycyBpbiBhIHJvdXRlIHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9bXFwte31cXFtcXF0rPy4sXFxcXFxcXiR8I1xcc10vZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVnZXgucHJvdG90eXBlLCBcImNhbWVsQ2FzZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgZGVsaW1ldGVycyBmb3Igc3BpbmFsLWNhc2UsIHNuYWtlX2Nhc2UsIGFuZCBkb3QuY2FzZS5cclxuICAgICAgICAgICAgICAgICAqIHVzZWZ1bCBmb3IgY29udmVydGluZyB0byBjYW1lbENhc2UuIEFsc28gY2FuIHR1cm4gYSBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAqIGludG8gY2FtZWxDYXNlIHdpdGggc3BhY2UgYXMgYSBkZWxpbWV0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvKFtcXC1fXFwuXFxzXSkoXFx3Kz8pL2c7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZ2V4LnByb3RvdHlwZSwgXCJjYXBpdGFsQ2FzZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgYWxsIGNhcGl0YWwgbGV0dGVycy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9bQS1aXS9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwid2hpdGVTcGFjZVJlZ2V4XCIsIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmluZHMgYWxsIHdoaXRlc3BhY2UgYW5kIG5ld2xpbmUgY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgICogbm90IGluIHN0cmluZyBsaXRlcmFscy4gTmVlZHMgdG8gYmUgY29tYmluZWRcclxuICAgICAgICAgICAgICAgICAqIHdpdGggc3RyaW5nIHJlcGxhY2UgZnVuY3Rpb24gdXNpbmcgJDEgYXJndW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAvKFwiW15cIl0qP1wifCdbXiddKj8nKXxbXFxzXFxyXFxuXFx0XFx2XS9nO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWdleC5wcm90b3R5cGUsIFwicXVvdGF0aW9uUmVnZXhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyBhbGwgc2luZ2xlIGFuZCBkb3VibGUgcXVvdGVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLyd8XCIvZztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVnZXg7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBleHByZXNzaW9ucy5SZWdleCA9IFJlZ2V4O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19SZWdleCwgUmVnZXgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgdGFraW5nIGluIGEgSmF2YVNjcmlwdCBleHByZXNzaW9uIHN0cmluZyBhbmRcclxuICAgICAgICAgKiBmaW5kaW5nIGFsbCBvZiBpdHMgdG9rZW5zIChpLmUuIGRlbGltaXRlcnMsIG9wZXJhdG9ycywgZXRjKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVG9rZW5pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVG9rZW5pemVyKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJldmlvdXMgY2hhcmFjdGVyIGR1cmluZyB0b2tlbml6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19wcmV2aW91c0NoYXIgPSAnJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGRldGVybWluaW5nIGlmIGEgcG90ZW50aWFsIHZhcmlhYmxlIGlzIHZhbGlkIHN5bnRheC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3ZhcmlhYmxlUmVnZXggPSBhY3F1aXJlKF9fUmVnZXgpLmludmFsaWRWYXJpYWJsZVJlZ2V4O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHF1ZXVlIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBvdXRwdXQgb2YgdGhlIHRva2VuaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX291dHB1dFF1ZXVlID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgc3RhY2sgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgb3BlcmF0b3IgcHJlY2VkZW5jZSBhbmQgYWlkaW5nIHdpdGggdGhlIGV2YWx1YXRpb25cclxuICAgICAgICAgICAgICAgICAqIG9wZXJhbmRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3BlcmF0b3JTdGFjayA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGNvbGxlY3Rpb24gdXNlZCBmb3IgZGV0ZXJtaW5pbmcgYXJndW1lbnQgY291bnQgZm9yIGNlcnRhaW4gb3BlcmF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FyZ0NvdW50ID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgY29sbGVjdGlvbiB1c2VkIGZvciBkZXRlcm1pbmluZyBhcmd1bWVudCBjb3VudCBmb3IgY2VydGFpbiBvYmplY3QgbGl0ZXJhbCBvcGVyYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb2JqQXJnQ291bnQgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGxhc3QgY2hhcmFjdGVyIGVuY291bnRlcmVkIHdoaWxlIGluIGFuIG9wZXJhdGlvbiBkZWFsaW5nIHdpdGggdGhlIGNvbG9uIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICAgICAgICogTmVlZHMgdG8gYmUgYW4gYXJyYXkgZHVlIHRvIHRoZSBwb3NzaWJpbGl0eSBvZiBuZXN0ZWQgY29sb24gb3BlcmF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb2xvbkNoYXIgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGxhc3QgY2hhcmFjdGVyIGVuY291bnRlcmVkIHdoaWxlIGluIGFuIG9wZXJhdGlvbiBkZWFsaW5nIHdpdGggY29tbWFzLlxyXG4gICAgICAgICAgICAgICAgICogTmVlZHMgdG8gYmUgYW4gYXJyYXkgZHVlIHRvIHRoZSBwb3NzaWJpbGl0eSBvZiBuZXN0ZWQgY29tbWEgb3BlcmF0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb21tYUNoYXIgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGFrZXMgaW4gYW4gZXhwcmVzc2lvbiBzdHJpbmcgYW5kIG91dHB1dHMgYSB0b2tlbml6ZWQgY29sbGVjdGlvbiBvZlxyXG4gICAgICAgICAgICAgKiBJVG9rZW5zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBzdHJpbmcgdG8gdG9rZW5pemUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLmNyZWF0ZVRva2VucyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXIsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aCwgdGVybmFyeSA9IDAsIHRlcm5hcnlGb3VuZCA9IGZhbHNlLCBpc1NwYWNlID0gdGhpcy5faXNTcGFjZSwgaXNBbHBoYU51bWVyaWMgPSB0aGlzLl9pc0FscGhhTnVtZXJpYztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGFyID0gaW5wdXRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NwYWNlKGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FscGhhTnVtZXJpYyhjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX19oYW5kbGVBcGxoYU51bWVyaWMoaW5kZXgsIGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RlbGltaXRlcihjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5fX2hhbmRsZVBlcmlvZChpbmRleCwgY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlTGVmdEJyYWNlKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnfSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVJpZ2h0QnJhY2UoY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdbJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlTGVmdEJyYWNrZXQoY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICddJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlUmlnaHRCcmFja2V0KGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZUxlZnRQYXJlbnRoZXNpcyhjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyknOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVSaWdodFBhcmVudGhlc2lzKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZUNvbW1hKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnXFwnJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wiJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX19oYW5kbGVTdHJpbmdMaXRlcmFsKGluZGV4LCBjaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09wZXJhdG9yKGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPyc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybmFyeUZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXJuYXJ5Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVF1ZXN0aW9uKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVybmFyeSA9IHRoaXMuX19oYW5kbGVDb2xvbihjaGFyLCB0ZXJuYXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9faGFuZGxlT3RoZXJPcGVyYXRvcihpbmRleCwgY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJzsnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ1VuZXhwZWN0ZWQgc2VtaWNvbG9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3ByZXZpb3VzQ2hhciA9IGNoYXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGVybmFyeUZvdW5kICYmICh0ZXJuYXJ5ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdJbXByb3BlciB0ZXJuYXJ5IGV4cHJlc3Npb24nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fb2JqQXJnQ291bnQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ0ltcHJvcGVyIG9iamVjdCBsaXRlcmFsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3BvcFJlbWFpbmluZ09wZXJhdG9ycygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX19vdXRwdXRRdWV1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0VG9rZW5pemVyKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBjaGFyYWN0ZXIgdHlwZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGNoYXJhY3RlciB0byBjaGVjay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc051bWJlckxpa2UgV2hldGhlciBvciBub3QgdGhlIGNoYXJhY3RlciByZXNlbWJsZXMgYSBudW1iZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9jaGVja1R5cGUgPSBmdW5jdGlvbiAoY2hhciwgaXNOdW1iZXJMaWtlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXJMaWtlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzTnVtZXJpYyhjaGFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0FscGhhTnVtZXJpYyhjaGFyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExvb2tzIGFoZWFkIGluIHRoZSBleHByZXNzaW9uIHRvIGdyb3VwIHNpbWlsYXIgY2hhcmFjdGVyIHR5cGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyYWN0ZXIgaW4gdGhlIGV4cHJlc3Npb24gc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb24gc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTnVtYmVyTGlrZSBXaGV0aGVyIG9yIG5vdCB0aGUgY2hhcmFjdGVyIHJlc2VtYmxlcyBhIG51bWJlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2xvb2tBaGVhZCA9IGZ1bmN0aW9uIChjaGFyLCBpbmRleCwgaXNOdW1iZXJMaWtlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2gsIGlucHV0ID0gdGhpcy5faW5wdXQsIG1heExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbWF4TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2ggPSBpbnB1dFtpbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoZWNrVHlwZShjaCwgaXNOdW1iZXJMaWtlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyICs9IGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb29rcyBhaGVhZCBpbiB0aGUgZXhwcmVzc2lvbiB0byB0cnkgYW5kIGNvbXBsZXRlIHRoZVxyXG4gICAgICAgICAgICAgKiBjdXJyZW50IG9wZXJhdG9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgb3BlcmF0b3IgdG8gZmluZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBleHByZXNzaW9uIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2xvb2tBaGVhZEZvck9wZXJhdG9yRm4gPSBmdW5jdGlvbiAoY2hhciwgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaCwgZm4gPSBjaGFyLCBpbnB1dCA9IHRoaXMuX2lucHV0LCBtYXhMZW5ndGggPSBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IG1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoID0gaW5wdXRbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZuICs9IGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdG9yKGZuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyID0gZm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExvb2tzIGFoZWFkIGluIHRoZSBleHByZXNzaW9uIHVudGlsIGl0IGNvbWVzIHRvIHRoZSBlbmRpbmdcclxuICAgICAgICAgICAgICogY2hhcmFjdGVyIHRvIHRyeSBhbmQgY29tcGxldGUgYSBwYXJ0aWN1bGFyIHNlcXVlbmNlXHJcbiAgICAgICAgICAgICAqIChlLmcuIC0gYSBzdHJpbmcgbGl0ZXJhbCkuIEFsc28gc3RyaXBzIHRoZSBmaXJzdCBhbmQgbGFzdFxyXG4gICAgICAgICAgICAgKiBjaGFyYWN0ZXJzIG9mIHRoZSByZXN1bHQgKGkuZS4gcmVtb3ZlcyB0aGUgZGVsaW1pdGVycykuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRDaGFyIFRoZSBlbmRpbmcgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIGV4cHJlc3Npb24gc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fbG9va0FoZWFkRm9yRGVsaW1pdGVyID0gZnVuY3Rpb24gKGVuZENoYXIsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hhciA9ICcnLCBjaCwgaW5wdXQgPSB0aGlzLl9pbnB1dCwgbWF4TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCgrK2luZGV4IDwgbWF4TGVuZ3RoKSAmJiAoY2ggPSBpbnB1dFtpbmRleF0pICE9PSBlbmRDaGFyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciArPSBjaDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUG9wcyB0aGUgb3BlcmF0b3Igc3RhY2sgb250byB0aGUgb3V0cHV0IHF1ZXVlIHVudGlsIGEgcGFydGljdWxhclxyXG4gICAgICAgICAgICAgKiBvcGVyYXRvciB2YWx1ZSBpcyByZWFjaGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXhwcmVzc2lvbnMuSVRva2VufSB0b3BPcGVyYXRvciBUaGUgdG9wIG9mIHRoZSBvcGVyYXRvciBzdGFjay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIG9wZXJhdG9yIHZhbHVlIGJlaW5nIHNlYXJjaGVkIGZvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVycm9yIFRoZSBlcnJvciB0byB0aHJvdyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBleHByZXNzaW9uXHJcbiAgICAgICAgICAgICAqIGlzIGludmFsaWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9wb3BTdGFja0ZvclZhbCA9IGZ1bmN0aW9uICh0b3BPcGVyYXRvciwgY2hhciwgZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRRdWV1ZSA9IHRoaXMuX19vdXRwdXRRdWV1ZSwgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRvcE9wZXJhdG9yLnZhbCAhPT0gY2hhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFF1ZXVlLnB1c2gob3BlcmF0b3JTdGFjay5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB0b3BPcGVyYXRvciA9IG9wZXJhdG9yU3RhY2tbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yU3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd0Vycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgXCJ2YWxcIiBwcm9wZXJ0eSBvbiBhbiBJVG9rZW5cclxuICAgICAgICAgICAgICogaXMgcHJlc2VudCBpbiBhIHBhcnRpY3VsYXIgY2hhcmFjdGVyIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV4cHJlc3Npb25zLklUb2tlbn0gb2JqIFRoZSBJVG9rZW5cclxuICAgICAgICAgICAgICogd2l0aCB0aGUgXCJ2YWxcIiBwcm9wZXJ0eSB0byBjb21wYXJlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhciB0byBjb21wYXJlIHdpdGguXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9pc1ZhbEVxdWFsID0gZnVuY3Rpb24gKG9iaiwgY2hhcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChvYmopIHx8IGlzTnVsbChvYmoudmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc051bGwoY2hhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvYmoudmFsID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFyID09PSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFyLmluZGV4T2Yob2JqLnZhbCkgIT09IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIFwidmFsXCIgcHJvcGVydHkgb24gYW4gSVRva2VuXHJcbiAgICAgICAgICAgICAqIGlzIG5vdCBwcmVzZW50IGluIGEgcGFydGljdWxhciBjaGFyYWN0ZXIgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXhwcmVzc2lvbnMuSVRva2VufSBvYmogVGhlIElUb2tlblxyXG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBcInZhbFwiIHByb3BlcnR5IHRvIGNvbXBhcmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjaGFyIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX2lzVmFsVW5lcXVhbCA9IGZ1bmN0aW9uIChvYmosIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwob2JqKSB8fCBpc051bGwob2JqLnZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVsbChjaGFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iai52YWwgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIgIT09ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIuaW5kZXhPZihvYmoudmFsKSA9PT0gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXNldHMgYWxsIHRoZSB0b2tlbml6ZXIncyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fcmVzZXRUb2tlbml6ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcHJldmlvdXNDaGFyID0gJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3V0cHV0UXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vcGVyYXRvclN0YWNrID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYXJnQ291bnQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vYmpBcmdDb3VudCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb2xvbkNoYXIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29tbWFDaGFyID0gW107XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaHJvd3MgYSBmYXRhbCBleGNlcHRpb24gaW4gdGhlIGNhc2Ugb2YgYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvciBUaGUgZXJyb3IgbWVzc2FnZSB0byB0aHJvdy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX3Rocm93RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5lcnJvcihuZXcgRXJyb3IoZXJyb3IgKyAnIGluICcgKyB0aGlzLl9pbnB1dCkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgc2luZ2xlIGNoYXJhY3RlciBpcyBudW1lcmljLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5faXNOdW1lcmljID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgc2luZ2xlIGNoYXJhY3RlciBpcyBhIHNwYWNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5faXNTcGFjZSA9IGZ1bmN0aW9uIChjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNoYXIgPT09ICcgJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPT09ICdcXHInIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9PT0gJ1xcbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBjaGFyID09PSAnXFx0JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoYXIgPT09ICdcXHYnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9PT0gJ1xcdTAwQTAnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiBhIHNpbmdsZSBjaGFyYWN0ZXIgaXMgYWxwaGFudW1lcmljLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5faXNBbHBoYU51bWVyaWMgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgnYScgPD0gY2hhciAmJiBjaGFyIDw9ICd6JyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICdBJyA8PSBjaGFyICYmIGNoYXIgPD0gJ1onIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgJzAnIDw9IGNoYXIgJiYgY2hhciA8PSAnOScgfHxcclxuICAgICAgICAgICAgICAgICAgICAnQCcgPT09IGNoYXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAnXycgPT09IGNoYXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAnJCcgPT09IGNoYXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgc3RyaW5nIGhhcyBwcm9wZXIgSmF2YVNjcmlwdCB2YXJpYWJsZSBzeW50YXguXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIHRvIGNoZWNrLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5faXNTdHJpbmdWYWxpZFZhcmlhYmxlID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gIXRoaXMuX192YXJpYWJsZVJlZ2V4LnRlc3QoaW5wdXQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgc3RyaW5nIGJlaW5nIHRva2VuaXplZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVBcGxoYU51bWVyaWMgPSBmdW5jdGlvbiAoaW5kZXgsIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc051bWJlckxpa2UgPSB0aGlzLl9pc051bWVyaWMoY2hhciksIGxvb2tBaGVhZCA9IHRoaXMuX2xvb2tBaGVhZChjaGFyLCBpbmRleCwgaXNOdW1iZXJMaWtlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vdXRwdXRRdWV1ZS5wdXNoKGlzTnVtYmVyTGlrZSA/ICh7IHZhbDogTnVtYmVyKGxvb2tBaGVhZCksIGFyZ3M6IDAgfSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICh7IHZhbDogbG9va0FoZWFkLCBhcmdzOiAtMSB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggKyBsb29rQWhlYWQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwiLlwiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcgYmVpbmcgdG9rZW5pemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZVBlcmlvZCA9IGZ1bmN0aW9uIChpbmRleCwgY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dFF1ZXVlID0gdGhpcy5fX291dHB1dFF1ZXVlLCBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIHRvcE91dHB1dExlbmd0aCA9IG91dHB1dFF1ZXVlLmxlbmd0aCAtIDEsIHByZXZpb3VzQ2hhciA9IHRoaXMuX19wcmV2aW91c0NoYXIsIGxvb2tBaGVhZDtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG91dHB1dCBxdWV1ZSBpcyBudWxsIE9SIHNwYWNlIG9yIG9wZXJhdG9yIG9yICggb3IgLCBiZWZvcmUgLiBcclxuICAgICAgICAgICAgICAgIGlmICh0b3BPdXRwdXRMZW5ndGggPCAwIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNTcGFjZShwcmV2aW91c0NoYXIpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWlzTnVsbChPUEVSQVRPUlNbcHJldmlvdXNDaGFyXSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NoYXIgPT09ICcoJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhciA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gdGhpcy5fbG9va0FoZWFkKGNoYXIsIGluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBsb29rQWhlYWQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZS5wdXNoKHsgdmFsOiBwYXJzZUZsb2F0KGxvb2tBaGVhZCksIGFyZ3M6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc1ZhbEVxdWFsKG9wZXJhdG9yU3RhY2tbMF0sIGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UXVldWUucHVzaCh7IHZhbDogY2hhciwgYXJnczogMCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEoaXNOdWxsKG91dHB1dFF1ZXVlW3RvcE91dHB1dExlbmd0aF0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWlzTnVtYmVyKE51bWJlcihvdXRwdXRRdWV1ZVt0b3BPdXRwdXRMZW5ndGhdLnZhbCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNWYWxFcXVhbChvdXRwdXRRdWV1ZVt0b3BPdXRwdXRMZW5ndGggLSAxXSwgY2hhcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9va0FoZWFkID0gdGhpcy5fbG9va0FoZWFkKGNoYXIsIGluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBsb29rQWhlYWQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZVt0b3BPdXRwdXRMZW5ndGhdLnZhbCArPSBwYXJzZUZsb2F0KGxvb2tBaGVhZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IGNoYXIsIGFyZ3M6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIntcIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlTGVmdEJyYWNlID0gZnVuY3Rpb24gKGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IGNoYXIsIGFyZ3M6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb2JqQXJnQ291bnQucHVzaCgwKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29sb25DaGFyLnB1c2goY2hhcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbW1hQ2hhci5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgXCJ9XCIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZVJpZ2h0QnJhY2UgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdLCBsYXN0QXJnQ291bnQgPSB0aGlzLl9fb2JqQXJnQ291bnQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRvcE9wZXJhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd0Vycm9yKCdJbXByb3BlciBvYmplY3QgbGl0ZXJhbCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wU3RhY2tGb3JWYWwodG9wT3BlcmF0b3IsICd7JywgJ0ltcHJvcGVyIG9iamVjdCBsaXRlcmFsJyk7XHJcbiAgICAgICAgICAgICAgICAvLyBwb3AgbGVmdCBicmFjZSBvZmYgc3RhY2sgXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbG9uQ2hhci5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0Q29tbWFDaGFyLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX291dHB1dFF1ZXVlLnB1c2goeyB2YWw6ICd7fScsIGFyZ3M6IGxhc3RBcmdDb3VudCB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwiW1wiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVMZWZ0QnJhY2tldCA9IGZ1bmN0aW9uIChjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNDaGFyID0gdGhpcy5fX3ByZXZpb3VzQ2hhciwgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsRXF1YWwob3BlcmF0b3JTdGFja1swXSwgJy4nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19vdXRwdXRRdWV1ZS5wdXNoKG9wZXJhdG9yU3RhY2suc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IGNoYXIsIGFyZ3M6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYXJnQ291bnQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzQXJyYXk6ICEocHJldmlvdXNDaGFyID09PSAnXScgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNDaGFyID09PSAnKScgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNBbHBoYU51bWVyaWMocHJldmlvdXNDaGFyKSlcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb21tYUNoYXIucHVzaChjaGFyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwiXVwiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVSaWdodEJyYWNrZXQgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdLCBsYXN0QXJnQ291bnRPYmogPSB0aGlzLl9fYXJnQ291bnQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRvcE9wZXJhdG9yKSB8fCBpc051bGwobGFzdEFyZ0NvdW50T2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90aHJvd0Vycm9yKCdCcmFja2V0cyBtaXNtYXRjaCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0QXJnQ291bnRPYmouaXNBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RBcmdDb3VudE9iai5udW0tLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcFN0YWNrRm9yVmFsKHRvcE9wZXJhdG9yLCAnWycsICdCcmFja2V0cyBtaXNtYXRjaCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gcG9wIGxlZnQgYnJhY2tldCBvZmYgc3RhY2sgXHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbW1hQ2hhci5wb3AoKTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGZ1bmN0aW9uIG9uIHRvcCBvZiBzdGFjayBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vdXRwdXRRdWV1ZS5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICB2YWw6ICdbXScsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogKHRoaXMuX19wcmV2aW91c0NoYXIgPT09ICdbJykgPyAtMSA6IGxhc3RBcmdDb3VudE9iai5udW0gKyAxXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhIFwiKFwiIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGN1cnJlbnQgY2hhci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19oYW5kbGVMZWZ0UGFyZW50aGVzaXMgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzQ2hhciA9IHRoaXMuX19wcmV2aW91c0NoYXIsIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgYXJncztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0FscGhhTnVtZXJpYyhwcmV2aW91c0NoYXIpIHx8IHByZXZpb3VzQ2hhciA9PT0gJ10nIHx8IHByZXZpb3VzQ2hhciA9PT0gJyknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG91dHB1dFF1ZXVlID0gdGhpcy5fX291dHB1dFF1ZXVlLCB0b3BPdXRwdXQgPSBvdXRwdXRRdWV1ZVtvdXRwdXRRdWV1ZS5sZW5ndGggLSAxXSwgdmFsID0gaXNOdWxsKHRvcE91dHB1dCkgPyB1bmRlZmluZWQgOiB0b3BPdXRwdXQudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICdbXScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KG91dHB1dFF1ZXVlLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KG91dHB1dFF1ZXVlLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YWwgPT09ICcoKScgfHwgdGhpcy5faXNOdW1lcmljKHZhbCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yU3RhY2sudW5zaGlmdChvdXRwdXRRdWV1ZS5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncyA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FyZ0NvdW50LnB1c2goeyBudW06IGFyZ3MgfSk7XHJcbiAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IGNoYXIsIGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdENvbW1hQ2hhci5wdXNoKGNoYXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgXCIpXCIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZVJpZ2h0UGFyZW50aGVzaXMgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdLCBsb2NhbEFyZ0NvdW50T2JqID0gdGhpcy5fX2FyZ0NvdW50LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0b3BPcGVyYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcignUGFyZW50aGVzZXMgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcFN0YWNrRm9yVmFsKHRvcE9wZXJhdG9yLCAnKCcsICdQYXJlbnRoZXNlcyBtaXNtYXRjaCcpO1xyXG4gICAgICAgICAgICAgICAgLy8gcG9wIGxlZnQgcGFyZW50aGVzaXMgb2ZmIHN0YWNrIFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb21tYUNoYXIucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBmdW5jdGlvbiBvbiB0b3Agb2Ygc3RhY2sgXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChsb2NhbEFyZ0NvdW50T2JqKSAmJiBsb2NhbEFyZ0NvdW50T2JqLm51bSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsQXJnTnVtID0gbG9jYWxBcmdDb3VudE9iai5udW07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19wcmV2aW91c0NoYXIgPT09ICcoJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3JlbW92ZUZuRnJvbVN0YWNrKGxvY2FsQXJnTnVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX291dHB1dFF1ZXVlLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbDogJygpJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fcmVtb3ZlRm5Gcm9tU3RhY2sobG9jYWxBcmdOdW0gKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb3V0cHV0UXVldWUucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWw6ICcoKScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiAobG9jYWxBcmdOdW0gKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIixcIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlQ29tbWEgPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb21tYUFycmF5ID0gdGhpcy5fX2xhc3RDb21tYUNoYXIsIGxhc3RDb21tYUFyZyA9IGxhc3RDb21tYUFycmF5W2xhc3RDb21tYUFycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RDb21tYUFyZyA9PT0gJygnIHx8IGxhc3RDb21tYUFyZyA9PT0gJ1snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ0NvdW50QXJyYXkgPSB0aGlzLl9fYXJnQ291bnQsIGxlbmd0aF8yID0gYXJnQ291bnRBcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aF8yID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgZGVlcGVzdCBmbiBjb3VudCAoZG9uJ3QgbmVlZCB0byBpbmNyZW1lbnQgb2JqIGNvdW50IGJlY2F1c2Ugd2UgaW5jcmVtZW50IHdpdGggY29sb24pIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdDb3VudEFycmF5W2xlbmd0aF8yIC0gMV0ubnVtKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcignTWlzbWF0Y2ggd2l0aCAnICsgbGFzdENvbW1hQXJnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9wT3BlcmF0b3IgPSB0aGlzLl9fb3BlcmF0b3JTdGFja1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodG9wT3BlcmF0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rocm93RXJyb3IoJ1VuZXhwZWN0ZWQgY29tbWEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcFN0YWNrRm9yVmFsKHRvcE9wZXJhdG9yLCBsYXN0Q29tbWFBcmcsICdVbmV4cGVjdGVkIGNvbW1hJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBzdHJpbmcgbGl0ZXJhbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBzdHJpbmcgYmVpbmcgdG9rZW5pemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZVN0cmluZ0xpdGVyYWwgPSBmdW5jdGlvbiAoaW5kZXgsIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb29rQWhlYWQgPSB0aGlzLl9sb29rQWhlYWRGb3JEZWxpbWl0ZXIoY2hhciwgaW5kZXgpLCBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIHRvcE9wZXJhdG9yID0gb3BlcmF0b3JTdGFja1swXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRvcE9wZXJhdG9yKSAmJiAodG9wT3BlcmF0b3IudmFsID09PSAnWycgfHwgKHRvcE9wZXJhdG9yLnZhbCA9PT0gJygnICYmIHRvcE9wZXJhdG9yLmFyZ3MgPj0gMCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBsb29rQWhlYWQsIGFyZ3M6IDAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb3V0cHV0UXVldWUucHVzaCh7IHZhbDogbG9va0FoZWFkLCBhcmdzOiAwIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgbG9va0FoZWFkLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIHRva2VuaXppbmcgYSBcIj9cIiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlUXVlc3Rpb24gPSBmdW5jdGlvbiAoY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RDb2xvbkNoYXIucHVzaChjaGFyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZXRlcm1pbmVQcmVjZWRlbmNlKGNoYXIpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0b2tlbml6aW5nIGEgXCI6XCIgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhciBUaGUgY3VycmVudCBjaGFyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGVybmFyeSBUaGUgY3VycmVudCB0ZXJuYXJ5IGNvdW50ZXIuIEluY3JlbWVudHMgd2hlbiBhIHRlcm5hcnkgaXMgZm91bmQsXHJcbiAgICAgICAgICAgICAqIGRlY3JlbWVudHMgd2hlbiBhIHRlcm5hcnkgaXMgY29tcGxldGVkLiBJdCBjYW4gYmUgdmVyeSB1c2VmdWwgd2hlbiB0aGVyZSBpcyBuZXN0ZWQgdGVybmFyaWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX2hhbmRsZUNvbG9uID0gZnVuY3Rpb24gKGNoYXIsIHRlcm5hcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0Q29sb25DaGFyQXJyYXkgPSB0aGlzLl9fbGFzdENvbG9uQ2hhciwgbGFzdENvbG9uQ2hhcmFjdGVyID0gbGFzdENvbG9uQ2hhckFycmF5W2xhc3RDb2xvbkNoYXJBcnJheS5sZW5ndGggLSAxXSwgb3V0cHV0UXVldWUgPSB0aGlzLl9fb3V0cHV0UXVldWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdENvbG9uQ2hhcmFjdGVyID09PSAnPycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrLCB0b3BPcGVyYXRvciA9IG9wZXJhdG9yU3RhY2tbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0b3BPcGVyYXRvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcignVGVybmFyeSBtaXNtYXRjaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRlcm5hcnktLTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3AgbGF0ZXN0IGNvbG9uIGNoYXIgb2ZmIHF1ZXVlIFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb2xvbkNoYXJBcnJheS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3BTdGFja0ZvclZhbCh0b3BPcGVyYXRvciwgJz8nLCAnVGVybmFyeSBtaXNtYXRjaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFF1ZXVlLnB1c2gob3BlcmF0b3JTdGFjay5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IGNoYXIsIGFyZ3M6IC0yIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobGFzdENvbG9uQ2hhcmFjdGVyID09PSAneycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqQXJnQ291bnQgPSB0aGlzLl9fb2JqQXJnQ291bnQsIG91dHB1dExhc3QgPSBvdXRwdXRRdWV1ZS5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iakFyZ0NvdW50W29iakFyZ0NvdW50Lmxlbmd0aCAtIDFdKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dExhc3QgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ1VuZXhwZWN0ZWQgY29sb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZVtvdXRwdXRMYXN0XS5hcmdzID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ1VuZXhwZWN0ZWQgY29sb24nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVybmFyeTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdG9rZW5pemluZyBhbGwgb3RoZXIgb3BlcmF0b3JzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIHN0cmluZyBiZWluZyB0b2tlbml6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjdXJyZW50IGNoYXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9faGFuZGxlT3RoZXJPcGVyYXRvciA9IGZ1bmN0aW9uIChpbmRleCwgY2hhcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvb2tBaGVhZCA9IHRoaXMuX2xvb2tBaGVhZEZvck9wZXJhdG9yRm4oY2hhciwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RldGVybWluZVByZWNlZGVuY2UobG9va0FoZWFkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCArIGxvb2tBaGVhZC5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUG9wcyBvcGVyYXRvcnMgbGVmdCBvbiB0aGUgb3BlcmF0b3Igc3RhY2sgb250byB0aGUgb3V0cHV0IHF1ZXVlXHJcbiAgICAgICAgICAgICAqIGNoZWNraW5nIGZvciBtaXNtYXRjaGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX3BvcFJlbWFpbmluZ09wZXJhdG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXRRdWV1ZSA9IHRoaXMuX19vdXRwdXRRdWV1ZSwgb3BlcmF0b3JTdGFjayA9IHRoaXMuX19vcGVyYXRvclN0YWNrLCB0b3BPcGVyYXRvciwgdG9wT3BlcmF0b3JWYWw7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAob3BlcmF0b3JTdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3BlcmF0b3JWYWwgPSB0b3BPcGVyYXRvci52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcE9wZXJhdG9yVmFsID09PSAnKCcgfHwgdG9wT3BlcmF0b3JWYWwgPT09ICcpJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGhyb3dFcnJvcignUGFyZW50aGVzZXMgbWlzbWF0Y2gnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0UXVldWUucHVzaCh0b3BPcGVyYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHcmFicyBlc3NlbnRpYWwgdG9rZW4gZGV0YWlscyBmb3IgYSBnaXZlbiBvcGVyYXRvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZXJhdG9yIFRoZSBvcGVyYXRvciB3aG9zZSBkZXRhaWxzIGFyZSBiZWluZyByZXF1ZXN0ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUb2tlbml6ZXIucHJvdG90eXBlLl9fZGV0ZXJtaW5lT3BlcmF0b3IgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19vdXRwdXRRdWV1ZS5sZW5ndGggPT09IDAgfHwgaXNPcGVyYXRvcih0aGlzLl9fcHJldmlvdXNDaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9QRVJBVE9SU1sndScgKyBvcGVyYXRvcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT1BFUkFUT1JTW29wZXJhdG9yXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgdGhlIHByZWNlZGVuY2Ugb2YgYSBnaXZlbiBvcGVyYXRvciBpbiByZWxhdGlvbiB0byBvdGhlciBvcGVyYXRvcnNcclxuICAgICAgICAgICAgICogaW4gdGhlIG9wZXJhdG9yIHN0YWNrIGFuZCBwbGFjZXMgaXQgaW4gdGhlIG9wZXJhdG9yIHN0YWNrLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlcmF0b3IgVGhlIG9wZXJhdG9yIHdob3NlIHByZWNlZGVuY2UgaXMgYmVpbmcgZGV0ZXJtaW5lZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRva2VuaXplci5wcm90b3R5cGUuX19kZXRlcm1pbmVQcmVjZWRlbmNlID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3JGbiA9IHRoaXMuX19kZXRlcm1pbmVPcGVyYXRvcihvcGVyYXRvciksIG9wZXJhdG9yUHJlY2VkZW5jZSA9IG9wZXJhdG9yRm4ucHJlY2VkZW5jZSwgaXNMdFIgPSBvcGVyYXRvckZuLmFzc29jaWF0aXZpdHkgPT09ICdsdHInLCBvcGVyYXRvclN0YWNrID0gdGhpcy5fX29wZXJhdG9yU3RhY2ssIG91dHB1dFF1ZXVlID0gdGhpcy5fX291dHB1dFF1ZXVlLCBmaXJzdEFycmF5T3BlcmF0b3IsIGZpcnN0QXJyYXlWYWw7XHJcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3JTdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IG9wZXJhdG9yLCBhcmdzOiBvcGVyYXRvckZuLmZuLmxlbmd0aCAtIDIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0QXJyYXlWYWwgPSBvcGVyYXRvclN0YWNrWzBdLnZhbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RBcnJheVZhbCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFF1ZXVlLnB1c2gob3BlcmF0b3JTdGFjay5zaGlmdCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0QXJyYXlPcGVyYXRvciA9IE9QRVJBVE9SU1tmaXJzdEFycmF5VmFsXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc051bGwoZmlyc3RBcnJheU9wZXJhdG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGZpcnN0QXJyYXlPcGVyYXRvci5wcmVjZWRlbmNlIDwgb3BlcmF0b3JQcmVjZWRlbmNlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaXNMdFIgJiYgZmlyc3RBcnJheU9wZXJhdG9yLnByZWNlZGVuY2UgPT09IG9wZXJhdG9yUHJlY2VkZW5jZSkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRRdWV1ZS5wdXNoKG9wZXJhdG9yU3RhY2suc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvclN0YWNrLnVuc2hpZnQoeyB2YWw6IG9wZXJhdG9yLCBhcmdzOiBvcGVyYXRvckZuLmZuLmxlbmd0aCAtIDIgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChvcGVyYXRvclN0YWNrLmxlbmd0aCA+IDApO1xyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JTdGFjay51bnNoaWZ0KHsgdmFsOiBvcGVyYXRvciwgYXJnczogb3BlcmF0b3JGbi5mbi5sZW5ndGggLSAyIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHRoYXQgaXMgcHJlc2VudCBpbiB0aGUgb3BlcmF0b3Igc3RhY2sgYW5kIHBsYWNlc1xyXG4gICAgICAgICAgICAgKiBpdCBpbiB0aGUgb3V0cHV0IHF1ZXVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJnQ291bnQgVGhlIGN1cnJlbnQgbG9jYWwgYXJndW1lbnQgY291bnQgdXNlZCB3aXRoIGZ1bmN0aW9ucyxcclxuICAgICAgICAgICAgICogYXJyYXlzLCBhbmQgb2JqZWN0IGxpdGVyYWxzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVG9rZW5pemVyLnByb3RvdHlwZS5fX3JlbW92ZUZuRnJvbVN0YWNrID0gZnVuY3Rpb24gKGFyZ0NvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0cHV0UXVldWUgPSB0aGlzLl9fb3V0cHV0UXVldWUsIG9wZXJhdG9yU3RhY2sgPSB0aGlzLl9fb3BlcmF0b3JTdGFjaywgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdLCBpc1ZhbEVxdWFsID0gdGhpcy5faXNWYWxFcXVhbCwgaXNWYWxVbmVxdWFsID0gdGhpcy5faXNWYWxVbmVxdWFsLCBmblRva2VuLCBhdExlYXN0T25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVsbCh0b3BPcGVyYXRvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbFVuZXF1YWwodG9wT3BlcmF0b3IsICcoWycpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2lzU3RyaW5nVmFsaWRWYXJpYWJsZSh0b3BPcGVyYXRvci52YWwpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsRXF1YWwodG9wT3BlcmF0b3IudmFsLCAnLltdJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBY2Nlc3Nvcih0b3BPcGVyYXRvci52YWwpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZuVG9rZW4gPSBvcGVyYXRvclN0YWNrLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZm5Ub2tlbi5hcmdzICE9PSAtMSB8fCBpc1ZhbEVxdWFsKGZuVG9rZW4sICcuW10nKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm5Ub2tlbi5hcmdzID0gLTI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFF1ZXVlLnB1c2goZm5Ub2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wT3BlcmF0b3IgPSBvcGVyYXRvclN0YWNrWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCEoYXRMZWFzdE9uZSB8fCBpc1ZhbFVuZXF1YWwob3V0cHV0UXVldWVbb3V0cHV0UXVldWUubGVuZ3RoIC0gYXJnQ291bnQgLSAxXSwgJygpJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXRMZWFzdE9uZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVG9rZW5pemVyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfbG9nOiBfX0xvZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVG9rZW5pemVyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZXhwcmVzc2lvbnMuVG9rZW5pemVyID0gVG9rZW5pemVyO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Ub2tlbml6ZXIsIFRva2VuaXplcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjbGFzcyBmb3IgcGFyc2luZyBKYXZhU2NyaXB0IGV4cHJlc3Npb24gc3RyaW5ncyBhbmQgY3JlYXRpbmdcclxuICAgICAgICAgKiBJUGFyc2VkRXhwcmVzc2lvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBzaW5nbGUgZXhwcmVzc2lvbidzIHRva2VuIHJlcHJlc2VudGF0aW9uIGNyZWF0ZWQgYnkgYSBUb2tlbml6ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBleHByZXNzaW9uIGNhY2hlLiBVc2VkIHNvIHRoYXQgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gaXMgb25seSBldmVyIHBhcnNlZCBvbmNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBkeW5hbWljYWxseSBidWlsdCBzdHJpbmcgYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBldmFsdWF0aW9uIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29kZUFycmF5ID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgbGlzdCBvZiBhbGwgdGhlIGlkZW50aWZpZXJzIGRpc2NvdmVyZWQgaW4gdGhlIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZGVudGlmaWVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHRlbXBvcmFyeSBsaXN0IG9mIGlkZW50aWZpZXJzIGZvdW5kIHVzZWQgdG8gYnVpbGQgYW5kIGV2YWx1YXRlIGVhY2ggYWN0dWFsIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wSWRlbnRpZmllcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IHdob3NlIGtleXMgcmVwcmVzZW50IGEgbGlzdCBvZiBhbGwgdW5pcXVlIGFsaWFzZXMgZm91bmQgaW4gdGhlIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19hbGlhc2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb25zdGFudCB0aGF0IG5lZWRzIHRvIGJlIHByZXBlbmRlZCB0byBldmVyeSBkeWFubWljIGV2YWwgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19mbkV2YWxDb25zdGFudCA9ICd2YXIgaW5pdGlhbENvbnRleHQ7cmV0dXJuICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbiBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gc3RyaW5nIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkT2JqZWN0ID0gdGhpcy5fX2NhY2hlW2V4cHJlc3Npb25dO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyc2VkT2JqZWN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHBhcnNlZE9iamVjdC5leHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogcGFyc2VkT2JqZWN0LmlkZW50aWZpZXJzLnNsaWNlKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBwYXJzZWRPYmplY3QuYWxpYXNlcy5zbGljZSgwKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IHBhcnNlZE9iamVjdC5ldmFsdWF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2tlbnMgPSB0aGlzLl90b2tlbml6ZXIuY3JlYXRlVG9rZW5zKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgcGFyc2VkT2JqZWN0ID0gdGhpcy5fZXZhbHVhdGUoZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSBwYXJzZWRPYmplY3QuaWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vTW9kZWxfMSA9IHBhcnNlZE9iamVjdC5ldmFsdWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRPYmplY3QuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBub01vZGVsXzE7IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FjaGVbZXhwcmVzc2lvbl0gPSBwYXJzZWRPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkT2JqZWN0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSWYgYSBrZXkgaXMgcGFzc2VkIGluLCBpdCBjbGVhcnMgdGhhdCBzaW5nbGUgdmFsdWUgaW4gdGhlIGV4cHJlc3Npb24gY2FjaGUuIElmIG5vXHJcbiAgICAgICAgICAgICAqIGtleSBpcyBwcmVzZW50LCB0aGUgZW50aXJlIGV4cHJlc3Npb24gY2FjaGUgd2lsbCBiZSBjbGVhcmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5PyBBbiBvcHRpb25hbCBrZXkgdGhhdCB3aWxsIGNsZWFyIGl0cyBzdG9yZWQgdmFsdWUgaW4gdGhlIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICogY2FjaGUgaWYgcGFzc2VkIGluLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSh0aGlzLl9fY2FjaGUsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhY2hlID0ge307XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFdmFsdWF0ZSB0aGUgY3VycmVudCBJVG9rZW4gYXJyYXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBKYXZhU2NyaXB0IGV4cHJlc3Npb24gdG8gZXZhbHVhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9ldmFsdWF0ZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy5fdG9rZW5zLCBsZW5ndGggPSB0b2tlbnMubGVuZ3RoLCB0ZW1wSWRlbnRpZmllcnMgPSB0aGlzLl9fdGVtcElkZW50aWZpZXJzLCBjb2RlQXJyYXkgPSB0aGlzLl9fY29kZUFycmF5LCB1c2VMb2NhbENvbnRleHQgPSBmYWxzZSwgdG9rZW5PYmosIHRva2VuLCBhcmdzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuT2JqID0gdG9rZW5zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2VuT2JqLnZhbDtcclxuICAgICAgICAgICAgICAgICAgICBhcmdzID0gdG9rZW5PYmouYXJncztcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBpdHMgYW4gYWNjZXNzb3IgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWNjZXNzb3IodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJygpJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VMb2NhbENvbnRleHQgPSB0aGlzLl9faGFuZGxlRnVuY3Rpb24oaW5kZXgsIGFyZ3MsIHVzZUxvY2FsQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd7fSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5LnB1c2godGhpcy5fX2NvbnZlcnRPYmplY3QoYXJncykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVycy5wdXNoKCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBlbXB0eSBhcnJheSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUFycmF5LnB1c2goJ1tdJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVycy5wdXNoKCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZ3MgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKHRoaXMuX19jb252ZXJ0QXJyYXlMaXRlcmFsKGFyZ3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZUxvY2FsQ29udGV4dCA9IHRoaXMuX19pbmRleEludG9PYmplY3QoaW5kZXgsIHRva2VuLCB1c2VMb2NhbENvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09wZXJhdG9yKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBzdHJpbmcgbGl0ZXJhbCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKHRoaXMuX19jb252ZXJ0UHJpbWl0aXZlKGluZGV4LCB0b2tlbiwgYXJncykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlUXVlc3Rpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVDb2xvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICctJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gJ3UnICsgdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlT3BlcmF0b3IodG9rZW4sIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcG90ZW50aWFsIGZ1bmN0aW9uIG9yIG9iamVjdCB0byBpbmRleCBpbnRvIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKHRoaXMuX19jb252ZXJ0RnVuY3Rpb24oaW5kZXgsIHRva2VuLCB1c2VMb2NhbENvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKHRoaXMuX19jb252ZXJ0UHJpbWl0aXZlKGluZGV4LCB0b2tlbiwgYXJncykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgcmVzdCBvZiB0aGUgdGVtcElkZW50aWZpZXJzIHRvIHRoZSBpZGVudGlmaWVycyBcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcFJlbWFpbmluZ0lkZW50aWZpZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHRoZSBpZGVudGlmaWVycyBhcnJheSB1bnFpdWUgZW50cmllcyBvbmx5IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZUlkZW50aWZpZXJzVW5pcXVlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VkRXhwcmVzc2lvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZTogbmV3IEZ1bmN0aW9uKF9fQ09OVEVYVCwgX19BTElBU0VTLCB0aGlzLl9fZm5FdmFsQ29uc3RhbnQgKyAoY29kZUFycmF5Lmxlbmd0aCA9PT0gMCA/ICgnXCInICsgZXhwcmVzc2lvbiArICdcIicpIDogY29kZUFycmF5LmpvaW4oJycpKSArICc7JyksXHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogdGhpcy5fX2lkZW50aWZpZXJzLnNsaWNlKDApLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWFzZXM6IE9iamVjdC5rZXlzKHRoaXMuX19hbGlhc2VzKVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHBhcnNlcidzIHByb3BlcnRpZXMgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFBhcnNlcigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQZWVrIGF0IHRoZSBuZXh0IElUb2tlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBiZWZvcmUgdGhlIGRlc2lyZWQgSVRva2VuXHJcbiAgICAgICAgICAgICAqIGluIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX3BlZWsgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl90b2tlbnNbaW5kZXggKyAxXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExvb2sgYmFjayBhdCB0aGUgcHJldmlvdXMgSVRva2VuLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IGFmdGVyIHRoZSBkZXNpcmVkIElUb2tlblxyXG4gICAgICAgICAgICAgKiBpbiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9sb29rQmFjayA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2Vuc1tpbmRleCAtIDFdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXZhbHVhdGUgYW5kIHJlbW92ZSB0aGUgbGVmdG92ZXIgaWRlbnRpZmllcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9wb3BSZW1haW5pbmdJZGVudGlmaWVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IHRoaXMuX19pZGVudGlmaWVycywgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgbGFzdDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSB0ZW1wSWRlbnRpZmllcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGxhc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZSBkdXBsaWNhdGUgaWRlbnRpZmllcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9tYWtlSWRlbnRpZmllcnNVbmlxdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSB0aGlzLl9faWRlbnRpZmllcnMsIHVuaXF1ZUlkZW50aWZpZXJzID0gW10sIHVuaXF1ZUlkZW50aWZpZXJPYmplY3QgPSB7fSwgaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGlkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdW5pcXVlSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVJZGVudGlmaWVyT2JqZWN0W2lkZW50aWZpZXJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlSWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faWRlbnRpZmllcnMgPSB1bmlxdWVJZGVudGlmaWVycztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrIGlmIHRoZSBcInZhbFwiIHByb3BlcnR5IG9uIGFuIElUb2tlblxyXG4gICAgICAgICAgICAgKiBpcyBwcmVzZW50IGluIGEgcGFydGljdWxhciBjaGFyYWN0ZXIgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXhwcmVzc2lvbnMuSVRva2VufSBvYmogVGhlIElUb2tlblxyXG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBcInZhbFwiIHByb3BlcnR5IHRvIGNvbXBhcmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjaGFyIHRvIGNvbXBhcmUgd2l0aC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX2lzVmFsRXF1YWwgPSBmdW5jdGlvbiAob2JqLCBjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG9iaikgfHwgaXNOdWxsKG9iai52YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTnVsbChjaGFyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9iai52YWwgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIgPT09ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXIuaW5kZXhPZihvYmoudmFsKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgXCJ2YWxcIiBwcm9wZXJ0eSBvbiBhbiBJVG9rZW5cclxuICAgICAgICAgICAgICogaXMgbm90IHByZXNlbnQgaW4gYSBwYXJ0aWN1bGFyIGNoYXJhY3RlciBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5leHByZXNzaW9ucy5JVG9rZW59IG9iaiBUaGUgSVRva2VuXHJcbiAgICAgICAgICAgICAqIHdpdGggdGhlIFwidmFsXCIgcHJvcGVydHkgdG8gY29tcGFyZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXIgVGhlIGNoYXIgdG8gY29tcGFyZSB3aXRoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5faXNWYWxVbmVxdWFsID0gZnVuY3Rpb24gKG9iaiwgY2hhcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChvYmopIHx8IGlzTnVsbChvYmoudmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdWxsKGNoYXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob2JqLnZhbCA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhciAhPT0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhci5pbmRleE9mKG9iai52YWwpID09PSAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc2V0cyBhbGwgdGhlIHBhcnNlcidzIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9yZXNldFBhcnNlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rva2VucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvZGVBcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lkZW50aWZpZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYWxpYXNlcyA9IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhyb3dzIGEgZmF0YWwgZXhjZXB0aW9uIGluIHRoZSBjYXNlIG9mIGFuIGVycm9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3IgVGhlIGVycm9yIG1lc3NhZ2UgdG8gdGhyb3cuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl90aHJvd0Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZXJyb3IobmV3IEVycm9yKGVycm9yKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGEgdG9rZW4gdGhhdCBpcyBhIHByaW1pdGl2ZSB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBJVG9rZW4gYXJyYXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgY3VycmVudCBJVG9rZW4gdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzIFRoZSBjdXJyZW50IElUb2tlbiBhcmdzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2NvbnZlcnRQcmltaXRpdmUgPSBmdW5jdGlvbiAoaW5kZXgsIHRva2VuLCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJncyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FzdFRva2VuSXNOdW1iZXJMaWtlID0gaXNOdW1iZXIoTnVtYmVyKHRva2VuKSksIHBlZWsgPSB0aGlzLl9wZWVrKGluZGV4KSwgaXNQZWVrSW5kZXhlciA9ICEoaXNOdWxsKHBlZWspIHx8IHBlZWsuYXJncyA+PSAxKSwgaXNWYWxFcXVhbCA9IHRoaXMuX2lzVmFsRXF1YWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNLZXl3b3JkKHRva2VuKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpc1N0cmluZyh0b2tlbikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNhc3RUb2tlbklzTnVtYmVyTGlrZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNWYWxVbmVxdWFsKHBlZWssICdbXSgpJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpc1ZhbEVxdWFsKHBlZWssICdbXScpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzUGVla0luZGV4ZXIpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1wiJyArIHRva2VuICsgJ1wiJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FzdFRva2VuSXNOdW1iZXJMaWtlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc1ZhbEVxdWFsKHBlZWssICcuW10nKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNQZWVrSW5kZXhlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBJZGVudGlmaWVycy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wSWRlbnRpZmllcnMucHVzaCgnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGEgcG90ZW50aWFsIGZ1bmN0aW9uIG9yIG9iamVjdCB0aGF0IG5lZWRzIHRvIGJlIGluZGV4ZWQgaW50by5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBjdXJyZW50IGluZGV4IGluIHRoZSBJVG9rZW4gYXJyYXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgY3VycmVudCBJVG9rZW4gdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlTG9jYWxDb250ZXh0IFdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gdXNlIGFuIGFscmVhZHkgcGFyc2VkIG9iamVjdCBhcyB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2NvbnZlcnRGdW5jdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgdG9rZW4sIHVzZUxvY2FsQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuWzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYWxpYXNlc1t0b2tlbi5zbGljZSgxKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNLZXl3b3JkKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wSWRlbnRpZmllcnMucHVzaCgnLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLl9wZWVrKGluZGV4KSwgaXNWYWxFcXVhbCA9IHRoaXMuX2lzVmFsRXF1YWw7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxFcXVhbCh0aGlzLl90b2tlbnNbaW5kZXggLSAxXSwgJygpJykgJiYgaXNWYWxFcXVhbChuZXh0VG9rZW4sICcuW10nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wSWRlbnRpZmllcnMucHVzaCgnLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBJZGVudGlmaWVycy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG5leHRUb2tlbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRUb2tlbi52YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnLic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJygpJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlTG9jYWxDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoaW5pdGlhbENvbnRleHQgPSAoJyArIHRoaXMuX19maW5kSW5pdGlhbENvbnRleHQudG9TdHJpbmcoKSArICcpKGNvbnRleHQsYWxpYXNlcyxcIicgKyB0b2tlbiArICdcIikpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnKGluaXRpYWxDb250ZXh0ID0gKCcgKyB0aGlzLl9fZmluZEluaXRpYWxDb250ZXh0LnRvU3RyaW5nKCkgKyAnKShjb250ZXh0LGFsaWFzZXMsXCInICsgdG9rZW4gKyAnXCIpKSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGFuIG9iamVjdCBsaXRlcmFsLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJncyBUaGUgY3VycmVudCBJVG9rZW4gYXJncy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19jb252ZXJ0T2JqZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IHRoaXMuX19pZGVudGlmaWVycywgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgY29kZUFycmF5ID0gdGhpcy5fX2NvZGVBcnJheSwgaiA9IDAsIGtleSwgY29kZVN0ciA9ICd7JywgdGVtcElkZW50aWZpZXIsIHRlbXA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaisrIDwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjb2RlQXJyYXkucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gY29kZUFycmF5LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgKz0gJyxcIicgKyBrZXkgKyAnXCI6JyArIHRlbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyID0gdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3AgdGhlIGtleSdzIHRlbXBJZGVudGlmaWVyIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb2RlU3RyLnJlcGxhY2UoJywnLCAnJykgKyAnfSc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGFuIEFycmF5IGxpdGVyYWwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzIFRoZSBjdXJyZW50IElUb2tlbiBhcmdzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2NvbnZlcnRBcnJheUxpdGVyYWwgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzLCB0ZW1wSWRlbnRpZmllcnMgPSB0aGlzLl9fdGVtcElkZW50aWZpZXJzLCBjb2RlQXJyYXkgPSB0aGlzLl9fY29kZUFycmF5LCBqID0gMCwgdGVtcFN0ciA9ICcnLCB0ZW1wSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChqKysgPCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGNvZGVBcnJheS5wb3AoKSArICcsJyArIHRlbXBTdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyID0gdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1snICsgdGVtcFN0ci5zbGljZSgwLCAtMSkgKyAnXSc7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGFuIGFjY2Vzc29yIHR5cGUgZnVuY3Rpb24gdG9rZW4gXCIoKVwiLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW4gdGhlIElUb2tlbiBhcnJheS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MgVGhlIGN1cnJlbnQgSVRva2VuIGFyZ3MuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlTG9jYWxDb250ZXh0IFdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gdXNlIGFuIGFscmVhZHkgcGFyc2VkIG9iamVjdCBhcyB0aGUgY3VycmVudCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2hhbmRsZUZ1bmN0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBhcmdzLCB1c2VMb2NhbENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVycyA9IHRoaXMuX19pZGVudGlmaWVycywgdGVtcElkZW50aWZpZXJzID0gdGhpcy5fX3RlbXBJZGVudGlmaWVycywgY29kZUFycmF5ID0gdGhpcy5fX2NvZGVBcnJheSwgaiA9IDAsIHByZXZpb3VzVG9rZW4gPSB0aGlzLl9sb29rQmFjayhpbmRleCksIGdyYWJGbk5hbWUgPSAhaXNOdWxsKHByZXZpb3VzVG9rZW4pICYmIChwcmV2aW91c1Rva2VuLmFyZ3MgPT09IC0yIHx8IHRoaXMuX2lzVmFsRXF1YWwocHJldmlvdXNUb2tlbiwgJy5bXScpKSwgdGVtcFN0ciA9ICcnLCB0ZW1wSWRlbnRpZmllciwgZm5OYW1lID0gJycsIGlkZW50aWZpZXJGbk5hbWUgPSAnJywgY29kZVN0ciwgcHVzaGVkSWRlbnRpZmllciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyYWJGbk5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbk5hbWUgPSBjb2RlQXJyYXkucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllckZuTmFtZSA9IHRlbXBJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlIChqKysgPCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0ciA9IGNvZGVBcnJheS5wb3AoKSArICcsJyArIHRlbXBTdHI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyID0gdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoZWRJZGVudGlmaWVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhcmdzID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSAnLmNhbGwoaW5pdGlhbENvbnRleHQgfHwgY29udGV4dCwnICsgdGVtcFN0ci5zbGljZSgwLCB0ZW1wU3RyLmxlbmd0aCAtIDEpICsgJyknO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9ICcuY2FsbChpbml0aWFsQ29udGV4dCB8fCBjb250ZXh0KSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXNlTG9jYWxDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXNlTG9jYWxDb250ZXh0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVBcnJheS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29kZUFycmF5LnBvcCgpLCBsYXN0SW5kZXggPSB0ZW1wSWRlbnRpZmllcnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobGFzdEluZGV4IDwgMCB8fCB0ZW1wSWRlbnRpZmllcnNbbGFzdEluZGV4XSA9PT0gJy4nIHx8IGlkZW50aWZpZXJGbk5hbWUgPT09ICcnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXJzW2xhc3RJbmRleF0gKz0gJy4nICsgaWRlbnRpZmllckZuTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godGVtcElkZW50aWZpZXJzLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKGlkZW50aWZpZXJGbk5hbWUgPT09ICcnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcHVzaGVkSWRlbnRpZmllciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFswXSA9PT0gJ1snIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPT09ICddJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzW2lkZW50aWZpZXJzLmxlbmd0aCAtIDFdICs9ICcuJyArIGlkZW50aWZpZXJGbk5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoZm5OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9IGNvbnRleHQgKyBjb2RlU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9ICcoKCcgKyB0aGlzLl9faW5kZXhJbnRvQ29udGV4dC50b1N0cmluZygpICsgJykoJyArIGNvbnRleHQgKyAnLFwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5OYW1lICsgJ1wiKSB8fCAoZnVuY3Rpb24gKCkge30pKScgKyBjb2RlU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdJbXByb3BlciBleHByZXNzaW9uIG9yIGNvbnRleHQnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhYkZuTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlU3RyID0gJyhpbml0aWFsQ29udGV4dCA9ICgoJyArIHRoaXMuX19maW5kSW5pdGlhbENvbnRleHQudG9TdHJpbmcoKSArICcpKGNvbnRleHQsYWxpYXNlcyxcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5OYW1lICsgJ1wiKSB8fCAoZnVuY3Rpb24gKCkge30pKScgKyBjb2RlU3RyICsgJyknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGZuTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlU3RyID0gY29kZUFycmF5LnBvcCgpICsgY29kZVN0cjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2RlQXJyYXkucHVzaChjb2RlU3RyKTtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0ZW1wSWRlbnRpZmllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmFsRXF1YWwodGhpcy5fcGVlayhpbmRleCksICdbXScpICYmIGxlbmd0aCA+IDAgJiYgdGVtcElkZW50aWZpZXJzW2xlbmd0aCAtIDFdICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVycy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTG9jYWxDb250ZXh0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhbiBhY2Nlc3NvciB0eXBlIHRva2VuIHRoYXQgaXMgZm9yIGluZGV4aW5nIChpLmUuIFwiLlwiIG9yIFwiW11cIikuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY3VycmVudCBpbmRleCBpbiB0aGUgSVRva2VuIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIGN1cnJlbnQgSVRva2VuIHZhbHVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVzZUxvY2FsQ29udGV4dCBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIHVzZSBhbiBhbHJlYWR5IHBhcnNlZCBvYmplY3QgYXMgdGhlIGN1cnJlbnQgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFBhcnNlci5wcm90b3R5cGUuX19pbmRleEludG9PYmplY3QgPSBmdW5jdGlvbiAoaW5kZXgsIHRva2VuLCB1c2VMb2NhbENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc1ZhbEVxdWFsID0gdGhpcy5faXNWYWxFcXVhbDtcclxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbEVxdWFsKHRoaXMuX3BlZWsoaW5kZXgpLCAnKCknKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGVBcnJheSA9IHRoaXMuX19jb2RlQXJyYXksIGNvZGVTdHIgPSBjb2RlQXJyYXkucG9wKCksIGlkZW50aWZpZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzLCB0ZW1wSWRlbnRpZmllcnMgPSB0aGlzLl9fdGVtcElkZW50aWZpZXJzLCBwcmV2aW91c1Rva2VuID0gdGhpcy5fbG9va0JhY2soaW5kZXgpLCBpZGVudGlmaWVySW5kZXhlciA9IHRlbXBJZGVudGlmaWVycy5wb3AoKSwgaGFzSWRlbnRpZmllckluZGV4ZXIgPSAhaXNOdWxsKGlkZW50aWZpZXJJbmRleGVyKSwgbGFzdEluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0lkZW50aWZpZXJJbmRleGVyICYmIGlkZW50aWZpZXJJbmRleGVyWzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlU3RyID0gJygnICsgdGhpcy5fX2luZGV4SW50b0NvbnRleHQudG9TdHJpbmcoKSArICcpKCcgKyBjb2RlQXJyYXkucG9wKCkgKyAnLCcgKyBjb2RlU3RyICsgJyknO1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllckluZGV4ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVycy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNWYWxFcXVhbChwcmV2aW91c1Rva2VuLCAnKystLSgpW10qLyU/Oj49PD0mJnx8IT09PScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9ICcoJyArIHRoaXMuX19pbmRleEludG9Db250ZXh0LnRvU3RyaW5nKCkgKyAnKSgnICsgY29kZUFycmF5LnBvcCgpICsgJywnICsgY29kZVN0ciArICcpJztcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllcnMucHVzaCgnLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG9rZW4gPT09ICdbXScgJiYgIShpc051bGwocHJldmlvdXNUb2tlbikgfHwgcHJldmlvdXNUb2tlbi5hcmdzID49IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZVN0ciA9ICcoJyArIHRoaXMuX19pbmRleEludG9Db250ZXh0LnRvU3RyaW5nKCkgKyAnKSgnICsgY29kZUFycmF5LnBvcCgpICsgJywnICsgY29kZVN0ciArICcpJztcclxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSB0ZW1wSWRlbnRpZmllcnMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVyc1tsYXN0SW5kZXhdICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godGVtcElkZW50aWZpZXJzLnBvcCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXJJbmRleGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVTdHIgPSAnKCcgKyB0aGlzLl9faW5kZXhJbnRvQ29udGV4dC50b1N0cmluZygpICsgJykoJyArIGNvZGVBcnJheS5wb3AoKSArICcsXCInICsgY29kZVN0ciArICdcIiknO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlbXBJZGVudGlmaWVycy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXJzW2xhc3RJbmRleF0gIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXJzW2xhc3RJbmRleF0gKz0gJy4nICsgaWRlbnRpZmllckluZGV4ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzSWRlbnRpZmllckluZGV4ZXIgJiYgaWRlbnRpZmllckluZGV4ZXIgIT09ICcuJyAmJiB0b2tlbiAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllckluZGV4ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKGNvZGVTdHIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZUxvY2FsQ29udGV4dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgdGhlIFwiP1wiIG9wZXJhdG9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2hhbmRsZVF1ZXN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzLCB0ZW1wSWRlbnRpZmllcnMgPSB0aGlzLl9fdGVtcElkZW50aWZpZXJzLCBjb2RlQXJyYXkgPSB0aGlzLl9fY29kZUFycmF5LCB0ZW1wID0gY29kZUFycmF5LnBvcCgpLCB0ZW1wSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBJZGVudGlmaWVyID0gdGVtcElkZW50aWZpZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXIgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnMucHVzaCh0ZW1wSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKGNvZGVBcnJheS5wb3AoKSArICc/JyArIHRlbXApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0aGUgXCI6XCIgb3BlcmF0b3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQYXJzZXIucHJvdG90eXBlLl9faGFuZGxlQ29sb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSB0aGlzLl9faWRlbnRpZmllcnMsIHRlbXBJZGVudGlmaWVycyA9IHRoaXMuX190ZW1wSWRlbnRpZmllcnMsIGNvZGVBcnJheSA9IHRoaXMuX19jb2RlQXJyYXksIHRlbXAgPSBjb2RlQXJyYXkucG9wKCksIHRlbXBJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcElkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXIgPSB0ZW1wSWRlbnRpZmllcnMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllciAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycy5wdXNoKHRlbXBJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29kZUFycmF5LnB1c2goY29kZUFycmF5LnBvcCgpICsgJzonICsgdGVtcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGFsbCBvdGhlciBvcGVyYXRvcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgY3VycmVudCBJVG9rZW4gdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzIFRoZSBjdXJyZW50IElUb2tlbiBhcmdzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2hhbmRsZU9wZXJhdG9yID0gZnVuY3Rpb24gKHRva2VuLCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllcnMgPSB0aGlzLl9faWRlbnRpZmllcnMsIHRlbXBJZGVudGlmaWVycyA9IHRoaXMuX190ZW1wSWRlbnRpZmllcnMsIGNvZGVBcnJheSA9IHRoaXMuX19jb2RlQXJyYXksIGogPSAwLCB0ZW1wU3RyID0gJycsIHRlbXBJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGorKyA8IGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wU3RyID0gJ2Z1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzKSB7IHJldHVybiAnICsgY29kZUFycmF5LnBvcCgpICsgJzsgfScgKyAnLCcgKyB0ZW1wU3RyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wSWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wSWRlbnRpZmllciA9IHRlbXBJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBJZGVudGlmaWVyICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzLnB1c2godGVtcElkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcHVzaCBpZGVudGlmaWVyIGZvciBuZXcgcmVzdWx0IG9mIG9wZXJhdG9yIFxyXG4gICAgICAgICAgICAgICAgdGVtcElkZW50aWZpZXJzLnB1c2goJy4nKTtcclxuICAgICAgICAgICAgICAgIGNvZGVBcnJheS5wdXNoKCcoJyArIE9QRVJBVE9SU1t0b2tlbl0uZm4udG9TdHJpbmcoKSArICcpKGNvbnRleHQsIGFsaWFzZXMsJyArIHRlbXBTdHIuc2xpY2UoMCwgdGVtcFN0ci5sZW5ndGggLSAxKSArICcpJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTYWZlbHkgZmluZHMgYW4gaW5pdGlhbCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBhbGlhc2VzIEFueSBhbGlhc2VzIHRoYXQgbWF5IGV4aXN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVGhlIHByb3BlcnR5IHVzZWQgdG8gZmluZCB0aGUgaW5pdGlhbCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2ZpbmRJbml0aWFsQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuWzBdID09PSAnQCcgJiYgYWxpYXNlcyAhPT0gbnVsbCAmJiB0eXBlb2YgYWxpYXNlcyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxpYXNlc1t0b2tlbi5zbGljZSgxKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZXh0ICE9PSBudWxsICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W3Rva2VuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNhZmVseSBkcmlsbHMgZG93biBpbnRvIGEgc3BlY2lmaWVkIGNvbnRleHQgd2l0aCBhIGdpdmVuIHRva2VuLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUaGUgcHJvcGVydHkgdXNlZCB0byBkcmlsbCBpbnRvIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUGFyc2VyLnByb3RvdHlwZS5fX2luZGV4SW50b0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgdG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSBudWxsICYmIHR5cGVvZiBjb250ZXh0ID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0W3Rva2VuXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUGFyc2VyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfdG9rZW5pemVyOiBfX1Rva2VuaXplcixcclxuICAgICAgICAgICAgICAgIF9sb2c6IF9fTG9nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBQYXJzZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBleHByZXNzaW9ucy5QYXJzZXIgPSBQYXJzZXI7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1BhcnNlciwgUGFyc2VyKTtcclxuICAgIH0pKGV4cHJlc3Npb25zID0gcGxhdF8xLmV4cHJlc3Npb25zIHx8IChwbGF0XzEuZXhwcmVzc2lvbnMgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gd2ViIGNvbXBvbmVudHMgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciB3ZWI7XHJcbiAgICAoZnVuY3Rpb24gKHdlYikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIExvY2F0aW9uKF93aW5kb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF93aW5kb3cubG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdlYi5Mb2NhdGlvbiA9IExvY2F0aW9uO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Mb2NhdGlvbiwgTG9jYXRpb24sIFtfX1dpbmRvd10pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjbGFzcyB0aGF0IGhhbmRsZXMgYWxsIGludGVyYWN0aW9uIHdpdGggdGhlIGJyb3dzZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJyb3dzZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIEJyb3dzZXIuIEFzc2lnbnMgYSB1aWQgYW5kIHN1YnNjcmliZXMgdG8gdGhlICdiZWZvcmVMb2FkJyBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJyb3dzZXIoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgdW5pcXVlIHN0cmluZyBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnVpZCA9IHVuaXF1ZUlkKF9fUGxhdCk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBicm93c2VyJ3MgbGFzdCBVUkwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0VXJsID0gdGhpcy5fbG9jYXRpb24uaHJlZjtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgaXMgaW4gYW4gaW5pdGlhbGl6YXRpb24gc3RhdGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19pbml0aWFsaXppbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX0V2ZW50TWFuYWdlci5vbih0aGlzLnVpZCwgX19iZWZvcmVMb2FkLCB0aGlzLmluaXRpYWxpemUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhdC5tc0FwcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YWNrID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBCcm93c2VyIGluc3RhbmNlLCB0cmltcyB0aGUgdXJsLCBhbmRcclxuICAgICAgICAgICAgICogYWRkcyBldmVudHMgZm9yIHBvcHN0YXRlIGFuZCBoYXNoY2hhbmdlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfY29tcGF0ID0gdGhpcy5fY29tcGF0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fRXZlbnRNYW5hZ2VyLmRpc3Bvc2UodGhpcy51aWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2luaXRpYWxpemluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhY3F1aXJlKF9fVXJsVXRpbHNJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwoKSwgdHJpbW1lZFVybCA9IHVybCwgY2hhbmdlZCA9IHRoaXMuX3VybENoYW5nZWQuYmluZCh0aGlzKSwgX2RvbSA9IHRoaXMuX2RvbSwgX3dpbmRvdyA9IHRoaXMuX3dpbmRvdztcclxuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkVXJsICE9PSB1cmwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCh0cmltbWVkVXJsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChfY29tcGF0LnB1c2hTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb20uYWRkRXZlbnRMaXN0ZW5lcihfd2luZG93LCBfX1BPUFNUQVRFLCBjaGFuZ2VkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfZG9tLmFkZEV2ZW50TGlzdGVuZXIoX3dpbmRvdywgX19IQVNIQ0hBTkdFLCBjaGFuZ2VkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faW5pdGlhbGl6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGN1cnJlbnQgX3dpbmRvdy5sb2NhdGlvblxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsPyBUaGUgVVJMIHRvIHNldCB0aGUgbG9jYXRpb24gdG8uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZT8gV2hldGhlciBvciBub3QgdG8gcmVwbGFjZSB0aGUgY3VycmVudCBVUkwgaW5cclxuICAgICAgICAgICAgICogdGhlIGhpc3RvcnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAodXJsLCByZXBsYWNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB0aGlzLl9sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh1cmwpICYmICF0aGlzLl9pc0xhc3RVcmwodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVwbGFjZSAmJiBpc0FycmF5KHRoaXMuX3N0YWNrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjay5wdXNoKGxvY2F0aW9uLmhyZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRVcmwodXJsLCByZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fY3VycmVudFVybCB8fCBsb2NhdGlvbi5ocmVmO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTmF2aWdhdGVzIGJhY2sgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoPTEgVGhlIGxlbmd0aCB0byBnbyBiYWNrXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBfc3RhY2sgPSB0aGlzLl9zdGFjaztcclxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KF9zdGFjaykgJiYgX3N0YWNrLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFjayA9IF9zdGFjayA9IF9zdGFjay5zbGljZSgwLCBfc3RhY2subGVuZ3RoIC0gKGxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVybChfc3RhY2sucG9wKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oaXN0b3J5LmdvKC1sZW5ndGgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTmF2aWdhdGVzIGZvcndhcmQgaW4gdGhlIGJyb3dzZXIgaGlzdG9yeVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoPTEgVGhlIGxlbmd0aCB0byBnbyBmb3J3YXJkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihsZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkuZ28obGVuZ3RoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgVXJsVXRpbHMgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdXJsPyBUaGUgVVJMIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgVXJsVXRpbHNcclxuICAgICAgICAgICAgICogaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCcm93c2VyLnByb3RvdHlwZS51cmxVdGlscyA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IHVybCB8fCB0aGlzLnVybCgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF91cmxVdGlscyA9IGFjcXVpcmUoX19VcmxVdGlsc0luc3RhbmNlKSwgX2NvbmZpZyA9IEJyb3dzZXIuY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jb25maWcucm91dGluZ1R5cGUgPT09IF9jb25maWcuSEFTSCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKG5ldyBSZWdFeHAoJyMnICsgKF9jb25maWcuaGFzaFByZWZpeCB8fCAnJykgKyAnLz8nKSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3VybFV0aWxzLmluaXRpYWxpemUodXJsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdXJsVXRpbHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSByZXF1ZXN0ZWQgVVJMIGlzIGNyb3NzIGRvbWFpbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIHZlcmlmeSB3aGV0aGVyIG9yIG5vdCBpdCdzIGNyb3NzIGRvbWFpbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLmlzQ3Jvc3NEb21haW4gPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdXJsVXRpbHMgPSB0aGlzLnVybFV0aWxzKHVybCksIGxvY2F0aW9uVXRpbHMgPSB0aGlzLnVybFV0aWxzKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgcHJvdG9jb2w6aG9zdDpwb3J0IG1pc21hdGNoIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybFV0aWxzLnByb3RvY29sICE9PSBsb2NhdGlvblV0aWxzLnByb3RvY29sIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsVXRpbHMuaG9zdG5hbWUgIT09IGxvY2F0aW9uVXRpbHMuaG9zdG5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICB1cmxVdGlscy5wb3J0ICE9PSBsb2NhdGlvblV0aWxzLnBvcnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGb3JtYXRzIHRoZSBVUkwgaW4gdGhlIGNhc2Ugb2YgSEFTSCByb3V0aW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gZm9ybWF0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUuZm9ybWF0VXJsID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEJyb3dzZXIuY29uZmlnLCBiYXNlVXJsID0gY29uZmlnLmJhc2VVcmwsIGlzTG9jYWwgPSAhdGhpcy5fcmVnZXguZnVsbFVybFJlZ2V4LnRlc3QodXJsKSB8fCB1cmwuaW5kZXhPZihiYXNlVXJsKSA+IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHVybCA9PT0gYmFzZVVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXJsWzBdID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMb2NhbCAmJiBjb25maWcucm91dGluZ1R5cGUgPT09IGNvbmZpZy5IQVNIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc1Byb3RvY29sID0gdXJsLmluZGV4T2YodGhpcy51cmxVdGlscygpLnByb3RvY29sKSAhPT0gLTEsIHByZWZpeCA9IGNvbmZpZy5oYXNoUHJlZml4IHx8ICcnLCBhcHBlbmQgPSAnIycgKyBwcmVmaXgsIGhhc2hSZWdleCA9IG5ldyBSZWdFeHAoYXBwZW5kICsgJ3wjLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmxbdXJsLmxlbmd0aCAtIDFdICE9PSAnLycgJiYgdXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9ICcvJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1Byb3RvY29sICYmICFoYXNoUmVnZXgudGVzdCh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHVybCArIGFwcGVuZCArICcvJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWhhc2hSZWdleC50ZXN0KHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gYXBwZW5kICsgKCh1cmxbMF0gIT09ICcvJykgPyAnLycgOiAnJykgKyB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTG9jYWwgJiYgdXJsLmluZGV4T2YoYmFzZVVybCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYmFzZVVybCArIHVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZXZlbnQgdG8gZmlyZSBpbiB0aGUgY2FzZSBvZiBhIFVSTCBjaGFuZ2UuIEl0IGtpY2tzXHJcbiAgICAgICAgICAgICAqIG9mZiBhICd1cmxDaGFuZ2VkJyBkaXJlY3QgZXZlbnQgbm90aWZpY2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgdG8gdmVyaWZ5IHdoZXRoZXIgb3Igbm90IGl0J3MgY3Jvc3MgZG9tYWluLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUuX3VybENoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pbml0aWFsaXppbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY3VycmVudFVybCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnVybFV0aWxzKCksICRjb25maWcgPSBCcm93c2VyLmNvbmZpZywgdXJsID0gdGhpcy5fdHJpbVNsYXNoZXModXRpbHMuaHJlZik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2xhc3RVcmwgPT09IHVybCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0VXJsID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgdmFyICRtYW5hZ2VyID0gdGhpcy5fRXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRtYW5hZ2VyLmRpc3BhdGNoKF9fdXJsQ2hhbmdlZCwgX3RoaXMsICRtYW5hZ2VyLkRJUkVDVCwgW3V0aWxzXSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBwdXNoU3RhdGUgYW5kXHJcbiAgICAgICAgICAgICAqIHNldHMgdGhlIGJyb3dzZXIgVVJMIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gc2V0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcGxhY2U/IFdoZXRoZXIgb3Igbm90IHRvIHJlcGxhY2UgdGhlXHJcbiAgICAgICAgICAgICAqIGN1cnJlbnQgVVJMIGluIHRoZSBoaXN0b3J5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5wcm90b3R5cGUuX3NldFVybCA9IGZ1bmN0aW9uICh1cmwsIHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuZm9ybWF0VXJsKHVybCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnVybFV0aWxzKHVybCksIGJhc2VVcmwgPSBCcm93c2VyLmNvbmZpZy5iYXNlVXJsLCBfaGlzdG9yeSA9IHRoaXMuX2hpc3RvcnksIF9sb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmhyZWYuaW5kZXhPZihiYXNlVXJsKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBfbG9jYXRpb24uaHJlZiA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgVVJMIGlzIGFic29sdXRlIFxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yZWdleC5mdWxsVXJsUmVnZXgudGVzdCh1cmwpICYmIHVybFswXSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gYmFzZVVybCArIHVybDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXQucHVzaFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gX2hpc3Rvcnkuc3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0xvY2F0aW9uOiBzdGF0ZS5wcmV2aW91c0xvY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICcnLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hpc3RvcnkucHVzaFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTG9jYXRpb246IHRoaXMudXJsVXRpbHMoKS5wYXRobmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnJywgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9faW5pdGlhbGl6aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VybENoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY3VycmVudFVybCA9IHVybDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9jYXRpb24ucmVwbGFjZSh1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvY2F0aW9uLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdXJsIGlzIGVxdWFsIHRvIHRoZSBsYXN0IHVybFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gbWF0Y2hcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLl9pc0xhc3RVcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuX19sYXN0VXJsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICcvJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5fdHJpbVNsYXNoZXModGhpcy51cmxVdGlscyh1cmwpLmhyZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybCA9PT0gbGFzdDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRyaW1zIHRyYWlsaW5nIHNsYXNoZXMgZnJvbSBhIHVybC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRyaW1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJyb3dzZXIucHJvdG90eXBlLl90cmltU2xhc2hlcyA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSB8fCB1cmxbdXJsLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJyb3dzZXIuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9FdmVudE1hbmFnZXI6IF9fRXZlbnRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgICAgICBfcmVnZXg6IF9fUmVnZXgsXHJcbiAgICAgICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgICAgIF9sb2NhdGlvbjogX19Mb2NhdGlvbixcclxuICAgICAgICAgICAgICAgIF9oaXN0b3J5OiBfX0hpc3RvcnksXHJcbiAgICAgICAgICAgICAgICBfZG9tOiBfX0RvbVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIElCcm93c2VyQ29uZmlnIGluamVjdGFibGUgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQnJvd3Nlci5jb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICBIQVNIOiAnaGFzaCcsXHJcbiAgICAgICAgICAgICAgICBTVEFURTogJ3N0YXRlJyxcclxuICAgICAgICAgICAgICAgIHJvdXRpbmdUeXBlOiAnaGFzaCcsXHJcbiAgICAgICAgICAgICAgICBoYXNoUHJlZml4OiAnIScsXHJcbiAgICAgICAgICAgICAgICBiYXNlVXJsOiAnJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQnJvd3NlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHdlYi5Ccm93c2VyID0gQnJvd3NlcjtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQnJvd3NlciwgQnJvd3Nlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUJyb3dzZXJDb25maWcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCcm93c2VyLmNvbmZpZztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2ViLklCcm93c2VyQ29uZmlnID0gSUJyb3dzZXJDb25maWc7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0Jyb3dzZXJDb25maWcsIElCcm93c2VyQ29uZmlnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWFscyB3aXRoIG9idGFpbmluZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBhblxyXG4gICAgICAgICAqIGFzc29jaWF0ZWQgVVJMLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBVcmxVdGlscyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgVXJsVXRpbHMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgcGFyc2luZyB0aGUgaW5pdGlhbCBVUkwgYW5kIG9idGFpbiB0aGUgYmFzZSBVUkwgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gVXJsVXRpbHMoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5fYnJvd3NlckNvbmZpZywgYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoYmFzZVVybCkgfHwgIXRoaXMuX3JlZ2V4LmZ1bGxVcmxSZWdleC50ZXN0KGJhc2VVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuX3dpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cmltbWVkVXJsID0gdXJsLnJlcGxhY2UodGhpcy5fcmVnZXguaW5pdGlhbFVybFJlZ2V4LCAnLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhiYXNlVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVVybC5pbmRleE9mKCcvJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBiYXNlVXJsLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBVcmxVdGlscy5fX2dldEJhc2VVcmwodHJpbW1lZFVybCkgKyBiYXNlVXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlVXJsW2Jhc2VVcmwubGVuZ3RoIC0gMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsID0gYmFzZVVybC5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5iYXNlVXJsID0gYmFzZVVybCArICcvJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIHF1ZXJ5IG9iamVjdCBvdXQgb2YgdGhlIFVSTCdzIHF1ZXJ5IHNlYXJjaCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2ggVGhlIFVSTCdzIHF1ZXJ5IHNlYXJjaCBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBVcmxVdGlscy5fX2dldFF1ZXJ5ID0gZnVuY3Rpb24gKHNlYXJjaCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplUXVlcnkoc2VhcmNoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9idGFpbnMgdGhlIGJhc2UgVVJMIGZvciB0aGUgYXBwL3NpdGUgZm9yIGRvaW5nIFNUQVRFIHR5cGUgcm91dGluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgaW5pdGlhbCBVUkwgcGFzc2VkIGludG8gdGhlIEJyb3dzZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBVcmxVdGlscy5fX2dldEJhc2VVcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3JlZ2V4ID0gYWNxdWlyZShfX1JlZ2V4KSwgX2xvY2F0aW9uID0gYWNxdWlyZShfX0xvY2F0aW9uKSwgb3JpZ2luID0gX2xvY2F0aW9uLm9yaWdpbiwgcHJvdG9jb2wgPSBfbG9jYXRpb24ucHJvdG9jb2wsIGhvc3QgPSBfbG9jYXRpb24uaG9zdDtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCBwcm90b2NvbC5pbmRleE9mKCd3bWFwcCcpID4gLTEgfHwgcHJvdG9jb2wuaW5kZXhPZignbXMtYXBweCcpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBfbG9jYXRpb24uaHJlZjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKG9yaWdpbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBfbG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgX2xvY2F0aW9uLmhvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcmlnaW4gPSBvcmlnaW4ucmVwbGFjZShfcmVnZXguaW5pdGlhbFVybFJlZ2V4LCAnJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luLnNwbGl0KCc/JylbMF0uc3BsaXQoJyMnKVswXSArICcvJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGFuZCBkZWZpbmVzIHByb3BlcnRpZXMgdXNpbmdcclxuICAgICAgICAgICAgICogdGhlIGlucHV0IHVybC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgaW5wdXQgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBVcmxVdGlscyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFVybFV0aWxzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHVybCkge1xyXG4gICAgICAgICAgICAgICAgdXJsID0gdXJsIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBVcmxVdGlscy5fX3VybFV0aWxzRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChVcmxVdGlscy5fX3VybFV0aWxzRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSksIF9icm93c2VyQ29uZmlnID0gdGhpcy5fYnJvd3NlckNvbmZpZztcclxuICAgICAgICAgICAgICAgIC8vIGFsd2F5cyBtYWtlIGxvY2FsIHVybHMgcmVsYXRpdmUgdG8gc3RhcnQgcGFnZS4gXHJcbiAgICAgICAgICAgICAgICBpZiAodXJsWzBdID09PSAnLycgJiYgdXJsLmluZGV4T2YoJy8vJykgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgYXBwZW5kIHRoZSBiYXNlVXJsIGlmIHRoaXMgaXMgbm90IGEgZnVsbC11cmwgXHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JlZ2V4LmZ1bGxVcmxSZWdleC50ZXN0KHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBfYnJvd3NlckNvbmZpZy5iYXNlVXJsICsgdXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgdXJsID0gZWxlbWVudC5ocmVmO1xyXG4gICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkbyB0aGlzIHR3aWNlIGZvciBjZXJhaW4gYnJvd3NlcnMgKGUuZy4gd2luOCkgXHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnaHJlZicsIHVybCk7XHJcbiAgICAgICAgICAgICAgICB1cmwgPSBlbGVtZW50LmhyZWY7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sID0gZWxlbWVudC5wcm90b2NvbCA/IGVsZW1lbnQucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJztcclxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdCA9IGVsZW1lbnQuaG9zdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gZWxlbWVudC5zZWFyY2ggPyBlbGVtZW50LnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJyc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc2ggPSBlbGVtZW50Lmhhc2ggPyBlbGVtZW50Lmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJztcclxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBlbGVtZW50Lmhvc3RuYW1lO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gZWxlbWVudC5wb3J0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGg7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoX2Jyb3dzZXJDb25maWcuYmFzZVVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdXJsLnJlcGxhY2UoX2Jyb3dzZXJDb25maWcuYmFzZVVybCwgJy8nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSAoZWxlbWVudC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbGVtZW50LnBhdGhuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJy8nICsgZWxlbWVudC5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UodGhpcy5fcmVnZXguaW5pdGlhbFVybFJlZ2V4LCAnLycpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhdGguc3BsaXQoJz8nKVswXS5zcGxpdCgnIycpWzBdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IFVybFV0aWxzLl9fZ2V0UXVlcnkodGhpcy5zZWFyY2gpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSB0b1N0cmluZyBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFVybFV0aWxzIGNsYXNzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVXJsVXRpbHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHJlZjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgVXJsVXRpbHMuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9FdmVudE1hbmFnZXI6IF9fRXZlbnRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgICAgIF9yZWdleDogX19SZWdleCxcclxuICAgICAgICAgICAgICAgIF9icm93c2VyQ29uZmlnOiBfX0Jyb3dzZXJDb25maWdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFVybFV0aWxzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgd2ViLlVybFV0aWxzID0gVXJsVXRpbHM7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1VybFV0aWxzSW5zdGFuY2UsIFVybFV0aWxzLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgIH0pKHdlYiA9IHBsYXRfMS53ZWIgfHwgKHBsYXRfMS53ZWIgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBhbGwgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIGFzeW5jIGNvbXBvbmVudHMgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBhc3luYztcclxuICAgIChmdW5jdGlvbiAoYXN5bmMpIHtcclxuICAgICAgICB2YXIgX19wcm9taXNlUXVldWUgPSBbXSwgYnJvd3Nlckdsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgPyB3aW5kb3cgOiB7fSwgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLCBzY2hlZHVsZUZsdXNoO1xyXG4gICAgICAgIHZhciBwcm9jZXNzID0gcHJvY2VzcztcclxuICAgICAgICAvLyBkZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOiBcclxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xyXG4gICAgICAgICAgICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNjaGVkdWxlRmx1c2ggPSB1c2VTZXRUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRha2VzIGluIGEgZ2VuZXJpYyB0eXBlIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZ1bGxmaWxsZWQgc3VjY2VzcyB0eXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBQcm9taXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIEVTNiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUHJvbWlzZSBBUEkuIFVzZWZ1bCBmb3IgYXN5bmNocm9ub3VzIHByb2dyYW1taW5nLlxyXG4gICAgICAgICAgICAgKiBUYWtlcyBpbiAyIGdlbmVyaWMgdHlwZXMgY29ycmVzcG9uZGluZyB0byB0aGUgZnVsbGZpbGxlZCBzdWNjZXNzIGFuZCBlcnJvciB0eXBlcy5cclxuICAgICAgICAgICAgICogVGhlIGVycm9yIHR5cGUgKFUpIHNob3VsZCBleHRlbmQgRXJyb3IgaW4gb3JkZXIgdG8gZ2V0IHByb3BlciBzdGFjayB0cmFjaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSVJlc29sdmVGdW5jdGlvbjxSPn0gcmVzb2x2ZUZ1bmN0aW9uIEEgSVJlc29sdmVGdW5jdGlvbiBmb3IgZnVsZmlsbGluZy9yZWplY3RpbmcgdGhlIFByb21pc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHJlc29sdmVGdW5jdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gY29uc3RydWN0IFwiUHJvbWlzZVwiOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19zdWJzY3JpYmVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5fX2ludm9rZVJlc29sdmVGdW5jdGlvbihyZXNvbHZlRnVuY3Rpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtwcm9taXNlc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLCByZW1haW5pbmcgPSBwcm9taXNlcy5sZW5ndGgsIHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gcmVzb2x2ZUFsbChpbmRleCwgdmFsdWUpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlQWxsKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UocHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVBbGwoaSwgcHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHByb21pc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbcHJvbWlzZXNdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlICYmIHR5cGVvZiBwcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVqZWN0cyB3aXRoIHRoZSBpbnB1dCB2YWx1ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGVycm9yIFRoZSB2YWx1ZSB0byByZWplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2VzIHRoZSByZXNvbHZlIGZ1bmN0aW9uIGZvciBhIHByb21pc2UuIEhhbmRsZXMgZXJyb3IgY2F0Y2hpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5JUmVzb2x2ZUZ1bmN0aW9uPFI+fSByZXNvbHZlRnVuY3Rpb24gVGhlIHJlc29sdmUgZnVuY3Rpb24gdG8gaW52b2tlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxSPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvbiB3aGljaCB0byBpbnZva2UgdGhlIHJlc29sdmUgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9faW52b2tlUmVzb2x2ZUZ1bmN0aW9uID0gZnVuY3Rpb24gKHJlc29sdmVGdW5jdGlvbiwgcHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZVByb21pc2UodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZ1bmN0aW9uKHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZShlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludm9rZXMgYSBjYWxsYmFjayBmb3IgYSBwcm9taXNlIHdpdGggdGhlIHNwZWNpZmllZCBkZXRhaWwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5TdGF0ZX0gc2V0dGxlZCBUaGUgc3RhdGUgb2YgdGhlIHByb21pc2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBwcm9taXNlIFRoZSBwcm9taXNlIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsocmVzcG9uc2U6IGFueSkgPT4gdm9pZH0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGludm9rZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGRldGFpbCBUaGUgZGV0YWlscyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuX19pbnZva2VDYWxsYmFjayA9IGZ1bmN0aW9uIChzZXR0bGVkLCBwcm9taXNlLCBjYWxsYmFjaywgZGV0YWlsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSwgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZGV0YWlsO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoUHJvbWlzZS5fX2hhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NhbGxiYWNrICYmIHN1Y2NlZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZhaWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGxlZCA9PT0gU3RhdGUuRlVMRklMTEVEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3Jlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGxlZCA9PT0gU3RhdGUuUkVKRUNURUQpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFB1Ymxpc2hlcyB0aGUgcHJvbWlzZSBkZXRhaWxzIHRvIGFsbCB0aGUgc3Vic2NyaWJlcnMgZm9yIGEgcHJvbWlzZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHByb21pc2UgVGhlIHByb21pc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuU3RhdGV9IHNldHRsZWQgVGhlIHN0YXRlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5fX3B1Ymxpc2ggPSBmdW5jdGlvbiAocHJvbWlzZSwgc2V0dGxlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fX3N1YnNjcmliZXJzLCBkZXRhaWwgPSBwcm9taXNlLl9fZGV0YWlsLCBjaGlsZCwgY2FsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBzdWJzY3JpYmVyc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHN1YnNjcmliZXJzW2kgKyBzZXR0bGVkXTtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9faW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgY2hpbGQsIGNhbGxiYWNrLCBkZXRhaWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fX3N1YnNjcmliZXJzID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFB1Ymxpc2hlcyBhIHByb21pc2VzIHRoYXQgaGFzIGJlZW4gZnVsZmlsbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9fcHVibGlzaEZ1bGZpbGxtZW50ID0gZnVuY3Rpb24gKHByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgIFByb21pc2UuX19wdWJsaXNoKHByb21pc2UsIHByb21pc2UuX19zdGF0ZSA9IFN0YXRlLkZVTEZJTExFRCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQdWJsaXNoZXMgYSBwcm9taXNlcyB0aGF0IGhhcyBiZWVuIHJlamVjdGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9fcHVibGlzaFJlamVjdGlvbiA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICBQcm9taXNlLl9fcHVibGlzaChwcm9taXNlLCBwcm9taXNlLl9fc3RhdGUgPSBTdGF0ZS5SRUpFQ1RFRCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBc3luY2hyb25vdXNseSByZWplY3RzIGEgcHJvbWlzZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSByZWFzb24gVGhlIGRldGFpbCBvZiB0aGUgcmVqZWN0ZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuX19yZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgcmVhc29uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5fX3N0YXRlICE9PSBTdGF0ZS5QRU5ESU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fX3N0YXRlID0gU3RhdGUuU0VBTEVEO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fX2RldGFpbCA9IHJlYXNvbjtcclxuICAgICAgICAgICAgICAgIFByb21pc2UuY29uZmlnLmFzeW5jKFByb21pc2UuX19wdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFzeW5jaHJvbm91c2x5IGZ1bGZpbGxzIGEgcHJvbWlzZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxSPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgZGV0YWlsIG9mIHRoZSBmdWxmaWxsZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuX19mdWxmaWxsID0gZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZS5fX3N0YXRlICE9PSBTdGF0ZS5QRU5ESU5HKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fX3N0YXRlID0gU3RhdGUuU0VBTEVEO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fX2RldGFpbCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5jb25maWcuYXN5bmMoUHJvbWlzZS5fX3B1Ymxpc2hGdWxmaWxsbWVudCwgcHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBc3luY2hyb25vdXNseSBmdWxmaWxscyBhIHByb21pc2UsIGFsbG93aW5nIGZvciBwcm9taXNlIGNoYWluaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxSPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgZGV0YWlsIG9mIHRoZSBmdWxmaWxsZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuX19yZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghUHJvbWlzZS5fX2hhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19mdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhhbmRsZXMgY2hhaW5pbmcgcHJvbWlzZXMgdG9nZXRoZXIsIHdoZW4gYSBwcm9taXNlIGlzIHJldHVybmVkIGZyb20gd2l0aGluIGEgdGhlbiBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuUHJvbWlzZTxSPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5Qcm9taXNlPFI+fSB2YWx1ZSBUaGUgbmV4dCBwcm9taXNlIHRvIGF3YWl0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUHJvbWlzZS5fX2hhbmRsZVRoZW5hYmxlID0gZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9fcmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGUgc2FtZSBwcm9taXNlLicpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbi5jYWxsKHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3Jlc29sdmUocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19mdWxmaWxsKHByb21pc2UsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3JlamVjdChwcm9taXNlLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuX19yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgY2hpbGQgcHJvbWlzZSB0byB0aGUgcGFyZW50J3Mgc3Vic2NyaWJlcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5Qcm9taXNlPGFueT59IHBhcmVudCBUaGUgcGFyZW50IHByb21pc2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5Qcm9taXNlPGFueT59IHZhbHVlIFRoZSBjaGlsZCBwcm9taXNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhzdWNjZXNzOiBhbnkpID0+IGFueX0gb25GdWxsZmlsbGVkIFRoZSBmdWxmaWxsZWQgbWV0aG9kIGZvciB0aGUgY2hpbGQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KGVycm9yOiBhbnkpID0+IGFueX0gb25SZWplY3RlZCBUaGUgcmVqZWN0ZWQgbWV0aG9kIGZvciB0aGUgY2hpbGQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBQcm9taXNlLl9fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaWJlcnMgPSBwYXJlbnQuX19zdWJzY3JpYmVycztcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdWJzY3JpYmVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBTdGF0ZS5GVUxGSUxMRURdID0gb25GdWxmaWxsZWQ7XHJcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyBTdGF0ZS5SRUpFQ1RFRF0gPSBvblJlamVjdGVkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGhlblByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzXzEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5jb25maWcuYXN5bmMoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLl9faW52b2tlQ2FsbGJhY2socHJvbWlzZS5fX3N0YXRlLCB0aGVuUHJvbWlzZSwgY2FsbGJhY2tzXzFbcHJvbWlzZS5fX3N0YXRlIC0gMV0sIHByb21pc2UuX19kZXRhaWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5fX3N1YnNjcmliZSh0aGlzLCB0aGVuUHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoZW5Qcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT3V0cHV0cyB0aGUgUHJvbWlzZSBhcyBhIHJlYWRhYmxlIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdbb2JqZWN0IFByb21pc2VdJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25maWd1cmF0aW9uIGZvciBjcmVhdGluZyBhc3luY2hyb25vdXMgcHJvbWlzZSBmbHVzaGluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFByb21pc2UuY29uZmlnID0ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGFzeW5jOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGFyZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBfX3Byb21pc2VRdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIGFzeW5jLlByb21pc2UgPSBQcm9taXNlO1xyXG4gICAgICAgIHZhciBTdGF0ZTtcclxuICAgICAgICAoZnVuY3Rpb24gKFN0YXRlKSB7XHJcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiUEVORElOR1wiXSA9ICh2b2lkIDApXSA9IFwiUEVORElOR1wiO1xyXG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlNFQUxFRFwiXSA9IDBdID0gXCJTRUFMRURcIjtcclxuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJGVUxGSUxMRURcIl0gPSAxXSA9IFwiRlVMRklMTEVEXCI7XHJcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiUkVKRUNURURcIl0gPSAyXSA9IFwiUkVKRUNURURcIjtcclxuICAgICAgICB9KShTdGF0ZSB8fCAoU3RhdGUgPSB7fSkpO1xyXG4gICAgICAgIDtcclxuICAgICAgICAvLyBub2RlIFxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XHJcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihmbHVzaCksIF9kb2N1bWVudCA9IGFjcXVpcmUoX19Eb2N1bWVudCksIF93aW5kb3cgPSBhY3F1aXJlKF9fV2luZG93KSwgZWxlbWVudCA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIF93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZHJhaW5RdWV1ZScsICdkcmFpblF1ZXVlJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBwb3N0cG9uZShmbHVzaCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xyXG4gICAgICAgICAgICB2YXIgdHVwbGUsIGNhbGxiYWNrLCBhcmc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX19wcm9taXNlUXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHR1cGxlID0gX19wcm9taXNlUXVldWVbaV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHR1cGxlWzBdO1xyXG4gICAgICAgICAgICAgICAgYXJnID0gdHVwbGVbMV07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhhcmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9fcHJvbWlzZVF1ZXVlID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElQcm9taXNlKF93aW5kb3cpIHtcclxuICAgICAgICAgICAgaWYgKCFpc051bGwoX3dpbmRvdy5Qcm9taXNlKSAmJlxyXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihfd2luZG93LlByb21pc2UuYWxsKSAmJlxyXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihfd2luZG93LlByb21pc2UucmFjZSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oX3dpbmRvdy5Qcm9taXNlLnJlc29sdmUpICYmXHJcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKF93aW5kb3cuUHJvbWlzZS5yZWplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3dpbmRvdy5Qcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhc3luYy5JUHJvbWlzZSA9IElQcm9taXNlO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Qcm9taXNlLCBJUHJvbWlzZSwgW19fV2luZG93XSwgX19DTEFTUyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSHR0cFJlcXVlc3QgcHJvdmlkZXMgYSB3cmFwcGVyIGZvciB0aGUgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LiBBbGxvd3MgZm9yXHJcbiAgICAgICAgICogc2VuZGluZyBBSkFYIHJlcXVlc3RzIHRvIGEgc2VydmVyLiBUaGlzIGNsYXNzIGRvZXMgbm90IHN1cHBvcnRcclxuICAgICAgICAgKiBzeW5jaHJvbm91cyByZXF1ZXN0cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgSHR0cFJlcXVlc3QgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIEh0dHBSZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gSHR0cFJlcXVlc3QoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29tcGF0ID0gYWNxdWlyZShfX0NvbXBhdCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZmlsZVN1cHBvcnRlZCA9IGNvbXBhdC5maWxlU3VwcG9ydGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgSHR0cFJlcXVlc3Qgd2l0aCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSUh0dHBDb25maWd9IG9wdGlvbnMgVGhlIElIdHRwQ29uZmlnU3RhdGljIHVzZWQgdG8gY3VzdG9taXplIHRoaXMgSHR0cFJlcXVlc3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3B0aW9ucyA9IF9leHRlbmQoZmFsc2UsIGZhbHNlLCB7fSwgdGhpcy5fY29uZmlnLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV4ZWN1dGVzIGFuIFhNTEh0dHBSZXF1ZXN0IGFuZCByZXNvbHZlcyBhbiBJQWpheFByb21pc2UgdXBvbiBjb21wbGV0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX19vcHRpb25zLCB1cmwgPSBvcHRpb25zLnVybDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSB8fCBpc0VtcHR5KHVybC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHRoaXMuX2Jyb3dzZXIudXJsVXRpbHModXJsKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQ3Jvc3NEb21haW4gPSBvcHRpb25zLmlzQ3Jvc3NEb21haW4gfHwgZmFsc2UsIHhEb21haW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGZvcmNlZCBjcm9zcyBkb21haW4gY2FsbCBvciBjb3JzIGlzIG5vdCBzdXBwb3J0ZWQgKElFOSkgXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDcm9zc0RvbWFpbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHhEb21haW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy54aHIud2l0aENyZWRlbnRpYWxzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4RG9tYWluID0gdGhpcy5fYnJvd3Nlci5pc0Nyb3NzRG9tYWluKHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHhEb21haW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnhociA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29ucENhbGxiYWNrID0gb3B0aW9ucy5qc29ucENhbGxiYWNrIHx8IHVuaXF1ZUlkKF9fSlNPTlBfQ0FMTEJBQ0spO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVKc29ucCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRYaHJSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeGVjdXRlcyBhbiBKU09OUCByZXF1ZXN0IGFuZCByZXNvbHZlcyBhbiBJQWpheFByb21pc2UgdXBvbiBjb21wbGV0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLmV4ZWN1dGVKc29ucCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX19vcHRpb25zLCB1cmwgPSBvcHRpb25zLnVybDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSB8fCBpc0VtcHR5KHVybC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWRPcHRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnVybCA9IHRoaXMuX2Jyb3dzZXIudXJsVXRpbHModXJsKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLmpzb25wQ2FsbGJhY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qc29ucENhbGxiYWNrID0gb3B0aW9ucy5qc29ucENhbGxiYWNrIHx8IHVuaXF1ZUlkKF9fQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgQWpheFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfd2luZG93ID0gX3RoaXMuX3dpbmRvdywgX2RvY3VtZW50ID0gX3RoaXMuX2RvY3VtZW50LCBzY3JpcHRUYWcgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksIGpzb25wQ2FsbGJhY2sgPSBfdGhpcy5qc29ucENhbGxiYWNrLCBqc29ucElkZW50aWZpZXIgPSBvcHRpb25zLmpzb25wSWRlbnRpZmllciB8fCAnY2FsbGJhY2snO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdFRhZy5zcmMgPSB1cmwgKyAoKHVybC5pbmRleE9mKCc/JykgPiAtMSkgPyAnJicgOiAnPycpICsganNvbnBJZGVudGlmaWVyICsgJz0nICsganNvbnBDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBfd2luZG93W2pzb25wQ2FsbGJhY2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIF93aW5kb3dbanNvbnBDYWxsYmFja10gPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW4gdXAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLmNsZWFyVGltZW91dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHNjcmlwdFRhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChvbGRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KF93aW5kb3csIGpzb25wQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvd1tqc29ucENhbGxiYWNrXSA9IG9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgY2FsbGJhY2sgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2sgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHRpbWVvdXQpICYmIHRpbWVvdXQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZpcnN0IHBvc3Rwb25lIHRvIGF2b2lkIGFsd2F5cyB0aW1pbmcgb3V0IHdoZW4gZGVidWdnaW5nLCB0aG91Z2ggdGhpcyBpcyBub3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZm9vbHByb29mIG1ldGhvZC4gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCA9IHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCA9IGRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFqYXhFcnJvcih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiAnUmVxdWVzdCB0aW1lZCBvdXQgaW4gJyArIHRpbWVvdXQgKyAnbXMgZm9yICcgKyB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QgdGltZW91dCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MDhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvd1tqc29ucENhbGxiYWNrXSA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZS5pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHdyYXBwZXIgZm9yIHRoZSBYTUxIdHRwUmVxdWVzdCdzIG9uUmVhZHlTdGF0ZUNoYW5nZWQgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3hock9uUmVhZHlTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcclxuICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXNfMSA9IHhoci5zdGF0dXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c18xID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHhoci5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZXNwb25zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgcHJvdG9jb2wgaXNzdWUgKipOZWVkcyB0byBiZSB0ZXN0ZWQgbW9yZSB0aG9yb3VnaGx5KiogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9rIGlmIHJlc3BvbnNlIGlzIG5vdCBlbXB0eSwgTm90IEZvdW5kIG90aGVyd2lzZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyAzMDQgaXMgbm90IG1vZGlmaWVkIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoc3RhdHVzXzEgPj0gMjAwICYmIHN0YXR1c18xIDwgMzAwKSB8fCBzdGF0dXNfMSA9PT0gMzA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVsc2Uge30gVE9ETzogYWRkIHByb2dyZXNzIGZvciB4aHIgaWYgd2UgY2hvb3NlIHRvIGFkZCBwcm9ncmVzcyB0byBBamF4UHJvbWlzZSBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiB0aGF0IGluaXRpYWxpemVzIGFuZCBzZW5kcyB0aGUgWE1MSHR0cFJlcXVlc3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRYaHJSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciB4aHIgPSB0aGlzLnhociwgb3B0aW9ucyA9IHRoaXMuX19vcHRpb25zLCBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCwgdXJsID0gb3B0aW9ucy51cmwsIHByb21pc2UgPSBuZXcgQWpheFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzID0gX3RoaXMuX3hock9uUmVhZHlTdGF0ZUNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHN1Y2Nlc3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gX3RoaXMuX2Zvcm1hdFJlc3BvbnNlKG9wdGlvbnMucmVzcG9uc2VUeXBlLCBzdWNjZXNzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBamF4RXJyb3IocmVzcG9uc2UpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy54aHIgPSBvcHRpb25zID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcobWV0aG9kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ0FqYXhPcHRpb25zIG1ldGhvZCB3YXMgbm90IG9mIHR5cGUgc3RyaW5nLiBEZWZhdWx0aW5nIHRvIFwiR0VUXCIuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihtZXRob2QudG9VcHBlckNhc2UoKSwgdXJsLCBcclxuICAgICAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbm91cyBYSFIgbm90IHN1cHBvcnRlZCBcclxuICAgICAgICAgICAgICAgICAgICB0cnVlLCBvcHRpb25zLnVzZXIsIG9wdGlvbnMucGFzc3dvcmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShfdGhpcy5fX2ZpbGVTdXBwb3J0ZWQgfHwgcmVzcG9uc2VUeXBlID09PSAnJyB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQgPCA0LjQgd2lsbCB0aHJvdyBhIERPTSBFeGNlcHRpb24gMTIgaWYgcmVzcG9uc2VUeXBlIGlzIHNldCB0byBqc29uLiBcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gZG8gZmVhdHVyZSBkZXRlY3Rpb24gaXMgd2l0aCB0cnkvY2F0Y2guIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdqc29uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBvcHRpb25zLndpdGhDcmVkZW50aWFscztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWltZVR5cGUgPSBvcHRpb25zLm92ZXJyaWRlTWltZVR5cGUsIGRhdGEgPSBvcHRpb25zLmRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1pbWVUeXBlKSAmJiAhaXNFbXB0eShtaW1lVHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUobWltZVR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRhdGEpIHx8IGRhdGEgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGRhdGEgZXhpc3RzIHNvIHNldCBoZWFkZXJzIGFuZCBzZW5kIHJlcXVlc3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybXMgPSBvcHRpb25zLnRyYW5zZm9ybXMgfHwgW10sIGxlbmd0aF8zID0gdHJhbnNmb3Jtcy5sZW5ndGgsIGNvbnRlbnRUeXBlID0gb3B0aW9ucy5jb250ZW50VHlwZSwgY29udGVudFR5cGVFeGlzdHMgPSBpc1N0cmluZyhjb250ZW50VHlwZSkgJiYgIWlzRW1wdHkoY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoXzMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBkYXRhIHRyYW5zZm9ybXMgZGVmaW5lZCwgYXNzdW1lIHRoZXkncmUgZ29pbmcgdG8gdGFrZSBjYXJlIG9mIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW55IGFuZCBhbGwgdHJhbnNmb3JtYXRpb25zLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzM7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0cmFuc2Zvcm1zW2ldKGRhdGEsIHhocik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb250ZW50VHlwZSBleGlzdHMsIGFzc3VtZSB0aGV5IGRpZCBub3Qgc2V0IGl0IGluIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlaXIgaGVhZGVycyBhcyB3ZWxsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGlzT2JqZWN0IGFuZCBjb250ZW50VHlwZSBleGlzdHMgd2Ugd2FudCB0byB0cmFuc2Zvcm0gdGhlIGRhdGEgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGVMb3dlciA9IGNvbnRlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlTG93ZXIuaW5kZXhPZigneC13d3ctZm9ybS11cmxlbmNvZGVkJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gYW4gZW5jb2RlZCBmb3JtIHRyYW5zZm9ybWF0aW9uIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3RoaXMuX19zZXJpYWxpemVGb3JtRGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgQ29udGVudC1UeXBlIGhlYWRlciBiZWNhdXNlIHdlJ3JlIGFzc3VtaW5nIHRoZXkgZGlkbid0IHNldCBpdCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlaXIgaGVhZGVycyBvYmplY3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGVMb3dlci5pbmRleE9mKCdtdWx0aXBhcnQvZm9ybS1kYXRhJykgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgRmlsZSBpcyBhIHN1cHBvcnRlZCBvYmplY3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fX2ZpbGVTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBGb3JtRGF0YSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBfdGhpcy5fX2FwcGVuZEZvcm1EYXRhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3Qgc2V0IHRoZSBDb250ZW50LVR5cGUgaGVhZGVyIGR1ZSB0byBtb2Rlcm4gYnJvd3NlcnMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXR0aW5nIHNwZWNpYWwgaGVhZGVycyBmb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaWZyYW1lIHRyaWNrIGZvciBvbGRlciBicm93c2VycyAoZG8gbm90IHNlbmQgYSByZXF1ZXN0KSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FzZSBpcyB0aGUgcmVhc29uIGZvciB0aGlzIGdpYW50LCB0ZXJyaWJsZSwgbmVzdGVkIGlmLWVsc2Ugc3RhdGVtZW50IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19zdWJtaXRGcmFtZWRGb3JtRGF0YSgpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMueGhyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgc3RyaW5naWZpY2F0aW9uIGlzIHBvc3NpYmxlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBDb250ZW50LVR5cGUgaGVhZGVyIGJlY2F1c2Ugd2UncmUgYXNzdW1pbmcgdGhleSBkaWRuJ3Qgc2V0IGl0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGVpciBoZWFkZXJzIG9iamVjdCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19zZXRIZWFkZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRlbnRUeXBlIGRvZXMgbm90IGV4aXN0IHNvIHNpbXBseSBzZXQgZGVmaW5lZCBoZWFkZXJzIGFuZCBzZW5kIHJhdyBkYXRhIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc2V0SGVhZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZW5kKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY29udGVudFR5cGUgZXhpc3RzIHNldCBDb250ZW50LVR5cGUgaGVhZGVyIGJlY2F1c2Ugd2UncmUgYXNzdW1pbmcgdGhleSBkaWRuJ3Qgc2V0IGl0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlaXIgaGVhZGVycyBvYmplY3QgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19zZXRIZWFkZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIodGltZW91dCkgJiYgdGltZW91dCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgZmlyc3QgcG9zdHBvbmUgdG8gYXZvaWQgYWx3YXlzIHRpbWluZyBvdXQgd2hlbiBkZWJ1Z2dpbmcsIHRob3VnaCB0aGlzIGlzIG5vdCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBmb29scHJvb2YgbWV0aG9kLiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJUaW1lb3V0ID0gcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJUaW1lb3V0ID0gZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgQWpheEVycm9yKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6ICdSZXF1ZXN0IHRpbWVkIG91dCBpbiAnICsgdGltZW91dCArICdtcyBmb3IgJyArIG9wdGlvbnMudXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHhoci5zdGF0dXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpOyB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHI6IHhoclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuYWJvcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy54aHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHByb21pc2UuaW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyBpbW1lZGlhdGVseSByZWplY3RlZCBkdWUgdG8gYW4gZXJyb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2ludmFsaWRPcHRpb25zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWpheFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignQXR0ZW1wdGluZyBhIHJlcXVlc3Qgd2l0aG91dCBzcGVjaWZ5aW5nIGEgdXJsJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBBamF4RXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogJ0F0dGVtcHRpbmcgYSByZXF1ZXN0IHdpdGhvdXQgc3BlY2lmeWluZyBhIHVybCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHI6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgdGhlIHJlc3BvbnNlIGZyb20gdGhlIFhNTEh0dHBSZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlIFRoZSB1c2VyIGRlc2lnbmF0ZWQgcmVzcG9uc2VUeXBlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3VjY2VzcyBTaWduaWZpZXMgaWYgdGhlIHJlc3BvbnNlIHdhcyBhIHN1Y2Nlc3NcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fZm9ybWF0UmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2VUeXBlLCBzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeGhyID0gdGhpcy54aHIsIHN0YXR1cyA9IHhoci5zdGF0dXMsIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cnksIGNhdGNoIGluc3RlYWQgb2YgYm9vbGVhbiBzaG9ydCBjaXJjdWl0IGJlY2F1c2UgY2hyb21lIGRvZXNuJ3QgbGlrZSBjaGVja2luZyBcclxuICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlVGV4dCB3aGVuIHRoZSByZXNwb25zZVR5cGUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBlbXB0eSBvciAndGV4dCcgXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc3BvbnNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbGUgcHJvdG9jb2wgaXNzdWUgKipOZWVkcyB0byBiZSB0ZXN0ZWQgbW9yZSB0aG9yb3VnaGx5KiogXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2sgaWYgcmVzcG9uc2UgZW1wdHksIE5vdCBGb3VuZCBvdGhlcndpc2UgXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gc3VjY2VzcyA/IDIwMCA6IDQwNDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5jbGVhclRpbWVvdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBpc1N0cmluZyhyZXNwb25zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICAgICAgICAgICAgICBnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICB4aHI6IHhoclxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGhlYWRlcnMgZm9yIGFuIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX19zZXRIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLl9fb3B0aW9ucy5oZWFkZXJzLCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVycyB8fCB7fSksIHhociA9IHRoaXMueGhyLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwga2V5LCBpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXJpYWxpemVzIG11bHRpcGFydCBmb3JtIGRhdGEgaW4gYW4gWE1MSHR0cFJlcXVlc3QgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX19zZXJpYWxpemVGb3JtRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX29wdGlvbnMuZGF0YSwga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLCBrZXksIHZhbCwgZm9ybUJ1ZmZlciA9IFtdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZGF0YVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXkgdGhyb3cgYSBmYXRhbCBlcnJvciBidXQgdGhpcyBpcyBhbiBpbnZhbGlkIGNhc2UgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdJbnZhbGlkIGZvcm0gZW50cnkgd2l0aCBrZXkgXCInICsga2V5ICsgJ1wiIGFuZCB2YWx1ZSBcIicgKyB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3JtQnVmZmVyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybUJ1ZmZlci5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIEZvcm1EYXRhIHRvIGFkZCB0byB0aGUgWE1MSHR0cFJlcXVlc3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5wcm90b3R5cGUuX19hcHBlbmRGb3JtRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX29wdGlvbnMuZGF0YSwgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKSwga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLCBrZXksIHZhbDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRhdGFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ZpbGUodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgdmFsLCB2YWwubmFtZSB8fCB2YWwuZmlsZU5hbWUgfHwgJ2Jsb2InKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1heSB0aHJvdyBhIGZhdGFsIGVycm9yIGJ1dCB0aGlzIGlzIGFuIGludmFsaWQgY2FzZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdJbnZhbGlkIGZvcm0gZW50cnkgd2l0aCBrZXkgXCInICsga2V5ICsgJ1wiIGFuZCB2YWx1ZSBcIicgKyB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBzdWJtaXR0aW5nIG11bHRpcGFydCBmb3JtIGRhdGEgdXNpbmcgYW4gaWZyYW1lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9fc3VibWl0RnJhbWVkRm9ybURhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9fb3B0aW9ucywgZGF0YSA9IG9wdGlvbnMuZGF0YSwgdXJsID0gb3B0aW9ucy51cmwsIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCAkYm9keSA9IF9kb2N1bWVudC5ib2R5LCBQcm9taXNlID0gYWNxdWlyZShfX1Byb21pc2UpLCBmb3JtID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKSwgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpLCBpZnJhbWVOYW1lID0gdW5pcXVlSWQoJ2lmcmFtZV90YXJnZXQnKSwga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLCBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZnJhbWUubmFtZSA9IGZvcm0udGFyZ2V0ID0gaWZyYW1lTmFtZTtcclxuICAgICAgICAgICAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDpmYWxzZTsnO1xyXG4gICAgICAgICAgICAgICAgZm9ybS5lbmN0eXBlID0gZm9ybS5lbmNvZGluZyA9ICdtdWx0aXBhcnQvZm9ybS1kYXRhJztcclxuICAgICAgICAgICAgICAgIGZvcm0uYWN0aW9uID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XHJcbiAgICAgICAgICAgICAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtLmluc2VydEJlZm9yZSh0aGlzLl9fY3JlYXRlSW5wdXQoa2V5LCBkYXRhW2tleV0pLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMueGhyLmFib3J0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGJvZHkucmVtb3ZlQ2hpbGQoZm9ybSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICRib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkYm9keS5yZW1vdmVDaGlsZChmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogY29udGVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnJzsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMueGhyID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAkYm9keS5pbnNlcnRCZWZvcmUoZm9ybSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgJGJvZHkuaW5zZXJ0QmVmb3JlKGlmcmFtZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBpbnB1dCBmb3IgZm9ybSBkYXRhIHN1Ym1pc3Npb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cFJlcXVlc3QucHJvdG90eXBlLl9fY3JlYXRlSW5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgaW5wdXQgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgIGlucHV0LnR5cGUgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIGlucHV0Lm5hbWUgPSBrZXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHZhbCBpcyBhbiBwc2V1ZG8gRmlsZSBcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWwuc2xpY2UpICYmICEoaXNVbmRlZmluZWQodmFsLm5hbWUpIHx8IGlzVW5kZWZpbmVkKHZhbC5wYXRoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbGVMaXN0ID0gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJmaWxlXCJdW25hbWU9XCInICsga2V5ICsgJ1wiXScpLCBsZW5ndGhfNCA9IGZpbGVMaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gaW5wdXRzIGZvdW5kLCBzdHJpbmdpZnkgdGhlIGRhdGEgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfNCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ0NvdWxkIG5vdCBmaW5kIGlucHV0W3R5cGU9XCJmaWxlXCJdIHdpdGggW25hbWU9XCInICsga2V5ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXCJdLiBTdHJpbmdpZnlpbmcgZGF0YSBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxlbmd0aF80ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGZpbGVMaXN0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCBub2RlcyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IGlucHV0LmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNsb25lLCBpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByYXJlIGNhc2UgYnV0IG1heSBoYXZlIG11bHRpcGxlIGZvcm1zIHdpdGggZmlsZSBpbnB1dHMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGhhdmUgdGhlIHNhbWUgbmFtZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlSW5wdXQgPSB2b2lkIDAsIHBhdGggPSB2YWwucGF0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGhfNC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVJbnB1dCA9IGZpbGVMaXN0W2xlbmd0aF80XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZUlucHV0LnZhbHVlID09PSBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0ID0gZmlsZUlucHV0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2FwIG5vZGVzIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5wdXRDbG9uZSA9IGlucHV0LmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5wdXRDbG9uZSwgaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBub3QgZmluZCB0aGUgcmlnaHQgZmlsZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfNCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnQ291bGQgbm90IGZpbmQgaW5wdXRbdHlwZT1cImZpbGVcIl0gd2l0aCBbbmFtZT1cIicgKyBrZXkgKyAnXCJdIGFuZCBbdmFsdWU9XCInICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsLnBhdGggKyAnXCJdLiBTdHJpbmdpZnlpbmcgZGF0YSBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF5IHRocm93IGEgZmF0YWwgZXJyb3IgYnV0IHRoaXMgaXMgYW4gaW52YWxpZCBjYXNlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnSW52YWxpZCBmb3JtIGVudHJ5IHdpdGgga2V5IFwiJyArIGtleSArICdcIiBhbmQgdmFsdWUgXCInICsgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LnZhbHVlID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBIdHRwUmVxdWVzdC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2Jyb3dzZXI6IF9fQnJvd3NlcixcclxuICAgICAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgX2NvbmZpZzogX19IdHRwQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgX2xvZzogX19Mb2dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEh0dHBSZXF1ZXN0O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgYXN5bmMuSHR0cFJlcXVlc3QgPSBIdHRwUmVxdWVzdDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIHRoYXQgZm9ybXMgYW4gRXJyb3Igb2JqZWN0IHdpdGggYW4gSUFqYXhSZXNwb25zZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQWpheEVycm9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYW4gQWpheEVycm9yLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSUFqYXhSZXNwb25zZX0gcmVzcG9uc2UgVGhlIElBamF4UmVzcG9uc2Ugb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gQWpheEVycm9yKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBFcnJvciAoJ0FqYXhFcnJvcicpXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICdBamF4RXJyb3InO1xyXG4gICAgICAgICAgICAgICAgRXJyb3IuYXBwbHkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5tZXNzYWdlID0gcmVzcG9uc2UucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2UuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy54aHIgPSByZXNwb25zZS54aHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE91dHB1dHMgYSBmb3JtYXR0ZWQgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIEFqYXhFcnJvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEFqYXhFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB0aGlzLnJlc3BvbnNlLCByZXNwb25zZVRleHQgPSByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChyZXNwb25zZSkgJiYgIXJlc3BvbnNlLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1czogJyArIHRoaXMuc3RhdHVzICsgJyBhbmQgcmVzcG9uc2U6ICcgKyByZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBBamF4RXJyb3I7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBhc3luYy5BamF4RXJyb3IgPSBBamF4RXJyb3I7XHJcbiAgICAgICAgLy8gaGF2ZSB0byBieXBhc3MgVFMgZmxhZ3MgaW4gb3JkZXIgdG8gcHJvcGVybHkgZXh0ZW5kIEVycm9yIFxyXG4gICAgICAgIEFqYXhFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzY3JpYmVzIGEgdHlwZSBvZiBQcm9taXNlIHRoYXQgZnVsZmlsbHMgd2l0aCBhbiBJQWpheFJlc3BvbnNlXHJcbiAgICAgICAgICogYW5kIGNhbiBiZSBvcHRpb25hbGx5IGNhbmNlbGxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQWpheFByb21pc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQWpheFByb21pc2UsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEFqYXhQcm9taXNlKHJlc29sdmVGdW5jdGlvbiwgcHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgcmVzb2x2ZUZ1bmN0aW9uKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIFdpbmRvdyBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvdyA9IGFjcXVpcmUoX19XaW5kb3cpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocHJvbWlzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faHR0cCA9IHByb21pc2UuX19odHRwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG1ldGhvZCB0byBpbml0aWFsaXplIHRoaXMgQWpheFByb21pc2UsIHBhc3NpbmcgaXQgdGhlXHJcbiAgICAgICAgICAgICAqIGFzc29jaWF0ZWQgSUh0dHBSZXF1ZXN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSHR0cFJlcXVlc3R9IGh0dHAgVGhlIGh0dHAgcmVxdWVzdCBmb3IgdGhpcyBwcm9taXNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQWpheFByb21pc2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoaHR0cCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGh0dHApICYmIGlzTnVsbCh0aGlzLl9faHR0cCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faHR0cCA9IGh0dHA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG1ldGhvZCB0byBjYW5jZWwgdGhlIEFKQVggY2FsbCBhc3NvY2lhdGVkIHdpdGggdGhpcyBBamF4UHJvbWlzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEFqYXhQcm9taXNlLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaHR0cCA9IHRoaXMuX19odHRwLCB4aHIgPSBodHRwLnhociwganNvbnBDYWxsYmFjayA9IGh0dHAuanNvbnBDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGh0dHAuY2xlYXJUaW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGh0dHAuY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh4aHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaHR0cC54aHIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbChqc29ucENhbGxiYWNrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvd1tqc29ucENhbGxiYWNrXSA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fc3Vic2NyaWJlcnMgPSBbXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQWpheFByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEFqYXhQcm9taXNlLnByb3RvdHlwZS5jYXRjaCA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jYXRjaC5jYWxsKHRoaXMsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQWpheFByb21pc2U7XHJcbiAgICAgICAgfShQcm9taXNlKSk7XHJcbiAgICAgICAgYXN5bmMuQWpheFByb21pc2UgPSBBamF4UHJvbWlzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5zdGFudGlhdGVkIGNsYXNzIG9mIHRoZSBpbmplY3RhYmxlIGZvciBtYWtpbmdcclxuICAgICAgICAgKiBBSkFYIHJlcXVlc3RzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBIdHRwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSHR0cCgpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHJvdmlkZXMgdmFsdWUgbWFwcGluZ3MgZm9yIFhNTEh0dHBSZXF1ZXN0UmVzcG9uc2VUeXBlc1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICBBUlJBWUJVRkZFUjogJ2FycmF5YnVmZmVyJyxcclxuICAgICAgICAgICAgICAgICAgICBCTE9COiAnYmxvYicsXHJcbiAgICAgICAgICAgICAgICAgICAgRE9DVU1FTlQ6ICdkb2N1bWVudCcsXHJcbiAgICAgICAgICAgICAgICAgICAgSlNPTjogJ2pzb24nLFxyXG4gICAgICAgICAgICAgICAgICAgIFRFWFQ6ICd0ZXh0J1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHJvdmlkZXMgQ29udGVudC1UeXBlIG1hcHBpbmdzIGZvciBIdHRwIFBPU1QgcmVxdWVzdHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFR5cGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRU5DT0RFRF9GT1JNOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnLFxyXG4gICAgICAgICAgICAgICAgICAgIEpTT046ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnLFxyXG4gICAgICAgICAgICAgICAgICAgIE1VTFRJUEFSVF9GT1JNOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXHJcbiAgICAgICAgICAgICAgICAgICAgT0NURVRfU1RSRUFNOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2NoYXJzZXQ9dXRmLTgnLFxyXG4gICAgICAgICAgICAgICAgICAgIFhNTDogJ2FwcGxpY2F0aW9uL3htbDtjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICAgICAgICAgICAgICBQTEFJTl9URVhUOiAndGV4dC9wbGFpbicsXHJcbiAgICAgICAgICAgICAgICAgICAgSFRNTDogJ3RleHQvaHRtbCdcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgd3JhcHBlciBtZXRob2QgZm9yIHRoZSBIdHRwIGNsYXNzIHRoYXQgY3JlYXRlcyBhbmQgZXhlY3V0ZXMgYSBuZXcgSHR0cCB3aXRoXHJcbiAgICAgICAgICAgICAqIHRoZSBzcGVjaWZpZWQgSUh0dHBDb25maWcuIFRoaXMgZnVuY3Rpb24gd2lsbCBjaGVjayBpZlxyXG4gICAgICAgICAgICAgKiBYTUxIdHRwUmVxdWVzdCBsZXZlbCAyIGlzIHByZXNlbnQsIGFuZCB3aWxsIGRlZmF1bHQgdG8gSlNPTlAgaWYgaXQgaXNuJ3QgYW5kXHJcbiAgICAgICAgICAgICAqIHRoZSByZXF1ZXN0IGlzIGNyb3NzLWRvbWFpbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLklIdHRwQ29uZmlnfSBvcHRpb25zIFRoZSBJSHR0cENvbmZpZyBmb3IgZWl0aGVyIHRoZSBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgICAgICAgKiBvciB0aGUgSlNPTlAgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwLnByb3RvdHlwZS5hamF4ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gYWNxdWlyZShfX0h0dHBSZXF1ZXN0SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5pbml0aWFsaXplKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBkaXJlY3QgbWV0aG9kIHRvIGZvcmNlIGEgY3Jvc3MtZG9tYWluIEpTT05QIHJlcXVlc3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5hc3luYy5JSnNvbnBDb25maWd9IG9wdGlvbnMgVGhlIElKc29ucENvbmZpZ1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgSHR0cC5wcm90b3R5cGUuanNvbnAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBhY3F1aXJlKF9fSHR0cFJlcXVlc3RJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmluaXRpYWxpemUob3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5leGVjdXRlSnNvbnAoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ha2VzIGFuIGFqYXggcmVxdWVzdCwgc3BlY2lmeWluZyByZXNwb25zZVR5cGU6ICdqc29uJy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmFzeW5jLklIdHRwQ29uZmlnfSBvcHRpb25zIFRoZSBJSHR0cENvbmZpZ1xyXG4gICAgICAgICAgICAgKiBmb3IgZWl0aGVyIHRoZSBYTUxIdHRwUmVxdWVzdCBvciB0aGUgSlNPTlAgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwLnByb3RvdHlwZS5qc29uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gYWNxdWlyZShfX0h0dHBSZXF1ZXN0SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5pbml0aWFsaXplKF9leHRlbmQoZmFsc2UsIGZhbHNlLCB7fSwgb3B0aW9ucywgeyByZXNwb25zZVR5cGU6ICdqc29uJyB9KSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5leGVjdXRlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWZhdWx0IEh0dHAgY29uZmlnXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBIdHRwLmNvbmZpZyA9IHtcclxuICAgICAgICAgICAgICAgIHVybDogbnVsbCxcclxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICcnLFxyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtczogW10sXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcclxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAganNvbnBJZGVudGlmaWVyOiAnY2FsbGJhY2snLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBIdHRwO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgYXN5bmMuSHR0cCA9IEh0dHA7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0h0dHAsIEh0dHApO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19IdHRwUmVxdWVzdEluc3RhbmNlLCBIdHRwUmVxdWVzdCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUh0dHBDb25maWcoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBIdHRwLmNvbmZpZztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXN5bmMuSUh0dHBDb25maWcgPSBJSHR0cENvbmZpZztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fSHR0cENvbmZpZywgSUh0dHBDb25maWcpO1xyXG4gICAgfSkoYXN5bmMgPSBwbGF0XzEuYXN5bmMgfHwgKHBsYXRfMS5hc3luYyA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBzdG9yYWdlIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgc3RvcmFnZTtcclxuICAgIChmdW5jdGlvbiAoc3RvcmFnZV8xKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGtleWVkIGNvbGxlY3Rpb24gb2YgYWxsIGNyZWF0ZWQgQ2FjaGVzIGluIHRoZVxyXG4gICAgICAgICAqIElDYWNoZUZhY3RvcnkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGNhY2hlcyA9IHt9LCBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIGZvciBhbGwgdGhlIGl0ZW1zIHN0b3JlZCBpbiBlYWNoIENhY2hlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGludGVybmFsQ2FjaGVzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBDYWNoZSBjbGFzcywgZm9yIHVzZSB3aXRoIHRoZSBJQ2FjaGVGYWN0b3J5IGluamVjdGFibGUuXHJcbiAgICAgICAgICogVXNlZCBmb3Igc3RvcmluZyBvYmplY3RzLiBUYWtlcyBpbiBhIGdlbmVyaWMgdHlwZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlIG9mIG9iamVjdHMgaXQgY29udGFpbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIENhY2hlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBDYWNoZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCB0byB1c2UgdG8gcmV0cmlldmUgdGhlIGNhY2hlIGZyb20gdGhlIElDYWNoZUZhY3RvcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5zdG9yYWdlLklDYWNoZU9wdGlvbnN9IG9wdGlvbnMgVGhlIElDYWNoZU9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIHRoZSBjYWNoZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENhY2hlKHVpZCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3VpZCA9IHVpZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuX19zaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbENhY2hlc1t1aWRdID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ldGhvZCBmb3IgY3JlYXRpbmcgYSBuZXcgY2FjaGUgb2JqZWN0LiBUYWtlcyBhIGdlbmVyaWMgdHlwZSB0byBkZW5vdGUgdGhlXHJcbiAgICAgICAgICAgICAqIHR5cGUgb2Ygb2JqZWN0cyBzdG9yZWQgaW4gdGhlIG5ldyBjYWNoZS4gIElmIGEgY2FjaGUgd2l0aCB0aGUgc2FtZSBJRCBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgICAgICAgKiBpbiB0aGUgSUNhY2hlRmFjdG9yeSwgYSBuZXcgY2FjaGUgd2lsbCBub3QgYmUgY3JlYXRlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgSUQgb2YgdGhlIG5ldyBDYWNoZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnN0b3JhZ2UuSUNhY2hlT3B0aW9uc30gb3B0aW9ucyBJQ2FjaGVPcHRpb25zXHJcbiAgICAgICAgICAgICAqIGZvciBjdXN0b21pemluZyB0aGUgQ2FjaGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDYWNoZS5jcmVhdGUgPSBmdW5jdGlvbiAodWlkLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbdWlkXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY2FjaGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbdWlkXSA9IG5ldyBDYWNoZSh1aWQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBhIGNhY2hlIG91dCBvZiB0aGUgSUNhY2hlRmFjdG9yeSBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIGlkZW50aWZpZXIgdXNlZCB0byBzZWFyY2ggZm9yIHRoZSBjYWNoZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENhY2hlLmZldGNoID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlc1t1aWRdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xlYXJzIHRoZSBJQ2FjaGVGYWN0b3J5IGFuZCBhbGwgb2YgaXRzIGNhY2hlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENhY2hlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjYWNoZXMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZXNba2V5c1tpXV0uY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhY2hlcyA9IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0cmlldmVzIHRoZSBJQ2FjaGVJbmZvIGFib3V0IHRoaXMgY2FjaGVcclxuICAgICAgICAgICAgICogKGkuZS4gSUQsIHNpemUsIG9wdGlvbnMpXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDYWNoZS5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWlkOiB0aGlzLl9fdWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemU6IHRoaXMuX19zaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHRoaXMuX19vcHRpb25zXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWV0aG9kIGZvciBpbnNlcnRpbmcgYW4gb2JqZWN0IGludG8gYW4gQ2FjaGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byB1c2UgZm9yIHN0b3JhZ2UvcmV0cmlldmFsIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIHZhbHVlIHRvIHN0b3JlIHdpdGggdGhlIGFzc29jaWF0ZWQga2V5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gaW50ZXJuYWxDYWNoZXNbdGhpcy5fX3VpZF1ba2V5XTtcclxuICAgICAgICAgICAgICAgIGludGVybmFsQ2FjaGVzW3RoaXMuX191aWRdW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3NpemUrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fX29wdGlvbnMudGltZW91dDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcih0aW1lb3V0KSAmJiB0aW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVyKHRoaXMucmVtb3ZlLCB0aW1lb3V0LCBba2V5XSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXRob2QgZm9yIHJldHJpZXZpbmcgYW4gb2JqZWN0IGZyb20gYW4gQ2FjaGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yIGluIGFuIENhY2hlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJuYWxDYWNoZXNbdGhpcy5fX3VpZF1ba2V5XTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ldGhvZCBmb3IgcmVtb3ZpbmcgYW4gb2JqZWN0IGZyb20gYW4gQ2FjaGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byByZW1vdmUgZnJvbSB0aGUgQ2FjaGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDYWNoZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoaW50ZXJuYWxDYWNoZXNbdGhpcy5fX3VpZF0sIGtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fc2l6ZS0tO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWV0aG9kIGZvciBjbGVhcmluZyBhbiBDYWNoZSwgcmVtb3ZpbmcgYWxsIG9mIGl0cyBrZXlzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxDYWNoZXNbdGhpcy5fX3VpZF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19zaXplID0gMDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1ldGhvZCBmb3IgcmVtb3ZpbmcgYW4gSUNhY2hlIGZyb20gdGhlIElDYWNoZUZhY3RvcnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDYWNoZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGNhY2hlcywgdGhpcy5fX3VpZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBDYWNoZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHN0b3JhZ2VfMS5DYWNoZSA9IENhY2hlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElDYWNoZUZhY3RvcnkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcmFnZV8xLklDYWNoZUZhY3RvcnkgPSBJQ2FjaGVGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19DYWNoZUZhY3RvcnksIElDYWNoZUZhY3RvcnksIG51bGwsIF9fRkFDVE9SWSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc3RvcmFnZV8xLm1hbmFnZXJDYWNoZSA9IENhY2hlLmNyZWF0ZSgnX19tYW5hZ2VyQ2FjaGUnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJTWFuYWdlckNhY2hlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZV8xLm1hbmFnZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RvcmFnZV8xLklNYW5hZ2VyQ2FjaGUgPSBJTWFuYWdlckNhY2hlO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19NYW5hZ2VyQ2FjaGUsIElNYW5hZ2VyQ2FjaGUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgZm9yIGNhY2hpbmcgY29tcGlsZWQgbm9kZXMuIFRoaXMgY2xhc3Mgd2lsbFxyXG4gICAgICAgICAqIGNsb25lIGEgdGVtcGxhdGUgd2hlbiB5b3UgcHV0IGl0IGluIHRoZSBjYWNoZS4gSXQgd2lsbFxyXG4gICAgICAgICAqIGFsc28gY2xvbmUgdGhlIHRlbXBsYXRlIHdoZW4geW91IHJldHJpZXZlIGl0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUZW1wbGF0ZUNhY2hlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRlbXBsYXRlQ2FjaGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgVGVtcGxhdGVDYWNoZS4gQ3JlYXRlcyBhIG5ldyBDYWNoZVxyXG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBJRCBcIl9fdGVtcGxhdGVDYWNoZVwiLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gVGVtcGxhdGVDYWNoZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdfX3RlbXBsYXRlQ2FjaGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUZW1wbGF0ZUNhY2hlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIFByb21pc2UgPSB0aGlzLl9Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wdXQuY2FsbCh0aGlzLCBrZXksIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRGcmFnbWVudCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQodmFsdWUuY2xvbmVOb2RlKHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZyYWdtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpIHx8IGlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlcmlhbGl6ZUh0bWwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNZXRob2QgZm9yIHJldHJpZXZpbmcgYSBOb2RlIGZyb20gdGhpcyBjYWNoZS4gVGhlIERvY3VtZW50RnJhZ21lbnQgdGhhdCByZXNvbHZlcyBmcm9tIHRoZSByZXR1cm5lZFxyXG4gICAgICAgICAgICAgKiBQcm9taXNlIHdpbGwgYmUgY2xvbmVkIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY2FjaGVkIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvciBpbiB0aGlzIGNhY2hlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDYWNoZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IF9zdXBlci5wcm90b3R5cGUucmVhZC5jYWxsKHRoaXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVqZWN0KG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wdXQoa2V5LCBub2RlKTtcclxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignRXJyb3IgcmV0cmlldmluZyB0ZW1wbGF0ZSwgJyArIGtleSArICcsIGZyb20gcHJvbWlzZS4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNhY2hlLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgX2xvZzogX19Mb2dcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlQ2FjaGU7XHJcbiAgICAgICAgfShDYWNoZSkpO1xyXG4gICAgICAgIHN0b3JhZ2VfMS5UZW1wbGF0ZUNhY2hlID0gVGVtcGxhdGVDYWNoZTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fVGVtcGxhdGVDYWNoZSwgVGVtcGxhdGVDYWNoZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBiYXNlIGNsYXNzIGZvciBzdG9yaW5nIGRhdGEgd2l0aCBhIGRlc2lnbmF0ZWQgc3RvcmFnZSB0eXBlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBCYXNlU3RvcmFnZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGEgQmFzZVN0b3JhZ2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBCYXNlU3RvcmFnZShzdG9yYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcmFnZSA9IHN0b3JhZ2U7XHJcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfSwgc3RvcmFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VTdG9yYWdlLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgaW4gc3RvcmFnZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbGVhcnMgc3RvcmFnZSwgZGVsZXRpbmcgYWxsIG9mIGl0cyBrZXlzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVN0b3JhZ2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcmFnZS5jbGVhcigpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyBhbiBpdGVtIG91dCBvZiBzdG9yYWdlIHdpdGggdGhlIGFzc2lnbmVkIGtleS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBpdGVtIHRvIHJldHJpZXZlIGZyb20gc3RvcmFnZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJhc2VTdG9yYWdlLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuZ2V0SXRlbShrZXkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWxsb3dzIGZvciBpdGVyYXRpbmcgb3ZlciBzdG9yYWdlIGtleXMgd2l0aCBhbiBpbmRleC4gV2hlblxyXG4gICAgICAgICAgICAgKiBjYWxsZWQgd2l0aCBhbiBpbmRleCwgaXQgd2lsbCByZXR1cm4gdGhlIGtleSBhdCB0aGF0IGluZGV4IGluXHJcbiAgICAgICAgICAgICAqIHN0b3JhZ2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdXNlZCB0byByZXRyaWV2ZSB0aGUgYXNzb2NpYXRlZCBrZXkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU3RvcmFnZS5wcm90b3R5cGUua2V5ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5rZXkoaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VhcmNoZXMgaW4gc3RvcmFnZSBmb3IgYW4gaXRlbSBhbmQgcmVtb3ZlcyBpdCBpZiBpdFxyXG4gICAgICAgICAgICAgKiBleGlzdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSBzdG9yYWdlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVN0b3JhZ2UucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgZGF0YSB0byBzdG9yYWdlIHdpdGggdGhlIGRlc2lnbmF0ZWQga2V5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gc3RvcmUgaW4gc3RvcmFnZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gc3RvcmUgaW4gc3RvcmFnZSB3aXRoIHRoZSBrZXkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU3RvcmFnZS5wcm90b3R5cGUuc2V0SXRlbSA9IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0SXRlbShrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpc1trZXldID0gdGhpcy5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBCYXNlU3RvcmFnZTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHN0b3JhZ2VfMS5CYXNlU3RvcmFnZSA9IEJhc2VTdG9yYWdlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgdXNlZCB0byB3cmFwIEhUTUw1IGxvY2FsU3RvcmFnZSBpbnRvIGFuIGluamVjdGFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIExvY2FsU3RvcmFnZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhMb2NhbFN0b3JhZ2UsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIExvY2FsU3RvcmFnZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGFjcXVpcmUoX19XaW5kb3cpLmxvY2FsU3RvcmFnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIExvY2FsU3RvcmFnZTtcclxuICAgICAgICB9KEJhc2VTdG9yYWdlKSk7XHJcbiAgICAgICAgc3RvcmFnZV8xLkxvY2FsU3RvcmFnZSA9IExvY2FsU3RvcmFnZTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTG9jYWxTdG9yYWdlLCBMb2NhbFN0b3JhZ2UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgZm9yIHdyYXBwaW5nIFNlc3Npb25TdG9yYWdlIGFzIGFuIGluamVjdGFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNlc3Npb25TdG9yYWdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFNlc3Npb25TdG9yYWdlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTZXNzaW9uU3RvcmFnZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGFjcXVpcmUoX19XaW5kb3cpLnNlc3Npb25TdG9yYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU2Vzc2lvblN0b3JhZ2U7XHJcbiAgICAgICAgfShCYXNlU3RvcmFnZSkpO1xyXG4gICAgICAgIHN0b3JhZ2VfMS5TZXNzaW9uU3RvcmFnZSA9IFNlc3Npb25TdG9yYWdlO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19TZXNzaW9uU3RvcmFnZSwgU2Vzc2lvblN0b3JhZ2UpO1xyXG4gICAgfSkoc3RvcmFnZSA9IHBsYXRfMS5zdG9yYWdlIHx8IChwbGF0XzEuc3RvcmFnZSA9IHt9KSk7XHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gY3JlYXRlIElUb2tlbkRldGFpbHMgZm9yIGV2ZXJ5IG9wZXJhdG9yLlxyXG4gICAgICovXHJcbiAgICB2YXIgT1BFUkFUT1JTID0ge1xyXG4gICAgICAgICd1Kyc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogNCwgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICthKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnKyc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogNiwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgKyBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAndS0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAtYShjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJy0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDYsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIC0gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyonOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDUsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpICogYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJy8nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDUsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIC8gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyUnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDUsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpICUgYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz8nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE1LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJzonOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE1LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz4nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDgsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpID4gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJzwnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDgsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIDwgYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyEnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhYShjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ34nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDQsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB+YShjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyYnOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDEwLCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSAmIGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICd8Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxMiwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgfCBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnPj4nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDcsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpID4+IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc8PCc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogNywgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgPDwgYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz4+Pic6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogNywgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgPj4+IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcmJic6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMTMsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpICYmIGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICd8fCc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMTQsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpIHx8IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc9PSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogOSwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOnRyaXBsZS1lcXVhbHMgKi9cclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSA9PSBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnPT09Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA5LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYShjb250ZXh0LCBhbGlhc2VzKSA9PT0gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJyE9Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiA5LCBhc3NvY2lhdGl2aXR5OiAnbHRyJyxcclxuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6dHJpcGxlLWVxdWFscyAqL1xyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpICE9IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICchPT0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDksIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpICE9PSBiKGNvbnRleHQsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnPj0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDgsIGFzc29jaWF0aXZpdHk6ICdsdHInLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhKGNvbnRleHQsIGFsaWFzZXMpID49IGIoY29udGV4dCwgYWxpYXNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICc8PSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogOCwgYXNzb2NpYXRpdml0eTogJ2x0cicsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEoY29udGV4dCwgYWxpYXNlcykgPD0gYihjb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJz0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE3LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZyk7XHJcbiAgICAgICAgICAgICAgICBfbG9nLmVycm9yKG5ldyBFcnJvcignQXNzaWdubWVudCBvcGVyYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcrKyc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMywgYXNzb2NpYXRpdml0eTogJycsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0Fzc2lnbm1lbnQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnLS0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDMsIGFzc29jaWF0aXZpdHk6ICcnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKTtcclxuICAgICAgICAgICAgICAgIF9sb2cuZXJyb3IobmV3IEVycm9yKCdBc3NpZ25tZW50IG9wZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJys9Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNywgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0Fzc2lnbm1lbnQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnLT0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE3LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZyk7XHJcbiAgICAgICAgICAgICAgICBfbG9nLmVycm9yKG5ldyBFcnJvcignQXNzaWdubWVudCBvcGVyYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgICcqPSc6IHtcclxuICAgICAgICAgICAgcHJlY2VkZW5jZTogMTcsIGFzc29jaWF0aXZpdHk6ICdydGwnLFxyXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGNvbnRleHQsIGFsaWFzZXMsIGEsIGIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9nID0gcGxhdC5hY3F1aXJlKF9fTG9nKTtcclxuICAgICAgICAgICAgICAgIF9sb2cuZXJyb3IobmV3IEVycm9yKCdBc3NpZ25tZW50IG9wZXJhdG9ycyBhcmUgbm90IHN1cHBvcnRlZCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJy89Jzoge1xyXG4gICAgICAgICAgICBwcmVjZWRlbmNlOiAxNywgYXNzb2NpYXRpdml0eTogJ3J0bCcsXHJcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoY29udGV4dCwgYWxpYXNlcywgYSwgYikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb2cgPSBwbGF0LmFjcXVpcmUoX19Mb2cpO1xyXG4gICAgICAgICAgICAgICAgX2xvZy5lcnJvcihuZXcgRXJyb3IoJ0Fzc2lnbm1lbnQgb3BlcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnJT0nOiB7XHJcbiAgICAgICAgICAgIHByZWNlZGVuY2U6IDE3LCBhc3NvY2lhdGl2aXR5OiAncnRsJyxcclxuICAgICAgICAgICAgZm46IGZ1bmN0aW9uIChjb250ZXh0LCBhbGlhc2VzLCBhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvZyA9IHBsYXQuYWNxdWlyZShfX0xvZyk7XHJcbiAgICAgICAgICAgICAgICBfbG9nLmVycm9yKG5ldyBFcnJvcignQXNzaWdubWVudCBvcGVyYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBvYmplY3QgdXNlZCB0byBjcmVhdGUgSVRva2VuRGV0YWlscyBmb3IgZXZlcnkgYWNjZXNzb3IuXHJcbiAgICAgKi9cclxuICAgIHZhciBBQ0NFU1NPUlMgPSB7XHJcbiAgICAgICAgJygpJzogeyBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICdbXSc6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnLic6IHsgcHJlY2VkZW5jZTogMiwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAne30nOiB7IHByZWNlZGVuY2U6IDEsIGFzc29jaWF0aXZpdHk6IG51bGwsIGZuOiBudWxsIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCB1c2VkIHRvIGNyZWF0ZSBJVG9rZW5EZXRhaWxzIGZvciBldmVyeSBkZWxpbWl0ZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciBERUxJTUlURVJTID0ge1xyXG4gICAgICAgICd7JzogeyBwcmVjZWRlbmNlOiAxLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICd9JzogeyBwcmVjZWRlbmNlOiAxLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICdbJzogeyBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICddJzogeyBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICcoJzogeyBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICcpJzogeyBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICcuJzogeyBwcmVjZWRlbmNlOiAyLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICcsJzogeyBwcmVjZWRlbmNlOiAxOCwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfSxcclxuICAgICAgICAnXFwnJzogeyBwcmVjZWRlbmNlOiAwLCBhc3NvY2lhdGl2aXR5OiBudWxsLCBmbjogbnVsbCB9LFxyXG4gICAgICAgICdcIic6IHsgcHJlY2VkZW5jZTogMCwgYXNzb2NpYXRpdml0eTogbnVsbCwgZm46IG51bGwgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gb2JqZWN0IHVzZWQgdG8gZ2V0IGxpdGVyYWwgdmFsdWVzIGZyb20gc3RyaW5nIHZhbHVlcyBvZiBmYWxzZSwgdHJ1ZSwgYW5kIHVuZGVmaW5lZFxyXG4gICAgICovXHJcbiAgICB2YXIgS0VZV09SRFMgPSB7XHJcbiAgICAgICAgZmFsc2U6IGZhbHNlLFxyXG4gICAgICAgIHRydWU6IHRydWUsXHJcbiAgICAgICAgbnVsbDogbnVsbCxcclxuICAgICAgICB1bmRlZmluZWQ6ICd1bmRlZmluZWQnXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgaW4gdGhlIERFTElNSVRFUlMgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBzdHJpbmcgdG8gaW5kZXggaW50byB0aGUgREVMSU1JVEVSUyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNEZWxpbWl0ZXIoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICFpc051bGwoREVMSU1JVEVSU1trZXldKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGluIHRoZSBBQ0NFU1NPUlMgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBzdHJpbmcgdG8gaW5kZXggaW50byB0aGUgQUNDRVNTT1JTIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0FjY2Vzc29yKGtleSkge1xyXG4gICAgICAgIHJldHVybiAhaXNOdWxsKEFDQ0VTU09SU1trZXldKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGluIHRoZSBPUEVSQVRPUlMgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBzdHJpbmcgdG8gaW5kZXggaW50byB0aGUgT1BFUkFUT1JTIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc09wZXJhdG9yKGtleSkge1xyXG4gICAgICAgIHJldHVybiAhaXNOdWxsKE9QRVJBVE9SU1trZXldKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGluIHRoZSBLRVlXT1JEUyBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHN0cmluZyB0byBpbmRleCBpbnRvIHRoZSBLRVlXT1JEUyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNLZXl3b3JkKGtleSkge1xyXG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoS0VZV09SRFNba2V5XSk7XHJcbiAgICB9XHJcbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBhbGwgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIG9ic2VydmFibGUgY29tcG9uZW50cyBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIG9ic2VydmFibGU7XHJcbiAgICAoZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYXJyYXkgbWV0aG9kcyB0byBiZSBvdmVyd3JpdHRlbiBpZiBpdCBpcyB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgYXJyYXlNZXRob2RzID0gWydwdXNoJywgJ3BvcCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIGZvciBtYW5hZ2luZyBib3RoIGNvbnRleHQgaW5oZXJpdGFuY2UgYW5kIG9ic2VydmFibGUgcHJvcGVydGllcyBvbiBjb250cm9scyBhbmRcclxuICAgICAgICAgKiBmYWNpbGl0YXRpbmcgaW4gZGF0YS1iaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDb250ZXh0TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbnRleHRNYW5hZ2VyKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIENvbXBhdCBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wYXQgPSBhY3F1aXJlKF9fQ29tcGF0KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IGZvciBxdWlja2x5IGFjY2Vzc2luZyBjYWxsYmFja3MgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lkZW50aWZpZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3IgcXVpY2tseSBhY2Nlc3NpbmcgY2hpbGQgY29udGV4dCBhc3NvY2lhdGlvbnMgKGhlbHBzIHdpdGhcclxuICAgICAgICAgICAgICAgICAqIG5vdGlmeWluZyBjaGlsZCBwcm9wZXJ0aWVzKS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lkZW50aWZpZXJIYXNoID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3Igc3RvcmluZyBsaXN0ZW5lcnMgZm9yIEFycmF5IGxlbmd0aCBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGVuZ3RoTGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3IgcXVpY2tseSBhY2Nlc3NpbmcgcHJldmlvdXNseSBhY2Nlc3NlZCBvciBvYnNlcnZlZCBvYmplY3RzIGFuZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29udGV4dE9iamVjdHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHByb3BlcnR5IGN1cnJlbnRseSBiZWluZyBtb2RpZmllZCBpcyBkdWUgdG8gYW4gb2JzZXJ2ZWQgYXJyYXkgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19pc0FycmF5RnVuY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgQ29udGV4dE1hbmFnZXIgYXNzb2NpYXRlZCB0byB0aGUgZ2l2ZW4gY29udHJvbC4gSWYgbm9cclxuICAgICAgICAgICAgICogQ29udGV4dE1hbmFnZXIgZXhpc3RzLCBvbmUgaXMgY3JlYXRlZCBmb3IgdGhhdCBjb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCBvbiB3aGljaCB0byBsb2NhdGUgdGhlIENvbnRleHRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlciA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dE1hbmFnZXIsIG1hbmFnZXJzID0gQ29udGV4dE1hbmFnZXIuX19tYW5hZ2VycywgdWlkID0gY29udHJvbC51aWQsIG1hbmFnZXIgPSBtYW5hZ2Vyc1t1aWRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFuYWdlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWFuYWdlciA9IG1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRNYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dE1hbmFnZXIgPSBtYW5hZ2Vyc1t1aWRdID0gbmV3IENvbnRleHRNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0TWFuYWdlci5jb250ZXh0ID0gY29udHJvbDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHVpZCA9IGNvbnRyb2wudWlkLCBjb250cm9scyA9IENvbnRleHRNYW5hZ2VyLl9fY29udHJvbHMsIGlkZW50aWZpZXJzID0gY29udHJvbHNbdWlkXSB8fCB7fSwgbWFuYWdlcnMgPSBDb250ZXh0TWFuYWdlci5fX21hbmFnZXJzLCBtYW5hZ2VyID0gbWFuYWdlcnNbdWlkXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKG1hbmFnZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkobWFuYWdlcnMsIHVpZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGlkZW50aWZpZXJzKSwgbGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGlkZW50aWZpZXJzW2tleXMuc2hpZnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zaGlmdCgpKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoY29udHJvbHMsIHVpZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjb250cm9sLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIudW5PYnNlcnZlKGNvbnRyb2wuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGVmaW5lUHJvcGVydHkoY29udHJvbCwgX19DT05URVhULCBjb250cm9sLmNvbnRleHQsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGZvciBhbiBBcnJheSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB1aWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNvbHV0ZUlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdXNlZCB0byBsb2NhdGUgdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSB1aWQgdXNlZCB0byBzZWFyY2ggZm9yIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnJlbW92ZUFycmF5TGlzdGVuZXJzID0gZnVuY3Rpb24gKGFic29sdXRlSWRlbnRpZmllciwgdWlkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gQ29udGV4dE1hbmFnZXIuYXJyYXlDaGFuZ2VMaXN0ZW5lcnNbYWJzb2x1dGVJZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShsaXN0ZW5lcnMsIHVpZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTYWZlbHkgcmV0cmlldmVzIHRoZSBsb2NhbCBjb250ZXh0IGdpdmVuIGEgcm9vdCBjb250ZXh0IGFuZCBhbiBBcnJheSBvZlxyXG4gICAgICAgICAgICAgKiBwcm9wZXJ0eSBzdHJpbmdzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcm9vdENvbnRleHQgVGhlIHJvb3Qgb2JqZWN0IGluIHdoaWNoIHRvIGZpbmQgYSBsb2NhbCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNwbGl0IFRoZSBzdHJpbmcgYXJyYXkgY29udGFpbmluZyBwcm9wZXJ0aWVzIHVzZWQgdG8gaW5kZXggaW50b1xyXG4gICAgICAgICAgICAgKiB0aGUgcm9vdENvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKHJvb3RDb250ZXh0LCBzcGxpdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyb290Q29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdENvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzcGxpdCA9IHNwbGl0LnNsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByb290Q29udGV4dCA9IHJvb3RDb250ZXh0W3NwbGl0LnNoaWZ0KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwocm9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb290Q29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdENvbnRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWZpbmVzIGFuIG9iamVjdCBwcm9wZXJ0eSB3aXRoIHRoZSBhc3NvY2lhdGVkIHZhbHVlLiBVc2VmdWwgZm9yIHVub2JzZXJ2aW5nIG9iamVjdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCBvbiB3aGljaCB0byBkZWZpbmUgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBrZXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdXNlZCB0byBkZWZpbmUgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVudW1lcmFibGU/IFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgZW51bWVyYWJsZSAoYWJsZSB0byBiZSBpdGVyYXRlZFxyXG4gICAgICAgICAgICAgKiBvdmVyIGluIGEgbG9vcClcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWd1cmFibGU/IFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSBpcyBhYmxlIHRvIGJlIHJlY29uZmlndXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB3cml0YWJsZT8gV2hldGhlciBvciBub3QgYXNzaWdubWVudCBvcGVyYXRvcnMgd29yayBvbiB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5kZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUsIGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUpIHtcclxuICAgICAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUsIGVudW1lcmFibGUsIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyBhbiBvYmplY3QgcHJvcGVydHkgd2l0aCB0aGUgYXNzb2NpYXRlZCB2YWx1ZS4gVXNlZnVsIGZvciB1bm9ic2VydmluZyBvYmplY3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcHJvcGVydHkga2V5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHVzZWQgdG8gZGVmaW5lIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBlbnVtZXJhYmxlPyBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGVudW1lcmFibGUgKGFibGUgdG8gYmUgaXRlcmF0ZWRcclxuICAgICAgICAgICAgICogb3ZlciBpbiBhIGxvb3ApXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZmlndXJhYmxlPyBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcGVydHkgaXMgYWJsZSB0byBiZSByZWNvbmZpZ3VyZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5kZWZpbmVHZXR0ZXIgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGUpIHtcclxuICAgICAgICAgICAgICAgIF9kZWZpbmVHZXR0ZXIob2JqLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlLCBjb25maWd1cmFibGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHVzaGVzIHRoZSBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYW4gb2JzZXJ2ZWQgcHJvcGVydHkgdXBvbiBhZGRpbmcgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmVyIFRoZSBpZGVudGlmaWVyIGZvciB3aGljaCB0aGUgcmVtb3ZlIGxpc3RlbmVyIGlzIGJlaW5nIHB1c2hlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgdW5pcXVlIElEIG9mIHRoZSBjb250cm9sIG9ic2VydmluZyB0aGUgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklSZW1vdmVMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIGZvciByZW1vdmluZyB0aGUgb2JzZXJ2ZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wdXNoUmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgdWlkLCBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gQ29udGV4dE1hbmFnZXIuX19jb250cm9scywgY29udHJvbCA9IGNvbnRyb2xzW3VpZF0sIGxpc3RlbmVycztcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbHNbdWlkXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gY29udHJvbFtpZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwobGlzdGVuZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGNvbnRyb2xbaWRlbnRpZmllcl0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNwbGljZXMgYSBnaXZlbiBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYW4gb2JzZXJ2ZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmZXIgVGhlIGlkZW50aWZpZXIgZm9yIHdoaWNoIHRoZSByZW1vdmUgbGlzdGVuZXIgaXMgYmVpbmcgc3BsaWNlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgdW5pcXVlIElEIG9mIHRoZSBjb250cm9sIG9ic2VydmluZyB0aGUgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklSZW1vdmVMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIGZvciByZW1vdmluZyB0aGUgb2JzZXJ2ZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5zcGxpY2VSZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB1aWQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHMgPSBDb250ZXh0TWFuYWdlci5fX2NvbnRyb2xzLCBjb250cm9sID0gY29udHJvbHNbdWlkXSwgbGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IGNvbnRyb2xbaWRlbnRpZmllcl07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGNvbnRyb2wsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhIHNwZWNpZmllZCBpZGVudGlmaWVyIGZyb20gYmVpbmcgb2JzZXJ2ZWQgZm9yIGEgZ2l2ZW4gc2V0IG9mIGNvbnRyb2wgSURzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVpZHMgVGhlIHNldCBvZiB1bmlxdWUgSWRzIGZvciB3aGljaCB0byByZW1vdmUgdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnJlbW92ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAodWlkcywgaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHVpZHMubGVuZ3RoLCBjb250cm9scyA9IENvbnRleHRNYW5hZ2VyLl9fY29udHJvbHMsIGlkZW50aWZpZXJzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzID0gY29udHJvbHNbdWlkc1tpXV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpZGVudGlmaWVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGlkZW50aWZpZXJzLCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEVuc3VyZXMgdGhhdCBhbiBpZGVudGlmaWVyIHBhdGggd2lsbCBleGlzdCBvbiBhIGdpdmVuIGNvbnRyb2wuIFdpbGwgY3JlYXRlXHJcbiAgICAgICAgICAgICAqIG9iamVjdHMvYXJyYXlzIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgVGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAqIG9uIHdoaWNoIHRvIGNyZWF0ZSB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIHBlcmlvZC1kZWxpbWl0ZWQgaWRlbnRpZmllciBzdHJpbmcgdXNlZCB0byBjcmVhdGVcclxuICAgICAgICAgICAgICogdGhlIGNvbnRleHQgcGF0aC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbiAoY29udHJvbCwgaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb250cm9sLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udHJvbC5jb250ZXh0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci5fbG9nLndhcm4oJ0EgY2hpbGQgY29udHJvbCBpcyB0cnlpbmcgdG8gY3JlYXRlIGEgY2hpbGQgY29udGV4dCB0aGF0IGhhcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhIHBhcmVudCBjb250cm9sIHdpdGggYSBwcmltaXRpdmUgdHlwZSBjb250ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBpZGVudGlmaWVyLnNwbGl0KCcuJyksIHByb3BlcnR5LCB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHNwbGl0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGNvbnRleHRbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwodGVtcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKE51bWJlcihzcGxpdFswXSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wID0gY29udGV4dFtwcm9wZXJ0eV0gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAgPSBjb250ZXh0W3Byb3BlcnR5XSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCB0aGUgbmVzdGVkIHByb3BlcnRpZXMgaW4gYW4gb2JqZWN0IGFuZCByZWRlZmluZXMgdGhlIHByb3BlcnRpZXMgdG8gbm90IHVzZSBnZXR0ZXJzL3NldHRlcnNcclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9iaiBUaGUgb2JqZWN0IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIudW5PYnNlcnZlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgX2V4dGVuZCh0cnVlLCB0cnVlLCBvYmopO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2FmZWx5IHJldHJpZXZlcyB0aGUgbG9jYWwgY29udGV4dCBmb3IgdGhpcyBtYW5hZ2VyIGdpdmVuIGFuIEFycmF5IG9mXHJcbiAgICAgICAgICAgICAqIHByb3BlcnR5IHN0cmluZ3MgYW5kIG9ic2VydmVzIGl0IGlmIG5vdCBmb3VuZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzcGxpdCBUaGUgc3RyaW5nIGFycmF5IGNvbnRhaW5pbmcgcHJvcGVydGllcyB1c2VkIHRvIGluZGV4IGludG9cclxuICAgICAgICAgICAgICogdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb2JzZXJ2ZT8gV2hldGhlciBvciBub3QgdG8gb2JzZXJ2ZSB0aGUgaWRlbnRpZmllciBpbmRpY2F0ZWQgYnkgdGhlXHJcbiAgICAgICAgICAgICAqIHNwbGl0IEFycmF5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoc3BsaXQsIG9ic2VydmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0KHNwbGl0LmpvaW4oJy4nKSwgc3BsaXQsIG9ic2VydmUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2l2ZW4gYSBwZXJpb2QtZGVsaW1pdGVkIGlkZW50aWZpZXIsIG9ic2VydmVzIGFuIG9iamVjdCBhbmQgY2FsbHMgdGhlIGdpdmVuIGxpc3RlbmVyIHdoZW4gdGhlXHJcbiAgICAgICAgICAgICAqIG9iamVjdCBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBwZXJpb2QtZGVsaW1pdGVkIGlkZW50aWZpZXIgbm90aW5nIHRoZSBwcm9wZXJ0eSB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUxpc3RlbmVyfSBvYnNlcnZhYmxlTGlzdGVuZXIgQW4gb2JqZWN0IGltcGxtZW50aW5nIElPYnNlcnZhYmxlTGlzdGVuZXIuIFRoZSBsaXN0ZW5lciB3aWxsIGJlXHJcbiAgICAgICAgICAgICAqIG5vdGlmaWVkIG9mIG9iamVjdCBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAoYWJzb2x1dGVJZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShhYnNvbHV0ZUlkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBhYnNvbHV0ZUlkZW50aWZpZXIuc3BsaXQoJy4nKSwga2V5ID0gc3BsaXQucG9wKCksIGlzTGVuZ3RoID0ga2V5ID09PSAnbGVuZ3RoJywgaGFzSWRlbnRpZmllciA9IHRoaXMuX2hhc0lkZW50aWZpZXIoYWJzb2x1dGVJZGVudGlmaWVyKSwgaGFzT2JzZXJ2YWJsZUxpc3RlbmVyID0gIWlzTnVsbChvYnNlcnZhYmxlTGlzdGVuZXIpLCBqb2luLCBjb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luID0gc3BsaXQuam9pbignLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLl9nZXRDb250ZXh0KGpvaW4sIHNwbGl0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW4gPSBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT2JzZXJ2YWJsZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2xlbmd0aExpc3RlbmVyc1thYnNvbHV0ZUlkZW50aWZpZXJdID0gb2JzZXJ2YWJsZUxpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHVzaFJlbW92ZUxpc3RlbmVyKGFic29sdXRlSWRlbnRpZmllciwgb2JzZXJ2YWJsZUxpc3RlbmVyLnVpZCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KF90aGlzLl9fbGVuZ3RoTGlzdGVuZXJzLCBhYnNvbHV0ZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZE9ic2VydmFibGVMaXN0ZW5lcihhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lciwgaXNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNldCBvYnNlcnZlZElkZW50aWZpZXIgdG8gbnVsbCBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRleHRPYmplY3RzW2Fic29sdXRlSWRlbnRpZmllcl0gPSBjb250ZXh0W2tleV07XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBvYnNlcnZlZElkZW50aWZpZXIgaXMgbm90IG51bGwsIHRoZSBwcmltaXRpdmUgaXMgYWxyZWFkeSBiZWluZyB3YXRjaGVkIFxyXG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVkSWRlbnRpZmllciA9IHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXIsIGlzT2JzZXJ2ZWQgPSAhaXNOdWxsKG9ic2VydmVkSWRlbnRpZmllciksIHJlbW92ZUNhbGxiYWNrID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIGlmIChpc09ic2VydmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzSWRlbnRpZmllciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzT2JzZXJ2YWJsZUxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZU9ic2VydmVkQ2FsbGJhY2tfMSA9IG5vb3AsIHJlbW92ZUFic29sdXRlQ2FsbGJhY2tfMSA9IHRoaXMuX2FkZE9ic2VydmFibGVMaXN0ZW5lcihhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lciwgaXNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09ic2VydmVkICYmIGFic29sdXRlSWRlbnRpZmllciAhPT0gb2JzZXJ2ZWRJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU9ic2VydmVkQ2FsbGJhY2tfMSA9IHRoaXMuX2FkZE9ic2VydmFibGVMaXN0ZW5lcihvYnNlcnZlZElkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lciwgaXNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWJzb2x1dGVDYWxsYmFja18xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU9ic2VydmVkQ2FsbGJhY2tfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SXNBcnJheSA9IGlzQXJyYXkoY29udGV4dCksIHJlbW92ZU9ic2VydmFibGVMaXN0ZW5lciA9IHJlbW92ZUNhbGxiYWNrLCByZW1vdmVMaXN0ZW5lciA9IG5vb3AsIHJlbW92ZUFycmF5T2JzZXJ2ZSA9IG5vb3AsIG51bUtleSA9IE51bWJlcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudElzQXJyYXkgJiYgbnVtS2V5ID49IGNvbnRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLm9ic2VydmUoam9pbiArICcubGVuZ3RoJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IG9ic2VydmFibGVMaXN0ZW5lci51aWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtS2V5ID49IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kZWZpbmUoYWJzb2x1dGVJZGVudGlmaWVyLCBjb250ZXh0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU9ic2VydmFibGVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaGFzSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGRlZmluZWQgYW5kIGNvbnRleHQgbWFuYWdlciBoYXNuJ3Qgc2VlbiB0aGlzIGlkZW50aWZpZXIgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElzQXJyYXkgJiYgaXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gc3BsaXQucG9wKCksIHBhcmVudENvbnRleHQgPSB0aGlzLmdldENvbnRleHQoc3BsaXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX29ic2VydmVkSWRlbnRpZmllciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VzcyhwYXJlbnRDb250ZXh0LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgam9pbiA9IHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc09ic2VydmFibGVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVpZF8xID0gb2JzZXJ2YWJsZUxpc3RlbmVyLnVpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyID0gdGhpcy5vYnNlcnZlQXJyYXlNdXRhdGlvbih1aWRfMSwgbm9vcCwgam9pbiwgY29udGV4dCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBcnJheU9ic2VydmUgPSB0aGlzLm9ic2VydmUoam9pbiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkXzEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBfdGhpcy5vYnNlcnZlQXJyYXlNdXRhdGlvbih1aWRfMSwgbm9vcCwgam9pbiwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU9ic2VydmFibGVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQXJyYXlPYnNlcnZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmaW5lKGFic29sdXRlSWRlbnRpZmllciwgY29udGV4dCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlQ2FsbGJhY2s7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyBhbiBhcnJheSBhbmQgY2FsbHMgdGhlIGxpc3RlbmVyIHdoZW4gY2VydGFpbiBmdW5jdGlvbnMgYXJlIGNhbGxlZCBvblxyXG4gICAgICAgICAgICAgKiB0aGF0IGFycmF5LiBUaGUgd2F0Y2hlZCBmdW5jdGlvbnMgYXJlIHB1c2gsIHBvcCwgc2hpZnQsIHNwbGljZSwgdW5zaGlmdCwgc29ydCxcclxuICAgICAgICAgICAgICogYW5kIHJldmVyc2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVuaXF1ZSBJRCBvZiB0aGUgb2JqZWN0IG9ic2VydmluZyB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KGNoYW5nZXM6IEFycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+KSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgZm9yIGFmdGVyXHJcbiAgICAgICAgICAgICAqIHdoZW4gYW4gb2JzZXJ2ZWQgQXJyYXkgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGZyb20gdGhlIHJvb3QgY29udGV4dCB1c2VkIHRvIGZpbmQgdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFycmF5IFRoZSBhcnJheSB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBvbGRBcnJheSBUaGUgb2xkIGFycmF5IHRvIHN0b3Agb2JzZXJ2aW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLm9ic2VydmVBcnJheU11dGF0aW9uID0gZnVuY3Rpb24gKHVpZCwgbGlzdGVuZXIsIGFic29sdXRlSWRlbnRpZmllciwgYXJyYXksIG9sZEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvbGRBcnJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXN0b3JlQXJyYXkob2xkQXJyYXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChhcnJheSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGFic29sdXRlSWRlbnRpZmllci5zcGxpdCgnLicpLCBwcm9wZXJ0eSA9IHNwbGl0LnBvcCgpLCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHNwbGl0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGFjY2Vzcyhjb250ZXh0LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodGhpcy5fX29ic2VydmVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5fcHVzaEFycmF5TGlzdGVuZXIodWlkLCBhYnNvbHV0ZUlkZW50aWZpZXIsIGxpc3RlbmVyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdmVyd3JpdGVBcnJheShhYnNvbHV0ZUlkZW50aWZpZXIsIGFycmF5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlbW92ZUxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wb3AoKSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEaXNwb3NlcyB0aGUgbWVtb3J5IGZvciBhbiBDb250ZXh0TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZGVudGlmaWVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lkZW50aWZpZXJIYXNoID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29udGV4dE9iamVjdHMgPSB7fTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFB1c2hlcyBBcnJheSBtdXRhdGlvbiBsaXN0ZW5lcnMgYW5kIHJlbW92ZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdWlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciB0byBzdG9yZSB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNvbHV0ZUlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgdGhlIEFycmF5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhjaGFuZ2VzOiBBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+PikgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIEFycmF5IG11dGF0aW9uIGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9wdXNoQXJyYXlMaXN0ZW5lciA9IGZ1bmN0aW9uICh1aWQsIGFic29sdXRlSWRlbnRpZmllciwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnJheUxpc3RlbmVycyA9IENvbnRleHRNYW5hZ2VyLmFycmF5Q2hhbmdlTGlzdGVuZXJzLCBhcnJheUNhbGxiYWNrcyA9IGFycmF5TGlzdGVuZXJzW2Fic29sdXRlSWRlbnRpZmllcl07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGFycmF5Q2FsbGJhY2tzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5Q2FsbGJhY2tzID0gYXJyYXlMaXN0ZW5lcnNbYWJzb2x1dGVJZGVudGlmaWVyXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGFycmF5Q2FsbGJhY2tzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNhbGxiYWNrcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBhcnJheUNhbGxiYWNrc1t1aWRdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJSZW1vdmVkID0gZmFsc2UsIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lclJlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnNwbGljZVJlbW92ZUxpc3RlbmVyKGFic29sdXRlSWRlbnRpZmllciwgdWlkLCByZW1vdmVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShhcnJheUNhbGxiYWNrcywgdWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoYXJyYXlDYWxsYmFja3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShhcnJheUxpc3RlbmVycywgYWJzb2x1dGVJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wdXNoUmVtb3ZlTGlzdGVuZXIoYWJzb2x1dGVJZGVudGlmaWVyLCB1aWQsIHJlbW92ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlc3RvcmVzIGFuIGFycmF5IHRvIHVzZSBBcnJheS5wcm90b3R5cGUgaW5zdGVhZCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyYXkgVGhlIGFycmF5IHRvIHJlc3RvcmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX3Jlc3RvcmVBcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb21wYXQgPSB0aGlzLl9jb21wYXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbXBhdC5zZXRQcm90bykge1xyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnJheSwgT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9jb21wYXQucHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJheS5fX3Byb3RvX18gPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzUgPSBhcnJheU1ldGhvZHMubGVuZ3RoLCBtZXRob2QgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfNTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9IGFycmF5TWV0aG9kc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlbbWV0aG9kXSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE92ZXJ3cml0ZXMgYW4gQXJyYXkncyBwcm90b3R5cGUgdG8gb2JzZXJ2ZSBtdXRhdGlvbiBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNvbHV0ZUlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBBcnJheSBvZmYgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJheSBUaGUgYXJyYXkgdG8gb3ZlcndyaXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9vdmVyd3JpdGVBcnJheSA9IGZ1bmN0aW9uIChhYnNvbHV0ZUlkZW50aWZpZXIsIGFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdCwgbGVuZ3RoID0gYXJyYXlNZXRob2RzLmxlbmd0aCwgbWV0aG9kLCBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jb21wYXQucHJvdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gT2JqZWN0LmNyZWF0ZShBcnJheS5wcm90b3R5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBhcnJheU1ldGhvZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialttZXRob2RdID0gdGhpcy5fb3ZlcndyaXRlQXJyYXlGdW5jdGlvbihhYnNvbHV0ZUlkZW50aWZpZXIsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29tcGF0LnNldFByb3RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnJheSwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Ll9fcHJvdG9fXyA9IG9iajtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gYXJyYXlNZXRob2RzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLmRlZmluZVByb3BlcnR5KGFycmF5LCBtZXRob2QsIHRoaXMuX292ZXJ3cml0ZUFycmF5RnVuY3Rpb24oYWJzb2x1dGVJZGVudGlmaWVyLCBtZXRob2QpLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIHRoZSBjb250ZXh0IG9iamVjdCBvZiBhbiBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciBmb3Igd2hpY2ggd2UncmUgZ2V0dGluZyB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzcGxpdCBUaGUgc3RyaW5nIGFycmF5IGNvbnRhaW5pbmcgcHJvcGVydGllcyB1c2VkIHRvIGluZGV4IGludG9cclxuICAgICAgICAgICAgICogdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb2JzZXJ2ZT8gV2hldGhlciBvciBub3QgdG8gb2JzZXJ2ZSB0aGUgaWRlbnRpZmllciBpbmRpY2F0ZWQgYnkgdGhlXHJcbiAgICAgICAgICAgICAqIHNwbGl0IEFycmF5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9nZXRDb250ZXh0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHNwbGl0LCBvYnNlcnZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuX19jb250ZXh0T2JqZWN0c1tpZGVudGlmaWVyXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5fX2NvbnRleHRPYmplY3RzW2lkZW50aWZpZXJdID0gdGhpcy5fb2JzZXJ2ZUltbWVkaWF0ZUNvbnRleHQoc3BsaXQsIGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuX2dldEltbWVkaWF0ZUNvbnRleHQoc3BsaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgaW1tZWRpYXRlIGNvbnRleHQgb2YgaWRlbnRpZmllciBieSBzcGxpdHRpbmcgb24gXCIuXCIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc3BsaXQgVGhlIHN0cmluZyBhcnJheSBjb250YWluaW5nIHByb3BlcnRpZXMgdXNlZCB0byBpbmRleCBpbnRvXHJcbiAgICAgICAgICAgICAqIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9nZXRJbW1lZGlhdGVDb250ZXh0ID0gZnVuY3Rpb24gKHNwbGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHRbc3BsaXQuc2hpZnQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHMgdGhlIGltbWVkaWF0ZSBjb250ZXh0IG9mIGlkZW50aWZpZXIgYnkgc3BsaXR0aW5nIG9uIFwiLlwiXHJcbiAgICAgICAgICAgICAqIGFuZCBvYnNlcnZlcyB0aGUgb2JqZWN0cyBhbG9uZyB0aGUgd2F5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHNwbGl0IFRoZSBpZGVudGlmaWVyJ3Mgc3BsaXQgc3RyaW5nIGFycmF5IGNvbnRhaW5pbmcgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgKiB1c2VkIHRvIGluZGV4IGludG8gdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9vYnNlcnZlSW1tZWRpYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChzcGxpdCwgaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLl9faWRlbnRpZmllcnNbaWRlbnRpZmllcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlKGlkZW50aWZpZXIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEltbWVkaWF0ZUNvbnRleHQoc3BsaXQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2J0YWlucyB0aGUgb2xkIHZhbHVlIGFuZCBuZXcgdmFsdWUgb2YgYSBnaXZlbiBjb250ZXh0XHJcbiAgICAgICAgICAgICAqIHByb3BlcnR5IG9uIGEgcHJvcGVydHkgY2hhbmdlZCBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzcGxpdCBUaGUgc3BsaXQgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgdGhhdCBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3Um9vdENvbnRleHQgVGhlIG5ldyBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkUm9vdENvbnRleHQgVGhlIG9sZCBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9nZXRWYWx1ZXMgPSBmdW5jdGlvbiAoc3BsaXQsIG5ld1Jvb3RDb250ZXh0LCBvbGRSb290Q29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5LCBkb05ldyA9IGlzT2JqZWN0KG5ld1Jvb3RDb250ZXh0KSwgZG9PbGQgPSBpc09iamVjdChvbGRSb290Q29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoc3BsaXQubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gc3BsaXQuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9OZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Um9vdENvbnRleHQgPSBuZXdSb290Q29udGV4dFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwobmV3Um9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb05ldyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkb09sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRSb290Q29udGV4dCA9IG9sZFJvb3RDb250ZXh0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChvbGRSb290Q29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvT2xkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZG9OZXcgfHwgZG9PbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gc3BsaXRbMF07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUsIG9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwobmV3Um9vdENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdSb290Q29udGV4dFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChvbGRSb290Q29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG9sZFJvb3RDb250ZXh0W3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIGFsbCBjaGlsZCBwcm9wZXJ0aWVzIGJlaW5nIG9ic2VydmVkIHRoYXQgYSBwYXJlbnQgcHJvcGVydHlcclxuICAgICAgICAgICAgICogaGFzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGZvciB0aGUgcHJvcGVydHkgdGhhdCBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBtYXBwaW5ncz8gQW4gYXJyYXkgb2YgbWFwcGVkIGNoaWxkIGlkZW50aWZpZXIga2V5cyB0byBub3RpZnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX25vdGlmeUNoaWxkUHJvcGVydGllcyA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIG1hcHBpbmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbWFwcGluZ3MgPSBtYXBwaW5ncyB8fCBPYmplY3Qua2V5cyh0aGlzLl9faWRlbnRpZmllckhhc2hbaWRlbnRpZmllcl0gfHwge30pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG1hcHBpbmdzLmxlbmd0aCwgYmluZGluZywgcHJvcGVydHksIHBhcmVudFByb3BlcnR5LCBzcGxpdCwgdmFsdWVzID0ge30sIHZhbHVlLCBwZXJpb2QgPSAnLicsIGxlbmd0aFN0ciA9ICdsZW5ndGgnLCBrZXksIGtleUlzTGVuZ3RoLCBzdGFydCA9IGlkZW50aWZpZXIubGVuZ3RoICsgMSwgbmV3UGFyZW50LCBvbGRQYXJlbnQsIG5ld0NoaWxkLCBvbGRDaGlsZDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nID0gbWFwcGluZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkgPSBiaW5kaW5nLnNsaWNlKHN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHByb3BlcnR5LnNwbGl0KHBlcmlvZCk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc3BsaXQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5SXNMZW5ndGggPSAoa2V5ID09PSBsZW5ndGhTdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudFByb3BlcnR5ID0gc3BsaXQuam9pbihwZXJpb2QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHBhcmVudFByb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkUGFyZW50ID0gb2xkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gaXNOdWxsKG5ld1BhcmVudCkgPyB1bmRlZmluZWQgOiBuZXdQYXJlbnRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkQ2hpbGQgPSBpc051bGwob2xkUGFyZW50KSA/IHVuZGVmaW5lZCA6IG9sZFBhcmVudFtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5SXNMZW5ndGggJiYgIWlzQXJyYXkob2xkUGFyZW50KSAmJiBpc0FycmF5KG5ld1BhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhMaXN0ZW5lciA9IHRoaXMuX19sZW5ndGhMaXN0ZW5lcnNbYmluZGluZ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChsZW5ndGhMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gbGVuZ3RoTGlzdGVuZXIudWlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJheVNwbGl0ID0gaWRlbnRpZmllci5zcGxpdChwZXJpb2QpLCBhcnJheUtleSA9IGFycmF5U3BsaXQucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpvaW4gPSBhcnJheVNwbGl0LmpvaW4ocGVyaW9kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXlQYXJlbnQgPSB0aGlzLl9nZXRDb250ZXh0KGpvaW4sIGFycmF5U3BsaXQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3MoYXJyYXlQYXJlbnQsIGFycmF5S2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcodGhpcy5fX29ic2VydmVkSWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgam9pbiA9IHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IHRoaXMub2JzZXJ2ZUFycmF5TXV0YXRpb24odWlkLCBub29wLCBqb2luLCBuZXdQYXJlbnQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZShqb2luLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpZDogdWlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKG5WYWx1ZSwgb1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIgPSBfdGhpcy5vYnNlcnZlQXJyYXlNdXRhdGlvbih1aWQsIG5vb3AsIGpvaW4sIG5WYWx1ZSwgb1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHRoaXMuX19sZW5ndGhMaXN0ZW5lcnMsIGJpbmRpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1twYXJlbnRQcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1twYXJlbnRQcm9wZXJ0eV0gPSB0aGlzLl9nZXRWYWx1ZXMoc3BsaXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UGFyZW50ID0gdmFsdWUubmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudCA9IHZhbHVlLm9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGlzTnVsbChuZXdQYXJlbnQpID8gbmV3UGFyZW50IDogbmV3UGFyZW50W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoaWxkID0gaXNOdWxsKG9sZFBhcmVudCkgPyBvbGRQYXJlbnQgOiBvbGRQYXJlbnRba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3Byb3BlcnR5XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld0NoaWxkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkQ2hpbGRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChuZXdQYXJlbnQpICYmICghaXNBcnJheShuZXdQYXJlbnQpIHx8IG5ld1BhcmVudC5sZW5ndGggPiBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmluZShiaW5kaW5nLCBuZXdQYXJlbnQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUoYmluZGluZywgbmV3Q2hpbGQsIG9sZENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYmUgZmlyZWQgZm9yIGEgcGFydGljdWxhciBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWJzb2x1dGVJZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JTGlzdGVuZXJ9IG9ic2VydmFibGVMaXN0ZW5lciBUaGUgZnVuY3Rpb24gYW5kIGFzc29jaWF0ZWQgdW5pcXVlIElEIHRvIGJlIGZpcmVkXHJcbiAgICAgICAgICAgICAqIGZvciB0aGlzIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZW5ndGg/IEluZGljYXRlcyB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQgaXMgYW4gQXJyYXkncyBsZW5ndGguXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX2FkZE9ic2VydmFibGVMaXN0ZW5lciA9IGZ1bmN0aW9uIChhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lciwgaXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMZW5ndGggPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBhYnNvbHV0ZUlkZW50aWZpZXIuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3AgbGVuZ3RoIGtleSBcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBzcGxpdC5wb3AoKSwgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChzcGxpdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzKGNvbnRleHQsIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHRoaXMuX19vYnNlcnZlZElkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSB0aGlzLl9fb2JzZXJ2ZWRJZGVudGlmaWVyICsgKGlzTGVuZ3RoID09PSB0cnVlID8gJy5sZW5ndGgnIDogJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FkZChhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB2YXIgdWlkID0gb2JzZXJ2YWJsZUxpc3RlbmVyLnVpZCwgcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnNwbGljZVJlbW92ZUxpc3RlbmVyKGFic29sdXRlSWRlbnRpZmllciwgdWlkLCByZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDYWxsYmFjayhhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHVzaFJlbW92ZUxpc3RlbmVyKGFic29sdXRlSWRlbnRpZmllciwgdWlkLCByZW1vdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9ic2VydmVzIGEgcHJvcGVydHkgb24gYSBnaXZlbiBjb250ZXh0IHNwZWNpZmllZCBieSBhbiBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgZnVsbCBpZGVudGlmaWVyIHBhdGggZm9yIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGltbWVkaWF0ZUNvbnRleHQgVGhlIG9iamVjdCB3aG9zZSBwcm9wZXJ0eSB3aWxsIGJlIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB2YWx1ZSBvbiB0aGUgaW1tZWRpYXRlQ29udGV4dCB0aGF0J3NcclxuICAgICAgICAgICAgICogYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX2RlZmluZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChpbW1lZGlhdGVDb250ZXh0W2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlZmluZU9iamVjdChpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RlZmluZVByaW1pdGl2ZShpZGVudGlmaWVyLCBpbW1lZGlhdGVDb250ZXh0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW50ZXJjZXB0cyBhbiBhcnJheSBmdW5jdGlvbiBmb3Igb2JzZXJ2YXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNvbHV0ZUlkZW50aWZpZXIgVGhlIGZ1bGwgaWRlbnRpZmllciBwYXRoIGZvciB0aGUgb2JzZXJ2ZWQgYXJyYXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIGFycmF5IG1ldGhvZCBiZWluZyBjYWxsZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX292ZXJ3cml0ZUFycmF5RnVuY3Rpb24gPSBmdW5jdGlvbiAoYWJzb2x1dGVJZGVudGlmaWVyLCBtZXRob2QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja09iamVjdHMgPSBDb250ZXh0TWFuYWdlci5hcnJheUNoYW5nZUxpc3RlbmVyc1thYnNvbHV0ZUlkZW50aWZpZXJdIHx8IHt9LCBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgYSBmYXQtYXJyb3cgZnVuY3Rpb24gaGVyZSBiZWNhdXNlIHdlIG5lZWQgdGhlIGFycmF5IGNvbnRleHQuIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9ic2VydmVkQXJyYXlGbigpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCwgb3JpZ2luYWxBcnJheSA9IHRoaXMuc2xpY2UoMCksIHJldHVyblZhbHVlLCBpc1Vuc2hpZnQgPSBtZXRob2QgPT09ICd1bnNoaWZ0JywgaXNTaGlmdCA9IG1ldGhvZCA9PT0gJ3NoaWZ0JywgaXNTcGxpY2UgPSBtZXRob2QgPT09ICdzcGxpY2UnLCBzZWxmTm90aWZ5ID0gaXNTaGlmdCB8fCBpc1Vuc2hpZnQgfHwgaXNTcGxpY2UsIGlzVXBkYXRlID0gbWV0aG9kID09PSAnc29ydCcgfHwgbWV0aG9kID09PSAncmV2ZXJzZScsIG9sZEFycmF5LCBhZGRlZENvdW50LCBpbmRleCwgbmV3TGVuZ3RoLCByZW1vdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmTm90aWZ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9faXNBcnJheUZ1bmN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBBcnJheS5wcm90b3R5cGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19pc0FycmF5RnVuY3Rpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gdGhpcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IG9sZExlbmd0aCA+IDAgPyBbcmV0dXJuVmFsdWVdIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNVbnNoaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENvdW50ID0gYXJncy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZENvdW50ID0gYXJncy5sZW5ndGggLSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBhcmdzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHJldHVyblZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IEFycmF5LnByb3RvdHlwZVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMZW5ndGggPSB0aGlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRBcnJheSA9IG9yaWdpbmFsQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWV0aG9kID09PSAncHVzaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ291bnQgPSBhcmdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gb2xkTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1ldGhvZCA9PT0gJ3BvcCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBuZXdMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkID0gb2xkTGVuZ3RoID4gMCA/IFtyZXR1cm5WYWx1ZV0gOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaGlmdCB8fCBpc1NwbGljZSB8fCBtZXRob2QgPT09ICdwb3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnVuT2JzZXJ2ZShyZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY2FsbGJhY2tPYmplY3RzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGNhbGxiYWNrcywgakxlbmd0aCwgaSwgajtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gY2FsbGJhY2tPYmplY3RzW2tleXNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqTGVuZ3RoID0gY2FsbGJhY2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzW2pdKFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEFycmF5OiBvbGRBcnJheVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZk5vdGlmeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbm90aWZ5Q2hpbGRQcm9wZXJ0aWVzKGFic29sdXRlSWRlbnRpZmllciwgdGhpcywgb3JpZ2luYWxBcnJheSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXhlY3V0ZShhYnNvbHV0ZUlkZW50aWZpZXIgKyAnLmxlbmd0aCcsIG5ld0xlbmd0aCwgb2xkTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYSBzaW5nbGUgbGlzdGVuZXIgY2FsbGJhY2tcclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgYXR0YWNoZWQgdG8gdGhlIGNhbGxiYWNrcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUxpc3RlbmVyfSBsaXN0ZW5lciBUaGUgb2JzZXJ2YWJsZSBsaXN0ZW5lciB0byByZW1vdmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX3JlbW92ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjYWxsYmFja3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIHRoZSBvYnNlcnZlZCBsaXN0ZW5lciBcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkodGhpcy5fX2NvbnRleHRPYmplY3RzLCBpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGlkZW50aWZpZXIgaXMgYWxyZWFkeSBiZWluZ1xyXG4gICAgICAgICAgICAgKiBvYnNlcnZlZCBpbiB0aGlzIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9oYXNJZGVudGlmaWVyID0gZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eSh0aGlzLl9faWRlbnRpZmllcnNbaWRlbnRpZmllcl0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXhlY3V0ZXMgdGhlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBpZGVudGlmaWVyIG9uXHJcbiAgICAgICAgICAgICAqIHRoaXMgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgYXR0YWNoZWQgdG8gdGhlIGNhbGxiYWNrcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBuZXcgdmFsdWUgb24gdGhpcyBjb250ZXh0IHNwZWNpZmllZCBieVxyXG4gICAgICAgICAgICAgKiB0aGUgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb24gdGhpcyBjb250ZXh0IHNwZWNpZmllZCBieVxyXG4gICAgICAgICAgICAgKiB0aGUgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCB2YWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlTGlzdGVuZXJzID0gdGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHRoaXMuX19jb250ZXh0T2JqZWN0cywgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY29udGV4dE9iamVjdHNbaWRlbnRpZmllcl0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUgfHwgaXNOdWxsKG9ic2VydmFibGVMaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IG9ic2VydmFibGVMaXN0ZW5lcnMuc2xpY2UoMCksIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmxpc3RlbmVyKHZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZWZpbmVzIGEgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIGFuIG9iamVjdCB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBvYmplY3QgYmVpbmcgZGVmaW5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGltbWVkaWF0ZUNvbnRleHQgVGhlIHBhcmVudCBvYmplY3Qgb2YgdGhlIG9iamVjdCBiZWluZyBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBrZXkgb2YgdGhlIG9iamVjdCBiZWluZyBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9fZGVmaW5lT2JqZWN0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIGltbWVkaWF0ZUNvbnRleHQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGltbWVkaWF0ZUNvbnRleHRba2V5XTtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbW1lZGlhdGVDb250ZXh0LCBrZXksIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19vYnNlcnZlZElkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fX2lzQXJyYXlGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnVuT2JzZXJ2ZShvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IF90aGlzLl9faWRlbnRpZmllckhhc2hbaWRlbnRpZmllcl0sIGNoaWxkUHJvcGVydGllc0V4aXN0ID0gZmFsc2UsIG1hcHBpbmdzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocHJvcHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5ncyA9IE9iamVjdC5rZXlzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcGVydGllc0V4aXN0ID0gbWFwcGluZ3MubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXhlY3V0ZShpZGVudGlmaWVyLCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0aWVzRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ub3RpZnlDaGlsZFByb3BlcnRpZXMoaWRlbnRpZmllciwgdmFsdWUsIG9sZFZhbHVlLCBtYXBwaW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZGVmaW5lUHJpbWl0aXZlKGlkZW50aWZpZXIsIGltbWVkaWF0ZUNvbnRleHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNFbXB0eShfdGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGVmaW5lUHJvcGVydHkoaW1tZWRpYXRlQ29udGV4dCwga2V5LCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19kZWZpbmVQcmltaXRpdmUoaWRlbnRpZmllciwgaW1tZWRpYXRlQ29udGV4dCwga2V5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyBhIGdldHRlciBhbmQgc2V0dGVyIGZvciBhIHByaW1pdGl2ZSB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBwcmltaXRpdmUgYmVpbmcgZGVmaW5lZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGltbWVkaWF0ZUNvbnRleHQgVGhlIHBhcmVudCBvYmplY3Qgb2YgdGhlIHByaW1pdGl2ZSBiZWluZyBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBwcm9wZXJ0eSBrZXkgb2YgdGhlIHByaW1pdGl2ZSBiZWluZyBkZWZpbmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIucHJvdG90eXBlLl9fZGVmaW5lUHJpbWl0aXZlID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIGltbWVkaWF0ZUNvbnRleHQsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGltbWVkaWF0ZUNvbnRleHRba2V5XSwgaXNEZWZpbmVkID0gIWlzTnVsbCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShpbW1lZGlhdGVDb250ZXh0KSAmJiBrZXkgPT09ICdsZW5ndGgnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGltbWVkaWF0ZUNvbnRleHQsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX29ic2VydmVkSWRlbnRpZmllciA9IGlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9faXNBcnJheUZ1bmN0aW9uICYmIGlzQXJyYXkoaW1tZWRpYXRlQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBfdGhpcy5fX2lkZW50aWZpZXJIYXNoW2lkZW50aWZpZXJdLCBjaGlsZFByb3BlcnRpZXNFeGlzdCA9IGZhbHNlLCBtYXBwaW5ncztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZ3MgPSBPYmplY3Qua2V5cyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BlcnRpZXNFeGlzdCA9IG1hcHBpbmdzLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2V4ZWN1dGUoaWRlbnRpZmllciwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFByb3BlcnRpZXNFeGlzdCAmJiBpc0VtcHR5KF90aGlzLl9faWRlbnRpZmllcnNbaWRlbnRpZmllcl0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250ZXh0TWFuYWdlci5kZWZpbmVQcm9wZXJ0eShpbW1lZGlhdGVDb250ZXh0LCBrZXksIHZhbHVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZGVmaW5lT2JqZWN0KGlkZW50aWZpZXIsIGltbWVkaWF0ZUNvbnRleHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRQcm9wZXJ0aWVzRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbm90aWZ5Q2hpbGRQcm9wZXJ0aWVzKGlkZW50aWZpZXIsIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgbWFwcGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc0RlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fZGVmaW5lUHJpbWl0aXZlKGlkZW50aWZpZXIsIGltbWVkaWF0ZUNvbnRleHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGFuZCBhc3NvY2lhdGVzIGEgbGlzdGVuZXIgd2l0aCBhIGdpdmVuIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklMaXN0ZW5lcn0gb2JzZXJ2YWJsZUxpc3RlbmVyIFRoZSBsaXN0ZW5lciBiZWluZyBhZGRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLnByb3RvdHlwZS5fX2FkZCA9IGZ1bmN0aW9uIChpZGVudGlmaWVyLCBvYnNlcnZhYmxlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9faWRlbnRpZmllcnNbaWRlbnRpZmllcl0sIHByaW9yaXR5ID0gb2JzZXJ2YWJsZUxpc3RlbmVyLnByaW9yaXR5LCBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjYWxsYmFja3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fX2lkZW50aWZpZXJzW2lkZW50aWZpZXJdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIocHJpb3JpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF82ID0gY2FsbGJhY2tzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF82OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaW9yaXR5ID4gY2FsbGJhY2tzW2ldLnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDAsIG9ic2VydmFibGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGVMaXN0ZW5lci5wcmlvcml0eSA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKG9ic2VydmFibGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYWRkSGFzaFZhbHVlcyhpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBtYXBwaW5nIGZvciBhbiBpZGVudGlmaWVyIHdoaWNoIGFsbG93cyBxdWljayBhY2Nlc3MgdG8gaXRcclxuICAgICAgICAgICAgICogaWYgYSBwYXJlbnQgY29udGV4dCBpcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgaWRlbnRpZmllciB0byBtYXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5wcm90b3R5cGUuX19hZGRIYXNoVmFsdWVzID0gZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZGVudGlmaWVySGFzaCA9IHRoaXMuX19pZGVudGlmaWVySGFzaDtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChpZGVudGlmaWVySGFzaFtpZGVudGlmaWVyXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVySGFzaFtpZGVudGlmaWVyXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4LCBwZXJpb2QgPSAnLicsIGlkZW50ID0gaWRlbnRpZmllciwgaGFzaFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChpbmRleCA9IGlkZW50Lmxhc3RJbmRleE9mKHBlcmlvZCkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50ID0gaWRlbnQuc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhc2hWYWx1ZSA9IGlkZW50aWZpZXJIYXNoW2lkZW50XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGhhc2hWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFZhbHVlID0gaWRlbnRpZmllckhhc2hbaWRlbnRdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZGVudCAhPT0gaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFZhbHVlW2lkZW50aWZpZXJdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpZGVudCAhPT0gaWRlbnRpZmllciAmJiAhaGFzaFZhbHVlW2lkZW50aWZpZXJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hWYWx1ZVtpZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBzZXQgb2YgZnVuY3Rpb25zIHRvIGJlIGZpcmVkIHdoZW4gYSBwYXJ0aWN1bGFyIG9ic2VydmVkIGFycmF5IGlzIG11dGF0ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5hcnJheUNoYW5nZUxpc3RlbmVycyA9IHt9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gb2JqZWN0IGZvciBxdWlja2x5IGFjY2Vzc2luZyBhIHByZXZpb3VzbHkgY3JlYXRlZCBDb250ZXh0TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbnRleHRNYW5hZ2VyLl9fbWFuYWdlcnMgPSB7fTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBmb3Igc3RvcmluZyBmdW5jdGlvbnMgdG8gcmVtb3ZlIGxpc3RlbmVycyBmb3Igb2JzZXJ2ZWQgaWRlbnRpZmllcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5fX2NvbnRyb2xzID0ge307XHJcbiAgICAgICAgICAgIHJldHVybiBDb250ZXh0TWFuYWdlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIG9ic2VydmFibGUuQ29udGV4dE1hbmFnZXIgPSBDb250ZXh0TWFuYWdlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJQ29udGV4dE1hbmFnZXJTdGF0aWMoX2xvZykge1xyXG4gICAgICAgICAgICBDb250ZXh0TWFuYWdlci5fbG9nID0gX2xvZztcclxuICAgICAgICAgICAgcmV0dXJuIENvbnRleHRNYW5hZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYnNlcnZhYmxlLklDb250ZXh0TWFuYWdlclN0YXRpYyA9IElDb250ZXh0TWFuYWdlclN0YXRpYztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ29udGV4dE1hbmFnZXJTdGF0aWMsIElDb250ZXh0TWFuYWdlclN0YXRpYywgW1xyXG4gICAgICAgICAgICBfX0xvZ1xyXG4gICAgICAgIF0sIF9fU1RBVElDKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ29udGV4dE1hbmFnZXJJbnN0YW5jZSwgQ29udGV4dE1hbmFnZXIsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgfSkob2JzZXJ2YWJsZSA9IHBsYXRfMS5vYnNlcnZhYmxlIHx8IChwbGF0XzEub2JzZXJ2YWJsZSA9IHt9KSk7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBldmVudCBtYW5hZ2VtZW50IGNvbXBvbmVudHMgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBldmVudHM7XHJcbiAgICAoZnVuY3Rpb24gKGV2ZW50cykge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGV2ZW50IGNsYXNzIHRoYXQgcHJvcGFnYXRlcyB0aHJvdWdoIGEgY29udHJvbCB0cmVlLlxyXG4gICAgICAgICAqIFByb3BhZ2F0aW9uIG9mIHRoZSBldmVudCBhbHdheXMgc3RhcnRzIGF0IHRoZSBzZW5kZXIsIGFsbG93aW5nIGEgY29udHJvbCB0byBib3RoXHJcbiAgICAgICAgICogaW5pdGlhbGl6ZSBhbmQgY29uc3VtZSBhbiBldmVudC4gSWYgYSBjb25zdW1lciBvZiBhbiBldmVudCB0aHJvd3MgYW4gZXJyb3Igd2hpbGVcclxuICAgICAgICAgKiBoYW5kbGluZyB0aGUgZXZlbnQgaXQgd2lsbCBiZSBsb2dnZWQgdG8gdGhlIGFwcCB1c2luZyBMb2cuZGVidWcuIEVycm9ycyB3aWxsXHJcbiAgICAgICAgICogbm90IHN0b3AgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEaXNwYXRjaEV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRGlzcGF0Y2hFdmVudCgpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgcHJldmVudERlZmF1bHQoKSB3YXMgY2FsbGVkIG9uIHRoZSBldmVudC4gU2VuZGVycyBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAqIGV2ZW50IGNhbiBjaGVjayB0aGlzIHByb3BlcnR5IHRvIGtub3cgaWYgdGhleSBzaG91bGQgY2Fycnkgb3V0IGEgZGVmYXVsdFxyXG4gICAgICAgICAgICAgICAgICogYWN0aW9uIGFzIGEgcmVzdWx0IG9mIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBldmVudCBwcm9wYWdhdGlvbiB3YXMgc3RvcHBlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgRGlzcGF0Y2hFdmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChuYW1lLCBzZW5kZXIsIGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IHRoaXMuX0V2ZW50TWFuYWdlci5VUDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FuY2VscyB0aGUgZGVmYXVsdCBhY3Rpb24gKGlmIHRoZXJlIGlzIG9uZSkgZm9yIGFuIGV2ZW50LiBEb2VzIG5vdCBhZmZlY3QgcHJvcGFnYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEaXNwYXRjaEV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fQ29udGV4dE1hbmFnZXIuZGVmaW5lR2V0dGVyKHRoaXMsICdkZWZhdWx0UHJldmVudGVkJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIGhhbHQgdGhlIHByb3BhZ2F0aW9uIG9mIGFuIHVwd2FyZC1tb3ZpbmcgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIERvd253YXJkIGV2ZW50cyBjYW5ub3QgYmUgc3RvcHBlZCB3aXRoIHRoaXMgbWV0aG9kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRGlzcGF0Y2hFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSB0aGlzLl9FdmVudE1hbmFnZXIuVVApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX0V2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50c1t0aGlzLm5hbWVdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIERpc3BhdGNoRXZlbnQuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9FdmVudE1hbmFnZXI6IF9fRXZlbnRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX0NvbnRleHRNYW5hZ2VyOiBfX0NvbnRleHRNYW5hZ2VyU3RhdGljXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBEaXNwYXRjaEV2ZW50O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgZXZlbnRzLkRpc3BhdGNoRXZlbnQgPSBEaXNwYXRjaEV2ZW50O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19EaXNwYXRjaEV2ZW50SW5zdGFuY2UsIERpc3BhdGNoRXZlbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlcHJlc2VudHMgYSBMaWZlY3ljbGUgRXZlbnQuIExpZmVjeWNsZSBFdmVudHMgYXJlIGFsd2F5cyBkaXJlY3QgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBMaWZlY3ljbGVFdmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhMaWZlY3ljbGVFdmVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gTGlmZWN5Y2xlRXZlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBMaWZlY3ljbGVFdmVudCBhbmQgZmlyZXMgaXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHNlbmRlciBUaGUgc2VuZGVyIG9mIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIExpZmVjeWNsZUV2ZW50LmRpc3BhdGNoID0gZnVuY3Rpb24gKG5hbWUsIHNlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gYWNxdWlyZShfX0xpZmVjeWNsZUV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuaW5pdGlhbGl6ZShuYW1lLCBzZW5kZXIpO1xyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLnNlbmRFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgZXZlbnQsIHBvcHVsYXRpbmcgaXRzIHB1YmxpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBzZW5kZXIgVGhlIHNlbmRlciBvZiB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBMaWZlY3ljbGVFdmVudC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChuYW1lLCBzZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG5hbWUsIHNlbmRlciwgdGhpcy5fRXZlbnRNYW5hZ2VyLkRJUkVDVCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBMaWZlY3ljbGVFdmVudDtcclxuICAgICAgICB9KERpc3BhdGNoRXZlbnQpKTtcclxuICAgICAgICBldmVudHMuTGlmZWN5Y2xlRXZlbnQgPSBMaWZlY3ljbGVFdmVudDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJTGlmZWN5Y2xlRXZlbnRTdGF0aWMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMaWZlY3ljbGVFdmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRzLklMaWZlY3ljbGVFdmVudFN0YXRpYyA9IElMaWZlY3ljbGVFdmVudFN0YXRpYztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fTGlmZWN5Y2xlRXZlbnRTdGF0aWMsIElMaWZlY3ljbGVFdmVudFN0YXRpYywgbnVsbCwgX19TVEFUSUMpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19MaWZlY3ljbGVFdmVudEluc3RhbmNlLCBMaWZlY3ljbGVFdmVudCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFuYWdlcyBkaXNwYXRjaGluZyBldmVudHMsIGhhbmRsaW5nIGFsbCBwcm9wYWdhdGluZyBldmVudHMgYXMgd2VsbCBhcyBhbnkgZXJyb3IgaGFuZGxpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEV2ZW50TWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEV2ZW50TWFuYWdlcigpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIEV2ZW50TWFuYWdlciwgY3JlYXRpbmcgdGhlIGluaXRpYWwgQUxNIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKEV2ZW50TWFuYWdlci5fX2luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxpZmVjeWNsZUxpc3RlbmVycyA9IEV2ZW50TWFuYWdlci5fX2xpZmVjeWNsZUV2ZW50TGlzdGVuZXJzLCBfY29tcGF0ID0gRXZlbnRNYW5hZ2VyLl9jb21wYXQsIF9kb2N1bWVudCA9IEV2ZW50TWFuYWdlci5fZG9jdW1lbnQsIF93aW5kb3cgPSBFdmVudE1hbmFnZXIuX3dpbmRvdywgX2RvbSA9IEV2ZW50TWFuYWdlci5fZG9tLCBkaXNwYXRjaCA9IExpZmVjeWNsZUV2ZW50LmRpc3BhdGNoLCBsaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChsaWZlY3ljbGVMaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlmZWN5Y2xlTGlzdGVuZXJzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGxpc3RlbmVyLm5hbWUsIGxpc3RlbmVyLnZhbHVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoX2NvbXBhdC5jb3Jkb3ZhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZXMgPSBbX19yZXN1bWUsIF9fb25saW5lLCBfX29mZmxpbmVdLCB3aW5Kc18xID0gX2NvbXBhdC53aW5KcywgbGVuZ3RoXzcgPSBldmVudE5hbWVzLmxlbmd0aCwgZXZlbnRfMSwgZGlzcGF0Y2hlciA9IGZ1bmN0aW9uIChldikgeyByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChldiwgRXZlbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICB9OyB9LCBmbiA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF83OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRfMSA9IGV2ZW50TmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gZGlzcGF0Y2hlcihldmVudF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlTGlzdGVuZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZXZlbnRfMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RvbS5hZGRFdmVudExpc3RlbmVyKF9kb2N1bWVudCwgZXZlbnRfMSwgZm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBkaXNwYXRjaGVyKF9fc3VzcGVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlTGlzdGVuZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX3BhdXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm5cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9tLmFkZEV2ZW50TGlzdGVuZXIoX2RvY3VtZW50LCBfX3BhdXNlLCBmbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gZGlzcGF0Y2hlcihfX3JlYWR5KTtcclxuICAgICAgICAgICAgICAgICAgICBsaWZlY3ljbGVMaXN0ZW5lcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IF9fZGV2aWNlUmVhZHksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb20uYWRkRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnQsIF9fZGV2aWNlUmVhZHksIGZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luSnNfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2goX19iYWNrQnV0dG9uLCBFdmVudE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgbGlmZWN5Y2xlTGlzdGVuZXJzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX2JhY2tCdXR0b24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmblxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb20uYWRkRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnQsIF9fYmFja0J1dHRvbiwgZm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAod2luSnNfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKF9fYmFja0J1dHRvbiwgRXZlbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaWZlY3ljbGVMaXN0ZW5lcnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBfX2JhY2tDbGljayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3dpbmRvdy5XaW5KUy5BcHBsaWNhdGlvbi5hZGRFdmVudExpc3RlbmVyKF9fYmFja0NsaWNrLCBmbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9jb21wYXQuYW1kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvbS5hZGRFdmVudExpc3RlbmVyKF93aW5kb3csICdsb2FkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChfX3JlYWR5LCBFdmVudE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIGZvciBhIGdpdmVuIHVpZC4gVXNlZnVsIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24gd2hlblxyXG4gICAgICAgICAgICAgKiBjZXJ0YWluIG9iamVjdHMgdGhhdCBsaXN0ZW4gdG8gZXZlbnRzIGdvIG91dCBvZiBzY29wZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgdWlkIGZvciB3aGljaCB0aGUgZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC4nXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuZGlzcG9zZSA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KEV2ZW50TWFuYWdlci5fX2V2ZW50c0xpc3RlbmVycywgdWlkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciBhIERpc3BhdGNoRXZlbnQuIFRoZSBsaXN0ZW5lciB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgRGlzcGF0Y2hFdmVudCBpc1xyXG4gICAgICAgICAgICAgKiBwcm9wYWdhdGluZyBvdmVyIHRoZSBnaXZlbiB1aWQuIEFueSBudW1iZXIgb2YgbGlzdGVuZXJzIGNhbiBleGlzdCBmb3IgYSBzaW5nbGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBBIHVuaXF1ZSBpZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgb2JqZWN0IHJlZ2lzdGVyaW5nIHRoZSBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geyhldjogRGlzcGF0Y2hFdmVudCwgLi4uYXJnczogYW55W10pID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBtZXRob2QgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dD8gVGhlIGNvbnRleHQgd2l0aCB3aGljaCB0byBjYWxsIHRoZSBsaXN0ZW5lciBtZXRob2QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIub24gPSBmdW5jdGlvbiAodWlkLCBldmVudE5hbWUsIGxpc3RlbmVyLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzTGlzdGVuZXIgPSBFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnNbdWlkXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZXZlbnRzTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzTGlzdGVuZXIgPSBFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnNbdWlkXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSBldmVudHNMaXN0ZW5lci5saXN0ZW5lcnNbZXZlbnROYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShldmVudExpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycyA9IGV2ZW50c0xpc3RlbmVyLmxpc3RlbmVyc1tldmVudE5hbWVdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldmVudExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAobmFtZSwgc2VuZGVyLCBkaXJlY3Rpb24sIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZGlzcGF0Y2hFdmVudCA9IGFjcXVpcmUoX19EaXNwYXRjaEV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQuaW5pdGlhbGl6ZShuYW1lLCBzZW5kZXIsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIuc2VuZEV2ZW50KF9kaXNwYXRjaEV2ZW50LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2hFdmVudDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIHN0cmluZyBpcyBhIHJlZ2lzdGVyZWQgZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuaGFzRGlyZWN0aW9uID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkaXJlY3Rpb24gPT09IEV2ZW50TWFuYWdlci5VUCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gRXZlbnRNYW5hZ2VyLkRPV04gfHxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09IEV2ZW50TWFuYWdlci5ESVJFQ1QpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgYXBwcm9wcmlhdGUgZGlyZWN0aW9uIGFuZCBkaXNwYXRjaGVzIHRoZSBldmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50fSBldmVudCBUaGUgRGlzcGF0Y2hFdmVudCB0byBzZW5kXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5zZW5kRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZXZlbnQubmFtZSwgZGlyZWN0aW9uID0gZXZlbnQuZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIucHJvcGFnYXRpbmdFdmVudHNbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRNYW5hZ2VyLlVQOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIuX2Rpc3BhdGNoVXAoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEV2ZW50TWFuYWdlci5ET1dOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIuX2Rpc3BhdGNoRG93bihldmVudCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRXZlbnRNYW5hZ2VyLkRJUkVDVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9kaXNwYXRjaERpcmVjdChldmVudCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoRXZlbnRNYW5hZ2VyLnByb3BhZ2F0aW5nRXZlbnRzLCBuYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERpc3BhdGNoZXMgdGhlIGV2ZW50IHVwIHRoZSBjb250cm9sIGNoYWluLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkRpc3BhdGNoRXZlbnR9IGV2ZW50IFRoZSBldmVudCBiZWluZyBkaXNwYXRjaGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9kaXNwYXRjaFVwID0gZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGV2ZW50Lm5hbWUsIHBhcmVudCA9IGV2ZW50LnNlbmRlcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlICghaXNOdWxsKHBhcmVudCkgJiYgRXZlbnRNYW5hZ2VyLnByb3BhZ2F0aW5nRXZlbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnQudWlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9fZXhlY3V0ZUV2ZW50KHBhcmVudC51aWQsIGV2ZW50LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQgZG93biB0aGUgY29udHJvbCBjaGFpbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50fSBldmVudCBUaGUgZXZlbnQgYmVpbmcgZGlzcGF0Y2hlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fZGlzcGF0Y2hEb3duID0gZnVuY3Rpb24gKGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHMgPSBbXSwgY29udHJvbCwgbmFtZSA9IGV2ZW50Lm5hbWU7XHJcbiAgICAgICAgICAgICAgICBjb250cm9scy5wdXNoKGV2ZW50LnNlbmRlcik7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29udHJvbHMubGVuZ3RoICYmIEV2ZW50TWFuYWdlci5wcm9wYWdhdGluZ0V2ZW50c1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9scy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wudWlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9fZXhlY3V0ZUV2ZW50KGNvbnRyb2wudWlkLCBldmVudCwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sLmNvbnRyb2xzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMgPSBjb250cm9scy5jb25jYXQoY29udHJvbC5jb250cm9scyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCBkaXJlY3RseSB0byBhbGwgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkRpc3BhdGNoRXZlbnR9IGV2ZW50IFRoZSBldmVudCBiZWluZyBkaXNwYXRjaGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyZ3MgVGhlIGFyZ3VtZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9kaXNwYXRjaERpcmVjdCA9IGZ1bmN0aW9uIChldmVudCwgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHVpZHMgPSBPYmplY3Qua2V5cyhFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnMpLCBsZW5ndGggPSB1aWRzLmxlbmd0aCwgbmFtZSA9IGV2ZW50Lm5hbWUsIGV2ZW50c0xpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghRXZlbnRNYW5hZ2VyLnByb3BhZ2F0aW5nRXZlbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBldmVudHNMaXN0ZW5lciA9IEV2ZW50TWFuYWdlci5fX2V2ZW50c0xpc3RlbmVyc1t1aWRzW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2ZW50c0xpc3RlbmVyKSB8fCBpc051bGwoZXZlbnRzTGlzdGVuZXIubGlzdGVuZXJzW25hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9fY2FsbExpc3RlbmVycyhldmVudHNMaXN0ZW5lci5jb250ZXh0LCBldmVudCwgZXZlbnRzTGlzdGVuZXIubGlzdGVuZXJzW25hbWVdLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERpc3BhdGNoZXMgdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiB1aWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVpZCB1c2VkIHRvIGZpbmQgdGhlIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50fSBUaGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2V4ZWN1dGVFdmVudCA9IGZ1bmN0aW9uICh1aWQsIGV2LCBhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzTGlzdGVuZXIgPSBFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnNbdWlkXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZXZlbnRzTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBldmVudHNMaXN0ZW5lci5jb250ZXh0LCBsaXN0ZW5lcnMgPSBldmVudHNMaXN0ZW5lci5saXN0ZW5lcnNbZXYubmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIuX19jYWxsTGlzdGVuZXJzKGNvbnRleHQsIGV2LCBsaXN0ZW5lcnMsIGFyZ3MpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbHMgZXZlbnQgbGlzdGVuZXJzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQsIGV2ZW50LCBhbmQgYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gY29udGV4dCBUaGUgY29udGV4dCB3aXRoIHdoaWNoIHRvIGNhbGwgdGhlIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50fSBUaGUgZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8KGV2OiBEaXNwYXRjaEV2ZW50LCAuLi5hcmdzOiBhbnlbXSkgPT4gdm9pZD59IFRoZSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHNlbmQgdG8gdGhlIGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2NhbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29udGV4dCwgZXYsIGxpc3RlbmVycywgYXJncykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBldi5uYW1lLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoLCBpbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgYXJncyA9IFtldl0uY29uY2F0KGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgRXZlbnRNYW5hZ2VyLnByb3BhZ2F0aW5nRXZlbnRzW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2luZGV4XS5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9sb2cuZGVidWcoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gdXB3YXJkLW1vdmluZyBldmVudCB3aWxsIHN0YXJ0IGF0IHRoZSBzZW5kZXIgYW5kIG1vdmVcclxuICAgICAgICAgICAgICogdXAgdGhlIHBhcmVudCBjaGFpbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5VUCA9ICd1cCc7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGRvd253YXJkLW1vdmluZyBldmVudCB3aWxsIHN0YXJ0IGF0IHRoZSBzZW5kZXIgYW5kIG1vdmVcclxuICAgICAgICAgICAgICogdG8gaXRzIGNoaWxkcmVuIGFuZCBiZXlvbmQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuRE9XTiA9ICdkb3duJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdvZXMgdGhyb3VnaCBhbGwgbGlzdGVuZXJzIGZvciBhbiBldmVudCBuYW1lLCBpZ25vcmluZyBvcmRlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5ESVJFQ1QgPSAnZGlyZWN0JztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBhcmUgY3VycmVudGx5IHByb3BhZ2F0aW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLnByb3BhZ2F0aW5nRXZlbnRzID0ge307XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIb2xkcyBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyBrZXllZCBieSB1aWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX19ldmVudHNMaXN0ZW5lcnMgPSB7fTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEhvbGRzIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgYXBwbGljYXRpb24gbGlmZWZ5Y2xlIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2xpZmVjeWNsZUV2ZW50TGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiB3aGV0aGVyIG9yIG5vdCB0aGUgZXZlbnQgbWFuYWdlciBoYXMgYmVlbiBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudE1hbmFnZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICBldmVudHMuRXZlbnRNYW5hZ2VyID0gRXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElFdmVudE1hbmFnZXJTdGF0aWMoX2xvZywgX2NvbXBhdCwgX2RvY3VtZW50LCBfd2luZG93LCBfZG9tKSB7XHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fbG9nID0gX2xvZztcclxuICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLl9jb21wYXQgPSBfY29tcGF0O1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xyXG4gICAgICAgICAgICBFdmVudE1hbmFnZXIuX3dpbmRvdyA9IF93aW5kb3c7XHJcbiAgICAgICAgICAgIEV2ZW50TWFuYWdlci5fZG9tID0gX2RvbTtcclxuICAgICAgICAgICAgcmV0dXJuIEV2ZW50TWFuYWdlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRzLklFdmVudE1hbmFnZXJTdGF0aWMgPSBJRXZlbnRNYW5hZ2VyU3RhdGljO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19FdmVudE1hbmFnZXJTdGF0aWMsIElFdmVudE1hbmFnZXJTdGF0aWMsIFtcclxuICAgICAgICAgICAgX19Mb2csXHJcbiAgICAgICAgICAgIF9fQ29tcGF0LFxyXG4gICAgICAgICAgICBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX19Eb21cclxuICAgICAgICBdLCBfX1NUQVRJQyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwcmVzZW50cyBhbiBpbnRlcm5hbCBFcnJvciBFdmVudC4gVGhpcyBpcyB1c2VkIGZvciBhbnlcclxuICAgICAgICAgKiBpbnRlcm5hbCBlcnJvcnMgKGJvdGggZmF0YWwgYW5kIHdhcm5pbmdzKS4gQWxsIGVycm9yIGV2ZW50cyBhcmVcclxuICAgICAgICAgKiBkaXJlY3QgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFcnJvckV2ZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEVycm9yRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEVycm9yRXZlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBFcnJvckV2ZW50IGFuZCBmaXJlcyBpdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gc2VuZGVyIFRoZSBzZW5kZXIgb2YgdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V9IGVycm9yIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkLCByZXN1bHRpbmcgaW4gdGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9nTGV2ZWwgVGhlIHNldmVyaXR5IGxldmVsIG9mIHRoZSBlcnJvclxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRXJyb3JFdmVudC5kaXNwYXRjaCA9IGZ1bmN0aW9uIChuYW1lLCBzZW5kZXIsIGVycm9yLCBsb2dMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50ID0gYWNxdWlyZShFcnJvckV2ZW50KTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LmluaXRpYWxpemUobmFtZSwgc2VuZGVyLCBudWxsLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBldmVudC5sb2dMZXZlbCA9IGxvZ0xldmVsO1xyXG4gICAgICAgICAgICAgICAgRXJyb3JFdmVudC5fRXZlbnRNYW5hZ2VyLnNlbmRFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEVycm9yRXZlbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobmFtZSwgc2VuZGVyLCBkaXJlY3Rpb24sIGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBuYW1lLCBzZW5kZXIsIHRoaXMuX0V2ZW50TWFuYWdlci5ESVJFQ1QpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JFdmVudDtcclxuICAgICAgICB9KERpc3BhdGNoRXZlbnQpKTtcclxuICAgICAgICBldmVudHMuRXJyb3JFdmVudCA9IEVycm9yRXZlbnQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUVycm9yRXZlbnRTdGF0aWMoX0V2ZW50TWFuYWdlcikge1xyXG4gICAgICAgICAgICBFcnJvckV2ZW50Ll9FdmVudE1hbmFnZXIgPSBfRXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgICAgICByZXR1cm4gRXJyb3JFdmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRzLklFcnJvckV2ZW50U3RhdGljID0gSUVycm9yRXZlbnRTdGF0aWM7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0Vycm9yRXZlbnRTdGF0aWMsIElFcnJvckV2ZW50U3RhdGljLCBbX19FdmVudE1hbmFnZXJTdGF0aWNdLCBfX1NUQVRJQyk7XHJcbiAgICB9KShldmVudHMgPSBwbGF0XzEuZXZlbnRzIHx8IChwbGF0XzEuZXZlbnRzID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBmb3IgZmFjaWxpdGF0aW5nIGRhdGEgYW5kIERPTSBtYW5pcHVsYXRpb24uIENvbnRhaW5zIGxpZmVjeWNsZSBldmVudHNcclxuICAgICAqIGFzIHdlbGwgYXMgcHJvcGVydGllcyBmb3IgY29tbXVuaWNhdGluZyB3aXRoIG90aGVyIGNvbnRyb2xzLiBUaGlzIGlzIHRoZSBiYXNlXHJcbiAgICAgKiBjbGFzcyBmb3IgYWxsIHR5cGVzIG9mIGNvbnRyb2xzLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ29udHJvbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIGNvbnRyb2wuIEFueSBpbmplY3RhYmxlcyBzcGVjaWZpZWQgZHVyaW5nIGNvbnRyb2wgcmVnaXN0cmF0aW9uIHdpbGwgYmVcclxuICAgICAgICAgKiBwYXNzZWQgaW50byB0aGUgY29uc3RydWN0b3IgYXMgYXJndW1lbnRzIGFzIGxvbmcgYXMgdGhlIGNvbnRyb2wgaXMgaW5zdGFudGlhdGVkIHdpdGggaXRzIGFzc29jaWF0ZWRcclxuICAgICAgICAgKiBpbmplY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDb250cm9sKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSB1bmlxdWUgaWQsIGNyZWF0ZWQgZHVyaW5nIGluc3RhbnRpYXRpb24gYW5kIGZvdW5kIG9uIGV2ZXJ5IENvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnVpZCA9IHVuaXF1ZUlkKF9fUGxhdCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHByaW9yaXR5IG9mIHRoZSBjb250cm9sLiBUaGUgcHVycG9zZSBvZlxyXG4gICAgICAgICAgICAgKiB0aGlzIGlzIHNvIHRoYXQgY29udHJvbHMgbGlrZSBwbGF0LWJpbmQgY2FuIGhhdmUgYSBoaWdoZXJcclxuICAgICAgICAgICAgICogcHJpb3JpdHkgdGhhbiBwbGF0LXRhcC4gVGhlIHBsYXQtYmluZCB3aWxsIGJlIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAqIGFuZCBsb2FkZWQgYmVmb3JlIHBsYXQtdGFwLCBtZWFuaW5nIGl0IGhhcyB0aGUgZmlyc3QgY2hhbmNlXHJcbiAgICAgICAgICAgICAqIHRvIHJlc3BvbmQgdG8gZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5wcmlvcml0eSA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb250YWlucyBET00gaGVscGVyIG1ldGhvZHMgZm9yIG1hbmlwdWxhdGluZyB0aGlzIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5kb20gPSBDb250cm9sLl9kb207XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgZGF0YSBtYW5pcHVsYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnV0aWxzID0gYWNxdWlyZShfX1V0aWxzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgTG9nIGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9sb2cgPSBDb250cm9sLl9sb2c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIENvbnRyb2wuZ2V0Um9vdENvbnRyb2wgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNOdWxsKGNvbnRyb2wucm9vdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sLnJvb3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKCEoaXNOdWxsKGNvbnRyb2wucGFyZW50KSB8fCBjb250cm9sLmhhc093bkNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjb250cm9sLnJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wucm9vdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNvbnRyb2wuaGFzT3duQ29udGV4dCAmJiBpc09iamVjdChjb250cm9sLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBDb250cm9sLl9sb2cuZGVidWcoJ1Jvb3QgY29udHJvbDogJyArIGNvbnRyb2wudHlwZSArICcgZm91bmQgdGhhdCBzZXRzIGl0cyBjb250ZXh0IHRvIGFuIE9iamVjdCBidXQgZG9lcyBub3Qgc2V0IHRoZSBoYXNPd25Db250ZXh0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbGFnIHRvIHRydWUuIFBsZWFzZSBzZXQgdGhlIGZsYWcgaWYgdGhlIGNvbnRyb2wgaW50ZW5kcyB0byB1c2UgaXRzIG93biBjb250ZXh0LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2l2ZW4gYSBjb250cm9sLCBjYWxscyB0aGUgbG9hZGVkIG1ldGhvZCBmb3IgdGhlIGNvbnRyb2wgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5Db250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHRvIGxvYWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5sb2FkID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgdmFyIF9Qcm9taXNlID0gQ29udHJvbC5fUHJvbWlzZTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3RybCA9IGNvbnRyb2w7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhjdHJsLmFic29sdXRlQ29udGV4dFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjdHJsLmNvbnRleHRDaGFuZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0TWFuYWdlciA9IENvbnRyb2wuX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIoY3RybC5yb290KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TWFuYWdlci5vYnNlcnZlKGN0cmwuYWJzb2x1dGVDb250ZXh0UGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IGNvbnRyb2wudWlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogX19DT05URVhUX0NIQU5HRURfUFJJT1JJVFksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aS5UZW1wbGF0ZUNvbnRyb2wuY29udGV4dENoYW5nZWQoY29udHJvbCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGN0cmwuekNDX19wbGF0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsLnpDQ19fcGxhdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShjdHJsLCAnekNDX19wbGF0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjdHJsLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKGVsZW1lbnQpICYmIGlzRnVuY3Rpb24oZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb250cm9sLmxvYWRlZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKGNvbnRyb2wubG9hZGVkKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNwb3NlcyBhbGwgdGhlIG5lY2Vzc2FyeSBtZW1vcnkgZm9yIGEgY29udHJvbC4gVXNlcyBzcGVjaWZpYyBkaXNwb3NlXHJcbiAgICAgICAgICogbWV0aG9kcyByZWxhdGVkIHRvIGEgY29udHJvbCdzIGNvbnN0cnVjdG9yIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQ29udHJvbH0gY29udHJvbCBUaGUgQ29udHJvbCB0byBkaXNwb3NlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIHZhciBjdHJsID0gY29udHJvbDtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjdHJsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZChjdHJsLnRlbXBsYXRlQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgIEF0dHJpYnV0ZUNvbnRyb2wuZGlzcG9zZShjdHJsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjdHJsLmhhc093bkNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHVpLlZpZXdDb250cm9sLmRpc3Bvc2UoY3RybCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY3RybC5jb250cm9scykge1xyXG4gICAgICAgICAgICAgICAgdWkuVGVtcGxhdGVDb250cm9sLmRpc3Bvc2UoY3RybCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5kaXNwb3NlKSkge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVycyhjb250cm9sKTtcclxuICAgICAgICAgICAgQ29udHJvbC5fQ29udGV4dE1hbmFnZXIuZGlzcG9zZShjb250cm9sKTtcclxuICAgICAgICAgICAgY29udHJvbC5lbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgQ29udHJvbC5yZW1vdmVQYXJlbnQoY29udHJvbCk7XHJcbiAgICAgICAgICAgIGlmIChjb250cm9sLl9faW5qZWN0YWJsZV9fdHlwZSA9PT0gX19TVEFUSUMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmplY3RvciA9IGNvbnRyb2xJbmplY3RvcnNbY29udHJvbC50eXBlXTtcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woY29udHJvbC50eXBlLCBjb250cm9sLmNvbnN0cnVjdG9yLCBpbmplY3Rvci5kZXBlbmRlbmNpZXMsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcGxpY2VzIGEgY29udHJvbCBmcm9tIGl0cyBwYXJlbnQncyBjb250cm9scyBsaXN0LiBTZXRzIHRoZSBjb250cm9sJ3MgcGFyZW50XHJcbiAgICAgICAgICogdG8gbnVsbC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBwYXJlbnQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wucmVtb3ZlUGFyZW50ID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gcGFyZW50LmNvbnRyb2xzIHx8IFtdLCBpbmRleCA9IGNvbnRyb2xzLmluZGV4T2YoY29udHJvbCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udHJvbC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIGZvciBhIGNvbnRyb2wgd2l0aCB0aGUgZ2l2ZW4gdWlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5Db250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIGhhdmluZyBpdHMgZXZlbnQgbGlzdGVuZXJzIHJlbW92ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gQ29udHJvbC5fX2V2ZW50TGlzdGVuZXJzLCB1aWQgPSBjb250cm9sLnVpZDtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHJlbW92ZUxpc3RlbmVyc1t1aWRdO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShsaXN0ZW5lcnMpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2luZGV4XSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkocmVtb3ZlTGlzdGVuZXJzLCB1aWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIENvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgY29udHJvbCBzcGVjaWZpZWRcclxuICAgICAgICAgKiBieSBpdHMgdWlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1aWQgVGhlIHVpZCBvZiB0aGUgY29udHJvbCBhc3NvY2lhdGVkIHdpdGggdGhlIHJlbW92ZSBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSVJlbW92ZUxpc3RlbmVyfSBsaXN0ZW5lciBUaGUgcmVtb3ZlIGZ1bmN0aW9uIHRvIGFkZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLl9fYWRkUmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAodWlkLCBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gQ29udHJvbC5fX2V2ZW50TGlzdGVuZXJzO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheShyZW1vdmVMaXN0ZW5lcnNbdWlkXSkpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyc1t1aWRdLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyc1t1aWRdID0gW2xpc3RlbmVyXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYSBJUmVtb3ZlTGlzdGVuZXIgZnJvbSBhIGNvbnRyb2wncyBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVpZCBUaGUgdWlkIG9mIHRoZSBjb250cm9sIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVtb3ZlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5JUmVtb3ZlTGlzdGVuZXJ9IGxpc3RlbmVyIFRoZSByZW1vdmUgZnVuY3Rpb24gdG8gYWRkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wuX19zcGxpY2VSZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICh1aWQsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBDb250cm9sLl9fZXZlbnRMaXN0ZW5lcnMsIGNvbnRyb2xMaXN0ZW5lcnMgPSByZW1vdmVMaXN0ZW5lcnNbdWlkXTtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY29udHJvbExpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbnRyb2xMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udHJvbExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIGNvbnRyb2xzIHRoYXQgaGF2ZSBhIHNwZWNpZmljIGtleS92YWx1ZSBzdHJpbmcgcGFpci5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQ29udHJvbH0gY29udHJvbCBUaGUgYXQgd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nIGZvciBrZXkvdmFsdWUgcGFpcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3Igb24gYWxsIHRoZSBjb250cm9scyBpbiB0aGUgdHJlZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGV4cGVjdGVkIHZhbHVlIHVzZWQgdG8gZmluZCBzaW1pbGFyIGNvbnRyb2xzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wuX19nZXRDb250cm9scyA9IGZ1bmN0aW9uIChjb250cm9sLCBrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9scyA9IFtdLCByb290ID0gQ29udHJvbC5nZXRSb290Q29udHJvbChjb250cm9sKSwgY2hpbGQ7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKHJvb3QpICYmIHJvb3Rba2V5XSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnB1c2gocm9vdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gcm9vdC5jb250cm9scztcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcXVldWUgPSBbXS5jb25jYXQoY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBxdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkW2tleV0gPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNoaWxkLmNvbnRyb2xzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcXVldWUgPSBxdWV1ZS5jb25jYXQoY2hpbGQuY29udHJvbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9scztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpbml0aWFsaXplIGV2ZW50IG1ldGhvZCBmb3IgYSBjb250cm9sLiBJbiB0aGlzIG1ldGhvZCBhIGNvbnRyb2wgc2hvdWxkIGluaXRpYWxpemUgYWxsIHRoZSBuZWNlc3NhcnlcclxuICAgICAgICAgKiB2YXJpYWJsZXMuIFRoaXMgbWV0aG9kIGlzIHR5cGljYWxseSBvbmx5IG5lY2Vzc2FyeSBmb3IgdmlldyBjb250cm9scy4gSWYgYSBjb250cm9sIGRvZXMgbm90IGltcGxlbWVudFxyXG4gICAgICAgICAqIElCYXNlVmlld0NvbnRyb2wgdGhlbiBpdCBpcyBub3Qgc2FmZSB0byBhY2Nlc3MsIG9ic2VydmUsIG9yIG1vZGlmeVxyXG4gICAgICAgICAqIHRoZSBjb250ZXh0IHByb3BlcnR5IGluIHRoaXMgbWV0aG9kLiBBIHZpZXcgY29udHJvbCBzaG91bGQgY2FsbCBzZXJ2aWNlcy9zZXQgY29udGV4dCBpbiB0aGlzIG1ldGhvZCBpblxyXG4gICAgICAgICAqIG9yZGVyIHRvIGZpcmUgdGhlIGxvYWRlZCBldmVudC4gTm8gY29udHJvbCB3aWxsIGJlIGxvYWRlZCB1bnRpbCB0aGUgdmlldyBjb250cm9sIGhhcyBzcGVjaWZpZWQgYSBjb250ZXh0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvYWRlZCBldmVudCBtZXRob2QgZm9yIGEgY29udHJvbC4gVGhpcyBldmVudCBpcyBmaXJlZCBhZnRlciBhIGNvbnRyb2wgaGFzIGJlZW4gbG9hZGVkLFxyXG4gICAgICAgICAqIG1lYW5pbmcgYWxsIG9mIGl0cyBjaGlsZHJlbiBoYXZlIGFsc28gYmVlbiBsb2FkZWQgYW5kIGluaXRpYWwgRE9NIGhhcyBiZWVuIGNyZWF0ZWQgYW5kIHBvcHVsYXRlZC4gSXQgaXMgbm93XHJcbiAgICAgICAgICogc2FmZSBmb3IgYWxsIGNvbnRyb2xzIHRvIGFjY2Vzcywgb2JzZXJ2ZSwgYW5kIG1vZGlmeSB0aGUgY29udGV4dCBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0cmlldmVzIGFsbCB0aGUgY29udHJvbHMgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHN0cmluZyBuYW1lIHdpdGggd2hpY2ggdG8gcG9wdWxhdGUgdGhlIHJldHVybmVkIGNvbnRyb2xzIGFycmF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLmdldENvbnRyb2xzQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbnRyb2wuX19nZXRDb250cm9scyh0aGlzLCAnbmFtZScsIG5hbWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUuZ2V0Q29udHJvbHNCeVR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb250cm9sLl9fZ2V0Q29udHJvbHModGhpcywgJ3R5cGUnLCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ29udHJvbC5fX2dldENvbnRyb2xzKHRoaXMsICdjb25zdHJ1Y3RvcicsIHR5cGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignXCJDb250cm9sLmFkZEV2ZW50TGlzdGVuZXJcIiBtdXN0IHRha2UgYSBmdW5jdGlvbiBhcyB0aGUgdGhpcmQgYXJndW1lbnQuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgdHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpLCB1aWQgPSB0aGlzLnVpZDtcclxuICAgICAgICAgICAgQ29udHJvbC5fX2FkZFJlbW92ZUxpc3RlbmVyKHVpZCwgcmVtb3ZlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIENvbnRyb2wuX19zcGxpY2VSZW1vdmVMaXN0ZW5lcih1aWQsIHJlbW92ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSBpc09iamVjdCh0aGlzLmNvbnRleHQpID8gdGhpcyA6IHRoaXMucGFyZW50LCByb290ID0gQ29udHJvbC5nZXRSb290Q29udHJvbChjb250cm9sKTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsKGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdTaG91bGQgbm90IGNhbGwgcGxhdC5Db250cm9sLm9ic2VydmUgcHJpb3IgdG8gdGhlIGNvbnRyb2wgYmVpbmcgbG9hZGVkJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWJzb2x1dGVJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICBpZiAoaXNFbXB0eShpZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGlkZW50aWZpZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllckV4cHJlc3Npb24gPSAoQ29udHJvbC5fcGFyc2VyIHx8IGFjcXVpcmUoX19QYXJzZXIpKS5wYXJzZShpZGVudGlmaWVyKSwgaWRlbnRpZmllcnMgPSBpZGVudGlmaWVyRXhwcmVzc2lvbi5pZGVudGlmaWVycztcclxuICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ09ubHkgYSBzaW5nbGUgaWRlbnRpZmllciBjYW4gYmUgb2JzZXJ2ZWQgd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvbiBwbGF0LkNvbnRyb2wub2JzZXJ2ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSBpZGVudGlmaWVyRXhwcmVzc2lvbi5pZGVudGlmaWVyc1swXTtcclxuICAgICAgICAgICAgICAgIGlmIChleHByZXNzaW9uWzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXQgPSBleHByZXNzaW9uLnNwbGl0KCcuJyksIHN0YXJ0ID0gc3BsaXQuc2hpZnQoKS5zbGljZSgxKSwgam9pbiA9IHNwbGl0Lmxlbmd0aCA+IDAgPyAoJy4nICsgc3BsaXQuam9pbignLicpKSA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gX19DT05URVhUICsgam9pbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnQgPT09IF9fQ09OVEVYVF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggKyBqb2luO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICsgJy4nICsgZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggKyAnLicgKyBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICsgJy4nICsgaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX0NvbnRleHRNYW5hZ2VyID0gQ29udHJvbC5fQ29udGV4dE1hbmFnZXIgfHwgYWNxdWlyZShfX0NvbnRleHRNYW5hZ2VyU3RhdGljKSwgY29udGV4dE1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlcihyb290KTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRNYW5hZ2VyLm9ic2VydmUoYWJzb2x1dGVJZGVudGlmaWVyLCB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwoX3RoaXMsIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdWlkOiB0aGlzLnVpZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbCA9IGlzT2JqZWN0KHRoaXMuY29udGV4dCkgPyB0aGlzIDogdGhpcy5wYXJlbnQsIGNvbnRleHQgPSBjb250cm9sLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkgfHwgIWlzT2JqZWN0KGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJyYXksIGFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgaWYgKGlzRW1wdHkoaWRlbnRpZmllcikpIHtcclxuICAgICAgICAgICAgICAgIGFycmF5ID0gY29udGV4dDtcclxuICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhpZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJFeHByZXNzaW9uID0gKENvbnRyb2wuX3BhcnNlciB8fCBhY3F1aXJlKF9fUGFyc2VyKSkucGFyc2UoaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICBhcnJheSA9IGlkZW50aWZpZXJFeHByZXNzaW9uLmV2YWx1YXRlKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoICsgJy4nICsgaWRlbnRpZmllckV4cHJlc3Npb24uaWRlbnRpZmllcnNbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheSA9IGNvbnRleHRbaWRlbnRpZmllcl07XHJcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggKyAnLicgKyBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcklzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcklzRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIENvbnRleHRNYW5hZ2VyID0gQ29udHJvbC5fQ29udGV4dE1hbmFnZXIgfHwgYWNxdWlyZShfX0NvbnRleHRNYW5hZ2VyU3RhdGljKSwgY29udGV4dE1hbmFnZXIgPSBDb250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyKENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCkpLCB1aWQgPSB0aGlzLnVpZCwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoY2hhbmdlcywgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH0sIHJlbW92ZUxpc3RlbmVyID0gY29udGV4dE1hbmFnZXIub2JzZXJ2ZUFycmF5TXV0YXRpb24odWlkLCBjYWxsYmFjaywgYWJzb2x1dGVJZGVudGlmaWVyLCBhcnJheSwgbnVsbCksIHJlbW92ZUNhbGxiYWNrID0gY29udGV4dE1hbmFnZXIub2JzZXJ2ZShhYnNvbHV0ZUlkZW50aWZpZXIsIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lciA9IGNvbnRleHRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYnNlcnZlQXJyYXlNdXRhdGlvbih1aWQsIGNhbGxiYWNrLCBhYnNvbHV0ZUlkZW50aWZpZXIsIG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdWlkOiB1aWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENvbnRyb2wucHJvdG90eXBlLm9ic2VydmVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBleHByZXNzaW9uKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSAoQ29udHJvbC5fcGFyc2VyIHx8IGFjcXVpcmUoX19QYXJzZXIpKS5wYXJzZShleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uLmV2YWx1YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSAhaXNOdWxsKHRoaXMucmVzb3VyY2VzKSA/XHJcbiAgICAgICAgICAgICAgICB0aGlzIDpcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpIHx8ICFpc1N0cmluZyhjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWxpYXNlcyA9IGV4cHJlc3Npb24uYWxpYXNlcywgYWxpYXMsIGxlbmd0aCA9IGFsaWFzZXMubGVuZ3RoLCByZXNvdXJjZXMgPSB7fSwgcmVzb3VyY2VPYmosIENvbnRleHRNYW5hZ2VyID0gQ29udHJvbC5fQ29udGV4dE1hbmFnZXIgfHwgYWNxdWlyZShfX0NvbnRleHRNYW5hZ2VyU3RhdGljKSwgZ2V0TWFuYWdlciA9IENvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIsIFRlbXBsYXRlQ29udHJvbCA9IHVpLlRlbXBsYXRlQ29udHJvbCwgZmluZFJlc291cmNlID0gVGVtcGxhdGVDb250cm9sLmZpbmRSZXNvdXJjZSwgZXZhbHVhdGVFeHByZXNzaW9uID0gVGVtcGxhdGVDb250cm9sLmV2YWx1YXRlRXhwcmVzc2lvbiwgdHlwZSwgaTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBhbGlhcyA9IGFsaWFzZXNbaV07XHJcbiAgICAgICAgICAgICAgICByZXNvdXJjZU9iaiA9IGZpbmRSZXNvdXJjZShjb250cm9sLCBhbGlhcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyZXNvdXJjZU9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gcmVzb3VyY2VPYmoucmVzb3VyY2UudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gX19PQlNFUlZBQkxFX1JFU09VUkNFIHx8IHR5cGUgPT09IF9fTElURVJBTF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNbYWxpYXNdID0gZ2V0TWFuYWdlcihyZXNvdXJjZU9iai5jb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gZXhwcmVzc2lvbi5pZGVudGlmaWVycywgY29udGV4dE1hbmFnZXIgPSBnZXRNYW5hZ2VyKENvbnRyb2wuZ2V0Um9vdENvbnRyb2woY29udHJvbCkpLCBpZGVudGlmaWVyLCBzcGxpdCA9IFtdLCB0b3BJZGVudGlmaWVyLCBhYnNvbHV0ZUNvbnRleHRQYXRoID0gY29udHJvbC5hYnNvbHV0ZUNvbnRleHRQYXRoLCBhYnNvbHV0ZVBhdGggPSBhYnNvbHV0ZUNvbnRleHRQYXRoICsgJy4nLCBtYW5hZ2VycyA9IHt9O1xyXG4gICAgICAgICAgICBsZW5ndGggPSBpZGVudGlmaWVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGlkZW50aWZpZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgc3BsaXQgPSBpZGVudGlmaWVyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB0b3BJZGVudGlmaWVyID0gc3BsaXRbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllclswXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSB0b3BJZGVudGlmaWVyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlhcyA9PT0gX19DT05URVhUX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXJzW2Fic29sdXRlQ29udGV4dFBhdGggKyBpZGVudGlmaWVyLnJlcGxhY2UodG9wSWRlbnRpZmllciwgJycpXSA9IGNvbnRleHRNYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGlhcyA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlcnNbaWRlbnRpZmllci5yZXBsYWNlKHRvcElkZW50aWZpZXIsICdjb250ZXh0JyldID0gY29udGV4dE1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gaWRlbnRpZmllci5yZXBsYWNlKHRvcElkZW50aWZpZXIsICdyZXNvdXJjZXMuJyArIGFsaWFzICsgJy52YWx1ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyZXNvdXJjZXNbYWxpYXNdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuYWdlcnNbaWRlbnRpZmllcl0gPSByZXNvdXJjZXNbYWxpYXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFuYWdlcnNbYWJzb2x1dGVQYXRoICsgaWRlbnRpZmllcl0gPSBjb250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZGVudGlmaWVycyA9IE9iamVjdC5rZXlzKG1hbmFnZXJzKTtcclxuICAgICAgICAgICAgbGVuZ3RoID0gaWRlbnRpZmllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBldmFsdWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgY29udHJvbCksIGxpc3RlbmVycyA9IFtdLCB1aWQgPSB0aGlzLnVpZCwgb2JzZXJ2YWJsZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbChfdGhpcywgdmFsdWUsIG9sZFZhbHVlLCBleHByZXNzaW9uLmV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gaWRlbnRpZmllcnNbaV07XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChtYW5hZ2Vyc1tpZGVudGlmaWVyXS5vYnNlcnZlKGlkZW50aWZpZXIsIHtcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpZCxcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogb2JzZXJ2YWJsZUxpc3RlbmVyXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgbGVuZ3RoOyArK2lfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXzFdKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5ldmFsdWF0ZUV4cHJlc3Npb24gPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgYWxpYXNlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdWkuVGVtcGxhdGVDb250cm9sLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCB0aGlzLnBhcmVudCwgYWxpYXNlcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kcyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxyXG4gICAgICAgICAqIGluIHRoZSBwYXJlbnQgY29udHJvbCBjaGFpbi4gUmV0dXJucyB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgcHJvcGVydHkgaWRlbnRpZmVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUuZmluZFByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sID0gdGhpcywgZXhwcmVzc2lvbiA9IChDb250cm9sLl9wYXJzZXIgfHwgYWNxdWlyZShfX1BhcnNlcikpLnBhcnNlKHByb3BlcnR5KSwgdmFsdWU7XHJcbiAgICAgICAgICAgIHdoaWxlICghaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4cHJlc3Npb24uZXZhbHVhdGUoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzc2lvbjogZXhwcmVzc2lvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBDb250cm9sLl9FdmVudE1hbmFnZXIgfHwgYWNxdWlyZShfX0V2ZW50TWFuYWdlclN0YXRpYyk7XHJcbiAgICAgICAgICAgIGlmICghbWFuYWdlci5oYXNEaXJlY3Rpb24oZGlyZWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkaXJlY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJncy51bnNoaWZ0KGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSBtYW5hZ2VyLlVQO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzZW5kZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChzZW5kZXIudGVtcGxhdGVDb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgc2VuZGVyID0gc2VuZGVyLnRlbXBsYXRlQ29udHJvbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYW5hZ2VyLmRpc3BhdGNoKG5hbWUsIHNlbmRlciwgZGlyZWN0aW9uLCBhcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciBhIERpc3BhdGNoRXZlbnQuIFRoZSBsaXN0ZW5lciB3aWxsIGJlIGNhbGxlZCB3aGVuIGFcclxuICAgICAgICAgKiBEaXNwYXRjaEV2ZW50IGlzIHByb3BhZ2F0aW5nIG92ZXIgdGhlIGNvbnRyb2wuIEFueSBudW1iZXIgb2YgbGlzdGVuZXJzIGNhbiBleGlzdFxyXG4gICAgICAgICAqIGZvciBhIHNpbmdsZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCwgY29vaW5jaWRpbmcgd2l0aCB0aGUgRGlzcGF0Y2hFdmVudCBuYW1lLlxyXG4gICAgICAgICAqIEBwYXJhbSB7KGV2OiBwbGF0LmV2ZW50cy5EaXNwYXRjaEV2ZW50LCAuLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB2b2lkfSBsaXN0ZW5lciBUaGUgbWV0aG9kIGNhbGxlZCB3aGVuIHRoZVxyXG4gICAgICAgICAqIERpc3BhdGNoRXZlbnQgaXMgZmlyZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdmFyIF9FdmVudE1hbmFnZXIgPSBDb250cm9sLl9FdmVudE1hbmFnZXIgfHwgYWNxdWlyZShfX0V2ZW50TWFuYWdlclN0YXRpYyk7XHJcbiAgICAgICAgICAgIHJldHVybiBfRXZlbnRNYW5hZ2VyLm9uKHRoaXMudWlkLCBuYW1lLCBsaXN0ZW5lciwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGlzcG9zZSBldmVudCBpcyBjYWxsZWQgd2hlbiBhIGNvbnRyb2wgaXMgYmVpbmcgcmVtb3ZlZCBmcm9tIG1lbW9yeS4gQSBjb250cm9sIHNob3VsZCByZWxlYXNlXHJcbiAgICAgICAgICogYWxsIG9mIHRoZSBtZW1vcnkgaXQgaXMgdXNpbmcsIGluY2x1ZGluZyBET00gZXZlbnQgYW5kIHByb3BlcnR5IGxpc3RlbmVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDb250cm9sLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBjb250cm9scycgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ29udHJvbC5fX2V2ZW50TGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgcmV0dXJuIENvbnRyb2w7XHJcbiAgICB9KCkpO1xyXG4gICAgcGxhdF8xLkNvbnRyb2wgPSBDb250cm9sO1xyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIElDb250cm9sRmFjdG9yeShfcGFyc2VyLCBfQ29udGV4dE1hbmFnZXIsIF9FdmVudE1hbmFnZXIsIF9Qcm9taXNlLCBfZG9tLCBfbG9nKSB7XHJcbiAgICAgICAgQ29udHJvbC5fcGFyc2VyID0gX3BhcnNlcjtcclxuICAgICAgICBDb250cm9sLl9Db250ZXh0TWFuYWdlciA9IF9Db250ZXh0TWFuYWdlcjtcclxuICAgICAgICBDb250cm9sLl9FdmVudE1hbmFnZXIgPSBfRXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIENvbnRyb2wuX1Byb21pc2UgPSBfUHJvbWlzZTtcclxuICAgICAgICBDb250cm9sLl9kb20gPSBfZG9tO1xyXG4gICAgICAgIENvbnRyb2wuX2xvZyA9IF9sb2c7XHJcbiAgICAgICAgcmV0dXJuIENvbnRyb2w7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuSUNvbnRyb2xGYWN0b3J5ID0gSUNvbnRyb2xGYWN0b3J5O1xyXG4gICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0NvbnRyb2xGYWN0b3J5LCBJQ29udHJvbEZhY3RvcnksIFtcclxuICAgICAgICBfX1BhcnNlcixcclxuICAgICAgICBfX0NvbnRleHRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgIF9fRXZlbnRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgIF9fUHJvbWlzZSxcclxuICAgICAgICBfX0RvbSxcclxuICAgICAgICBfX0xvZ1xyXG4gICAgXSwgX19GQUNUT1JZKTtcclxuICAgIC8qKlxyXG4gICAgICogQSB0eXBlIG9mIGNvbnRyb2wgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhdHRyaWJ1dGUgYnV0IHdpbGxcclxuICAgICAqIG5vdCBiZSB1c2VkIHRvIGFkZCwgcmVtb3ZlLCBvciBtb2RpZnkgRE9NLlxyXG4gICAgICovXHJcbiAgICB2YXIgQXR0cmlidXRlQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKEF0dHJpYnV0ZUNvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gQXR0cmlidXRlQ29udHJvbCgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIFRlbXBsYXRlQ29udHJvbCBhc3NvY2lhdGVkIHdpdGggdGhpc1xyXG4gICAgICAgICAgICAgKiBjb250cm9sJ3MgZWxlbWVudC4gQ2FuIGJlIG51bGwgaWYgbm8gVGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAqIGV4aXN0cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVDb250cm9sID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIGZvciBkaXNwb3NpbmcgYW4gYXR0cmlidXRlIGNvbnRyb2wuIFJlbW92ZXMgYW55XHJcbiAgICAgICAgICogbmVjZXNzYXJ5IG9iamVjdHMgZnJvbSB0aGUgY29udHJvbC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuQXR0cmlidXRlQ29udHJvbH0gY29udHJvbCBUaGUgQXR0cmlidXRlQ29udHJvbCB0byBkaXNwb3NlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF0dHJpYnV0ZUNvbnRyb2wuZGlzcG9zZSA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KGNvbnRyb2wsICd0ZW1wbGF0ZUNvbnRyb2wnKTtcclxuICAgICAgICAgICAgQ29udHJvbC5kaXNwb3NlKGNvbnRyb2wpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBBdHRyaWJ1dGVDb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEF0dHJpYnV0ZUNvbnRyb2wuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlQ29udHJvbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICB9KENvbnRyb2wpKTtcclxuICAgIHBsYXRfMS5BdHRyaWJ1dGVDb250cm9sID0gQXR0cmlidXRlQ29udHJvbDtcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJQXR0cmlidXRlQ29udHJvbEZhY3RvcnkoKSB7XHJcbiAgICAgICAgcmV0dXJuIEF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuSUF0dHJpYnV0ZUNvbnRyb2xGYWN0b3J5ID0gSUF0dHJpYnV0ZUNvbnRyb2xGYWN0b3J5O1xyXG4gICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0F0dHJpYnV0ZUNvbnRyb2xGYWN0b3J5LCBJQXR0cmlidXRlQ29udHJvbEZhY3RvcnksIG51bGwsIF9fRkFDVE9SWSk7XHJcbiAgICAvKipcclxuICAgICAqIEhvbGRzIGFsbCB0aGUgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyByZWxhdGVkIHRvIFVJIGNvbXBvbmVudHMgZm9yIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgdWk7XHJcbiAgICAoZnVuY3Rpb24gKHVpKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJhc2UgY29udHJvbCBmb3IgYW55IGNvbnRyb2wgdGhhdCBhZmZlY3RzIHRoZSBVSS4gVGhleSBwcm92aWRlIHByb3BlcnRpZXMgZm9yIHRoZSBjb250cm9sIHRvIHVzZVxyXG4gICAgICAgICAqIHRvIG1hbmFnZSBpdHMgYm9keSBIVE1MLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUZW1wbGF0ZUNvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVGVtcGxhdGVDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZUNvbnRyb2woKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnkgZGVmYXVsdCBUZW1wbGF0ZUNvbnRyb2xzIGhhdmUgYSBwcmlvcml0eSBvZiAxMDAuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHkgPSAxMDA7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb250ZXh0IG9mIGFuIFRlbXBsYXRlQ29udHJvbCwgdXNlZCBmb3IgaW5oZXJpdGFuY2UgYW5kIGRhdGEtYmluZGluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3BlY2lmaWVzIHRoZSBhYnNvbHV0ZSBwYXRoIGZyb20gd2hlcmUgdGhlIGNvbnRleHQgd2FzIGNyZWF0ZWQgdG8gdGhpcyBDb250cm9sJ3MgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqIFVzZWQgYnkgdGhlIENvbnRleHRNYW5hZ2VyIGZvciBtYWludGFpbmluZyBjb250ZXh0IHBhcml0eVxyXG4gICAgICAgICAgICAgICAgICogKGUuZy4gJ2NvbnRleHQuY2hpbGRDb250ZXh0UHJvcGVydHkuZ3JhbmRDaGlsZENvbnRleHRQcm9wZXJ0eScpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmFic29sdXRlQ29udGV4dFBhdGggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgdGhlIFRlbXBsYXRlQ29udHJvbCBkZWZpbmVzIHRoZSBjb250ZXh0IHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc093bkNvbnRleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWxsb3dzIGEgVGVtcGxhdGVDb250cm9sIHRvIGVpdGhlciBzd2FwIGl0cyBlbGVtZW50IHdpdGggYW5vdGhlciBlbGVtZW50IChlLmcuIHBsYXQtc2VsZWN0KSxcclxuICAgICAgICAgICAgICAgICAqIG9yIHJlcGxhY2UgaXRzIGVsZW1lbnQgYWx0b2dldGhlci4gSWYgbnVsbCBvciBlbXB0eSBzdHJpbmcsIHRoZSBlbGVtZW50IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBET00sIGFuZCB0aGVcclxuICAgICAgICAgICAgICAgICAqIGNoaWxkTm9kZXMgb2YgdGhlIGVsZW1lbnQgd2lsbCBiZSBpbiBpdHMgcGxhY2UuIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBlbGVtZW50IGlzIHBsYWNlZCBzdGFydE5vZGUgYW5kIGVuZE5vZGUgQ29tbWVudHNcclxuICAgICAgICAgICAgICAgICAqIGFyZSBjcmVhdGVkLCBhbmQgdGhlIGNoaWxkTm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBlbGVtZW50Tm9kZXMgcHJvcGVydHkgb24gdGhlIGNvbnRyb2wuIFRoZSByZXBsYWNlV2l0aFxyXG4gICAgICAgICAgICAgICAgICogcHJvcGVydHkgY2FuIGJlIGFueSBwcm9wZXJ0eSB0aGF0IHdvcmtzIHdpdGggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgpLiBJZiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaGFkXHJcbiAgICAgICAgICAgICAgICAgKiBhdHRyaWJ1dGVzIChhcyB3ZWxsIGFzIGF0dHJpYnV0ZSBDb250cm9scyksIHRob3NlIGF0dHJpYnV0ZXMgd2lsbCBiZSBjYXJyaWVkIHRvIHRoZSBzd2FwcGVkIGVsZW1lbnQuIFRoZSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICAgKiByZXBsYWNlV2l0aCBpcyAnYW55LCcgbWVhbmluZyBpdCB3aWxsIGRlZmF1bHQgdG8gYSAnZGl2JyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBjb250cm9sIHR5cGUgaXMgdXNlZCBhcyB0aGVcclxuICAgICAgICAgICAgICAgICAqIGVsZW1lbnQncyBub2RlbmFtZSAoZS5nLiBgPHBsYXQtZm9yZWFjaCBwbGF0LWNvbnRleHQ9XCIuLi5cIj48L3BsYXQtZm9yZWFjaD5gKSwgYnV0IHdpbGwgbWFpbnRhaW4gd2hhdGV2ZXIgZWxlbWVudCB0eXBlXHJcbiAgICAgICAgICAgICAgICAgKiBpcyB1c2VkIG90aGVyd2lzZSAoZS5nLiBgPHRyIHBsYXQtY29udHJvbD1cInBsYXQtZm9yZWFjaFwiIHBsYXQtY29udGV4dD1cIi4uLlwiPjwvdHI+YCkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGggPSAnYW55JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuZXZhbHVhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGNvbnRyb2wsIGFsaWFzZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXhwcmVzc2lvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gVGVtcGxhdGVDb250cm9sLl9wYXJzZXIucGFyc2UoZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNGdW5jdGlvbihleHByZXNzaW9uLmV2YWx1YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uLmV2YWx1YXRlKG51bGwsIGFsaWFzZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uYWxpYXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxpYXNlcyA9IFRlbXBsYXRlQ29udHJvbC5nZXRSZXNvdXJjZXMoY29udHJvbCwgZXhwcmVzc2lvbi5hbGlhc2VzLCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShhbGlhc2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb24uZXZhbHVhdGUoY29udHJvbC5jb250ZXh0LCBhbGlhc2VzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdpdmVuIGEgY29udHJvbCBhbmQgQXJyYXkgb2YgYWxpYXNlcywgZmluZHMgdGhlIGFzc29jaWF0ZWQgcmVzb3VyY2VzIGFuZCBidWlsZHMgYSBjb250ZXh0IG9iamVjdCBjb250YWluaW5nXHJcbiAgICAgICAgICAgICAqIHRoZSB2YWx1ZXMuIFJldHVybnMgdGhlIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB1c2VkIGFzIHRoZSBzdGFydGluZyBwb2ludCBmb3IgZmluZGluZyByZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWxpYXNlcyBBbiBhcnJheSBvZiBhbGlhc2VzIHRvIHNlYXJjaCBmb3IuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7SU9iamVjdDxhbnk+fSByZXNvdXJjZXM/IEFuIG9wdGlvbmFsIHJlc291cmNlcyBvYmplY3QgdG8gZXh0ZW5kLCBpZiBubyByZXNvdXJjZXMgb2JqZWN0IGlzIHBhc3NlZCBpbiBhXHJcbiAgICAgICAgICAgICAqIG5ldyBvbmUgd2lsbCBiZSBjcmVhdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmdldFJlc291cmNlcyA9IGZ1bmN0aW9uIChjb250cm9sLCBhbGlhc2VzLCByZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYWxpYXNlcy5sZW5ndGgsIGFsaWFzLCByZXNvdXJjZSwgcmVzb3VyY2VPYmosIGNhY2hlID0gVGVtcGxhdGVDb250cm9sLl9fcmVzb3VyY2VDYWNoZVtjb250cm9sLnVpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNhY2hlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlID0gVGVtcGxhdGVDb250cm9sLl9fcmVzb3VyY2VDYWNoZVtjb250cm9sLnVpZF0gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc291cmNlcyA9IHJlc291cmNlcyB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhcyA9IGFsaWFzZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzWzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXMgPSBhbGlhcy5zbGljZSgxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzID09PSBfX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzW2FsaWFzXSA9IGNvbnRyb2wuY29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFsaWFzID09PSBfX1JPT1RfQ09OVEVYVF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNbYWxpYXNdID0gQ29udHJvbC5nZXRSb290Q29udHJvbChjb250cm9sKS5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmVzb3VyY2VzW2FsaWFzXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc051bGwoY2FjaGVbYWxpYXNdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VDb250cm9sID0gY2FjaGVbYWxpYXNdLmNvbnRyb2wsIGNvbnRyb2xSZXNvdXJjZXMgPSByZXNvdXJjZUNvbnRyb2wucmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2xSZXNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZU9iaiA9IFRlbXBsYXRlQ29udHJvbC5maW5kUmVzb3VyY2UoY29udHJvbCwgYWxpYXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VPYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogcmVzb3VyY2VDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiBjb250cm9sUmVzb3VyY2VzW2FsaWFzXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VPYmogPSBUZW1wbGF0ZUNvbnRyb2wuZmluZFJlc291cmNlKGNvbnRyb2wsIGFsaWFzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyZXNvdXJjZU9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wudHlwZS5pbmRleE9mKF9fQ09NUElMRUQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9sb2cud2FybignUmVzb3VyY2UgYWxpYXM6ICcgKyBhbGlhcyArICcgaXMgbm90IGRlZmluZWQuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWNoZVthbGlhc10gPSByZXNvdXJjZU9iajtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlT2JqLnJlc291cmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc1thbGlhc10gPSBpc051bGwocmVzb3VyY2UpID8gcmVzb3VyY2UgOiByZXNvdXJjZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdGFydHMgYXQgYSBjb250cm9sIGFuZCBzZWFyY2hlcyB1cCBpdHMgcGFyZW50IGNoYWluIGZvciBhIHBhcnRpY3VsYXIgcmVzb3VyY2UgYWxpYXMuXHJcbiAgICAgICAgICAgICAqIElmIHRoZSByZXNvdXJjZSBpcyBmb3VuZCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhbG9uZyB3aXRoIHRoZSBjb250cm9sIGluc3RhbmNlIG9uIHdoaWNoXHJcbiAgICAgICAgICAgICAqIHRoZSByZXNvdXJjZSB3YXMgZm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgb24gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nIGZvciB0aGUgcmVzb3VyY2UgYWxpYXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyBUaGUgYWxpYXMgdG8gc2VhcmNoIGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5maW5kUmVzb3VyY2UgPSBmdW5jdGlvbiAoY29udHJvbCwgYWxpYXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkgfHwgaXNOdWxsKGNvbnRyb2wucmVzb3VyY2VzKSB8fCAhaXNTdHJpbmcoYWxpYXMpIHx8IGlzRW1wdHkoYWxpYXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFsaWFzWzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhcyA9IGFsaWFzLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGlzUm9vdENvbnRleHQgPSBhbGlhcyA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0U7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSb290Q29udGV4dCB8fCBhbGlhcyA9PT0gX19DT05URVhUX1JFU09VUkNFIHx8IGFsaWFzID09PSBfX0NPTlRST0xfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSb290Q29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gQ29udHJvbC5nZXRSb290Q29udHJvbChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSAoY29udHJvbC5yZXNvdXJjZXMgfHwge30pW2FsaWFzXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlOiByZXNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogY29udHJvbFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gKGNvbnRyb2wucmVzb3VyY2VzIHx8IHt9KVthbGlhc107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmVzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZTogcmVzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBjb250cm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9sLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlY3Vyc2l2ZWx5IGRpc3Bvc2VzIGEgY29udHJvbCBhbmQgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIEEgY29udHJvbCB0byBkaXNwb3NlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB1aWQgPSBjb250cm9sLnVpZCwgY2hpbGRDb250cm9scyA9IGNvbnRyb2wuY29udHJvbHMsIGNvbnRyb2xzID0gKGNoaWxkQ29udHJvbHMgJiYgY2hpbGRDb250cm9scy5zbGljZSgwKSksIENvbnRleHRNYW5hZ2VyID0gQ29udHJvbC5fQ29udGV4dE1hbmFnZXIsIGRlZmluZSA9IENvbnRleHRNYW5hZ2VyLmRlZmluZVByb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY29udHJvbHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF84ID0gY29udHJvbHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoXzg7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbnRyb2wuZGlzcG9zZShjb250cm9sc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5kaXNwb3NlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQ29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVycyhjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5yZW1vdmVFbGVtZW50KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9SZXNvdXJjZXNGYWN0b3J5LmRpc3Bvc2UoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeS5kaXNwb3NlKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoVGVtcGxhdGVDb250cm9sLl9fcmVzb3VyY2VDYWNoZSwgY29udHJvbC51aWQpO1xyXG4gICAgICAgICAgICAgICAgQ29udGV4dE1hbmFnZXIuZGlzcG9zZShjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5FdmVudE1hbmFnZXIuZGlzcG9zZShjb250cm9sLnVpZCk7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX21hbmFnZXJDYWNoZS5yZW1vdmUodWlkKTtcclxuICAgICAgICAgICAgICAgIENvbnRyb2wucmVtb3ZlUGFyZW50KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgZGVmaW5lKGNvbnRyb2wsIF9fUkVTT1VSQ0VTLCBudWxsLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuYXR0cmlidXRlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmJpbmRhYmxlVGVtcGxhdGVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuY29udHJvbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wucm9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmlubmVyVGVtcGxhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX19pbmplY3RhYmxlX190eXBlID09PSBfX1NUQVRJQykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmplY3RvciA9IGNvbnRyb2xJbmplY3RvcnNbY29udHJvbC50eXBlXTtcclxuICAgICAgICAgICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKGNvbnRyb2wudHlwZSwgY29udHJvbC5jb25zdHJ1Y3RvciwgaW5qZWN0b3IuZGVwZW5kZW5jaWVzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExvYWRzIHRoZSBjb250cm9sIHRyZWUgZGVwdGggZmlyc3QgKHZpc2l0IGNoaWxkcmVuLCB0aGVuIHZpc2l0IHNlbGYpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHNlcnZpbmcgYXMgdGhlIHJvb3QgY29udHJvbCB0byBsb2FkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmxvYWRDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbnRyb2wuY29udHJvbHMsIGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChjaGlsZC5jb250cm9scykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLmxvYWRDb250cm9sKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmxvYWRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRyb2wubG9hZGVkKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBOb3RpZmllcyBhIGNvbnRyb2wgdGhhdCBpdHMgY29udGV4dCBoYXMgYmVlbiBjaGFuZ2VkIGJ5XHJcbiAgICAgICAgICAgICAqIGNhbGxpbmcgdGhlIGBjb250cm9sLmNvbnRleHRDaGFuZ2VkYCBtZXRob2QgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIGNvbnRleHQgY2hhbmdlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbnRyb2wncyBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgY29udHJvbCdzIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuY29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAoY29udHJvbCwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmNvbnRleHQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5zZXRDb250ZXh0UmVzb3VyY2VzKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5jb250ZXh0Q2hhbmdlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmNvbnRleHRDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBgY29udGV4dGAgcmVzb3VyY2UgdmFsdWUgb24gYSBUZW1wbGF0ZUNvbnRyb2wuIElmIHRoZSBjb250cm9sIHNwZWNpZmllc1xyXG4gICAgICAgICAgICAgKiBoYXNPd25Db250ZXh0IGFzIHRydWUsIHRoZSBgcm9vdENvbnRleHRgIHJlc291cmNlIHZhbHVlIHdpbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIGNvbnRleHQgcmVzb3VyY2VzIHdpbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLnNldENvbnRleHRSZXNvdXJjZXMgPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gY29udHJvbC5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sLnJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLnJlc291cmNlcyA9IFRlbXBsYXRlQ29udHJvbC5fUmVzb3VyY2VzRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzb3VyY2VzLmluaXRpYWxpemUoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5oYXNPd25Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sLnJlc291cmNlcy5yb290Q29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMuYWRkKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfX09CU0VSVkFCTEVfUkVTT1VSQ0UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMucm9vdENvbnRleHQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wucmVzb3VyY2VzLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5yZXNvdXJjZXMuYWRkKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX19PQlNFUlZBQkxFX1JFU09VUkNFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc291cmNlcy5jb250ZXh0LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb21wbGV0ZWx5IHJlbW92ZXMgYSBjb250cm9sJ3MgZWxlbWVudCBmcm9tIGl0cyBwYXJlbnROb2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIGVsZW1lbnQgc2hvdWxkIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBjb250cm9sLmVsZW1lbnQsIHBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbC5yZXBsYWNlV2l0aCA9PT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucmVwbGFjZVdpdGggPT09ICcnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgaXNEb2N1bWVudEZyYWdtZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsKGNvbnRyb2wuc3RhcnROb2RlLCBjb250cm9sLmVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuZWxlbWVudE5vZGVzID0gY29udHJvbC5zdGFydE5vZGUgPSBjb250cm9sLmVuZE5vZGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVsbChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgYWJzb2x1dGVDb250ZXh0UGF0aCByZWFkLW9ubHkgcHJvcGVydHkgb24gYSBjb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIG9uIHdoaWNoIHRvIHNldCB0aGUgYWJzb2x1dGVDb250ZXh0UGF0aC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gc2V0IG9uIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLnNldEFic29sdXRlQ29udGV4dFBhdGggPSBmdW5jdGlvbiAoY29udHJvbCwgcGF0aCkge1xyXG4gICAgICAgICAgICAgICAgQ29udHJvbC5fQ29udGV4dE1hbmFnZXIuZGVmaW5lR2V0dGVyKGNvbnRyb2wsICdhYnNvbHV0ZUNvbnRleHRQYXRoJywgcGF0aCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgdGVtcGxhdGUgZm9yIGEgY29udHJvbCBieSBzZWFyY2hpbmcgZm9yIGEgdGVtcGxhdGVVcmwsXHJcbiAgICAgICAgICAgICAqIHVzaW5nIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZVVybCwgb3Igc2VyaWFsaXppbmcgdGhlIGNvbnRyb2wncyB0ZW1wbGF0ZVN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSB0ZW1wbGF0ZSBpcyBiZWluZyBkZXRlcm1pbmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVVcmw/IFRoZSBwb3RlbnRpYWwgdGVtcGxhdGUgVVJMIHRvIHVzZSB0byBncmFiIHRoZSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5kZXRlcm1pbmVUZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb250cm9sLCB0ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ2FjaGUgPSBUZW1wbGF0ZUNvbnRyb2wuX3RlbXBsYXRlQ2FjaGUsIGRvbSA9IGNvbnRyb2wuZG9tLCBQcm9taXNlID0gVGVtcGxhdGVDb250cm9sLl9Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNOdWxsKGNvbnRyb2wudGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVVcmwgPSBjb250cm9sLnRlbXBsYXRlVXJsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbChjb250cm9sLnRlbXBsYXRlU3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlXzEgPSBjb250cm9sLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlQ2FjaGUucmVhZCh0eXBlXzEpLmNhdGNoKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBjb250cm9sLnRlbXBsYXRlU3RyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZUNhY2hlLnB1dCh0eXBlXzEsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBkb20uZ2V0VGVtcGxhdGUodGVtcGxhdGVVcmwpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0YWNoZXMgYSBUZW1wbGF0ZUNvbnRyb2wuIERpc3Bvc2VzIGl0cyBjaGlsZHJlbixcclxuICAgICAgICAgICAgICogYnV0IGRvZXMgbm90IGRpc3Bvc2UgdGhlIFRlbXBsYXRlQ29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB0byBiZSBkZXRhY2hlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5kZXRhY2ggPSBmdW5jdGlvbiAoY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChjb250cm9sKSB8fCBpc051bGwoY29udHJvbC5jb250cm9scykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbHMgPSBjb250cm9sLmNvbnRyb2xzLnNsaWNlKDApLCBsZW5ndGggPSBjb250cm9scy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ29udHJvbC5kaXNwb3NlKGNvbnRyb2xzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIENvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucmVtb3ZlRWxlbWVudChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fUmVzb3VyY2VzRmFjdG9yeS5kaXNwb3NlKGNvbnRyb2wsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoVGVtcGxhdGVDb250cm9sLl9fcmVzb3VyY2VDYWNoZSwgY29udHJvbC51aWQpO1xyXG4gICAgICAgICAgICAgICAgQ29udHJvbC5fQ29udGV4dE1hbmFnZXIuZGlzcG9zZShjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5FdmVudE1hbmFnZXIuZGlzcG9zZShjb250cm9sLnVpZCk7XHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX21hbmFnZXJDYWNoZS5yZW1vdmUoY29udHJvbC51aWQpO1xyXG4gICAgICAgICAgICAgICAgQ29udHJvbC5yZW1vdmVQYXJlbnQoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmNvbnRyb2xzID0gW107XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmF0dHJpYnV0ZXMgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBUZW1wbGF0ZUNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRlbXBsYXRlQ29udHJvbCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGFuIFRlbXBsYXRlQ29udHJvbCdzIGNvbnRleHQgcHJvcGVydHlcclxuICAgICAgICAgICAgICogaXMgY2hhbmdlZCBieSBhbiBhbmNlc3RvciBjb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWU/IFRoZSBuZXcgdmFsdWUgb2YgdGhlIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgbWV0aG9kIGNhbGxlZCBmb3IgVGVtcGxhdGVDb250cm9scyB0byBzZXQgdGhlaXIgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqIER1cmluZyB0aGlzIG1ldGhvZCBhIGNvbnRyb2wgc2hvdWxkIHJlYWR5IGl0cyB0ZW1wbGF0ZSBmb3IgY29tcGlsYXRpb24uIFdoYXRldmVyIGlzIGluIHRoZSBjb250cm9sJ3NcclxuICAgICAgICAgICAgICogZWxlbWVudCAob3IgZWxlbWVudE5vZGVzIGlmIHJlcGxhY2VXaXRoIGlzIGltcGxlbWVudGVkKSBhZnRlciB0aGlzIG1ldGhvZCdzIGV4ZWN1dGlvbiB3aWxsIGJlIGNvbXBpbGVkXHJcbiAgICAgICAgICAgICAqIGFuZCBhcHBlYXIgb24gdGhlIERPTS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyB0aGUgYXNzb2NpYXRlZCByZXNvdXJjZXMgYW5kIGJ1aWxkcyBhIGNvbnRleHQgb2JqZWN0IGNvbnRhaW5pbmdcclxuICAgICAgICAgICAgICogdGhlIHZhbHVlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGlhc2VzIEFuIGFycmF5IG9mIGFsaWFzZXMgdG8gc2VhcmNoIGZvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtJT2JqZWN0PGFueT59IHJlc291cmNlcz8gQW4gb3B0aW9uYWwgcmVzb3VyY2VzIG9iamVjdCB0byBleHRlbmQsXHJcbiAgICAgICAgICAgICAqIGlmIG5vIHJlc291cmNlcyBvYmplY3QgaXMgcGFzc2VkIGluIGEgbmV3IG9uZSB3aWxsIGJlIGNyZWF0ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wucHJvdG90eXBlLmdldFJlc291cmNlcyA9IGZ1bmN0aW9uIChhbGlhc2VzLCByZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUNvbnRyb2wuZ2V0UmVzb3VyY2VzKHRoaXMsIGFsaWFzZXMsIHJlc291cmNlcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdGFydHMgYXQgYSBjb250cm9sIGFuZCBzZWFyY2hlcyB1cCBpdHMgcGFyZW50IGNoYWluIGZvciBhIHBhcnRpY3VsYXIgcmVzb3VyY2UgYWxpYXMuXHJcbiAgICAgICAgICAgICAqIElmIHRoZSByZXNvdXJjZSBpcyBmb3VuZCwgaXQgd2lsbCBiZSByZXR1cm5lZCBhbG9uZyB3aXRoIHRoZSBjb250cm9sIGluc3RhbmNlIG9uIHdoaWNoXHJcbiAgICAgICAgICAgICAqIHRoZSByZXNvdXJjZSB3YXMgZm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyBUaGUgYWxpYXMgdG8gc2VhcmNoIGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5wcm90b3R5cGUuZmluZFJlc291cmNlID0gZnVuY3Rpb24gKGFsaWFzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVDb250cm9sLmZpbmRSZXNvdXJjZSh0aGlzLCBhbGlhcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5wcm90b3R5cGUuZXZhbHVhdGVFeHByZXNzaW9uID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUNvbnRyb2wuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gb2JqZWN0IGZvciBxdWlja2x5IHJldHJpZXZpbmcgcHJldmlvdXNseSBhY2Nlc3NlZCByZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX19yZXNvdXJjZUNhY2hlID0ge307XHJcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUNvbnRyb2w7XHJcbiAgICAgICAgfShDb250cm9sKSk7XHJcbiAgICAgICAgdWkuVGVtcGxhdGVDb250cm9sID0gVGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElUZW1wbGF0ZUNvbnRyb2xGYWN0b3J5KF9SZXNvdXJjZXNGYWN0b3J5LCBfQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LCBfbWFuYWdlckNhY2hlLCBfdGVtcGxhdGVDYWNoZSwgX3BhcnNlciwgX2h0dHAsIF9Qcm9taXNlLCBfbG9nKSB7XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fUmVzb3VyY2VzRmFjdG9yeSA9IF9SZXNvdXJjZXNGYWN0b3J5O1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeSA9IF9CaW5kYWJsZVRlbXBsYXRlc0ZhY3Rvcnk7XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fbWFuYWdlckNhY2hlID0gX21hbmFnZXJDYWNoZTtcclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl90ZW1wbGF0ZUNhY2hlID0gX3RlbXBsYXRlQ2FjaGU7XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fcGFyc2VyID0gX3BhcnNlcjtcclxuICAgICAgICAgICAgVGVtcGxhdGVDb250cm9sLl9odHRwID0gX2h0dHA7XHJcbiAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5fUHJvbWlzZSA9IF9Qcm9taXNlO1xyXG4gICAgICAgICAgICBUZW1wbGF0ZUNvbnRyb2wuX2xvZyA9IF9sb2c7XHJcbiAgICAgICAgICAgIHJldHVybiBUZW1wbGF0ZUNvbnRyb2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpLklUZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gSVRlbXBsYXRlQ29udHJvbEZhY3Rvcnk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1RlbXBsYXRlQ29udHJvbEZhY3RvcnksIElUZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LCBbXHJcbiAgICAgICAgICAgIF9fUmVzb3VyY2VzRmFjdG9yeSxcclxuICAgICAgICAgICAgX19CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnksXHJcbiAgICAgICAgICAgIF9fTWFuYWdlckNhY2hlLFxyXG4gICAgICAgICAgICBfX1RlbXBsYXRlQ2FjaGUsXHJcbiAgICAgICAgICAgIF9fUGFyc2VyLFxyXG4gICAgICAgICAgICBfX0h0dHAsXHJcbiAgICAgICAgICAgIF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgX19Mb2dcclxuICAgICAgICBdLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19UZW1wbGF0ZUNvbnRyb2xJbnN0YW5jZSwgVGVtcGxhdGVDb250cm9sLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBleHRlbmRlZCBUZW1wbGF0ZUNvbnRyb2wgdGhhdCBhbGxvd3MgZm9yIHRoZSBiaW5kaW5nIG9mIGEgdmFsdWUgdG9cclxuICAgICAgICAgKiBhbm90aGVyIGxpc3RlbmluZyBjb250cm9sIChlLmcuIHBsYXQtYmluZCBjb250cm9sKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQmluZENvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQmluZENvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJpbmRDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldCB0byAxMjAsIGhpZ2hlciB0aGFuIGBwbGF0LWJpbmRgIHRvIGVuc3VyZSB0aGF0IEJpbkNvbnRyb2xzIGxvYWRcclxuICAgICAgICAgICAgICAgICAqIHByaW9yIHRvIHRoZSBgcGxhdC1iaW5kYC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eSA9IDEyMDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHNldCBvZiBmdW5jdGlvbnMgYWRkZWQgZXh0ZXJuYWxseSB0aGF0IGxpc3RlbnNcclxuICAgICAgICAgICAgICAgICAqIGZvciBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSVByb3BlcnR5Q2hhbmdlZExpc3RlbmVyPGFueT59IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0aGF0IGFjdHMgYXMgYSBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRDb250cm9sLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZENvbnRyb2wucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGJpbmRlcikgeyB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNpZ25pZmllcyB3aGVuIHRoaXMgY29udHJvbCdzIGJpbmRhYmxlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYWZ0ZXIgdGhlIGNoYW5nZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlPyBUaGUgb2xkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBwcmlvciB0byB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZENvbnRyb2wucHJvdG90eXBlLmlucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyByZWZlcmVuY2VzIHRvIHRoZSBsaXN0ZW5lcnNcclxuICAgICAgICAgICAgICogZGVmaW5lZCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZENvbnRyb2wucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJpbmRDb250cm9sO1xyXG4gICAgICAgIH0oVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICAgICAgdWkuQmluZENvbnRyb2wgPSBCaW5kQ29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNvbnRyb2wgdXNlZCBpbiBhIFZpZXdwb3J0IGZvciBwYWdlIG5hdmlnYXRpb24uIFRoZVxyXG4gICAgICAgICAqIGNvbnRyb2wgaGFzIG5hdmlnYXRpb24gZXZlbnRzIHRoYXQgYXJlIGNhbGxlZCB3aGVuIG5hdmlnYXRpbmcgdG8gYW5kIGZyb20gdGhlIGNvbnRyb2wuIEEgVmlld0NvbnRyb2xcclxuICAgICAgICAgKiByZXByZXNlbnRzIGEgcm91dGluZyBjb21wb25lbnQgb24gYSBwYWdlIChpLmUuIGEgcGllY2Ugb2YgYSBwYWdlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciByb3V0ZSkuXHJcbiAgICAgICAgICogSXQgaGFzIHRoZSBhYmlsaXR5IHRvIGluaXRpYXRlLCBhcHByb3ZlLCBhbmQgcmVqZWN0IG5hdmlnYXRpb24gdG8vZnJvbSBpdHNlbGYuIEEgVmlld0NvbnRyb2wgYWxzbyBoYXMgdGhlXHJcbiAgICAgICAgICogYWJpbGl0eSB0byBpbmplY3QgYSBSb3V0ZXIgYW5kIGNvbmZpZ3VyZSBzdWItbmF2aWdhdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVmlld0NvbnRyb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVmlld0NvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFZpZXdDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpZmllcyB0aGF0IHRoaXMgY29udHJvbCB3aWxsIGhhdmUgaXRzIG93biBjb250ZXh0LCBhbmQgaXQgc2hvdWxkIG5vdCBpbmhlcml0IGEgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNPd25Db250ZXh0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVjdXJzaXZlbHkgZGlzcG9zZXMgYSBWaWV3Q29udHJvbCBhbmQgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVmlld0NvbnRyb2x9IGNvbnRyb2wgQSBjb250cm9sIHRvIGRpc3Bvc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaWV3Q29udHJvbC5kaXNwb3NlID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlQ29udHJvbC5kaXNwb3NlKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBhIFZpZXdDb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmlld0NvbnRyb2wuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZpZXdDb250cm9sKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBbGxvd3MgYSBWaWV3Q29udHJvbCB0byBhc3luY2hyb25vdXNseSBkZWNpZGUgaWYgdGhlIGFwcCBpcyBhYmxlIHRvIG5hdmlnYXRlIGF3YXkgZnJvbSB0aGVcclxuICAgICAgICAgICAgICogY3VycmVudCB2aWV3LiBBIHBvc3NpYmxlIHVzZSBvZiB0aGlzIG1ldGhvZCBtaWdodCBiZSB0byBwb3B1cCBhIGNvbmZpcm1hdGlvbiBtb2RhbC4gWW91IGNhblxyXG4gICAgICAgICAgICAgKiByZXR1cm4gYSBib29sZWFuIG9yIElUaGVuYWJsZTxib29sZWFuPiB0byBhY2NlcHQvcmVqZWN0IG5hdmlnYXRpb24uXHJcbiAgICAgICAgICAgICAqIEEgd29yZCBvZiBjYXV0aW9uLCB0aGlzIGlzIGEgbmF2aWdhdGlvbi1ibG9ja2luZyBmdW5jdGlvbi4gSXQgaXMgYmVzdCB0byBhdm9pZCBsb25nLXJ1bm5pbmcgZnVuY3Rpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmlld0NvbnRyb2wucHJvdG90eXBlLmNhbk5hdmlnYXRlRnJvbSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFsbG93cyBhIFZpZXdDb250cm9sIHRvIGFzeW5jaHJvbm91c2x5IGRlY2lkZSBpZiBpdCBjYW4gYmUgbmF2aWdhdGVkIHRvIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMvcXVlcnkuXHJcbiAgICAgICAgICAgICAqIFlvdSBjYW4gcmV0dXJuIGEgYm9vbGVhbiBvciBJVGhlbmFibGU8Ym9vbGVhbj4gdG8gYWNjZXB0L3JlamVjdCBuYXZpZ2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBBIHdvcmQgb2YgY2F1dGlvbiwgdGhpcyBpcyBhIG5hdmlnYXRpb24tYmxvY2tpbmcgZnVuY3Rpb24uIEl0IGlzIGJlc3QgdG8gYXZvaWQgbG9uZy1ydW5uaW5nIGZ1bmN0aW9ucy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZpZXdDb250cm9sLnByb3RvdHlwZS5jYW5OYXZpZ2F0ZVRvID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMsIHF1ZXJ5KSB7IH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgVmlld0NvbnRyb2wgaXMgZ29pbmcgb3V0IG9mIHNjb3BlIGFzIGEgcmVzdWx0IG9mIGEgbmF2aWdhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZpZXdDb250cm9sLnByb3RvdHlwZS5uYXZpZ2F0aW5nRnJvbSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBWaWV3Q29udHJvbCBoYXMgY29tZSBpbnRvIHNjb3BlIGFzIGEgcmVzdWx0IG9mIG5hdmlnYXRpb24uIEl0IGNhblxyXG4gICAgICAgICAgICAgKiByZWNlaXZlIHRoZSByb3V0ZSBwYXJhbWV0ZXJzIGFuZCBxdWVyeSBpbiBvcmRlciB0byBzZXQgaXRzIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaWV3Q29udHJvbC5wcm90b3R5cGUubmF2aWdhdGVkVG8gPSBmdW5jdGlvbiAocGFyYW1ldGVycywgcXVlcnkpIHsgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFZpZXdDb250cm9sO1xyXG4gICAgICAgIH0oVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICAgICAgdWkuVmlld0NvbnRyb2wgPSBWaWV3Q29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBleHRlbnNpYmxlIGNsYXNzIGRlYWxpbmcgd2l0aCB0aGUgY3JlYXRpb24sIGRlbGV0aW9uLCBhbmQgbW9kaWZpY2F0aW9uXHJcbiAgICAgICAgICogb2YgRE9NLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBEb20oKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgRG9tRXZlbnRzIGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2RvbUV2ZW50cyA9IGFjcXVpcmUoX19Eb21FdmVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvbUV2ZW50cy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5hcHBlbmRDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlTGlzdCwgcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGVuZENoaWxkcmVuKG5vZGVMaXN0LCByb290KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5jbG9uZUNoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGVMaXN0LCByb290KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwZW5kQ2hpbGRyZW4obm9kZUxpc3QsIHJvb3QsIHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xlYXJzIGEgRE9NIE5vZGUgYnkgcmVtb3ZpbmcgYWxsIG9mIGl0cyBjaGlsZE5vZGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIERPTSBOb2RlIHRvIGNsZWFyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5jbGVhck5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyTm9kZShub2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5jbGVhck5vZGVCbG9jayA9IGZ1bmN0aW9uIChub2RlTGlzdCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJOb2RlQmxvY2sobm9kZUxpc3QsIHBhcmVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBpbm5lckhUTUwgb2YgYSBOb2RlLiBDYW4gdGFrZSBpbiBhIE5vZGUgcmF0aGVyIHRoYW4gYW4gRWxlbWVudFxyXG4gICAgICAgICAgICAgKiBiZWNhdXNlIGl0IGRvZXMgbm90IHVzZSBpbm5lckhUTUwgb24gdGhlIHBhc3NlZC1pbiBOb2RlIChpdCBhcHBlbmRzIGl0c1xyXG4gICAgICAgICAgICAgKiBjaGlsZE5vZGVzKS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBOb2RlIHRvIHNldCBpbm5lckhUTUwuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIEhUTUwgc3RyaW5nIHRvIGJlIHB1dCBpbnNpZGUgdGhlIG5vZGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLnNldElubmVySHRtbCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0SW5uZXJIdG1sKG5vZGUsIGh0bWwpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uIChwYXJlbnQsIG5vZGVzLCBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZXMsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGFrZXMgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBnaXZlbiBub2RlIGFuZCBwbGFjZXMgdGhlbSBhYm92ZSB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgKiBpbiB0aGUgRE9NLiBUaGVuIHJlbW92ZXMgdGhlIGdpdmVuIG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgTm9kZSB0byByZXBsYWNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlKG5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlV2l0aChub2RlLCBuZXdOb2RlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2VzIGluIGEgc3RyaW5nIHJlcHJlc2VudGluZyBpbm5lckhUTUwgYW5kIHJldHVybnMgYSBEb2N1bWVudEZyYWdtZW50XHJcbiAgICAgICAgICAgICAqIGNvbnRhaW5pbmcgdGhlIHNlcmlhbGl6ZWQgRE9NLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBUaGUgRE9NIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUuc2VyaWFsaXplSHRtbCA9IGZ1bmN0aW9uIChodG1sKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplSHRtbChodG1sKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2VzIGluIGEgc3RhcnROb2RlIGFuZCBlbmROb2RlLCBlYWNoIGhhdmluZyB0aGUgc2FtZSBwYXJlbnROb2RlLlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGV2ZXJ5IG5vZGUgaW4gYmV0d2VlbiB0aGUgc3RhcnROb2RlLiAgSWYgZW5kTm9kZSBpcyBub3Qgc3BlY2lmaWVkLFxyXG4gICAgICAgICAgICAgKiBET00gd2lsbCBiZSByZW1vdmVkIHVudGlsIHRoZSBlbmQgb2YgdGhlIHBhcmVudE5vZGUncyBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBzdGFydE5vZGUgVGhlIHN0YXJ0aW5nIG5vZGUsIHdoaWNoIHdpbGwgbm90IGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gZW5kTm9kZSBUaGUgZW5kaW5nIG5vZGUsIHdoaWNoIHdpbGwgbm90IGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLnJlbW92ZUJldHdlZW4gPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlQmV0d2VlbihzdGFydE5vZGUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGFrZXMgaW4gYSBzdGFydE5vZGUgYW5kIGVuZE5vZGUsIGVhY2ggaGF2aW5nIHRoZSBzYW1lIHBhcmVudE5vZGUuXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgZXZlcnkgbm9kZSBpbiBiZXR3ZWVuIHRoZSBzdGFydE5vZGUgYW5kIGVuZE5vZGUgYXMgd2VsbCBhc1xyXG4gICAgICAgICAgICAgKiB0aGUgc3RhcnROb2RlIGFuZCB0aGUgZW5kTm9kZS4gIElmIGVuZE5vZGUgaXMgbm90IHNwZWNpZmllZCwgRE9NXHJcbiAgICAgICAgICAgICAqIHdpbGwgYmUgcmVtb3ZlZCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBwYXJlbnROb2RlJ3MgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnROb2RlIFRoZSBmaXJzdCBub2RlIHRvIHJlbW92ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBlbmROb2RlIFRoZSBsYXN0IG5vZGUgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5yZW1vdmVBbGwgPSBmdW5jdGlvbiAoc3RhcnROb2RlLCBlbmROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlQWxsKHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgY2xhc3Mgb3IgbXVsdGlwbGUgY2xhc3NlcyB0byB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgY2xhc3MgbmFtZSBpcyBiZWluZyBhZGRlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZSBvciBzcGFjZSBkZWxpbWl0ZWQgY2xhc3MgbmFtZXMgdG8gYWRkIHRvIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBhIGNsYXNzIG9yIG11bHRpcGxlIGNsYXNzZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBjbGFzcyBuYW1lIGlzIGJlaW5nIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUgb3Igc3BhY2UgZGVsaW1pdGVkIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVG9nZ2xlcyBhIGNsYXNzIG9yIG11bHRpcGxlIGNsYXNzZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBvbiB3aGljaCB0aGUgY2xhc3MgbmFtZSBpcyBiZWluZyB0b2dnbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzcyBuYW1lIG9yIHNwYWNlIGRlbGltaXRlZCBjbGFzcyBuYW1lcyB0byB0b2dnbGUgb24gdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLnRvZ2dsZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvZ2dsZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXBsYWNlcyBhIHNpbmdsZSBjbGFzcyB3aXRoIGFub3RoZXIgY2xhc3MuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBvbiB3aGljaCB0aGUgY2xhc3MgbmFtZSBpcyBiZWluZyB0b2dnbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkQ2xhc3MgVGhlIGNsYXNzIG5hbWUgYmVpbmcgcmVwbGFjZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdDbGFzcyBUaGUgY2xhc3MgbmFtZSBkb2luZyB0aGUgcmVwbGFjaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5yZXBsYWNlQ2xhc3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgb2xkQ2xhc3MsIG5ld0NsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZUNsYXNzKGVsZW1lbnQsIG9sZENsYXNzLCBuZXdDbGFzcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIGVsZW1lbnQgaGFzIGEgcGFydGljdWxhciBjbGFzcyBvciBjbGFzc2VzIGFzc2lnbmVkIHRvIGl0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGNsYXNzIG5hbWUgaXMgYmVpbmcgY2hlY2tlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZSBvciBzcGFjZSBkZWxpbWl0ZWQgY2xhc3MgbmFtZXMgdG8gY2hlY2sgb24gdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb20ucHJvdG90eXBlLmhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZXMgYW5kIHNlcmlhbGl6ZXMgSFRNTCBmcm9tIGFuIEhUTUwgdGVtcGxhdGUgZmlsZSB1c2luZyBhamF4LiBXaWxsIGZhY2lsaXRhdGUgY2FjaGluZyB0aGUgdGVtcGxhdGVcclxuICAgICAgICAgICAgICogYXMgd2VsbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlVXJsIFRoZSB1cmwgd2hlcmUgdGhlIEhUTUwgdGVtcGxhdGUgaXMgc3RvcmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZVVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFRlbXBsYXRlKHRlbXBsYXRlVXJsKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluc3BlY3RzIHRoZSBFbGVtZW50IGFuZCByZXNvbHZlcyB3aGVuIHRoZSBFbGVtZW50IGlzIHByZXNlbnQgaW4gdGhlIERPTSBib2R5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGNiIEEgY2FsbGJhY2sgdGhhdCB3aWxsIGZpcmUgd2hlbiB0aGUgZWxlbWVudCBpcyBwcmVzZW50IGluIHRoZSBET00gYm9keS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdob3NlIHByZXNlbmNlIGlzIGJlaW5nIGluc3BlY3RlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbS5wcm90b3R5cGUud2hlblByZXNlbnQgPSBmdW5jdGlvbiAoY2IsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB3aGVuUHJlc2VudChjYiwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnNwZWN0cyB0aGUgRWxlbWVudCBhbmQgcmVzb2x2ZXMgd2hlbiB0aGUgRWxlbWVudCBpcyB2aXNpYmxlIGluIHRoZSBET00uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2IgQSBjYWxsYmFjayB0aGF0IHdpbGwgZmlyZSB3aGVuIHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gdGhlIERPTS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdob3NlIHZpc2liaWxpdHkgaXMgYmVpbmcgaW5zcGVjdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tLnByb3RvdHlwZS53aGVuVmlzaWJsZSA9IGZ1bmN0aW9uIChjYiwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdoZW5WaXNpYmxlKGNiLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgRG9tLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfZG9tRXZlbnRzOiBfX0RvbUV2ZW50c1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRG9tO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgdWkuRG9tID0gRG9tO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Eb20sIERvbSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsYXNzIHdoaWNoIHByb3ZpZGVzIGEgd2F5IGZvciBUZW1wbGF0ZUNvbnRyb2xzIHRvIGJpbmQgYSB0ZW1wbGF0ZVxyXG4gICAgICAgICAqIHRvIGEgY29udGV4dC4gVXNlZnVsIGZvciBuYXJyb3dpbmcgY29udGV4dCB3aXRob3V0IG5lZWRpbmcgYW5vdGhlclxyXG4gICAgICAgICAqIFRlbXBsYXRlQ29udHJvbC4gSW4gYWRkaXRpb24sIHRoaXMgb2JqZWN0IHByb3ZpZGVzIGEgcGVyZm9ybWFuY2UgaW5jcmVhc2UgYmVjYXVzZVxyXG4gICAgICAgICAqIGl0IHdpbGwgb25seSBjb21waWxlIHRoZSB0ZW1wbGF0ZSBvbmNlLiBUaGlzIG9iamVjdCBpcyBhbHNvIHVzZWZ1bCB3aGVuIGFcclxuICAgICAgICAgKiBUZW1wbGF0ZUNvbnRyb2xzIGV4cGVjdHMgbXVsdGlwbGUgY29uZmlndXJhdGlvbiB0ZW1wbGF0ZXMgaW4gaXRzIGlubmVySFRNTC4gSXQgY2FuXHJcbiAgICAgICAgICogc2VwYXJhdGUgdGhvc2UgdGVtcGxhdGVzIGFuZCByZXVzZSB0aGVtIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBCaW5kYWJsZVRlbXBsYXRlcyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJpbmRhYmxlVGVtcGxhdGVzKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIElSZXNvdXJjZXNGYWN0b3J5IGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX1Jlc291cmNlc0ZhY3RvcnkgPSBhY3F1aXJlKF9fUmVzb3VyY2VzRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgSUNvbnRyb2xGYWN0b3J5IGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX0NvbnRyb2xGYWN0b3J5ID0gYWNxdWlyZShfX0NvbnRyb2xGYWN0b3J5KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBJVGVtcGxhdGVDb250cm9sRmFjdG9yeSBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gYWNxdWlyZShfX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIElDb250ZXh0TWFuYWdlclN0YXRpYyBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9Db250ZXh0TWFuYWdlciA9IGFjcXVpcmUoX19Db250ZXh0TWFuYWdlclN0YXRpYyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgSVByb21pc2UgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZSA9IGFjcXVpcmUoX19Qcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIGEgY2FjaGUgaW5qZWN0YWJsZSB0aGF0IHN0b3JlcyBFbGVtZW50TWFuYWdlcnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZXJDYWNoZSA9IGFjcXVpcmUoX19NYW5hZ2VyQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50IGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50ID0gYWNxdWlyZShfX0RvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBJRWxlbWVudE1hbmFnZXJGYWN0b3J5IGluamVjdGFibGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeSA9IGFjcXVpcmUoX19FbGVtZW50TWFuYWdlckZhY3RvcnkpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIEJpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeSBpbmplY3RhYmxlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgPSBhY3F1aXJlKF9fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBMb2cgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nID0gYWNxdWlyZShfX0xvZyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFN0b3JlcyBwcm9taXNlcyB0aGF0IHJlc29sdmUgdG8gYWxsIHRoZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIHRoaXMgb2JqZWN0LCByZWFkeSB0byBiZSBib3VuZCB0byBhIGRhdGEgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqIEFsbCBjcmVhdGVkIHRlbXBsYXRlcyBhcmUgRG9jdW1lbnRGcmFnbWVudHMsIGFsbG93aW5nIGFuIFRlbXBsYXRlQ29udHJvbCB0b1xyXG4gICAgICAgICAgICAgICAgICogZWFzaWx5IGluc2VydCB0aGUgdGVtcGxhdGUgaW50byB0aGUgRE9NICh3aXRob3V0IGl0ZXJhdGluZyBvdmVyIGNoaWxkTm9kZXMpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGtleWVkIGNhY2hlIG9mIEVsZW1lbnRNYW5hZ2VycyB0aGF0IHJlcHJlc2VudCB0aGUgcm9vdHMgb2YgY29tcGlsZWQgdGVtcGxhdGVzXHJcbiAgICAgICAgICAgICAgICAgKiBjcmVhdGVkIGJ5IHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIGFsbCB0aGUgY29udHJvbHMgY3JlYXRlZCB3aGlsZSBjb21waWxpbmcgYW4gYWRkZWQgdGVtcGxhdGUuIFVzZWZ1bCBkdXJpbmcgZGlzcG9zYWwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19jb21waWxlZENvbnRyb2xzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQmluZGFibGVUZW1wbGF0ZXMgYW5kIHJldHVybnMgaXQuIElmIGEgQmluZGFibGVUZW1wbGF0ZXMgaXNcclxuICAgICAgICAgICAgICogcGFzc2VkIGluLCBpdCB3aWxsIHVzZSB0aGUgcHJvcGVydGllcyBvbiB0aGUgb3JpZ2luYWwgQmluZGFibGVUZW1wbGF0ZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBjb250YWluaW5nIHRoZSBuZXcgQmluZGFibGVUZW1wbGF0ZXMgb2JqZWN0LCB1c2VkIGZvciBkYXRhXHJcbiAgICAgICAgICAgICAqIGNvbnRleHQgaW5oZXJpdGFuY2UgZm9yIHRlbXBsYXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLkJpbmRhYmxlVGVtcGxhdGVzfSBvcmlnaW5hbD8gQW4gb3B0aW9uYWwgQmluZGFibGVUZW1wbGF0ZXNcclxuICAgICAgICAgICAgICogb2JqZWN0IHRvIGNvcHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5jcmVhdGUgPSBmdW5jdGlvbiAoY29udHJvbCwgb3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kYWJsZVRlbXBsYXRlcyA9IG5ldyBCaW5kYWJsZVRlbXBsYXRlcygpO1xyXG4gICAgICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMuY29udHJvbCA9IGNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChvcmlnaW5hbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5kYWJsZVRlbXBsYXRlcy50ZW1wbGF0ZXMgPSBvcmlnaW5hbC50ZW1wbGF0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMuY2FjaGUgPSBvcmlnaW5hbC5jYWNoZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBiaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsZWFycyB0aGUgbWVtb3J5IGJlaW5nIGhlbGQgYnkgY29udHJvbCdzIGJpbmRhYmxlVGVtcGxhdGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIGJpbmRhYmxlVGVtcGxhdGVzIHdpbGwgYmUgZGlzcG9zZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5kaXNwb3NlID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjb250cm9sLmJpbmRhYmxlVGVtcGxhdGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpbnN0YW5jZSkgfHwgIWlzRnVuY3Rpb24oaW5zdGFuY2UuZGlzcG9zZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgY29udHJvbCB3YXMgY3JlYXRlZCB1c2luZyBiaW5kYWJsZVRlbXBsYXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgcG90ZW50aWFsIGJvdW5kIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5pc0JvdW5kQ29udHJvbCA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGNvbnRyb2wucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2wudHlwZS5pbmRleE9mKHBhcmVudC50eXBlICsgX19CT1VORF9QUkVGSVgpID09PSAwO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcmVsYXRpdmVJZGVudGlmaWVyLCByZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUodGhpcy5fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gc2VyaWFsaXplSHRtbCh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RvY3VtZW50RnJhZ21lbnQodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0ZW1wbGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGUodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2UodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKHRlbXBsYXRlLCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIShpc051bGwocmVsYXRpdmVJZGVudGlmaWVyKSB8fCBpc051bWJlcihyZWxhdGl2ZUlkZW50aWZpZXIpIHx8IGlzU3RyaW5nKHJlbGF0aXZlSWRlbnRpZmllcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy5jb250cm9sLnR5cGUgKyAnIGNhbm5vdCBiaW5kIHRlbXBsYXRlIHdpdGggcmVsYXRpdmVJZGVudGlmaWVyOiAnICsgcmVsYXRpdmVJZGVudGlmaWVyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJy4gSWRlbnRpZmllciBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXInKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5jb250cm9sLCBjb250cm9sTWFuYWdlciA9IHRoaXMuX21hbmFnZXJDYWNoZS5yZWFkKHBhcmVudC51aWQpLCBtYW5hZ2VyID0gdGhpcy5fRWxlbWVudE1hbmFnZXJGYWN0b3J5LmdldEluc3RhbmNlKCksIGNvbnRyb2wgPSB0aGlzLl9jcmVhdGVCb3VuZENvbnRyb2woJycsIGZyYWdtZW50LCByZWxhdGl2ZUlkZW50aWZpZXIsIHJlc291cmNlcyksIG5vZGVNYXAgPSB0aGlzLl9jcmVhdGVOb2RlTWFwKGNvbnRyb2wsIGZyYWdtZW50LCByZWxhdGl2ZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sTWFuYWdlci5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKG5vZGVNYXAsIGNvbnRyb2xNYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuc2V0VWlDb250cm9sVGVtcGxhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLmZ1bGZpbGxBbmRMb2FkKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IF90aGlzLl9kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLnN0YXJ0Tm9kZSA9IGZyYWdtZW50Lmluc2VydEJlZm9yZShfZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250cm9sLnR5cGUgKyBfX1NUQVJUX05PREUpLCBmcmFnbWVudC5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmVuZE5vZGUgPSBmcmFnbWVudC5pbnNlcnRCZWZvcmUoX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udHJvbC50eXBlICsgX19FTkRfTk9ERSksIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChrZXksIHJlbGF0aXZlSWRlbnRpZmllciwgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmluZChrZXksIHJlbGF0aXZlSWRlbnRpZmllciwgcmVzb3VyY2VzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChrZXksIHRlbXBsYXRlLCBvdmVyd3JpdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcodGhpcy5jb250cm9sLnR5cGUgKyAnIG11c3QgdXNlIGEgdmFsaWQga2V5IHRvIGFkZCBhIHRlbXBsYXRlIHRvIEJpbmRhYmxlVGVtcGxhdGVzLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVByb21pc2UgPSB0aGlzLnRlbXBsYXRlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGVtcGxhdGVQcm9taXNlKSAmJiAhb3ZlcndyaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21waWxlKGtleSwgc2VyaWFsaXplSHRtbCh0ZW1wbGF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRG9jdW1lbnRGcmFnbWVudCh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21waWxlKGtleSwgdGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05vZGUodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2UodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRyZW4odGVtcGxhdGUsIGZyYWdtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGUoa2V5LCBmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKGluZGV4LCBrZXksIHJlbGF0aXZlSWRlbnRpZmllciwgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHRoaXMuY29udHJvbC5jb250cm9sc1tpbmRleF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUJpbmRhYmxlVGVtcGxhdGVzLmlzQm91bmRDb250cm9sKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ1RoZSBjaGlsZCBjb250cm9sIG9mICcgKyB0aGlzLmNvbnRyb2wudHlwZSArICcgYXQgdGhlIHNwZWNpZmllZCBpbmRleDogJyArIGluZGV4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBpcyBub3QgYSBib3VuZCBjb250cm9sIGFuZCB0aHVzIGNhbm5vdCBiZSByZXBsYWNlZCBieSBCaW5kYWJsZVRlbXBsYXRlcy4nKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKFtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlbmROb2RlID0gY29udHJvbC5lbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoaXNOb2RlKGVuZE5vZGUpICYmIGlzTm9kZShlbmROb2RlLnBhcmVudE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdUaGUgY2hpbGQgY29udHJvbCBvZiAnICsgdGhpcy5jb250cm9sLnR5cGUgKyAnIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXg6ICcgKyBpbmRleCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcgaGFkIGVpdGhlciBubyBwbGFjZWhvbGRpbmcgY29tbWVudCBub2RlcyBvciBpdHMgY29tbWVudCBub2RlcyBoYWQgbm8gcGFyZW50IGFuZCB0aHVzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2Fubm90IGJlIHJlcGxhY2VkIGJ5IEJpbmRhYmxlVGVtcGxhdGVzLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JpbmQoa2V5LCByZWxhdGl2ZUlkZW50aWZpZXIsIHJlc291cmNlcywgaW5kZXgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xlYXJzIHRoZSBtZW1vcnkgYmVpbmcgaGVsZCBieSB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZSA9IHRoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZGlzcG9zZSwgY29tcGlsZWRDb250cm9scyA9IHRoaXMuX19jb21waWxlZENvbnRyb2xzLCBsZW5ndGggPSBjb21waWxlZENvbnRyb2xzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlKGNvbXBpbGVkQ29udHJvbHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbXBpbGVkQ29udHJvbHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlcyA9IHt9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWV0aG9kIGZvciBsaW5raW5nIGEgdGVtcGxhdGUgdG8gYSBkYXRhIGNvbnRleHQgYW5kIHJldHVybmluZyBhIGNsb25lIG9mIHRoZSB0ZW1wbGF0ZSxcclxuICAgICAgICAgICAgICogd2l0aCBhbGwgbmV3IENvbnRyb2xzIGNyZWF0ZWQgaWYgdGhlIHRlbXBsYXRlIGNvbnRhaW5zIGNvbnRyb2xzLiBJZiBubyBkYXRhIGNvbnRleHRcclxuICAgICAgICAgICAgICogaXMgc3BlY2lmaWVkLCBpdCB3aWxsIGJlIGluaGVyaXRlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHVzZWQgdG8gcmV0cmlldmUgdGhlIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVJZGVudGlmaWVyPyBUaGUgaWRlbnRpZmllciBzdHJpbmcgcmVsYXRpdmUgdG8gdGhpcyBjb250cm9sJ3MgY29udGV4dFxyXG4gICAgICAgICAgICAgKiAoZS5nLiAnZm9vLmJhci5iYXonIHdvdWxkIHNpZ25pZnkgdGhlIG9iamVjdCB0aGlzLmNvbnRleHQuZm9vLmJhci5iYXopLiBUaGlzIGlzIHRoZVxyXG4gICAgICAgICAgICAgKiBtb3N0IGVmZmljaWVudCB3YXkgb2Ygc3BlY2lmeWluZyBjb250ZXh0LCBlbHNlIHRoZSBmcmFtZXdvcmsgaGFzIHRvIHNlYXJjaCBmb3IgdGhlXHJcbiAgICAgICAgICAgICAqIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklPYmplY3Q8cGxhdC5JUmVzb3VyY2U+fSByZXNvdXJjZXM/IEFuIG9iamVjdCB1c2VkIGFzIHRoZSByZXNvdXJjZXMgZm9yIGFueSB0b3AtbGV2ZWxcclxuICAgICAgICAgICAgICogY29udHJvbHMgY3JlYXRlZCBpbiB0aGUgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleD8gQW4gb3B0aW9uYWwgaW5kZXggb25seSB0byBiZSB1c2VkIGlmIHRoZSBuZXdseSBib3VuZCB0ZW1wbGF0ZSBpcyBpbnRlbmRlZCB0b1xyXG4gICAgICAgICAgICAgKiByZXBsYWNlIGFuIGV4aXN0aW5nIENvbnRyb2wgaW4gdGhlIGNoaWxkIGNvbnRyb2xzIEFycmF5IGFuZCBpdHMgZWxlbWVudCBpbiB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLl9iaW5kID0gZnVuY3Rpb24gKGtleSwgcmVsYXRpdmVJZGVudGlmaWVyLCByZXNvdXJjZXMsIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlUHJvbWlzZSA9IHRoaXMudGVtcGxhdGVzW2tleV0sIG5vSW5kZXggPSBpc051bGwoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0ZW1wbGF0ZVByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmVycm9yKG5ldyBFcnJvcih0aGlzLmNvbnRyb2wudHlwZSArICcgY2Fubm90IGJpbmQgdGVtcGxhdGUsIG5vIHRlbXBsYXRlIHN0b3JlZCB3aXRoIGtleTogJyArIGtleSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghKGlzTnVsbChyZWxhdGl2ZUlkZW50aWZpZXIpIHx8IGlzTnVtYmVyKHJlbGF0aXZlSWRlbnRpZmllcikgfHwgaXNTdHJpbmcocmVsYXRpdmVJZGVudGlmaWVyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLmNvbnRyb2wudHlwZSArICcgY2Fubm90IGJpbmQgdGVtcGxhdGUgd2l0aCByZWxhdGl2ZUlkZW50aWZpZXI6ICcgKyByZWxhdGl2ZUlkZW50aWZpZXIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiBJZGVudGlmaWVyIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlcicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlUHJvbWlzZSA9IHRlbXBsYXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSByZXN1bHQuY2xvbmVOb2RlKHRydWUpLCBjb250cm9sID0gX3RoaXMuX2NyZWF0ZUJvdW5kQ29udHJvbChrZXksIHRlbXBsYXRlLCByZWxhdGl2ZUlkZW50aWZpZXIsIHJlc291cmNlcyksIG5vZGVNYXAgPSBfdGhpcy5fY3JlYXRlTm9kZU1hcChjb250cm9sLCB0ZW1wbGF0ZSwgcmVsYXRpdmVJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sLmNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYmluZFRlbXBsYXRlKGtleSwgbm9kZU1hcCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmICghbm9JbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZVByb21pc2UudGhlbihmdW5jdGlvbiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcmFnbWVudC5jaGlsZE5vZGVzKSwgb2xkQ29udHJvbCA9IF90aGlzLmNvbnRyb2wuY29udHJvbHNbaW5kZXhdLCBlbmROb2RlID0gb2xkQ29udHJvbC5lbmROb2RlLCBwYXJlbnROb2RlID0gZW5kTm9kZS5wYXJlbnROb2RlLCBuZXh0U2libGluZyA9IGVuZE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmRpc3Bvc2Uob2xkQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBuZXh0U2libGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlUHJvbWlzZS50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIHRoZSB0ZW1wbGF0ZSdzIGJvdW5kIGNvbnRyb2wgYW5kIElOb2RlTWFwIGFuZCBpbml0aWF0ZXNcclxuICAgICAgICAgICAgICogdGhlIGJpbmRpbmcgb2YgdGhlIElOb2RlTWFwIGZvciBhIGNsb25lZCB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGVtcGxhdGUga2V5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gbm9kZU1hcCBUaGUgbm9kZSBtYXAgdG8gYmluZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlID0gZnVuY3Rpb24gKGtleSwgbm9kZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gbm9kZU1hcC51aUNvbnRyb2xOb2RlLmNvbnRyb2wsIGRpc3Bvc2VkID0gZmFsc2UsIGRpc3Bvc2UgPSBpc0Z1bmN0aW9uKGNvbnRyb2wuZGlzcG9zZSkgPyBjb250cm9sLmRpc3Bvc2UuYmluZChjb250cm9sKSA6IG5vb3A7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmRpc3Bvc2UgPSBkaXNwb3NlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5kTm9kZU1hcChrZXksIG5vZGVNYXApLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSBfdGhpcy5fZG9jdW1lbnQsIHRlbXBsYXRlID0gbm9kZU1hcC5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5zdGFydE5vZGUgPSB0ZW1wbGF0ZS5pbnNlcnRCZWZvcmUoX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udHJvbC50eXBlICsgX19TVEFSVF9OT0RFKSwgdGVtcGxhdGUuZmlyc3RDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5lbmROb2RlID0gdGVtcGxhdGUuaW5zZXJ0QmVmb3JlKF9kb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRyb2wudHlwZSArIF9fRU5EX05PREUpLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIHRoZSBjb21waWxlZCBFbGVtZW50TWFuYWdlciB1c2luZyB0aGUgbmV3bHkgY3JlYXRlZFxyXG4gICAgICAgICAgICAgKiBJTm9kZU1hcCBhbmQgYmluZHMgYW5kIGxvYWRzIHRoaXMgY29udHJvbCdzXHJcbiAgICAgICAgICAgICAqIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0ZW1wbGF0ZSBrZXkgdXNlZCB0byBncmFiIHRoZSBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IG5vZGVNYXAgVGhlIG5vZGUgbWFwIHRvIGJpbmQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUuX2JpbmROb2RlTWFwID0gZnVuY3Rpb24gKGtleSwgbm9kZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSB0aGlzLmNhY2hlW2tleV0sIGNoaWxkID0gbm9kZU1hcC51aUNvbnRyb2xOb2RlLmNvbnRyb2wsIHRlbXBsYXRlID0gbm9kZU1hcC5lbGVtZW50LCBfbWFuYWdlckNhY2hlID0gdGhpcy5fbWFuYWdlckNhY2hlO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5jbG9uZSh0ZW1wbGF0ZSwgX21hbmFnZXJDYWNoZS5yZWFkKHRoaXMuY29udHJvbC51aWQpLCBub2RlTWFwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfbWFuYWdlckNhY2hlLnJlYWQoY2hpbGQudWlkKS5iaW5kQW5kTG9hZCgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyB0aGUgdGVtcGxhdGUncyBjb21waWxlZCwgYm91bmQgY29udHJvbCBhbmQgSU5vZGVNYXAgYW5kIGluaXRpYXRlc1xyXG4gICAgICAgICAgICAgKiB0aGUgY29tcGlsYXRpb24gb2YgdGhlIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0ZW1wbGF0ZSBrZXkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGUgVGhlIEhUTUwgdGVtcGxhdGUgYmVpbmcgYm91bmQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUuX2NvbXBpbGUgPSBmdW5jdGlvbiAoa2V5LCB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9jcmVhdGVCb3VuZENvbnRyb2woa2V5ICsgX19DT01QSUxFRCwgdGVtcGxhdGUpLCBub2RlTWFwID0gdGhpcy5fY3JlYXRlTm9kZU1hcChjb250cm9sLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29tcGlsZWRDb250cm9scy5wdXNoKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZU5vZGVNYXAoY29udHJvbCwgbm9kZU1hcCwga2V5KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluc3RhbnRpYXRlcyBhIG5ldyBFbGVtZW50TWFuYWdlciBmb3IgdGhlIHJvb3Qgb2YgdGhpc1xyXG4gICAgICAgICAgICAgKiB0ZW1wbGF0ZSBhbmQgcmVzb2x2ZXMgYW55IGFzeW5jaHJvbm91cyB1cmwgdGVtcGxhdGVzIHdpdGhpbiB0aGUgdGVtcGxhdGUgYmVpbmcgY29tcGlsZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIG5ld2x5IGNyZWF0ZWQgY29udHJvbCB1c2VkIHRvIGJpbmQgdGhlIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gbm9kZU1hcCBUaGUgbmV3bHkgY3JlYXRlZCBub2RlIG1hcCB0byBiaW5kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSB0ZW1wbGF0ZSBrZXkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kYWJsZVRlbXBsYXRlcy5wcm90b3R5cGUuX2NvbXBpbGVOb2RlTWFwID0gZnVuY3Rpb24gKGNvbnRyb2wsIG5vZGVNYXAsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcy5fRWxlbWVudE1hbmFnZXJGYWN0b3J5LmdldEluc3RhbmNlKCksIHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLmlzQ2xvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKG5vZGVNYXAsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5zZXRVaUNvbnRyb2xUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZVtrZXldID0gbWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2gobWFuYWdlci5mdWxmaWxsVGVtcGxhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlc1trZXldID0gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbm9kZU1hcC5lbGVtZW50LCBjbG9uZSA9IGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpLCBfZG9jdW1lbnQgPSBfdGhpcy5fZG9jdW1lbnQsIHN0YXJ0Tm9kZSA9IGNvbnRyb2wuc3RhcnROb2RlID0gX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udHJvbC50eXBlICsgX19TVEFSVF9OT0RFKSwgZW5kTm9kZSA9IGNvbnRyb2wuZW5kTm9kZSA9IF9kb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRyb2wudHlwZSArIF9fRU5EX05PREUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0Tm9kZSwgZWxlbWVudC5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShlbmROb2RlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYW4gSU5vZGVNYXAgZm9yIGVpdGhlciBhIHRlbXBsYXRlIGJlaW5nIGNvbXBpbGVkIG9yIGFcclxuICAgICAgICAgICAgICogdGVtcGxhdGUgYmVpbmcgYm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHVpQ29udHJvbCBUaGUgbmV3bHkgY3JlYXRlZCBjb250cm9sIHVzZWQgdG8gYmluZCB0aGUgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gdGVtcGxhdGUgVGhlIHRlbXBsYXRlIGJlaW5nIGNvbXBpbGVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpbGRDb250ZXh0PyBBIHBvdGVudGlhbCBjaGlsZCBjb250ZXh0IHN0cmluZyBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZGFibGVUZW1wbGF0ZXMucHJvdG90eXBlLl9jcmVhdGVOb2RlTWFwID0gZnVuY3Rpb24gKHVpQ29udHJvbCwgdGVtcGxhdGUsIGNoaWxkQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0ZW1wbGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBub2RlczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0OiBjaGlsZENvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sTm9kZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB1aUNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiB1aUNvbnRyb2wudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvcjogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgVGVtcGxhdGVDb250cm9sIHVzZWQgZm9yIGJpbmRpbmcgZWl0aGVyIGEgdGVtcGxhdGUgYmVpbmcgY29tcGlsZWRcclxuICAgICAgICAgICAgICogb3IgYSB0ZW1wbGF0ZSBiZWluZyBib3VuZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgdGVtcGxhdGUga2V5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSBiZWluZyBjb21waWxlZCBvciBiZWluZyBib3VuZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklPYmplY3Q8cGxhdC51aS5JUmVzb3VyY2U+fSByZXNvdXJjZXM/IEEgc2V0IG9mIHJlc291cmNlcyB0byBhZGQgdG8gdGhlIGNvbnRyb2wgdXNlZCB0b1xyXG4gICAgICAgICAgICAgKiBjb21waWxlL2JpbmQgdGhpcyB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmRhYmxlVGVtcGxhdGVzLnByb3RvdHlwZS5fY3JlYXRlQm91bmRDb250cm9sID0gZnVuY3Rpb24gKGtleSwgdGVtcGxhdGUsIGNoaWxkQ29udGV4dCwgcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkgPSB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LCBjb250cm9sID0gX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZ2V0SW5zdGFuY2UoKSwgX1Jlc291cmNlc0ZhY3RvcnkgPSB0aGlzLl9SZXNvdXJjZXNGYWN0b3J5LCBwYXJlbnQgPSB0aGlzLmNvbnRyb2wsIGNvbXBpbGVkTWFuYWdlciA9IHRoaXMuY2FjaGVba2V5XSwgaXNDb21waWxlZCA9IGlzT2JqZWN0KGNvbXBpbGVkTWFuYWdlciksIF9yZXNvdXJjZXMgPSBfUmVzb3VyY2VzRmFjdG9yeS5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tcGlsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGlsZWRDb250cm9sID0gY29tcGlsZWRNYW5hZ2VyLmdldFVpQ29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNvdXJjZXMuaW5pdGlhbGl6ZShjb250cm9sLCBjb21waWxlZENvbnRyb2wucmVzb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBfcmVzb3VyY2VzLmFkZChyZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc291cmNlcy5pbml0aWFsaXplKGNvbnRyb2wsIHJlc291cmNlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc291cmNlcyA9IF9yZXNvdXJjZXM7XHJcbiAgICAgICAgICAgICAgICBfUmVzb3VyY2VzRmFjdG9yeS5hZGRDb250cm9sUmVzb3VyY2VzKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcyA9IHRoaXMuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeS5jcmVhdGUoY29udHJvbCwgcGFyZW50LmJpbmRhYmxlVGVtcGxhdGVzKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5jb250cm9scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5lbGVtZW50ID0gdGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnR5cGUgPSBwYXJlbnQudHlwZSArIF9fQk9VTkRfUFJFRklYICsga2V5O1xyXG4gICAgICAgICAgICAgICAgY29udHJvbC5yb290ID0gdGhpcy5fQ29udHJvbEZhY3RvcnkuZ2V0Um9vdENvbnRyb2woY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21waWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0TWFuYWdlciA9IHRoaXMuX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIoY29udHJvbC5yb290KTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggPSBwYXJlbnQuYWJzb2x1dGVDb250ZXh0UGF0aCB8fCBfX0NPTlRFWFQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY2hpbGRDb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLmFic29sdXRlQ29udGV4dFBhdGggKz0gJy4nICsgY2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLmNvbnRleHQgPSBjb250ZXh0TWFuYWdlci5nZXRDb250ZXh0KGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aC5zcGxpdCgnLicpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udHJvbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEJpbmRhYmxlVGVtcGxhdGVzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgdWkuQmluZGFibGVUZW1wbGF0ZXMgPSBCaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQmluZGFibGVUZW1wbGF0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpLklCaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgPSBJQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnksIElCaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnksIG51bGwsIF9fRkFDVE9SWSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsYXNzIHRoYXQgc3RvcmVzIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhbiBFbGVtZW50J3MgYXR0cmlidXRlcyAoTmFtZWROb2RlTWFwKS5cclxuICAgICAgICAgKiBNZXRob2RzIGFyZSBpbXBsZW1lbnRlZCB0byBhbGxvdyB5b3UgdG8gb2JzZXJ2ZSBmb3IgY2hhbmdlcyBvbiBhbiBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEF0dHJpYnV0ZXMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBBdHRyaWJ1dGVzKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgc2V0IG9mIGZ1bmN0aW9ucyBhZGRlZCBleHRlcm5hbGx5IHRoYXQgbGlzdGVuc1xyXG4gICAgICAgICAgICAgICAgICogZm9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQXR0cmlidXRlcy5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlcygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhpcyBpbnN0YW5jZSB3aXRoIGEgQ29udHJvbCBhbmQgdGhlIGNhbWVsQ2FzZWRcclxuICAgICAgICAgICAgICogYXR0cmlidXRlIHByb3BlcnRpZXMgYW5kIHRoZWlyIHZhbHVlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LkNvbnRyb2x9IGNvbnRyb2wgVGhlIGZ1bmN0aW9uIHRoYXQgYWN0cyBhcyBhIGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSU9iamVjdDxzdHJpbmc+fSBhdHRyaWJ1dGVzIFRoZSBjYW1lbENhc2VkIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIGFuZCB0aGVpciB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVzLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGNvbnRyb2wsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jb250cm9sID0gY29udHJvbDtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcyksIGF0dHJpYnV0ZUxpc3RlbmVycyA9IHRoaXMuX19saXN0ZW5lcnMsIGtleSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTGlzdGVuZXJzW2tleV0gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIG9ic2VydmUgYW4gYXR0cmlidXRlIGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSVByb3BlcnR5Q2hhbmdlZExpc3RlbmVyfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhdHRyaWJ1dGUgdG8gb2JzZXJ2ZSBmb3IgY2hhbmdlcyAoZS5nLiAnc3JjJykuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVzLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9fbGlzdGVuZXJzW2NhbWVsQ2FzZShrZXkpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwobGlzdGVuZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXMuX19jb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVc2VkIHRvIHNob3cgYW4gYXR0cmlidXRlIGhhcyBiZWVuIGNoYW5nZWQgYW5kIGZvcmNlcyBsaXN0ZW5lcnMgdG8gYmUgZmlyZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGF0dHJpYnV0ZSBiZWluZyBvYnNlcnZlZCBmb3IgY2hhbmdlcyAoZS5nLiAnc3JjJykuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEF0dHJpYnV0ZXMucHJvdG90eXBlLl9hdHRyaWJ1dGVDaGFuZ2VkID0gZnVuY3Rpb24gKGtleSwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fX2xpc3RlbmVyc1tjYW1lbENhc2Uoa2V5KV0sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldKG5ld1ZhbHVlLCBvbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBBdHRyaWJ1dGVzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgdWkuQXR0cmlidXRlcyA9IEF0dHJpYnV0ZXM7XHJcbiAgICAgICAgZnVuY3Rpb24gSUF0dHJpYnV0ZXNGYWN0b3J5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0cmlidXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdWkuSUF0dHJpYnV0ZXNGYWN0b3J5ID0gSUF0dHJpYnV0ZXNGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19BdHRyaWJ1dGVzSW5zdGFuY2UsIEF0dHJpYnV0ZXMsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19BdHRyaWJ1dGVzRmFjdG9yeSwgSUF0dHJpYnV0ZXNGYWN0b3J5LCBudWxsLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc291cmNlcyBhcmUgdXNlZCBmb3IgcHJvdmlkaW5nIGFsaWFzZXMgdG8gdXNlIGluIG1hcmt1cCBleHByZXNzaW9ucy4gVGhleVxyXG4gICAgICAgICAqIGFyZSBwYXJ0aWN1bGFybHkgdXNlZnVsIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyBwcm9wZXJ0aWVzIG91dHNpZGUgb2YgdGhlXHJcbiAgICAgICAgICogY3VycmVudCBjb250ZXh0LCBhcyB3ZWxsIGFzIHJlYXNzaWduaW5nIGNvbnRleHQgYXQgYW55IHBvaW50IGluIGFuIGFwcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUmVzb3VyY2VzID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUmVzb3VyY2VzKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGFsbCBvZiB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSByZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXNvdXJjZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciB0aGlzIFJlc291cmNlcyBpbnN0YW5jZSBoYXMgYmVlbiBib3VuZCB5ZXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19ib3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQb3B1bGF0ZXMgYW4gSVJlc291cmNlIHZhbHVlIGlmIG5lY2Vzc2FyeSwgYW5kIGFkZHMgaXQgdG8gdGhlIGdpdmVuXHJcbiAgICAgICAgICAgICAqIGNvbnRyb2wncyByZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIHJlc291cmNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVJlc291cmNlfSByZXNvdXJjZSBUaGUgb2JqZWN0IHVzZWQgdG8gc2V0IHRoZSByZXNvdXJjZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuY3JlYXRlID0gZnVuY3Rpb24gKGNvbnRyb2wsIHJlc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVzb3VyY2UudHlwZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfX0lOSkVDVEFCTEVfUkVTT1VSQ0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmplY3RvciA9IGluamVjdGFibGVJbmplY3RvcnNbcmVzb3VyY2UudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChpbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gaW5qZWN0b3IuaW5qZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfX09CU0VSVkFCTEVfUkVTT1VSQ0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlc291cmNlcy5fb2JzZXJ2ZVJlc291cmNlKGNvbnRyb2wsIHJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfX09CSkVDVF9SRVNPVVJDRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXNvdXJjZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UudmFsdWUgPSBjb250cm9sLmV2YWx1YXRlRXhwcmVzc2lvbih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBfX0xJVEVSQUxfUkVTT1VSQ0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgX19GVU5DVElPTl9SRVNPVVJDRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXNvdXJjZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb250cm9sW3ZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gdmFsdWUuYmluZChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlc291cmNlcy5fbG9nLndhcm4oJ0F0dGVtcHRlZCB0byBjcmVhdGUgYSBcImZ1bmN0aW9uXCIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0eXBlIFJlc291cmNlLCBidXQgdGhlIGZ1bmN0aW9uICcgKyB2YWx1ZSArICdjYW5ub3QgYmUgZm91bmQgb24geW91ciBjb250cm9sLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgcmVzb3VyY2UgYWxpYXNlcyBmb3IgYEBjb250cm9sYCBhbmQgYEBjb250ZXh0YC4gVGhlIHJlc291cmNlcyBhcmVcclxuICAgICAgICAgICAgICogYWxpYXNlcyBmb3IgdGhlIGNvbnRyb2wgaW5zdGFuY2UgYW5kIHRoZSBjb250cm9sLmNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IGNvbnRyb2wgVGhlIGNvbnRyb2wgb24gd2hpY2ggdG8gYWRkIHRoZSByZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuYWRkQ29udHJvbFJlc291cmNlcyA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sLnJlc291cmNlcy5hZGQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRyb2wuY29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX19PQlNFUlZBQkxFX1JFU09VUkNFXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBfX09CSkVDVF9SRVNPVVJDRVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuaGFzT3duQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFJlc291cmNlcy5fX2FkZFJvb3QoY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5iaW5kUmVzb3VyY2VzID0gZnVuY3Rpb24gKHJlc291cmNlc0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VzID0gcmVzb3VyY2VzSW5zdGFuY2UuX19yZXNvdXJjZXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHJlc291cmNlc0luc3RhbmNlLl9fY29udHJvbEluc3RhbmNlLCBhbGlhc2VzID0gT2JqZWN0LmtleXMocmVzb3VyY2VzKSwgY29udHJvbFJlc291cmNlcyA9IFJlc291cmNlcy5fX2NvbnRyb2xSZXNvdXJjZXMsIGxlbmd0aCA9IGFsaWFzZXMubGVuZ3RoLCBhbGlhcztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhcyA9IGFsaWFzZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xSZXNvdXJjZXNbYWxpYXNdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXNJbnN0YW5jZVthbGlhc10gPSByZXNvdXJjZXNbYWxpYXNdID0gUmVzb3VyY2VzLmNyZWF0ZShjb250cm9sLCByZXNvdXJjZXNJbnN0YW5jZVthbGlhc10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzSW5zdGFuY2UuX19ib3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBEaXNwb3NlcyBhIHJlc291cmNlIGluc3RhbmNlLCByZW1vdmluZyBpdHMgcmVmZXJlbmNlXHJcbiAgICAgICAgICAgICAqIGZyb20gYSBjb250cm9sIGFuZCBicmVha2luZyByZWZlcmVuY2VzIHRvIGFsbCByZXNvdXJjZVxyXG4gICAgICAgICAgICAgKiBvYmplY3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIHJlc291cmNlcyB3aWxsIGJlIGRpc3Bvc2VkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBlcnNpc3Q/IFdoZXRoZXIgb3Igbm90IHRvIHBlcnNpc3QgYSByZXNvdXJjZSBvYmplY3QgcG9zdFxyXG4gICAgICAgICAgICAgKiBkaXNwb3NhbCBvciBzZXQgaXQgdG8gbnVsbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlc291cmNlcy5kaXNwb3NlID0gZnVuY3Rpb24gKGNvbnRyb2wsIHBlcnNpc3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXNvdXJjZXMgPSBjb250cm9sLnJlc291cmNlcztcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzb3VyY2VzLl9fcmVzb3VyY2VzKSwga2V5LCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgZGVmaW5lID0gUmVzb3VyY2VzLl9Db250ZXh0TWFuYWdlci5kZWZpbmVQcm9wZXJ0eSwgcmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHJlc291cmNlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHJlc291cmNlKSAmJiAocmVzb3VyY2UudHlwZSA9PT0gX19PQlNFUlZBQkxFX1JFU09VUkNFIHx8IHJlc291cmNlLnR5cGUgPT09IF9fTElURVJBTF9SRVNPVVJDRSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lKHJlc291cmNlcywga2V5LCBwZXJzaXN0ID8gX2Nsb25lKHJlc291cmNlLCB0cnVlKSA6IG51bGwsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFJlc291cmNlcy5fcmVtb3ZlTGlzdGVuZXJzKHJlc291cmNlcy5fX2NvbnRyb2xJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSByZXNvdXJjZXMgRWxlbWVudCAoYDxwbGF0LXJlc291cmNlcz5gKSBhbmQgY3JlYXRlc1xyXG4gICAgICAgICAgICAgKiBhbiBJT2JqZWN0PElSZXNvdXJjZT4gd2l0aCBpdHMgZWxlbWVudCBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSByZXNvdXJjZXMgZWxlbWVudCB0byBwYXJzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlc291cmNlcy5wYXJzZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZHJlbiksIGNoaWxkLCBfcmVnZXggPSBSZXNvdXJjZXMuX3JlZ2V4LCB3aGl0ZVNwYWNlUmVnZXggPSBfcmVnZXgud2hpdGVTcGFjZVJlZ2V4LCBxdW90YXRpb25SZWdleCA9IF9yZWdleC5xdW90YXRpb25SZWdleCwgcmVzb3VyY2VzID0ge30sIHJlc291cmNlLCB0eXBlcyA9IFJlc291cmNlcy5fX3Jlc291cmNlVHlwZXMsIGF0dHJzLCBhdHRyLCBub2RlTmFtZSwgdGV4dDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbi5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlc1tub2RlTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzID0gY2hpbGQuYXR0cmlidXRlcztcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHIgPSBhdHRycy5nZXROYW1lZEl0ZW0oX19BTElBUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChhdHRyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UuYWxpYXMgPSBhdHRyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBjaGlsZC50ZXh0Q29udGVudC5yZXBsYWNlKHdoaXRlU3BhY2VSZWdleCwgJyQxJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlLnZhbHVlID0gKG5vZGVOYW1lID09PSBfX0lOSkVDVEFCTEVfUkVTT1VSQ0UgfHwgbm9kZU5hbWUgPT09IF9fTElURVJBTF9SRVNPVVJDRSkgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LnJlcGxhY2UocXVvdGF0aW9uUmVnZXgsICcnKSA6IHRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UudHlwZSA9IG5vZGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc1tyZXNvdXJjZS5hbGlhc10gPSByZXNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvdXJjZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIHdpdGggdHlwZSBSZXNvdXJjZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlcygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogT2JzZXJ2ZXMgdGhlIHJlc291cmNlIGlmIHRoZSB0eXBlIGlzIGBvYnNlcnZhYmxlYC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCBpbiBjaGFyZ2Ugb2YgdGhlIG9ic2VydmFibGUgcmVzb3VyY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUmVzb3VyY2V9IHJlc291cmNlIFRoZSByZXNvdXJjZSB0byBvYnNlcnZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9vYnNlcnZlUmVzb3VyY2UgPSBmdW5jdGlvbiAoY29udHJvbCwgcmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc291cmNlLnZhbHVlLCB1aWQgPSBjb250cm9sLnVpZCwgcmVtb3ZlTGlzdGVuZXJzID0gUmVzb3VyY2VzLl9fb2JzZXJ2YWJsZVJlc291cmNlUmVtb3ZlTGlzdGVuZXJzW3VpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHJlbW92ZUxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMgPSBSZXNvdXJjZXMuX19vYnNlcnZhYmxlUmVzb3VyY2VSZW1vdmVMaXN0ZW5lcnNbdWlkXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHJlc291cmNlLmluaXRpYWxWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXNvdXJjZS5pbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gY29udHJvbC5vYnNlcnZlRXhwcmVzc2lvbihmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UudmFsdWUgPSBjb250cm9sLmV2YWx1YXRlRXhwcmVzc2lvbih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBvYnNlcnZhYmxlIHJlc291cmNlIGxpc3RlbmVycyBmb3IgYSBzcGVjaWZpZWQgY29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuX3JlbW92ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHVpZCA9IGNvbnRyb2wudWlkLCByZW1vdmVMaXN0ZW5lcnMgPSBSZXNvdXJjZXMuX19vYnNlcnZhYmxlUmVzb3VyY2VSZW1vdmVMaXN0ZW5lcnNbdWlkXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHJlbW92ZUxpc3RlbmVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzkgPSByZW1vdmVMaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnNbaV0oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShSZXNvdXJjZXMuX19vYnNlcnZhYmxlUmVzb3VyY2VSZW1vdmVMaXN0ZW5lcnMsIHVpZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGEgYEByb290YCBhbGlhcyBhbmQgYEByb290Q29udGV4dGAgdG8gYSBjb250cm9sLCBzcGVjaWZ5aW5nIHRoYXQgaXQgY29udGFpbnMgdGhlIHJvb3RcclxuICAgICAgICAgICAgICogYW5kIHJvb3QgY29udGV4dC4gUm9vdCBjb250cm9scyBhcmUgZ2VuZXJhbGx5IHRoZSByb290IFZpZXdDb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSByb290IGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuX19hZGRSb290ID0gZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wucmVzb3VyY2VzLmFkZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcm9vdDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX19PQkpFQ1RfUkVTT1VSQ0UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzOiBfX1JPT1RfUkVTT1VSQ0VcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3RDb250ZXh0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250cm9sLmNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IF9fT0JTRVJWQUJMRV9SRVNPVVJDRSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IF9fUk9PVF9DT05URVhUX1JFU09VUkNFXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChjb250cm9sSW5zdGFuY2UsIHJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRyb2xJbnN0YW5jZSA9IGNvbnRyb2xJbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTm9kZShyZXNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzID0gUmVzb3VyY2VzLnBhcnNlRWxlbWVudChyZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QocmVzb3VyY2VzLnJlc291cmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMgPSByZXNvdXJjZXMucmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3Jlc291cmNlcyA9IHJlc291cmNlcztcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVzb3VyY2VzKSwga2V5LCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHJlc291cmNlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChyZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVzb3VyY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTm9kZShyZXNvdXJjZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzID0gUmVzb3VyY2VzLnBhcnNlRWxlbWVudChyZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXNvdXJjZXMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgcmVzb3VyY2UsIGNvbnRyb2wgPSB0aGlzLl9fY29udHJvbEluc3RhbmNlLCBib3VuZCA9IHRoaXMuX19ib3VuZCwga2V5LCBjcmVhdGUgPSBSZXNvdXJjZXMuY3JlYXRlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZS5hbGlhcyA9IGtleTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB0aGlzLl9fcmVzb3VyY2VzW2tleV0gPSBib3VuZCA/IGNyZWF0ZShjb250cm9sLCByZXNvdXJjZSkgOiByZXNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBpbmplY3RhYmxlIHJlc291cmNlIHR5cGUgdG9rZW4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuSU5KRUNUQUJMRSA9IF9fSU5KRUNUQUJMRV9SRVNPVVJDRTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBvYmplY3QgcmVzb3VyY2UgdHlwZSB0b2tlbi4gT2JqZWN0cyBzaG91bGQgYmUgbGl0ZXJhbCBvYmplY3RzIGFuZCB3b24ndCBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJlc291cmNlcy5PQkpFQ1QgPSBfX09CSkVDVF9SRVNPVVJDRTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBvYnNlcnZhYmxlIHJlc291cmNlIHR5cGUgdG9rZW4uIE9ic2VydmFibGUgcmVzb3VyY2VzIGFyZSBleHBlY3RlZCB0byBiZVxyXG4gICAgICAgICAgICAgKiBzdHJpbmcgaWRlbnRpZmllcnMgYW5kIHdpbGwgYmUgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuT0JTRVJWQUJMRSA9IF9fT0JTRVJWQUJMRV9SRVNPVVJDRTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBsaXRlcmFsIHJlc291cmNlIHR5cGUgdG9rZW4uIExpdGVyYWxzIHdpbGwgYmUgb2JzZXJ2ZWQgb24gdGhlIHJlc291cmNlIG9iamVjdCxcclxuICAgICAgICAgICAgICogc28gaWYgeW91IGNoYW5nZSBgcmVzb3VyY2VzLjxhbGlhcz4udmFsdWVgIGl0IHdpbGwgYmUgcmVmbGVjdGVkIGV2ZXJ5d2hlcmUgaXQgaXNcclxuICAgICAgICAgICAgICogb2JzZXJ2ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZXNvdXJjZXMuTElURVJBTCA9IF9fTElURVJBTF9SRVNPVVJDRTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiByZXNvdXJjZSB0eXBlIHRva2VuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLkZVTkNUSU9OID0gX19GVU5DVElPTl9SRVNPVVJDRTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb25zaXN0aW5nIG9mIGtleWVkIGFycmF5cyBjb250YWluaW5nIGZ1bmN0aW9ucyBmb3IgcmVtb3Zpbmcgb2JzZXJ2YXRpb24gbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9fb2JzZXJ2YWJsZVJlc291cmNlUmVtb3ZlTGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgICAgIHJldHVybiBSZXNvdXJjZXM7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICB1aS5SZXNvdXJjZXMgPSBSZXNvdXJjZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSVJlc291cmNlc0ZhY3RvcnkoX0NvbnRleHRNYW5hZ2VyLCBfcmVnZXgsIF9sb2cpIHtcclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9Db250ZXh0TWFuYWdlciA9IF9Db250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9yZWdleCA9IF9yZWdleDtcclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9sb2cgPSBfbG9nO1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbFJlc291cmNlcyA9IHt9LCByZXNvdXJjZVR5cGVzID0ge307XHJcbiAgICAgICAgICAgIGNvbnRyb2xSZXNvdXJjZXNbX19DT05UUk9MX1JFU09VUkNFXSA9IGNvbnRyb2xSZXNvdXJjZXNbX19DT05URVhUX1JFU09VUkNFXSA9IGNvbnRyb2xSZXNvdXJjZXNbX19ST09UX1JFU09VUkNFXSA9IGNvbnRyb2xSZXNvdXJjZXNbX19ST09UX0NPTlRFWFRfUkVTT1VSQ0VdID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzb3VyY2VUeXBlc1tfX0lOSkVDVEFCTEVfUkVTT1VSQ0VdID0gcmVzb3VyY2VUeXBlc1tfX09CSkVDVF9SRVNPVVJDRV0gPSByZXNvdXJjZVR5cGVzW19fT0JTRVJWQUJMRV9SRVNPVVJDRV0gPSByZXNvdXJjZVR5cGVzW19fRlVOQ1RJT05fUkVTT1VSQ0VdID0gcmVzb3VyY2VUeXBlc1tfX0xJVEVSQUxfUkVTT1VSQ0VdID0gdHJ1ZTtcclxuICAgICAgICAgICAgUmVzb3VyY2VzLl9fY29udHJvbFJlc291cmNlcyA9IGNvbnRyb2xSZXNvdXJjZXM7XHJcbiAgICAgICAgICAgIFJlc291cmNlcy5fX3Jlc291cmNlVHlwZXMgPSByZXNvdXJjZVR5cGVzO1xyXG4gICAgICAgICAgICByZXR1cm4gUmVzb3VyY2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1aS5JUmVzb3VyY2VzRmFjdG9yeSA9IElSZXNvdXJjZXNGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19SZXNvdXJjZXNGYWN0b3J5LCBJUmVzb3VyY2VzRmFjdG9yeSwgW1xyXG4gICAgICAgICAgICBfX0NvbnRleHRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICBfX1JlZ2V4LFxyXG4gICAgICAgICAgICBfX0xvZ1xyXG4gICAgICAgIF0sIF9fRkFDVE9SWSk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1Jlc291cmNlc0luc3RhbmNlLCBSZXNvdXJjZXMsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgZm9yIG1hbmFnaW5nIERPTSBldmVudCByZWdpc3RyYXRpb24gYW5kIGhhbmRsaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEb21FdmVudHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0cmlldmUgdGhlIHR5cGUgb2YgdG91Y2ggZXZlbnRzIGZvciB0aGlzIGJyb3dzZXIgYW5kIGNyZWF0ZSB0aGUgZGVmYXVsdCBnZXN0dXJlIHN0eWxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gRG9tRXZlbnRzKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZXZlbnQgdHlwZXMgZm9yIGFsbCBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAqIHN1cHBvcnRlZCBnZXN0dXJlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZXMgPSBEb21FdmVudHMuZ2VzdHVyZXM7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSB2ZXJzaW9uIG9mIGFuZHJvaWQsIG9yIC0xIGlmIG5vdCBvbiBhbmRyb2lkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbmRyb2lkVmVyc2lvbiA9IGlzVW5kZWZpbmVkKHRoaXMuX2NvbXBhdC5BTkRST0lEKSA/IC0xIDogdGhpcy5fY29tcGF0LkFORFJPSUQ7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHdlJ3JlIG9uIEFuZHJvaWQgNC40Lnggb3IgYmVsb3cuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuZHJvaWQ0NG9yQmVsb3cgPSB0aGlzLl9hbmRyb2lkVmVyc2lvbiA+IC0xICYmIE1hdGguZmxvb3IodGhpcy5fYW5kcm9pZFZlcnNpb24gLyAxMCkgPD0gNDQ7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIHVzaW5nIG1vdXNlIHdoZW4gdG91Y2ggZXZlbnRzIGFyZSBwcmVzZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbk1vdXNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCB3aXRoIGtleWVkIHN1YnNjcmliZXJzIHRoYXQga2VlcCB0cmFjayBvZiBhbGwgb2YgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBldmVudHMgcmVnaXN0ZXJlZCBvbiBhIHBhcnRpY3VsYXIgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG51bWJlciBvZiBjdXJyZW50bHkgYWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgKiBldmVudHMgb2YgZWFjaCBiYXNlIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVDb3VudCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAkdGFwOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRkYmx0YXA6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJGhvbGQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHJlbGVhc2U6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHN3aXBlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0cmFjazogMCxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhY2tlbmQ6IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIG1vdmVkIHdoaWxlIGluIHRvdWNoLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFzTW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlaXIgaXMgYSByZWdpc3RlcmVkIFwicmVsZWFzZVwiIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFzUmVsZWFzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgYmUgZGV0ZWN0aW5nIG1vdmUgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGV0ZWN0aW5nTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY3VycmVudCB0YXAgY291bnQgdG8gaGVscCBkaXN0aW5ndWlzaCBzaW5nbGUgZnJvbSBkb3VibGUgdGFwcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHRvdGFsIG51bWJlciBvZiB0b3VjaGVzIG9uIHRoZSBzY3JlZW4uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX190b3VjaENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byByZW1vdmUgYSBkZWZlcnJlZCB0YXAgZ2l2ZW4gdGhlIGNhc2UgdGhhdCBhIHRhcCBkZWxheSB3YXMgbmVlZGVkIGZvclxyXG4gICAgICAgICAgICAgICAgICogc29tZXRoaW5nIHN1Y2ggYXMgYSBkb3VibGUgdGFwIHRvIHpvb20gZmVhdHVyZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkVGFwID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYSBkZWZlcnJlZCBob2xkIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npbm8gZm9yIGRldGVybWluaW5nIGEgXCJjYW5jZWxcIiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbFJlZ2V4ID0gL2NhbmNlbC9pO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lubyBmb3IgZGV0ZXJtaW5pbmcgYSBwb2ludGVyIGVuZCBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3BvaW50ZXJFbmRSZWdleCA9IC91cHxjYW5jZWwvaTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBzd2lwZSBzdWJzY3JpYmVycyBmb3IgdGhlIGN1cnJlbnQgdGFyZ2V0IGR1cmluZyB0b3VjaCBtb3ZlIGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhdmVTd2lwZVN1YnNjcmliZXJzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIGJsdXIgZXZlbnRzIG9uIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYmx1clJlbW92ZXIgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHNldCBvZiBmbGFncyBzaWduaWZ5aW5nIHdoZXRoZXIgd2Ugc2hvdWxkIGlnbm9yZSBuYXRpdmUgZXZlbnRzIG9yIG5vdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2lnbm9yZUV2ZW50ID0geyBtb3VzZWRvd246IGZhbHNlLCBtb3VzZXVwOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHdpdGggYSBib3VuZCBjb250ZXh0IHRoYXQgcHJldmVudHMgZGVmYXVsdCBhbmQgc3RvcHMgcHJvcGFnYXRpb24gZm9yIGRlbGF5ZWQgb3IgcGhhbnRvbSBjbGlja3MuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19ib3VuZFByZXZlbnREZWZhdWx0Q2xpY2sgPSB0aGlzLl9fcHJldmVudERlZmF1bHRDbGljay5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGhhc2ggbWFwIGZvciBtYXBwaW5nIGN1c3RvbSBldmVudHMgdG8gc3RhbmRhcmQgZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmV2ZXJzZU1hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhY3RpdmUgbWFwcGVkIHRvdWNoXHJcbiAgICAgICAgICAgICAgICAgKiBldmVudHMgb2YgZWFjaCB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbWFwcGVkQ291bnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoc3RhcnQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNobW92ZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAkdG91Y2hlbmQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoY2FuY2VsOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGhhc2ggb2YgdGhlIGN1cnJlbnQgcG9pbnRlciB0b3VjaCBwb2ludHMgb24gdGhlIHBhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVySGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGFsbCBjdXJyZW50IHBvaW50ZXIgdG91Y2ggcG9pbnRzIG9uIHRoZSBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcG9pbnRlckV2ZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHNldCBvZiB0b3VjaCBzdGFydCwgbW92ZSwgYW5kIGVuZCBsaXN0ZW5lcnMgdG8gYmUgcGxhY2Ugb24gdGhlIGRvY3VtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGlzdGVuZXJzID0ge307XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZ2V0VHlwZXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBfY29tcGF0ID0gdGhpcy5fY29tcGF0LCBtYXBwZWRHZXN0dXJlcyA9IF9jb21wYXQubWFwcGVkRXZlbnRzLCBtYXBwZWRUeXBlID0gbWFwcGVkR2VzdHVyZXNbdHlwZV0sIG1hcHBpbmdFeGlzdHMgPSAhaXNOdWxsKG1hcHBlZFR5cGUpLCBtYXBwZWRDb3VudCA9IHRoaXMuX19tYXBwZWRDb3VudCwgZ2VzdHVyZXMgPSB0aGlzLl9nZXN0dXJlcywgbGlzdGVuZXJSZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwcGluZ0V4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZXZlcnNlTWFwW21hcHBlZFR5cGVdID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZENvdW50W3R5cGVdKys7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jb21wYXQuaGFzVG91Y2hFdmVudHMgJiYgIXRoaXMuX19jYW5jZWxSZWdleC50ZXN0KG1hcHBlZFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZFR5cGUgPSBtYXBwZWRUeXBlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgndG91Y2gnLCAnbW91c2UnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3N0YXJ0JywgJ2Rvd24nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ2VuZCcsICd1cCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmV2ZXJzZU1hcFttYXBwZWRUeXBlXSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZWxlbWVudFsnb24nICsgdHlwZV0pIHx8IGlzVW5kZWZpbmVkKGdlc3R1cmVzW3R5cGVdKSB8fCBtYXBwaW5nRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcHBpbmdFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwZWRDb3VudFt0eXBlXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRDb3VudFt0eXBlXS0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX191bnJlZ2lzdGVyRWxlbWVudChlbGVtZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lclJlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3dpcGVHZXN0dXJlID0gZ2VzdHVyZXMuJHN3aXBlLCB0cmFja0dlc3R1cmUgPSBnZXN0dXJlcy4kdHJhY2ssIGNvdW50VHlwZSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pbmRleE9mKHRyYWNrR2VzdHVyZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrZW5kID0gZ2VzdHVyZXMuJHRyYWNrZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50VHlwZSA9IHR5cGUgPT09IHRyYWNrZW5kID8gdHJhY2tlbmQgOiB0cmFja0dlc3R1cmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLmluZGV4T2Yoc3dpcGVHZXN0dXJlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudFR5cGUgPSBzd2lwZUdlc3R1cmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlQ291bnRbY291bnRUeXBlXSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlZ2lzdGVyRWxlbWVudChlbGVtZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyUmVtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZW1vdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJZiBEb21FdmVudHMgaXMgaW5hY3RpdmUsIHdpbGwgaW5pdGlhbGl6ZSBiZWhhdmlvciBhbmRcclxuICAgICAgICAgICAgICogYmVnaW4gbGlzdGVuaW5nIGZvciBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNBY3RpdmUgPSB0aGlzLl9pc0FjdGl2ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQgYW5kIHdhcyBuZXZlciBkaXNwb3NlZCBcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVnaXN0ZXJUeXBlcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpc0FjdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYXBwZW5kR2VzdHVyZVN0eWxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdG9wcyBsaXN0ZW5pbmcgZm9yIHRvdWNoIGV2ZW50cyBhbmQgcmVzZXRzIHRoZSBEb21FdmVudHNcclxuICAgICAgICAgICAgICogaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdW5yZWdpc3RlclR5cGVzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYmx1clJlbW92ZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyUmVtb3ZlciA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXN0dXJlQ291bnQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRhcDogMCxcclxuICAgICAgICAgICAgICAgICAgICAkZGJsdGFwOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRob2xkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRyZWxlYXNlOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICRzd2lwZTogMCxcclxuICAgICAgICAgICAgICAgICAgICAkdHJhY2s6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRyYWNrZW5kOiAwXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX21hcHBlZENvdW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaHN0YXJ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaG1vdmU6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgJHRvdWNoZW5kOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICR0b3VjaGNhbmNlbDogMFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3BvaW50ZXJFdmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVySGFzaCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JldmVyc2VNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pZ25vcmVFdmVudCA9IHsgbW91c2Vkb3duOiBmYWxzZSwgbW91c2V1cDogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX190YXBDb3VudCA9IHRoaXMuX190b3VjaENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19kZXRlY3RpbmdNb3ZlID0gdGhpcy5fX2hhc01vdmVkID0gdGhpcy5fX2hhc1JlbGVhc2UgPSB0aGlzLl9faGF2ZVN3aXBlU3Vic2NyaWJlcnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0TW92ZUV2ZW50ID0gdGhpcy5fX2xhc3RUb3VjaERvd24gPSB0aGlzLl9fbGFzdFRvdWNoVXAgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3N3aXBlT3JpZ2luID0gdGhpcy5fX2NhcHR1cmVkVGFyZ2V0ID0gdGhpcy5fX2ZvY3VzZWRFbGVtZW50ID0gdGhpcy5fX2RlbGF5ZWRDbGlja1JlbW92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCA9IHRoaXMuX19jYW5jZWxEZWZlcnJlZFRhcCA9IG5vb3A7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGxpc3RlbmVyIGZvciB0b3VjaC9tb3VzZSBzdGFydCBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggc3RhcnQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fb25Ub3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGV2LnR5cGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2lnbm9yZUV2ZW50W2V2ZW50VHlwZV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faWdub3JlRXZlbnRbZXZlbnRUeXBlXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZWxheWVkQ2xpY2tSZW1vdmVyW2V2ZW50VHlwZV0oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYudGFyZ2V0ICE9PSB0aGlzLl9fZm9jdXNlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmNhbmNlbGFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190b3VjaENvdW50KysgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlICE9PSAnbW91c2Vkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luVG91Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faW5Ub3VjaCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSBpZiBtb3VzZSBldmVudCBhbmQgY3VycmVudGx5IGluIGEgdG91Y2ggXHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jb21wYXQuaGFzVG91Y2hFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbk1vdXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ID0gdGhpcy5fX3N0YW5kYXJkaXplRXZlbnRPYmplY3QoZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChldikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHNldCBsYXN0IG1vdmUgYmFjayB0byBudWxsIGFuZCBoYXNNb3ZlZCB0byBmYWxzZSBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0TW92ZUV2ZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19oYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNsaWVudFggPSBldi5jbGllbnRYLCBjbGllbnRZID0gZXYuY2xpZW50WSwgdGltZVN0YW1wID0gZXYudGltZVN0YW1wLCB0YXJnZXQgPSBldi50YXJnZXQsIGdlc3R1cmVzID0gdGhpcy5fZ2VzdHVyZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fbGFzdFRvdWNoRG93biA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfYnV0dG9uczogZXYuX2J1dHRvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBjbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTdGFtcDogdGltZVN0YW1wLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGV2LmlkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fc3dpcGVPcmlnaW4gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY2xpZW50WCxcclxuICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBjbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgICAgIHhUaW1lc3RhbXA6IHRpbWVTdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICB5VGltZXN0YW1wOiB0aW1lU3RhbXAsXHJcbiAgICAgICAgICAgICAgICAgICAgeFRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICAgICAgICAgIHlUYXJnZXQ6IHRhcmdldFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmRyb2lkNDRvckJlbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhdmVTd2lwZVN1YnNjcmliZXJzID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXJzKHRhcmdldCwgW2dlc3R1cmVzLiRzd2lwZSwgZ2VzdHVyZXMuJHN3aXBlZG93biwgZ2VzdHVyZXMuJHN3aXBlbGVmdCwgZ2VzdHVyZXMuJHN3aXBlcmlnaHQsIGdlc3R1cmVzLiRzd2lwZXVwXSkubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlQ291bnQgPSB0aGlzLl9nZXN0dXJlQ291bnQsIG5vSG9sZHMgPSBnZXN0dXJlQ291bnQuJGhvbGQgPD0gMCwgbm9SZWxlYXNlID0gZ2VzdHVyZUNvdW50LiRyZWxlYXNlIDw9IDAsIG1hcHBlZENvdW50ID0gdGhpcy5fX21hcHBlZENvdW50O1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgYW55IG1vdmluZyBldmVudHMgcmVnaXN0ZXJlZCwgcmVnaXN0ZXIgbW92ZSBcclxuICAgICAgICAgICAgICAgIGlmIChldmVudFR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBtYXBwZWRDb3VudC4kdG91Y2htb3ZlID4gMCB8fCBnZXN0dXJlQ291bnQuJHRyYWNrID4gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGdlc3R1cmVDb3VudC4kdHJhY2tlbmQgPiAwIHx8IGdlc3R1cmVDb3VudC4kc3dpcGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlZ2lzdGVyVHlwZSh0aGlzLl9tb3ZlRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGV0ZWN0aW5nTW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBtYXBwZWQgZXZlbnRzIFxyXG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZFR5cGUgPSB0aGlzLl9fcmV2ZXJzZU1hcFtldmVudFR5cGVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcHBlZENvdW50W21hcHBlZFR5cGVdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWREb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgbWFwcGVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFwcGVkRG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZERvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBpZiBubyBob2xkIG9yIHJlbGVhc2UgZXZlbnRzIGFyZSByZWdpc3RlcmVkIFxyXG4gICAgICAgICAgICAgICAgaWYgKG5vSG9sZHMgJiYgbm9SZWxlYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9sZEludGVydmFsID0gRG9tRXZlbnRzLmNvbmZpZy5pbnRlcnZhbHMuaG9sZEludGVydmFsLCBkb21FdmVudCwgc3Vic2NyaWJlRm4sIGRvbUV2ZW50Rm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChub0hvbGRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhc1JlbGVhc2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkID0gZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2hhc1JlbGVhc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGhvbGRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub1JlbGVhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgdGhpcy5fZ2VzdHVyZXMuJGhvbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZG9tRXZlbnRGb3VuZCA9ICFpc051bGwoZG9tRXZlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19jYW5jZWxEZWZlcnJlZEhvbGQgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYXNSZWxlYXNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIGJvdGggaG9sZCBhbmQgcmVsZWFzZSBldmVudHMgcmVnaXN0ZXJlZCBcclxuICAgICAgICAgICAgICAgICAgICBkb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgdGhpcy5fZ2VzdHVyZXMuJGhvbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZG9tRXZlbnRGb3VuZCA9ICFpc051bGwoZG9tRXZlbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19oYXNSZWxlYXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgdGltZW91dCB0byBmaXJlIHRoZSBzdWJzY3JpYmVGbiBcclxuICAgICAgICAgICAgICAgIGlmIChkb21FdmVudEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkSG9sZCA9IGRlZmVyKHN1YnNjcmliZUZuLCBob2xkSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBsaXN0ZW5lciBmb3IgdG91Y2gvbW91c2UgbW92ZSBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggbW92ZSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgaG9sZCBldmVudCBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZEhvbGQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZEhvbGQgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGV2LnR5cGU7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gaW1tZWRpYXRlbHkgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHRvdWNoZXMgcHJlc2VudCwgb3IgXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhIG1vdXNlIGV2ZW50IGFuZCBjdXJyZW50bHkgaW4gYSB0b3VjaCBcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pblRvdWNoID09PSB0cnVlICYmIGV2ZW50VHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBldnQgPSB0aGlzLl9fc3RhbmRhcmRpemVFdmVudE9iamVjdChldik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIG1hcHBlZCBldmVudHMgXHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGVkVHlwZSA9IHRoaXMuX19yZXZlcnNlTWFwW2V2ZW50VHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX21hcHBlZENvdW50W21hcHBlZFR5cGVdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWREb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgbWFwcGVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFwcGVkRG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZERvbUV2ZW50LnRyaWdnZXIoZXZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2VzdHVyZUNvdW50ID0gdGhpcy5fZ2VzdHVyZUNvdW50LCBub1RyYWNraW5nID0gZ2VzdHVyZUNvdW50LiR0cmFjayA8PSAwLCBub1N3aXBpbmcgPSBnZXN0dXJlQ291bnQuJHN3aXBlIDw9IDAsIGNvbmZpZyA9IERvbUV2ZW50cy5jb25maWcsIHN3aXBlT3JpZ2luID0gdGhpcy5fX3N3aXBlT3JpZ2luLCB4ID0gZXZ0LmNsaWVudFgsIHkgPSBldnQuY2xpZW50WSwgbWluTW92ZSA9IHRoaXMuX19oYXNNb3ZlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9fZ2V0RGlzdGFuY2Uoc3dpcGVPcmlnaW4uY2xpZW50WCwgeCwgc3dpcGVPcmlnaW4uY2xpZW50WSwgeSkgPj0gY29uZmlnLmRpc3RhbmNlcy5taW5TY3JvbGxEaXN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBtaW5pbXVtIGRpc3RhbmNlIG5vdCBtZXQgXHJcbiAgICAgICAgICAgICAgICBpZiAoIW1pbk1vdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19oYXNNb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBtb3ZpbmcgZXZlbnRzIHJldHVybiBcclxuICAgICAgICAgICAgICAgIGlmIChub1RyYWNraW5nICYmIG5vU3dpcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RNb3ZlID0gdGhpcy5fX2xhc3RNb3ZlRXZlbnQgfHwgc3dpcGVPcmlnaW4sIGRpcmVjdGlvbiA9IGV2dC5kaXJlY3Rpb24gPSB0aGlzLl9fZ2V0RGlyZWN0aW9uKHggLSBsYXN0TW92ZS5jbGllbnRYLCB5IC0gbGFzdE1vdmUuY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlT3JpZ2luQ2hhbmdlKGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gc3dpcGVPcmlnaW4uY2xpZW50WCksIGR5ID0gTWF0aC5hYnMoeSAtIHN3aXBlT3JpZ2luLmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICAgZXZ0LnZlbG9jaXR5ID0gdGhpcy5fX2dldFZlbG9jaXR5KGR4LCBkeSwgZXZ0LnRpbWVTdGFtcCAtIHN3aXBlT3JpZ2luLnhUaW1lc3RhbXAsIGV2dC50aW1lU3RhbXAgLSBzd2lwZU9yaWdpbi55VGltZXN0YW1wKTtcclxuICAgICAgICAgICAgICAgIGlmICghbm9Td2lwaW5nICYmIHRoaXMuX2FuZHJvaWQ0NG9yQmVsb3cgJiYgdGhpcy5fX2hhdmVTd2lwZVN1YnNjcmliZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIHRyYWNraW5nIGV2ZW50cyBleGlzdCBcclxuICAgICAgICAgICAgICAgIGlmICghbm9UcmFja2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVUcmFjayhldnQsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0TW92ZUV2ZW50ID0gZXZ0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBsaXN0ZW5lciBmb3IgdG91Y2gvbW91c2UgZW5kIGV2ZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSB0b3VjaCBlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fb25Ub3VjaEVuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBldmVudFR5cGUgPSBldi50eXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pZ25vcmVFdmVudFtldmVudFR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lnbm9yZUV2ZW50W2V2ZW50VHlwZV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGVsYXllZENsaWNrUmVtb3ZlcltldmVudFR5cGVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldCAhPT0gdGhpcy5fX2ZvY3VzZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAoX3RoaXMuX19sYXN0VG91Y2hVcCB8fCB7fSkudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2hhbmRsZUlucHV0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGhhc01vdmVkID0gdGhpcy5fX2hhc01vdmVkLCBub3RNb3VzZVVwID0gZXZlbnRUeXBlICE9PSAnbW91c2V1cCc7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3RvdWNoQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190b3VjaENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190b3VjaENvdW50LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm90TW91c2VVcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbCBub24gbW91c2UgY2FzZXMgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3RvdWNoZW5kJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgdG8gaGFuZGxlIGEgc3RyYW5nZSBpc3N1ZSB3aGVuIHRvdWNoIGNsaWNraW5nIGNlcnRhaW4gdHlwZXMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIERPTSBlbGVtZW50cyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc01vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjaGVjayBldi5jYW5jZWxhYmxlIGluIHRoZSBFTkQgY2FzZSBpbiBjYXNlIG9mIHNjcm9sbGluZyBjb25kaXRpb25zIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmNhbmNlbGFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2luVG91Y2ggPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IGhhbmRsZSB0aGUgaW5wdXQgZGVwZW5kaW5nIG9uIHR5cGUgZm9yIG1vcmUgbmF0aXZlLWxpa2UgZXhwZXJpZW5jZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi50YXJnZXQgIT09IHRoaXMuX19mb2N1c2VkRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faGFuZGxlSW5wdXQoZXYudGFyZ2V0KSAmJiBldi5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmNhbmNlbGFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3ByZXZlbnRDbGlja0Zyb21Ub3VjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3ByZXZlbnRDbGlja0Zyb21Ub3VjaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pblRvdWNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5Nb3VzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGNhc2Ugd2hlcmUgdG91Y2hlbmQgZmlyZWQgYW5kIG5vdyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgZW5kIGlzIGFsc28gYmVpbmcgZmlyZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldi5jYW5jZWxhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5Nb3VzZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNhbmNlbCBldmVudCBcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fY2FuY2VsUmVnZXgudGVzdChldmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZUNhbmNlbGVkKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplRXZlbnRPYmplY3QgY3JlYXRlcyB0b3VjaGVzIFxyXG4gICAgICAgICAgICAgICAgZXYgPSB0aGlzLl9fc3RhbmRhcmRpemVFdmVudE9iamVjdChldik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm90TW91c2VVcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luVG91Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIG1hcHBlZCBldmVudHMgXHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwcGVkVHlwZSA9IHRoaXMuX19yZXZlcnNlTWFwW2V2ZW50VHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX21hcHBlZENvdW50W21hcHBlZFR5cGVdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXBwZWREb21FdmVudCA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVyKGV2LnRhcmdldCwgbWFwcGVkVHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobWFwcGVkRG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZERvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWwgY2hlY2sgZm9yIG1vdXNlZG93bi90b3VjaHN0YXJ0IC0gbW91c2V1cC90b3VjaGVuZCBpbmNvbnNpc3RlbmNpZXMgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3RvdWNoQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RvdWNoQ291bnQgPSBldi50b3VjaGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19jbGVhclRlbXBTdGF0ZXMoKTtcclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSByZWxlYXNlIGV2ZW50IFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19oYXNSZWxlYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVJlbGVhc2UoZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHN3aXBlIGV2ZW50cyBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19oYW5kbGVTd2lwZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IERvbUV2ZW50cy5jb25maWcsIGludGVydmFscyA9IGNvbmZpZy5pbnRlcnZhbHMsIHRvdWNoRW5kID0gZXYudGltZVN0YW1wLCB0b3VjaERvd24gPSB0aGlzLl9fbGFzdFRvdWNoRG93bjtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIG1vdmVkIHRoZWlyIGZpbmdlciAoZm9yIHNjcm9sbCkgd2UgaGFuZGxlICR0cmFja2VuZCBhbmQgcmV0dXJuLCBcclxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhleSBoYWQgdGhlaXIgZmluZ2VyIGRvd24gdG9vIGxvbmcgdG8gYmUgY29uc2lkZXJlZCBhIHRhcCwgd2Ugd2FudCB0byByZXR1cm4gXHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlVHJhY2tFbmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190YXBDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FwdHVyZWQgdGFyZ2V0IFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jYXB0dXJlZFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bGwodG91Y2hEb3duKSB8fCAoKHRvdWNoRW5kIC0gdG91Y2hEb3duLnRpbWVTdGFtcCkgPiBpbnRlcnZhbHMudGFwSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXB0dXJlZCB0YXJnZXQgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NhcHR1cmVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsYXN0VG91Y2hVcCA9IHRoaXMuX19sYXN0VG91Y2hVcCwgeCA9IGV2LmNsaWVudFgsIHkgPSBldi5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgY2FuIGJlIGEgZG91YmxlIHRhcCBldmVudCBieSBjaGVja2luZyBudW1iZXIgb2YgdGFwcywgZGlzdGFuY2UgYmV0d2VlbiB0YXBzLCBcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aW1lIGJldHdlZW4gdGFwcyBcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fdGFwQ291bnQgPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2dldERpc3RhbmNlKHgsIGxhc3RUb3VjaFVwLmNsaWVudFgsIHksIGxhc3RUb3VjaFVwLmNsaWVudFkpIDw9IGNvbmZpZy5kaXN0YW5jZXMubWF4RGJsVGFwRGlzdGFuY2UgJiZcclxuICAgICAgICAgICAgICAgICAgICAoKHRvdWNoRW5kIC0gbGFzdFRvdWNoVXAudGltZVN0YW1wKSA8PSBpbnRlcnZhbHMuZGJsVGFwSW50ZXJ2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIGRibHRhcCBldmVudHMgXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZURibHRhcChldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGFwQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHRhcCBldmVudHMgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlVGFwKGV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19sYXN0VG91Y2hVcCA9IGV2O1xyXG4gICAgICAgICAgICAgICAgLy8gY2xlYXIgY2FwdHVyZWQgdGFyZ2V0IFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhcHR1cmVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsZWFycyBhbGwgdGVtcG9yYXJ5IHN0YXRlcyBsaWtlIG1vdmUgYW5kIGhvbGQgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2NsZWFyVGVtcFN0YXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFyIGhvbGQgZXZlbnQgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRIb2xkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZGV0ZWN0aW5nTW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX191bnJlZ2lzdGVyVHlwZSh0aGlzLl9tb3ZlRXZlbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGV0ZWN0aW5nTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgcmVzZXR0aW5nIGFsbCB2YWx1ZXMgcG90ZW50aWFsbHkgbW9kaWZpZWQgZHVyaW5nIHRoZSB0b3VjaCBldmVudCBzZXF1ZW5jZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19yZXNldFRvdWNoRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50ID0gdGhpcy5fX3RvdWNoQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5Ub3VjaCA9IHRoaXMuX19oYXNSZWxlYXNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcG9pbnRlckhhc2ggPSB7fTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVyRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBjYXB0dXJlZCB0YXJnZXQgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FwdHVyZWRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBnZXN0dXJlIGhhbmRsaW5nIG1ldGhvZHMgXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyB3aGVuIGdlc3R1cmVzIGFyZSBjYW5jZWxlZCB2aWEgdGhlIEJyb3dzZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggY2FuY2VsIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVDYW5jZWxlZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzIHx8IHRoaXMuX19wb2ludGVyRXZlbnRzLCBpbmRleCA9IHRoaXMuX19nZXRUb3VjaEluZGV4KHRvdWNoZXMpO1xyXG4gICAgICAgICAgICAgICAgZXYgPSBpbmRleCA+PSAwID8gdG91Y2hlc1tpbmRleF0gOiB0aGlzLl9fc3RhbmRhcmRpemVFdmVudE9iamVjdChldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pblRvdWNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2xlYXJUZW1wU3RhdGVzKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBtYXBwZWQgZXZlbnRzIFxyXG4gICAgICAgICAgICAgICAgdmFyIG1hcHBlZFR5cGUgPSB0aGlzLl9fcmV2ZXJzZU1hcFtldi50eXBlXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fbWFwcGVkQ291bnRbbWFwcGVkVHlwZV0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcHBlZERvbUV2ZW50ID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXIoZXYudGFyZ2V0LCBtYXBwZWRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChtYXBwZWREb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkRG9tRXZlbnQudHJpZ2dlcihldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19oYXNNb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFuZHJvaWQgNC40LnggZmlyZXMgdG91Y2hjYW5jZWwgd2hlbiB0aGUgZmluZ2VyIG1vdmVzIG9mZiBhbiBlbGVtZW50IHRoYXQgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbGlzdGVuaW5nIGZvciB0b3VjaCBldmVudHMsIHNvIHdlIHNob3VsZCBoYW5kbGUgc3dpcGVzIGhlcmUgaW4gdGhhdCBjYXNlLiBcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5kcm9pZDQ0b3JCZWxvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGFuZGxlU3dpcGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2hhbmRsZVRyYWNrRW5kKGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXNldFRvdWNoRW5kKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyBhbmQgZmlyaW5nIHRhcCBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVUYXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdGFwQ291bnQrKztcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlQ291bnQuJHRhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGdlc3R1cmVzID0gdGhpcy5fZ2VzdHVyZXMsIGRvbUV2ZW50ID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXIoZXYudGFyZ2V0LCBnZXN0dXJlcy4kdGFwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZmlyZSB0YXAgZXZlbnQgaW1tZWRpYXRlbHkgaWYgbm8gZGJsdGFwIHpvb20gZGVsYXkgXHJcbiAgICAgICAgICAgICAgICAvLyBvciBhIG1vdXNlIGlzIGJlaW5nIHVzZWQgXHJcbiAgICAgICAgICAgICAgICBpZiAoRG9tRXZlbnRzLmNvbmZpZy5pbnRlcnZhbHMuZGJsVGFwWm9vbURlbGF5IDw9IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICBldi5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldi50eXBlID09PSAnbW91c2V1cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBldi5fYnV0dG9ucyA9IHRoaXMuX19sYXN0VG91Y2hEb3duLl9idXR0b25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRlZmVyIGZvciB0YXAgZGVsYXkgaW4gY2FzZSBvZiBzb21ldGhpbmcgbGlrZSBkZXNpcmVkIFxyXG4gICAgICAgICAgICAgICAgLy8gZGJsdGFwIHpvb20gXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fY2FuY2VsRGVmZXJyZWRUYXAgPSBkZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuX2J1dHRvbnMgPSBfdGhpcy5fX2xhc3RUb3VjaERvd24uX2J1dHRvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQudHJpZ2dlcihldik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX190YXBDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19jYW5jZWxEZWZlcnJlZFRhcCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9LCBEb21FdmVudHMuY29uZmlnLmludGVydmFscy5kYmxUYXBab29tRGVsYXkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgYW5kIGZpcmluZyBkb3VibGUgdGFwIGV2ZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSB0b3VjaCBlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2hhbmRsZURibHRhcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3RhcENvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19jYW5jZWxEZWZlcnJlZFRhcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NhbmNlbERlZmVycmVkVGFwID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nZXN0dXJlQ291bnQuJGRibHRhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXIoZXYudGFyZ2V0LCB0aGlzLl9nZXN0dXJlcy4kZGJsdGFwKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXYuX2J1dHRvbnMgPSB0aGlzLl9fbGFzdFRvdWNoRG93bi5fYnV0dG9ucztcclxuICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvdWNoIGNvdW50IHRvIC0xIHRvIHByZXZlbnQgcmVwZWF0ZWQgZmlyZSBvbiBzZXF1ZW50aWFsIHRhcHMgXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fdGFwQ291bnQgPSAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFuZCBmaXJpbmcgcmVsZWFzZSBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19oYW5kbGVSZWxlYXNlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldi50YXJnZXQsIHRoaXMuX2dlc3R1cmVzLiRyZWxlYXNlKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2hhc1JlbGVhc2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFuZCBmaXJpbmcgc3dpcGUgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2hhbmRsZVN3aXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgc3dpcGluZyBldmVudHMgZXhpc3QgXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUNvdW50LiRzd2lwZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RNb3ZlID0gdGhpcy5fX2xhc3RNb3ZlRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGxhc3RNb3ZlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLl9fc3dpcGVPcmlnaW4sIGR4ID0gTWF0aC5hYnMobGFzdE1vdmUuY2xpZW50WCAtIG9yaWdpbi5jbGllbnRYKSwgZHkgPSBNYXRoLmFicyhsYXN0TW92ZS5jbGllbnRZIC0gb3JpZ2luLmNsaWVudFkpLCBzd2lwZVN1YnNjcmliZXJzID0gdGhpcy5fX2dldFJlZ2lzdGVyZWRTd2lwZXMobGFzdE1vdmUuZGlyZWN0aW9uLCBsYXN0TW92ZS52ZWxvY2l0eSwgZHgsIGR5KTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzd2lwZVN1YnNjcmliZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZVN1YnNjcmliZXJzLnBvcCgpLnRyaWdnZXIobGFzdE1vdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2xhc3RNb3ZlRXZlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgYW5kIGZpcmluZyB0cmFjayBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBldiBUaGUgdG91Y2ggbW92ZSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JUG9pbnRlckV2ZW50fSBvcmlnaW5hbEV2IFRoZSBvcmlnaW5hbCB0b3VjaCBtb3ZlIGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAgICAgKiB1c2VkIGZvciBwcmV2ZW50aW5nIGRlZmF1bHQgaW4gdGhlIGNhc2Ugb2YgYW4gQU5EUk9JRCBkZXZpY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9faGFuZGxlVHJhY2sgPSBmdW5jdGlvbiAoZXYsIG9yaWdpbmFsRXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBnZXN0dXJlcyA9IHRoaXMuX2dlc3R1cmVzLCB0cmFja0dlc3R1cmUgPSBnZXN0dXJlcy4kdHJhY2ssIGRpcmVjdGlvbiA9IGV2LmRpcmVjdGlvbiwgZXZlbnRUYXJnZXQgPSB0aGlzLl9fY2FwdHVyZWRUYXJnZXQgfHwgZXYudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvbUV2ZW50cyA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVycyhldmVudFRhcmdldCwgW3RyYWNrR2VzdHVyZSwgKHRyYWNrR2VzdHVyZSArIGRpcmVjdGlvbi54KSwgKHRyYWNrR2VzdHVyZSArIGRpcmVjdGlvbi55KV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuZHJvaWQ0NG9yQmVsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW55RXZlbnRzID0gdGhpcy5fX2ZpbmRGaXJzdFN1YnNjcmliZXJzKGV2ZW50VGFyZ2V0LCBbdHJhY2tHZXN0dXJlLCBnZXN0dXJlcy4kdHJhY2tkb3duLCBnZXN0dXJlcy4kdHJhY2t1cCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VzdHVyZXMuJHRyYWNrbGVmdCwgZ2VzdHVyZXMuJHRyYWNrcmlnaHQsIGdlc3R1cmVzLiR0cmFja2VuZF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbnlFdmVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRvbUV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuZHJvaWRWZXJzaW9uID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZG9tRXZlbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnRzLnBvcCgpLnRyaWdnZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIGhhbmRsaW5nIGFuZCBmaXJpbmcgdHJhY2sgZW5kIGV2ZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSB0b3VjaCBlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2hhbmRsZVRyYWNrRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2VzdHVyZUNvdW50LiR0cmFja2VuZCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50VGFyZ2V0ID0gdGhpcy5fX2NhcHR1cmVkVGFyZ2V0IHx8IGV2LnRhcmdldCwgZG9tRXZlbnQgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcihldmVudFRhcmdldCwgdGhpcy5fZ2VzdHVyZXMuJHRyYWNrZW5kKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9tRXZlbnQudHJpZ2dlcihldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHRvdWNoIHR5cGUgYW5kIGVsZW1lbnQgcmVnaXN0cmF0aW9uIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgZGV0ZXJtaW5pbmcgdGhlIHByb3BlciB0b3VjaCBldmVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fZ2V0VHlwZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdCwgdG91Y2hFdmVudHMgPSBfY29tcGF0Lm1hcHBlZEV2ZW50cywgbGlzdGVuZXJzID0gdGhpcy5fX2xpc3RlbmVycywgc3RhcnRFdmVudHMsIG1vdmVFdmVudHMsIGVuZEV2ZW50cztcclxuICAgICAgICAgICAgICAgIGlmIChfY29tcGF0Lmhhc1BvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50cyA9IHRoaXMuX3N0YXJ0RXZlbnRzID0gdG91Y2hFdmVudHMuJHRvdWNoc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZUV2ZW50cyA9IHRoaXMuX21vdmVFdmVudHMgPSB0b3VjaEV2ZW50cy4kdG91Y2htb3ZlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZEV2ZW50cyA9IHRoaXMuX2VuZEV2ZW50cyA9IHRvdWNoRXZlbnRzLiR0b3VjaGVuZCArICcgJyArIHRvdWNoRXZlbnRzLiR0b3VjaGNhbmNlbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9jb21wYXQuaGFzVG91Y2hFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFydEV2ZW50cyA9IHRoaXMuX3N0YXJ0RXZlbnRzID0gdG91Y2hFdmVudHMuJHRvdWNoc3RhcnQgKyAnIG1vdXNlZG93bic7XHJcbiAgICAgICAgICAgICAgICAgICAgbW92ZUV2ZW50cyA9IHRoaXMuX21vdmVFdmVudHMgPSB0b3VjaEV2ZW50cy4kdG91Y2htb3ZlICsgJyBtb3VzZW1vdmUnO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZEV2ZW50cyA9IHRoaXMuX2VuZEV2ZW50cyA9IHRvdWNoRXZlbnRzLiR0b3VjaGVuZCArICcgbW91c2V1cCAnICsgdG91Y2hFdmVudHMuJHRvdWNoY2FuY2VsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbEV2ZW50ID0gdG91Y2hFdmVudHMuJHRvdWNoY2FuY2VsO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnRzID0gdGhpcy5fc3RhcnRFdmVudHMgPSB0b3VjaEV2ZW50cy4kdG91Y2hzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBtb3ZlRXZlbnRzID0gdGhpcy5fbW92ZUV2ZW50cyA9IHRvdWNoRXZlbnRzLiR0b3VjaG1vdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kRXZlbnRzID0gdGhpcy5fZW5kRXZlbnRzID0gdG91Y2hFdmVudHMuJHRvdWNoZW5kICsgKCFjYW5jZWxFdmVudCA/ICcnIDogKCcgJyArIGNhbmNlbEV2ZW50KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbc3RhcnRFdmVudHNdID0gdGhpcy5fb25Ub3VjaFN0YXJ0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbbW92ZUV2ZW50c10gPSB0aGlzLl9vblRvdWNoTW92ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzW2VuZEV2ZW50c10gPSB0aGlzLl9vblRvdWNoRW5kLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgZm9yIGFuZCBzdGFydHMgbGlzdGVuaW5nIHRvIHN0YXJ0IGFuZCBlbmQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19yZWdpc3RlclR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlZ2lzdGVyVHlwZSh0aGlzLl9zdGFydEV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVnaXN0ZXJUeXBlKHRoaXMuX2VuZEV2ZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvLyBkcmFnc3RhcnQgd2lsbCBjYXVzZSB0b3VjaGVuZCB0byBub3QgZmlyZSBcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX19wcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5yZWdpc3RlcnMgZm9yIGFuZCBzdG9wcyBsaXN0ZW5pbmcgdG8gYWxsIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fdW5yZWdpc3RlclR5cGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3VucmVnaXN0ZXJUeXBlKHRoaXMuX3N0YXJ0RXZlbnRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX191bnJlZ2lzdGVyVHlwZSh0aGlzLl9lbmRFdmVudHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19kZXRlY3RpbmdNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3VucmVnaXN0ZXJUeXBlKHRoaXMuX21vdmVFdmVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19kZXRlY3RpbmdNb3ZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVycyBmb3IgYW5kIGJlZ2lucyBsaXN0ZW5pbmcgdG8gYSBwYXJ0aWN1bGFyIHRvdWNoIGV2ZW50IHR5cGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudHMgVGhlIGV2ZW50cyB0byBiZWdpbiBsaXN0ZW5pbmcgZm9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3JlZ2lzdGVyVHlwZSA9IGZ1bmN0aW9uIChldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX19saXN0ZW5lcnNbZXZlbnRzXSwgX2RvY3VtZW50ID0gdGhpcy5fZG9jdW1lbnQsIGV2ZW50U3BsaXQgPSBldmVudHMuc3BsaXQoJyAnKSwgaW5kZXggPSBldmVudFNwbGl0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50U3BsaXRbaW5kZXhdLCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5yZWdpc3RlcnMgZm9yIGFuZCBzdG9wcyBsaXN0ZW5pbmcgdG8gYSBwYXJ0aWN1bGFyIHRvdWNoIGV2ZW50IHR5cGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudHMgVGhlIGV2ZW50cyB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fdW5yZWdpc3RlclR5cGUgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9fbGlzdGVuZXJzW2V2ZW50c10sIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBldmVudFNwbGl0ID0gZXZlbnRzLnNwbGl0KCcgJyksIGluZGV4ID0gZXZlbnRTcGxpdC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFNwbGl0W2luZGV4XSwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVycyBhbmQgYXNzb2NpYXRlcyBhbiBlbGVtZW50IHdpdGggYW4gZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JQ3VzdG9tRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCBiZWluZyB0aWVkIHRvIGEgY3VzdG9tIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19yZWdpc3RlckVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkLCBfcGxhdCA9IGVsZW1lbnQuX19wbGF0O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChfcGxhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IHVuaXF1ZUlkKCdkb21FdmVudF8nKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Ll9fcGxhdCA9IF9wbGF0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21FdmVudDogaWRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsKF9wbGF0LmRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkID0gdW5pcXVlSWQoJ2RvbUV2ZW50XycpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9wbGF0LmRvbUV2ZW50ID0gaWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvbUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHRoaXMuX3N1YnNjcmliZXJzW19wbGF0LmRvbUV2ZW50XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc3Vic2NyaWJlclt0eXBlXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2RvbUV2ZW50ID0gbmV3IEN1c3RvbURvbUV2ZW50KGVsZW1lbnQsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyW3R5cGVdID0gX2RvbUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlclt0eXBlXS5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmdlc3R1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBuZXdTdWJzY3JpYmVyID0geyBnZXN0dXJlQ291bnQ6IDEgfTtcclxuICAgICAgICAgICAgICAgIF9kb21FdmVudCA9IG5ldyBDdXN0b21Eb21FdmVudChlbGVtZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgICAgIG5ld1N1YnNjcmliZXJbdHlwZV0gPSBfZG9tRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVyc1tpZF0gPSBuZXdTdWJzY3JpYmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChlbGVtZW50LmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBEb21FdmVudHMuY29uZmlnLnN0eWxlQ29uZmlnWzBdLmNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlU2VsZWN0aW9ucyhlbGVtZW50KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVucmVnaXN0ZXJzIGFuZCBkaXNhc3NvY2lhdGVzIGFuIGVsZW1lbnQgd2l0aCBhbiBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklDdXN0b21FbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGJlaW5nIGRpc2Fzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gY3VzdG9tIGV2ZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgdHlwZSBvZiBldmVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX191bnJlZ2lzdGVyRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BsYXQgPSBlbGVtZW50Ll9fcGxhdDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoX3BsYXQpIHx8IGlzTnVsbChfcGxhdC5kb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9tRXZlbnRJZCA9IF9wbGF0LmRvbUV2ZW50LCBldmVudFN1YnNjcmliZXIgPSB0aGlzLl9zdWJzY3JpYmVyc1tkb21FdmVudElkXSwgZG9tRXZlbnQgPSBldmVudFN1YnNjcmliZXJbdHlwZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGRvbUV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRvbUV2ZW50LmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9tRXZlbnQuY291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShldmVudFN1YnNjcmliZXIsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXZlbnRTdWJzY3JpYmVyLmdlc3R1cmVDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50U3Vic2NyaWJlci5nZXN0dXJlQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSh0aGlzLl9zdWJzY3JpYmVycywgZG9tRXZlbnRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlbW92ZUVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHRvdWNoIHBvaW50IGFuZCBoZWxwcyBzdGFuZGFyZGl6ZSB0aGUgZ2l2ZW4gZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIGN1cnJlbnQgcG9pbnQgYmVpbmcgdG91Y2hlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19zZXRUb3VjaFBvaW50ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gZXYudHlwZSwgX2NvbXBhdCA9IHRoaXMuX2NvbXBhdDtcclxuICAgICAgICAgICAgICAgIGlmIChfY29tcGF0Lmhhc1BvaW50ZXJFdmVudHMgfHwgX2NvbXBhdC5oYXNNc1BvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdXBkYXRlUG9pbnRlcnMoZXYsIHRoaXMuX19wb2ludGVyRW5kUmVnZXgudGVzdChldmVudFR5cGUpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldi5wb2ludGVyVHlwZSA9IGV2ZW50VHlwZS5pbmRleE9mKCdtb3VzZScpID09PSAtMSA/ICd0b3VjaCcgOiAnbW91c2UnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY2FwdHVyZWQgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXQgVGhlIHRhcmdldCB0byBjYXB0dXJlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3NldENhcHR1cmUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuX19jYXB0dXJlZFRhcmdldCkgJiYgIWlzRG9jdW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19jYXB0dXJlZFRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGNhcHR1cmVkIHRhcmdldC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSBjdXJyZW50IHRvdWNoIHBvaW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbW92ZSBXaGV0aGVyIHRvIHJlbW92ZSB0aGUgdG91Y2ggcG9pbnQgb3IgYWRkIGl0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3VwZGF0ZVBvaW50ZXJzID0gZnVuY3Rpb24gKGV2LCByZW1vdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZCA9IGV2LnBvaW50ZXJJZCwgcG9pbnRlckhhc2ggPSB0aGlzLl9fcG9pbnRlckhhc2gsIHBvaW50ZXIgPSBwb2ludGVySGFzaFtpZF0sIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQocG9pbnRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9fcG9pbnRlckV2ZW50cy5pbmRleE9mKHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3BvaW50ZXJFdmVudHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eSh0aGlzLl9fcG9pbnRlckhhc2gsIGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgPT09IDEgJiYgIWlzRW1wdHkocG9pbnRlckhhc2gpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBtb3VzZSBtb3ZlbWVudCB3aGlsZSBtaWQgdG91Y2ggXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZXYuaWRlbnRpZmllciA9IGV2LnBvaW50ZXJJZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQocG9pbnRlcikgfHwgKGluZGV4ID0gdGhpcy5fX3BvaW50ZXJFdmVudHMuaW5kZXhPZihwb2ludGVyKSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19wb2ludGVyRXZlbnRzLnB1c2goZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3BvaW50ZXJFdmVudHMuc3BsaWNlKGluZGV4LCAxLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJIYXNoW2lkXSA9IGV2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyBldmVudCBhbmQgc3Vic2NyaXB0aW9uIGhhbmRsaW5nIFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VhcmNoZXMgZnJvbSB0aGUgRXZlbnRUYXJnZXQgdXAgdGhlIERPTSB0cmVlIGxvb2tpbmcgZm9yIGFuIGVsZW1lbnQgd2l0aCB0aGVcclxuICAgICAgICAgICAgICogcmVnaXN0ZXJlZCBldmVudCB0eXBlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUN1c3RvbUVsZW1lbnR9IGV2ZW50VGFyZ2V0IFRoZSBjdXJyZW50IHRhcmdldCBvZiB0aGUgdG91Y2ggZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IGJlaW5nIHNlYXJjaGVkIGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19maW5kRmlyc3RTdWJzY3JpYmVyID0gZnVuY3Rpb24gKGV2ZW50VGFyZ2V0LCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGV2ZW50VGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBfcGxhdCwgc3Vic2NyaWJlciwgZG9tRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3BsYXQgPSBldmVudFRhcmdldC5fX3BsYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9wbGF0KSB8fCBpc1VuZGVmaW5lZChfcGxhdC5kb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIgPSB0aGlzLl9zdWJzY3JpYmVyc1tfcGxhdC5kb21FdmVudF07XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tRXZlbnQgPSBzdWJzY3JpYmVyW3R5cGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkb21FdmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb21FdmVudDtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKCFpc051bGwoZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldC5wYXJlbnROb2RlKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZWFyY2hlcyBmcm9tIHRoZSBFdmVudFRhcmdldCB1cCB0aGUgRE9NIHRyZWUgbG9va2luZyBmb3IgYWxsIGVsZW1lbnRzIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyZWQgZXZlbnQgdHlwZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JQ3VzdG9tRWxlbWVudH0gZXZlbnRUYXJnZXQgVGhlIGN1cnJlbnQgdGFyZ2V0IG9mIHRoZSB0b3VjaCBldmVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB0eXBlcyBBbiBhcnJheSBvZiB0aGUgdHlwZXMgb2YgZXZlbnRzIGJlaW5nIHNlYXJjaGVkIGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19maW5kRmlyc3RTdWJzY3JpYmVycyA9IGZ1bmN0aW9uIChldmVudFRhcmdldCwgdHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoZXZlbnRUYXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIF9wbGF0LCBzdWJzY3JpYmVyLCBzdWJzY3JpYmVyS2V5cywgc3Vic2NyaWJlcktleSwgZG9tRXZlbnRzID0gW10sIGluZGV4O1xyXG4gICAgICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9wbGF0ID0gZXZlbnRUYXJnZXQuX19wbGF0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChfcGxhdCkgfHwgaXNVbmRlZmluZWQoX3BsYXQuZG9tRXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyID0gdGhpcy5fc3Vic2NyaWJlcnNbX3BsYXQuZG9tRXZlbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJLZXlzID0gT2JqZWN0LmtleXMoc3Vic2NyaWJlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN1YnNjcmliZXJLZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcktleSA9IHN1YnNjcmliZXJLZXlzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHR5cGVzLmluZGV4T2Yoc3Vic2NyaWJlcktleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbUV2ZW50cy5wdXNoKHN1YnNjcmliZXJbc3Vic2NyaWJlcktleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHR5cGVzLmxlbmd0aCA+IDAgJiYgIWlzTnVsbChldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0LnBhcmVudE5vZGUpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkb21FdmVudHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50IHR5cGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JQ3VzdG9tRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byByZW1vdmUgdGhlIGxpc3RlbmVyIGZyb20uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IGJlaW5nIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUxpc3RlbmVyfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgYmVpbmcgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB1c2VDYXB0dXJlPyBXaGV0aGVyIHRoZSBsaXN0ZW5lciBpcyBmaXJlZCBvbiB0aGUgY2FwdHVyZSBvciBidWJibGUgcGhhc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGdlc3R1cmVzID0gdGhpcy5fZ2VzdHVyZXM7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN3aXBlR2VzdHVyZSA9IGdlc3R1cmVzLiRzd2lwZSwgdHJhY2tHZXN0dXJlID0gZ2VzdHVyZXMuJHRyYWNrLCBjb3VudFR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaW5kZXhPZih0cmFja0dlc3R1cmUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFja2VuZCA9IGdlc3R1cmVzLiR0cmFja2VuZDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudFR5cGUgPSB0eXBlID09PSB0cmFja2VuZCA/IHRyYWNrZW5kIDogdHJhY2tHZXN0dXJlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5pbmRleE9mKHN3aXBlR2VzdHVyZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRUeXBlID0gc3dpcGVHZXN0dXJlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZUNvdW50W2NvdW50VHlwZV0tLTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX191bnJlZ2lzdGVyRWxlbWVudChlbGVtZW50LCB0eXBlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBzdWJzY3JpYmVyIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklDdXN0b21FbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGJlaW5nIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fcmVtb3ZlRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmV0dXJuU2VsZWN0aW9ucyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZWxlbWVudC5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgRG9tRXZlbnRzLmNvbmZpZy5zdHlsZUNvbmZpZ1swXS5jbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBsYXQgPSBlbGVtZW50Ll9fcGxhdDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHBsYXQsICdkb21FdmVudCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkocGxhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShlbGVtZW50LCAnX19wbGF0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdGFuZGFyZGl6ZXMgY2VydGFpbiBwcm9wZXJ0aWVzIG9uIHRoZSBldmVudCBvYmplY3QgZm9yIGN1c3RvbSBldmVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JRXh0ZW5kZWRFdmVudH0gZXYgVGhlIGV2ZW50IG9iamVjdCB0byBiZSBzdGFuZGFyZGl6ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fc3RhbmRhcmRpemVFdmVudE9iamVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3NldFRvdWNoUG9pbnQoZXYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzU3RhcnQgPSB0aGlzLl9zdGFydEV2ZW50cy5pbmRleE9mKGV2LnR5cGUpICE9PSAtMSwgdG91Y2hlcyA9IGV2LnRvdWNoZXMgfHwgdGhpcy5fX3BvaW50ZXJFdmVudHMsIGNoYW5nZWRUb3VjaGVzID0gZXYuY2hhbmdlZFRvdWNoZXMsIGNoYW5nZWRUb3VjaGVzRXhpc3QgPSAhaXNVbmRlZmluZWQoY2hhbmdlZFRvdWNoZXMpLCBwcmV2ZW50RGVmYXVsdCwgdGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRUb3VjaGVzRXhpc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IGV2LnByZXZlbnREZWZhdWx0LmJpbmQoZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldiA9IGNoYW5nZWRUb3VjaGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRUb3VjaEluZGV4ID0gdGhpcy5fX2dldFRvdWNoSW5kZXgoY2hhbmdlZFRvdWNoZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZFRvdWNoSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgPSBldi5wcmV2ZW50RGVmYXVsdC5iaW5kKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ID0gY2hhbmdlZFRvdWNoZXNbY2hhbmdlZFRvdWNoSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fZ2V0VG91Y2hJbmRleCh0b3VjaGVzKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIHJldHVybiBudWxsIGJlY2F1c2Ugb3VyIHBvaW50IG9mIGludGVyZXN0IGlzIGluIHRvdWNoZXMgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2FzIG5vdCBpbiBjaGFuZ2VkVG91Y2hlcyBzbyBpdCBpcyBzdGlsbCBwbGF5aW5nIGEgcGFydCBvbiB0aGUgcGFnZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU3RhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc2V0Q2FwdHVyZShldi50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX25vcm1hbGl6ZUJ1dHRvbnMoZXYpO1xyXG4gICAgICAgICAgICAgICAgZXYudG91Y2hlcyA9IHRvdWNoZXM7XHJcbiAgICAgICAgICAgICAgICBldi5vZmZzZXQgPSB0aGlzLl9fZ2V0T2Zmc2V0KGV2KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChldi50aW1lU3RhbXApIHx8IHRpbWVTdGFtcCA+IGV2LnRpbWVTdGFtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2LnRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBldjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vcm1hbGl6ZXMgdGhlICdidXR0b25zJyBwcm9wZXJ0eSBvbiBhbiBJRXhldGVuZGVkRXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JRXh0ZW5kZWRFdmVudH0gZXYgVGhlIGV2ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX25vcm1hbGl6ZUJ1dHRvbnMgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBidXR0b25zO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGV2LmJ1dHRvbnMpICYmIGV2LmJ1dHRvbnMgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gZXYuYnV0dG9ucztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKGV2LndoaWNoKSAmJiBldi53aGljaCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gZXYud2hpY2g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2LmJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDE2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2Ll9idXR0b25zID0gYnV0dG9ucztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNlYXJjaGVzIHRocm91Z2ggdGhlIGlucHV0IGFycmF5IGxvb2tpbmcgZm9yIHRoZSBwcmltYXJ5XHJcbiAgICAgICAgICAgICAqIHRvdWNoIGRvd24gaW5kZXguXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC51aS5JRXh0ZW5kZWRFdmVudD59IGV2IFRoZSBhcnJheSBvZiB0b3VjaCBldmVudCBvYmplY3RzXHJcbiAgICAgICAgICAgICAqIHRvIHNlYXJjaCB0aHJvdWdoLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2dldFRvdWNoSW5kZXggPSBmdW5jdGlvbiAodG91Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSAodGhpcy5fX2xhc3RUb3VjaERvd24gfHwge30pLmlkZW50aWZpZXIsIGxlbmd0aCA9IHRvdWNoZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3VjaGVzW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR3JhYnMgdGhlIHggYW5kIHkgb2Zmc2V0cyBvZiBhbiBldmVudCBvYmplY3QncyB0YXJnZXQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JRXh0ZW5kZWRFdmVudH0gZXYgVGhlIGN1cnJlbnQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2dldE9mZnNldCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX19jYXB0dXJlZFRhcmdldCB8fCBldi50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEb2N1bWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNVbmRlZmluZWQoZXYub2Zmc2V0WCkgJiYgIWlzVW5kZWZpbmVkKGV2Lm9mZnNldFkpICYmIHRhcmdldCA9PT0gZXYudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogZXYub2Zmc2V0WCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogZXYub2Zmc2V0WVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgeCwgeTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHJlY3QubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gcmVjdC50b3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gdGFyZ2V0Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHRhcmdldC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bGwodGFyZ2V0ID0gdGFyZ2V0Lm9mZnNldFBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSB0YXJnZXQub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSB0YXJnZXQub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogKGV2LmNsaWVudFggLSB4KSxcclxuICAgICAgICAgICAgICAgICAgICB5OiAoZXYuY2xpZW50WSAtIHkpXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvLyB1dGlsaXR5IG1ldGhvZHMgXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byAoeCwgeSkgY29vcmRpbmF0ZSBwb2ludHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHgyIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHkxIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geTIgVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIHBvaW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2dldERpc3RhbmNlID0gZnVuY3Rpb24gKHgxLCB4MiwgeTEsIHkyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHgyIC0geDEsIHkgPSB5MiAtIHkxO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byAoeCwgeSkgY29vcmRpbmF0ZSBwb2ludHMgb3ZlciBhIGdpdmVuIHRpbWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUaGUgY2hhbmdlIGluIHggcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUaGUgY2hhbmdlIGluIHkgcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkdHggVGhlIGNoYW5nZSBpbiB0aW1lIGluIHggZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHR5IFRoZSBjaGFuZ2UgaW4gdGltZSBpbiB5IGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uIChkeCwgZHksIGR0eCwgZHR5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IDAsIHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGR0eCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gKGR4IC8gZHR4KSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGR0eSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gKGR5IC8gZHR5KSB8fCAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXJlY3Rpb24gb2YgbW92ZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUaGUgY2hhbmdlIGluIHggcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeSBUaGUgY2hhbmdlIGluIHkgcG9zaXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKGR4LCBkeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGguYWJzKGR4KSwgZGlzdGFuY2VZID0gTWF0aC5hYnMoZHkpLCBsYXN0RGlyZWN0aW9uID0gKHRoaXMuX19sYXN0TW92ZUV2ZW50IHx8IHt9KS5kaXJlY3Rpb24gfHwge30sIGhvcml6b250YWwgPSBkeCA9PT0gMCA/IChsYXN0RGlyZWN0aW9uLnggfHwgJ25vbmUnKSA6IChkeCA8IDAgPyAnbGVmdCcgOiAncmlnaHQnKSwgdmVydGljYWwgPSBkeSA9PT0gMCA/IChsYXN0RGlyZWN0aW9uLnkgfHwgJ25vbmUnKSA6IChkeSA8IDAgPyAndXAnIDogJ2Rvd24nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogaG9yaXpvbnRhbCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB2ZXJ0aWNhbCxcclxuICAgICAgICAgICAgICAgICAgICBwcmltYXJ5OiAoZGlzdGFuY2VYID09PSBkaXN0YW5jZVkgPyAobGFzdERpcmVjdGlvbi5wcmltYXJ5IHx8ICdub25lJykgOiAoZGlzdGFuY2VYID4gZGlzdGFuY2VZID8gaG9yaXpvbnRhbCA6IHZlcnRpY2FsKSlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3dpcGUgZGlyZWN0aW9uIGhhcyBjaGFuZ2VkIHRvIHJlY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAqIGFuIG9yaWdpbiBwb2ludC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklEaXJlY3Rpb259IGRpcmVjdGlvbiBUaGUgY3VycmVudCB2ZXJ0aWNhbCBhbmQgaG9yaXp0b25hbCBkaXJlY3Rpb25zIG9mIG1vdmVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2hhbmRsZU9yaWdpbkNoYW5nZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBsYXN0TW92ZSA9IHRoaXMuX19sYXN0TW92ZUV2ZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChsYXN0TW92ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3dpcGVEaXJlY3Rpb24gPSBsYXN0TW92ZS5kaXJlY3Rpb24sIHhTYW1lID0gc3dpcGVEaXJlY3Rpb24ueCA9PT0gZGlyZWN0aW9uLngsIHlTYW1lID0gc3dpcGVEaXJlY3Rpb24ueSA9PT0gZGlyZWN0aW9uLnk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeFNhbWUgJiYgeVNhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5fX3N3aXBlT3JpZ2luLCBnZXN0dXJlcyA9IHRoaXMuX2dlc3R1cmVzLCBzd2lwZXMgPSBbZ2VzdHVyZXMuJHN3aXBlLCBnZXN0dXJlcy4kc3dpcGVkb3duLCBnZXN0dXJlcy4kc3dpcGVsZWZ0LCBnZXN0dXJlcy4kc3dpcGVyaWdodCwgZ2VzdHVyZXMuJHN3aXBldXBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF4U2FtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi5jbGllbnRYID0gbGFzdE1vdmUuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4ueFRpbWVzdGFtcCA9IGxhc3RNb3ZlLnRpbWVTdGFtcDtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4ueFRhcmdldCA9IGxhc3RNb3ZlLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYW5kcm9pZDQ0b3JCZWxvdykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9faGF2ZVN3aXBlU3Vic2NyaWJlcnMgPSB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcnMob3JpZ2luLnhUYXJnZXQsIHN3aXBlcykubGVuZ3RoID4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXlTYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luLmNsaWVudFkgPSBsYXN0TW92ZS5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi55VGltZXN0YW1wID0gbGFzdE1vdmUudGltZVN0YW1wO1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbi55VGFyZ2V0ID0gbGFzdE1vdmUudGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmRyb2lkNDRvckJlbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19oYXZlU3dpcGVTdWJzY3JpYmVycyA9IHRoaXMuX19maW5kRmlyc3RTdWJzY3JpYmVycyhvcmlnaW4ueVRhcmdldCwgc3dpcGVzKS5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENoZWNrcyB0byBzZWUgaWYgYSBzd2lwZSBldmVudCBoYXMgYmVlbiByZWdpc3RlcmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSURpcmVjdGlvbn0gZGlyZWN0aW9uIFRoZSBjdXJyZW50IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRpcmVjdGlvbnMgb2YgbW92ZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JVmVsb2NpdHl9IHZlbG9jaXR5IFRoZSBjdXJyZW50IGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHZlbG9jaXRpZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkeCBUaGUgZGlzdGFuY2UgaW4gdGhlIHggZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZHkgVGhlIGRpc3RhbmNlIGluIHRoZSB5IGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19nZXRSZWdpc3RlcmVkU3dpcGVzID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgdmVsb2NpdHksIGR4LCBkeSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN3aXBlVGFyZ2V0LCBzd2lwZUdlc3R1cmUgPSB0aGlzLl9nZXN0dXJlcy4kc3dpcGUsIG1pblN3aXBlVmVsb2NpdHkgPSBEb21FdmVudHMuY29uZmlnLnZlbG9jaXRpZXMubWluU3dpcGVWZWxvY2l0eSwgZXZlbnRzID0gW3N3aXBlR2VzdHVyZV0sIG9yaWdpbiA9ICh0aGlzLl9fc3dpcGVPcmlnaW4gfHwge30pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGR4ID4gZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZVRhcmdldCA9IG9yaWdpbi54VGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZWxvY2l0eS54ID49IG1pblN3aXBlVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goc3dpcGVHZXN0dXJlICsgZGlyZWN0aW9uLngpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5ID4gZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2lwZVRhcmdldCA9IG9yaWdpbi55VGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ZWxvY2l0eS55ID49IG1pblN3aXBlVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goc3dpcGVHZXN0dXJlICsgZGlyZWN0aW9uLnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZmluZEZpcnN0U3Vic2NyaWJlcnMoc3dpcGVUYXJnZXQsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGEgc3dpcGUgZXZlbnQgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBUaGUgY3VycmVudCBkaXJlY3Rpb24gb2YgbW92ZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9faXNIb3Jpem9udGFsID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ2xlZnQnIHx8IGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFwcGVuZHMgQ1NTIHRvIHRoZSBoZWFkIGZvciBnZXN0dXJlcyBpZiBuZWVkZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fYXBwZW5kR2VzdHVyZVN0eWxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBzdHlsZUNsYXNzZXMsIGNsYXNzTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhdC5wbGF0Q3NzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbChfZG9jdW1lbnQuc3R5bGVTaGVldHMpICYmIF9kb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlU2hlZXQgPSBfZG9jdW1lbnQuc3R5bGVTaGVldHNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVDbGFzc2VzID0gRG9tRXZlbnRzLmNvbmZpZy5zdHlsZUNvbmZpZztcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc0xlbmd0aCA9IHN0eWxlQ2xhc3Nlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNsYXNzTGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZSh0aGlzLl9fY3JlYXRlU3R5bGUoc3R5bGVDbGFzc2VzW2NsYXNzTGVuZ3RoXSksIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVhZCA9IF9kb2N1bWVudC5oZWFkLCBzdHlsZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLCB0ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XHJcbiAgICAgICAgICAgICAgICBzdHlsZUNsYXNzZXMgPSBEb21FdmVudHMuY29uZmlnLnN0eWxlQ29uZmlnO1xyXG4gICAgICAgICAgICAgICAgY2xhc3NMZW5ndGggPSBzdHlsZUNsYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNsYXNzTGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgPSB0aGlzLl9fY3JlYXRlU3R5bGUoc3R5bGVDbGFzc2VzW2NsYXNzTGVuZ3RoXSkgKyB0ZXh0Q29udGVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENyZWF0ZXMgYSBzdHlsZSB0ZXh0IHRvIGFwcGVuZCB0byB0aGUgZG9jdW1lbnQgaGVhZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklEZWZhdWx0U3R5bGV9IHN0eWxlQ2xhc3MgVGhlIG9iamVjdCBjb250YWluaW5nIHRoZSBjdXN0b20gc3R5bGVzIGZvclxyXG4gICAgICAgICAgICAgKiBnZXN0dXJlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19jcmVhdGVTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZUNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVzID0gc3R5bGVDbGFzcy5zdHlsZXMgfHwgW10sIHN0eWxlTGVuZ3RoID0gc3R5bGVzLmxlbmd0aCwgc3R5bGUgPSAnLicgKyBzdHlsZUNsYXNzLmNsYXNzTmFtZSArICcgeyAnLCB0ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVMZW5ndGggPSBzdHlsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdHlsZUxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbnRlbnQgKz0gc3R5bGVzW2pdICsgJzsnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3R5bGUgKz0gdGV4dENvbnRlbnQgKyAnIH0gJztcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEJsdXJzIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2JsdXJGb2N1c2VkRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmb2N1c2VkRWxlbWVudCA9IHRoaXMuX19mb2N1c2VkRWxlbWVudCB8fCB7fTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGZvY3VzZWRFbGVtZW50LmJsdXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZEVsZW1lbnQuYmx1cigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTGlzdGVucyBmb3IgYmx1ciBhbmQgdGhlbiBzZXRzIHRoZSBmb2N1c2VkIGVsZW1lbnQgYmFjayB0byBudWxsIGZvciB0aGUgbmV4dCBjYXNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IHRvIGxpc3RlbiBmb3IgdGhlIGJsdXIgZXZlbnQgb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBEb21FdmVudHMucHJvdG90eXBlLl9fd2FpdEZvckJsdXIgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJSZW1vdmVyID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRhcmdldCwgJ2JsdXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19ibHVyUmVtb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fYmx1clJlbW92ZXIgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IF90aGlzLl9fZm9jdXNlZEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19mb2N1c2VkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBhIGNsaWNrIHRhcmdldCBjYXNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IHRvIGhhbmRsZSBjbGljayBmdW5jdGlvbmFsaXkgZm9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2NsaWNrVGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBjbGlja2VkID0gZmFsc2UsIGhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xpY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnModGFyZ2V0KSAmJiBpc0Z1bmN0aW9uKHRhcmdldC5jbGljaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNsaWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIEhUTUxJbnB1dEVsZW1lbnRzIGluIFdlYktpdCBiYXNlZCB0b3VjaCBhcHBsaWNhdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gdGFyZ2V0IFRoZSB0YXJnZXQgdG8gaGFuZGxlIGZ1bmN0aW9uYWxpdHkgZm9yLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX2hhbmRsZUlucHV0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKG5vZGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19mb2N1c2VkRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJGb2N1c2VkRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYmx1ckZvY3VzZWRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Bhc3N3b3JkJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2VhcmNoJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VybCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3dhaXRGb3JCbHVyKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyRm9jdXNlZEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2xpY2tUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2JsdXJGb2N1c2VkRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY2xpY2tUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dGFyZWEnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3dhaXRGb3JCbHVyKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19ibHVyRm9jdXNlZEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NsaWNrVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2ZvY3VzZWRFbGVtZW50ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZlbnREZWZhdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyB0aGUgcGhhbnRvbSBjbGljayBpbiBXZWJLaXQgYmFzZWQgdG91Y2ggYXBwbGljYXRpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3ByZXZlbnRDbGlja0Zyb21Ub3VjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgaWdub3JlRXZlbnRzID0gdGhpcy5fX2lnbm9yZUV2ZW50LCBib3VuZFByZXZlbnREZWZhdWx0ID0gdGhpcy5fX2JvdW5kUHJldmVudERlZmF1bHRDbGljaywgaW50ZXJ2YWwgPSBEb21FdmVudHMuY29uZmlnLmludGVydmFscy5kZWxheWVkQ2xpY2tJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnZhbCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RlbGF5ZWRDbGlja1JlbW92ZXIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2Vkb3duOiBkZWZlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZUV2ZW50cy5tb3VzZWRvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbCksXHJcbiAgICAgICAgICAgICAgICAgICAgbW91c2V1cDogZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVFdmVudHMubW91c2V1cCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGludGVydmFsKSxcclxuICAgICAgICAgICAgICAgICAgICBjbGljazogZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBib3VuZFByZXZlbnREZWZhdWx0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBpbnRlcnZhbClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZ25vcmVFdmVudHMubW91c2Vkb3duID0gaWdub3JlRXZlbnRzLm1vdXNldXAgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGJvdW5kUHJldmVudERlZmF1bHQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcmV2ZW50cyBkZWZhdWx0IGFuZCBzdG9wcyBwcm9wYWdhdGlvbiBmb3IgZGVsYXllZCBvciBwaGFudG9tIGNsaWNrcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5wcm90b3R5cGUuX19wcmV2ZW50RGVmYXVsdENsaWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZXYuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX19ib3VuZFByZXZlbnREZWZhdWx0Q2xpY2ssIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RlbGF5ZWRDbGlja1JlbW92ZXIuY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgc2VsZWN0aW9uIGNhcGFiaWxpdHkgZnJvbSB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZSBzZWxlY3Rpb25zIG9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3JlbW92ZVNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnQub25zZWxlY3RzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcy5fX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnQub25kcmFnc3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHVybnMgc2VsZWN0aW9uIGNhcGFiaWxpdHkgZnJvbSB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJldHVybiBzZWxlY3Rpb25zIG9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3JldHVyblNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnQub25zZWxlY3RzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgdGhpcy5fX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnQub25kcmFnc3RhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByZXZlbnRzIGRlZmF1bHQgYW5kIHN0b3BzIHByb3BhZ2F0aW9uIGluIGFsbCBlbGVtZW50cyBvdGhlciB0aGFuXHJcbiAgICAgICAgICAgICAqIGlucHV0cyBhbmQgdGV4dGFyZWFzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRG9tRXZlbnRzLnByb3RvdHlwZS5fX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBldi50YXJnZXQubm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcobm9kZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBEb21FdmVudHMuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhbGwgRE9NIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5jb25maWcgPSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGFwSW50ZXJ2YWw6IDMwMCxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBkYmxUYXBJbnRlcnZhbDogMzAwLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRJbnRlcnZhbDogNDAwLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGRibFRhcFpvb21EZWxheTogMCxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBkZWxheWVkQ2xpY2tJbnRlcnZhbDogNDAwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlczoge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblNjcm9sbERpc3RhbmNlOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG1heERibFRhcERpc3RhbmNlOiAxMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0aWVzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgbWluU3dpcGVWZWxvY2l0eTogMC42NDVcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgc3R5bGVDb25maWc6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAncGxhdC1nZXN0dXJlJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctbW96LXVzZXItc2VsZWN0OiBub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLXdlYmtpdC11c2VyLWRyYWc6IG5vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLW1zLXVzZXItc2VsZWN0OiBub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctbXMtdG91Y2gtYWN0aW9uOiBtYW5pcHVsYXRpb24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BsYXQtbm8tdG91Y2gtYWN0aW9uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICctbXMtdG91Y2gtYWN0aW9uOiBub25lJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0b3VjaC1hY3Rpb246IG5vbmUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGV2ZW50IHR5cGVzIGZvciBhbGwgb2YgdGhlXHJcbiAgICAgICAgICAgICAqIHN1cHBvcnRlZCBnZXN0dXJlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50cy5nZXN0dXJlcyA9IHtcclxuICAgICAgICAgICAgICAgICR0YXA6IF9fdGFwLFxyXG4gICAgICAgICAgICAgICAgJGRibHRhcDogX19kYmx0YXAsXHJcbiAgICAgICAgICAgICAgICAkaG9sZDogX19ob2xkLFxyXG4gICAgICAgICAgICAgICAgJHJlbGVhc2U6IF9fcmVsZWFzZSxcclxuICAgICAgICAgICAgICAgICRzd2lwZTogX19zd2lwZSxcclxuICAgICAgICAgICAgICAgICRzd2lwZWxlZnQ6IF9fc3dpcGVsZWZ0LFxyXG4gICAgICAgICAgICAgICAgJHN3aXBlcmlnaHQ6IF9fc3dpcGVyaWdodCxcclxuICAgICAgICAgICAgICAgICRzd2lwZXVwOiBfX3N3aXBldXAsXHJcbiAgICAgICAgICAgICAgICAkc3dpcGVkb3duOiBfX3N3aXBlZG93bixcclxuICAgICAgICAgICAgICAgICR0cmFjazogX190cmFjayxcclxuICAgICAgICAgICAgICAgICR0cmFja2xlZnQ6IF9fdHJhY2tsZWZ0LFxyXG4gICAgICAgICAgICAgICAgJHRyYWNrcmlnaHQ6IF9fdHJhY2tyaWdodCxcclxuICAgICAgICAgICAgICAgICR0cmFja3VwOiBfX3RyYWNrdXAsXHJcbiAgICAgICAgICAgICAgICAkdHJhY2tkb3duOiBfX3RyYWNrZG93bixcclxuICAgICAgICAgICAgICAgICR0cmFja2VuZDogX190cmFja2VuZFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRG9tRXZlbnRzO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgdWkuRG9tRXZlbnRzID0gRG9tRXZlbnRzO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Eb21FdmVudHMsIERvbUV2ZW50cyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSURvbUV2ZW50c0NvbmZpZygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERvbUV2ZW50cy5jb25maWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVpLklEb21FdmVudHNDb25maWcgPSBJRG9tRXZlbnRzQ29uZmlnO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19JRG9tRXZlbnRzQ29uZmlnLCBJRG9tRXZlbnRzQ29uZmlnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNsYXNzIGZvciBtYW5hZ2luZyBhIHNpbmdsZSBjdXN0b20gZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIERvbUV2ZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gRG9tRXZlbnQoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnQgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBhY3F1aXJlKF9fRG9jdW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIERvbUV2ZW50LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBldmVudFR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IGlzU3RyaW5nKGV2ZW50VHlwZSkgPyBldmVudFR5cGUgOiAnQ3VzdG9tRXZlbnQnO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVHJpZ2dlcnMgaXRzIGV2ZW50IG9uIGl0cyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRFeHRlbnNpb24/IEFuIGV2ZW50IGV4dGVuc2lvbiB0byBleHRlbmQgdGhlIGRpc3BhdGNoZWQgQ3VzdG9tRXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBkZXRhaWxBcmc/IFRoZSBkZXRhaWwgYXJnIHRvIGluY2x1ZGUgaW4gdGhlIGV2ZW50IG9iamVjdFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IGRpc3BhdGNoRWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gZGlzcGF0Y2ggdGhlIEV2ZW50IGZyb20uIElmIG5vdCBzcGVjaWZpZWQsXHJcbiAgICAgICAgICAgICAqIHRoaXMgaW5zdGFuY2UncyBlbGVtZW50IHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIERvbUV2ZW50LnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50RXh0ZW5zaW9uLCBkZXRhaWxBcmcsIGRpc3BhdGNoRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUV2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRXZlbnQodGhpcy5ldmVudFR5cGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGV2ZW50RXh0ZW5zaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9leHRlbmQoZmFsc2UsIGZhbHNlLCBjdXN0b21FdiwgZXZlbnRFeHRlbnNpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYuaW5pdEN1c3RvbUV2ZW50KHRoaXMuZXZlbnQsIHRydWUsIHRydWUsIGlzTnVsbChkZXRhaWxBcmcpID8gMCA6IGRldGFpbEFyZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRpc3BhdGNoRWxlbWVudCB8fCB0aGlzLmVsZW1lbnQpLmRpc3BhdGNoRXZlbnQoY3VzdG9tRXYpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRG9tRXZlbnQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICB1aS5Eb21FdmVudCA9IERvbUV2ZW50O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Eb21FdmVudEluc3RhbmNlLCBEb21FdmVudCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzcGVjaWFsaXplZCBjbGFzcyBmb3IgbWFuYWdpbmcgYSBzaW5nbGUgY3VzdG9tIHRvdWNoIGV2ZW50IGluIERvbUV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ3VzdG9tRG9tRXZlbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQ3VzdG9tRG9tRXZlbnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEN1c3RvbURvbUV2ZW50KGVsZW1lbnQsIGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgYWRkZWQgZm9yIHRoaXMgZXZlbnQgb24gdGhpcyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRyaWdnZXJzIGl0cyBldmVudCBvbiBpdHMgZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklQb2ludGVyRXZlbnR9IGV2IFRoZSBjdXJyZW50IHRvdWNoIGV2ZW50IG9iamVjdCB1c2VkIHRvIGV4dGVuZCB0aGVcclxuICAgICAgICAgICAgICogbmV3bHkgY3JlYXRlZCBjdXN0b20gZXZlbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDdXN0b21Eb21FdmVudC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1c3RvbUV2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JyksIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19leHRlbmRFdmVudE9iamVjdChjdXN0b21FdiwgZXYpO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYuaW5pdEN1c3RvbUV2ZW50KHRoaXMuZXZlbnQsIHRydWUsIHRydWUsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBpc0RvY3VtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQuY29udGFpbnModGFyZ2V0KSA/IHRhcmdldC5kaXNwYXRjaEV2ZW50KGN1c3RvbUV2KSA6IGVsZW1lbnQuZGlzcGF0Y2hFdmVudChjdXN0b21Fdik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBFeHRlbmRzIHRoZSBjdXN0b20gZXZlbnQgdG8gbWltaWMgYSBzdGFuZGFyZGl6ZWQgdG91Y2ggZXZlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBjdXN0b21FdiBUaGUgbmV3bHkgY3JlYXRlZCBjdXN0b20gZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSVBvaW50ZXJFdmVudH0gZXYgVGhlIGN1cnJlbnQgdG91Y2ggZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ3VzdG9tRG9tRXZlbnQucHJvdG90eXBlLl9fZXh0ZW5kRXZlbnRPYmplY3QgPSBmdW5jdGlvbiAoY3VzdG9tRXYsIGV2KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBub3QgdXNpbmcgZXh0ZW5kIGZ1bmN0aW9uIGJlY2F1c2UgdGhpcyBnZXRzIGNhbGxlZCBzbyBvZnRlbiBmb3IgY2VydGFpbiBldmVudHMuIFxyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gZXYucG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5jbGllbnRYID0gZXYuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LmNsaWVudFkgPSBldi5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYub2Zmc2V0WCA9IGV2Lm9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYub2Zmc2V0WSA9IGV2Lm9mZnNldC55O1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYuZGlyZWN0aW9uID0gZXYuZGlyZWN0aW9uIHx8IHtcclxuICAgICAgICAgICAgICAgICAgICB4OiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnk6ICdub25lJ1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LnRvdWNoZXMgPSBldi50b3VjaGVzO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYudmVsb2NpdHkgPSBldi52ZWxvY2l0eSB8fCB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LmlkZW50aWZpZXIgPSBldi5pZGVudGlmaWVyIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5wb2ludGVyVHlwZSA9IGlzTnVtYmVyKHBvaW50ZXJUeXBlKSA/IHRoaXMuX19jb252ZXJ0UG9pbnRlclR5cGUocG9pbnRlclR5cGUsIGV2LnR5cGUpIDogcG9pbnRlclR5cGU7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5zY3JlZW5YID0gZXYuc2NyZWVuWDtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LnNjcmVlblkgPSBldi5zY3JlZW5ZO1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRXYucGFnZVggPSBldi5wYWdlWDtcclxuICAgICAgICAgICAgICAgIGN1c3RvbUV2LnBhZ2VZID0gZXYucGFnZVk7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Fdi5idXR0b25zID0gZXYuX2J1dHRvbnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyBwb2ludGVyIHR5cGUgdG8gYSBzdGFuZGFyZGl6ZWQgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcG9pbnRlclR5cGUgVGhlIHBvaW50ZXIgdHlwZSBhcyBlaXRoZXIgYSBudW1iZXIgb3IgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgVGhlIHRvdWNoIGV2ZW50IHR5cGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDdXN0b21Eb21FdmVudC5wcm90b3R5cGUuX19jb252ZXJ0UG9pbnRlclR5cGUgPSBmdW5jdGlvbiAocG9pbnRlclR5cGUsIGV2ZW50VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb2ludGVyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTVNQb2ludGVyRXZlbnQuTVNQT0lOVEVSX1RZUEVfTU9VU0U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnbW91c2UnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTVNQb2ludGVyRXZlbnQuTVNQT0lOVEVSX1RZUEVfUEVOOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3Blbic7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNU1BvaW50ZXJFdmVudC5NU1BPSU5URVJfVFlQRV9UT1VDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0b3VjaCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGV2ZW50VHlwZS5pbmRleE9mKCdtb3VzZScpID09PSAtMSkgPyAndG91Y2gnIDogJ21vdXNlJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIEN1c3RvbURvbUV2ZW50O1xyXG4gICAgICAgIH0oRG9tRXZlbnQpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyBhbGwgdGhlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBVSSBhbmltYXRpb24gY29tcG9uZW50cyBmb3IgcGxhdHlwdXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbnM7XHJcbiAgICAgICAgKGZ1bmN0aW9uIChhbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGNsYXNzIHVzZWQgZm9yIGFuaW1hdGluZyBlbGVtZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBBbmltYXRvciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBBbmltYXRvcigpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBPYmplY3RzIHJlcHJlc2VudGluZyBjb2xsZWN0aW9ucyBvZiBhbGwgY3VycmVudGx5IGFuaW1hdGVkIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVkRWxlbWVudHMgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGUoZWxlbWVudHMsIGtleSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50cywga2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUoZWxlbWVudHMsIGtleSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSwgcGFyZW50LCByZWZDaGlsZCwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmQ2hpbGQ6IHJlZkNoaWxkXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZShlbGVtZW50cywga2V5LCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2xlYXZlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBrZXksIHBhcmVudCwgcmVmQ2hpbGQsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0ZShlbGVtZW50cywga2V5LCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ21vdmUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IHBhcmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmQ2hpbGQ6IHJlZkNoaWxkXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGtleSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnc2hvdydcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uIChlbGVtZW50cywga2V5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGUoZWxlbWVudHMsIGtleSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdoaWRlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCBmdWxmaWxscyB3aGVuIGV2ZXJ5IGFuaW1hdGlvbiBwcm9taXNlIGluIHRoZSBpbnB1dCBhcnJheSBpcyBmdWxmaWxsZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwcm9taXNlcy5sZW5ndGgsIGFyZ3MgPSBbXSwgYW5pbWF0aW9uUHJvbWlzZSA9IG5ldyBBbmltYXRpb25Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9Qcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KHByb21pc2VzW2ldLmdldEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZS5pbml0aWFsaXplKGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbW1lZGlhdGVseSByZXNvbHZlcyBhbiBlbXB0eSBBbmltYXRpb25Qcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uUHJvbWlzZSA9IG5ldyBBbmltYXRpb25Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW5pbWF0ZXMgdGhlIHBhc3NlZCBpbiBlbGVtZW50cyB3aXRoIHRoZSBnaXZlbiBrZXkgYW5kIGhhbmRsZXMgc3BlY2lhbCBhbmltYXRpb24gZnVuY3Rpb25hbGl0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBlbGVtZW50cyBUaGUgTm9kZXMgdG8gYmUgYW5pbWF0ZWQuIEFsbCBub2RlcyBpbiB0aGUgQXJyYXkgbXVzdCBoYXZlXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgc2FtZSBwYXJlbnQsIG90aGVyd2lzZSB0aGUgYW5pbWF0aW9uIHdpbGwgbm90IGZ1bmN0aW9uIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGlkZW50aWZpZXIgc3BlY2lmeWluZyB0aGUgdHlwZSBvZiBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb3B0aW9ucz8gU3BlY2lmaWVkIG9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuYW5pbWF0aW9ucy5JQW5pbWF0aW9uRnVuY3Rpb259IGZ1bmN0aW9uYWxpdHkgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXRcclxuICAgICAgICAgICAgICAgICAqIHNwZWNpYWwgYW5pbWF0aW9uIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5fYW5pbWF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50cywga2V5LCBvcHRpb25zLCBmdW5jdGlvbmFsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuX2NyZWF0ZShlbGVtZW50cywga2V5LCBvcHRpb25zLCBmdW5jdGlvbmFsaXR5KSwgY3VycmVudCA9IGFuaW1hdGlvbi5jdXJyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wcmV2aW91cy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuc3RhcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbmltYXRlcyB0aGUgcGFzc2VkIGluIGVsZW1lbnRzIHdpdGggdGhlIGdpdmVuIGtleSBhbmQgaGFuZGxlcyBzcGVjaWFsIGFuaW1hdGlvbiBmdW5jdGlvbmFsaXR5LiBSZXR1cm5zIGJvdGhcclxuICAgICAgICAgICAgICAgICAqIHRoZSBwcmV2aW91cyBhbmQgY3VycmVudCBhbmltYXRpb25zIGZvciB0aGUgZ2l2ZW4gZWxlbWVudChzKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBlbGVtZW50cyBUaGUgTm9kZXMgdG8gYmUgYW5pbWF0ZWQuIEFsbCBub2RlcyBpbiB0aGUgQXJyYXkgbXVzdCBoYXZlXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgc2FtZSBwYXJlbnQsIG90aGVyd2lzZSB0aGUgYW5pbWF0aW9uIHdpbGwgbm90IGZ1bmN0aW9uIGNvcnJlY3RseS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGlkZW50aWZpZXIgc3BlY2lmeWluZyB0aGUgdHlwZSBvZiBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb3B0aW9ucz8gU3BlY2lmaWVkIG9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuYW5pbWF0aW9ucy5JQW5pbWF0aW9uRnVuY3Rpb259IGZ1bmN0aW9uYWxpdHkgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXRcclxuICAgICAgICAgICAgICAgICAqIHNwZWNpYWwgYW5pbWF0aW9uIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5fY3JlYXRlID0gZnVuY3Rpb24gKGVsZW1lbnRzLCBrZXksIG9wdGlvbnMsIGZ1bmN0aW9uYWxpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbmplY3RvciA9IGFuaW1hdGlvbkluamVjdG9yc1trZXldLCBhbmltYXRpb25JbnN0YW5jZXMgPSBbXSwgZWxlbWVudE5vZGVzID0gW10sIGltbWVkaWF0ZVJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb21wYXQuYW5pbWF0aW9uU3VwcG9ydGVkIHx8IGlzVW5kZWZpbmVkKGFuaW1hdGlvbkluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbmplY3RvciA9IGpzQW5pbWF0aW9uSW5qZWN0b3JzW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChhbmltYXRpb25JbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhpcy5fX2NvbnN0cnVjdEFuaW1hdGFibGVFbGVtZW50cyhlbGVtZW50cywgeyBpbmplY3Q6IG5vb3AgfSwgZWxlbWVudE5vZGVzLCBhbmltYXRpb25JbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUHJlSW5pdEZ1bmN0aW9uYWxpdHkoZWxlbWVudHMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQb3N0SW5pdEZ1bmN0aW9uYWxpdHkoZWxlbWVudHMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFbmRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1tZWRpYXRlUmVzb2x2ZSA9IHRoaXMucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJldmlvdXM6IGltbWVkaWF0ZVJlc29sdmUsIGN1cnJlbnQ6IGltbWVkaWF0ZVJlc29sdmUgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHRoaXMuX19jb25zdHJ1Y3RBbmltYXRhYmxlRWxlbWVudHMoZWxlbWVudHMsIGFuaW1hdGlvbkluamVjdG9yLCBlbGVtZW50Tm9kZXMsIGFuaW1hdGlvbkluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGVsZW1lbnROb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQcmVJbml0RnVuY3Rpb25hbGl0eShlbGVtZW50cywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUG9zdEluaXRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFbmRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW1lZGlhdGVSZXNvbHZlID0gdGhpcy5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHByZXZpb3VzOiBpbW1lZGlhdGVSZXNvbHZlLCBjdXJyZW50OiBpbW1lZGlhdGVSZXNvbHZlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVByZUluaXRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHVuaXF1ZUlkKCdhbmltYXRpb25fJyksIHByZXZpb3VzQW5pbWF0aW9ucyA9IHRoaXMuX19zZXRBbmltYXRpb25JZChpZCwgZWxlbWVudE5vZGVzKSwgcHJldmlvdXNQcm9taXNlLCBhbmltYXRpb25Qcm9taXNlID0gbmV3IEFuaW1hdGlvblByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9Qcm9taXNlID0gX3RoaXMuX1Byb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUHJvbWlzZSA9IF9Qcm9taXNlLmFsbChwcmV2aW91c0FuaW1hdGlvbnMpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZXMucHVzaChhbmltYXRpb25JbnN0YW5jZXNbaV0uaW5zdGFudGlhdGUoZWxlbWVudE5vZGVzW2ldLCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlUG9zdEluaXRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnNGaW5pc2hlZCA9IF9Qcm9taXNlLmFsbChhbmltYXRpb25Qcm9taXNlcyksIGFuaW1hdGluZ1BhcmVudElkID0gX3RoaXMuX19pc1BhcmVudEFuaW1hdGluZyhlbGVtZW50Tm9kZXMpLCBhbmltYXRlZEVsZW1lbnQgPSBfdGhpcy5fX2dlbmVyYXRlQW5pbWF0ZWRFbGVtZW50KGlkLCBlbGVtZW50Tm9kZXMsIGFuaW1hdGlvblByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwoYW5pbWF0aW5nUGFyZW50SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUVuZEZ1bmN0aW9uYWxpdHkoZWxlbWVudHMsIGVsZW1lbnROb2RlcywgZnVuY3Rpb25hbGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZWRFbGVtZW50LmFuaW1hdGlvbkVuZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBfdGhpcy5fYW5pbWF0ZWRFbGVtZW50c1thbmltYXRpbmdQYXJlbnRJZF0sIHJlc29sdmVkUHJvbWlzZV8xID0gaXNQcm9taXNlKHBhcmVudF8xLnByb21pc2UpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudF8xLnByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uc0ZpbmlzaGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc29sdmVkUHJvbWlzZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fc3RvcENoaWxkQW5pbWF0aW9ucyhlbGVtZW50Tm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZWRFbGVtZW50LnByb21pc2UgPSBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uc0ZpbmlzaGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFbmRGdW5jdGlvbmFsaXR5KGVsZW1lbnRzLCBlbGVtZW50Tm9kZXMsIGZ1bmN0aW9uYWxpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudC5hbmltYXRpb25FbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZS5pbml0aWFsaXplKGFuaW1hdGlvbkluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJldmlvdXM6IHByZXZpb3VzUHJvbWlzZSwgY3VycmVudDogYW5pbWF0aW9uUHJvbWlzZSB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBkaWZmZXJlbnQgc3BlY2lhbGl6ZWQgZnVuY3Rpb25hbGl0aWVzIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdCBwb3J0aW9uIG9mIHRoZSBhbmltYXRpb24gY3ljbGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2RlcyBBbGwgdGhlIG5vZGVzIGJlaW5nIGFuaW1hdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZWxlbWVudE5vZGVzIFRoZSBhbmltYXRhYmxlIG5vZGVzIGJlaW5nIGFuaW1hdGVkIChvbmx5IG9mIHR5cGUgTm9kZS5FTEVNRU5UX05PREUpLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLmFuaW1hdGlvbnMuSUFuaW1hdGlvbkZ1bmN0aW9ufSBmdW5jdGlvbmFsaXR5IFRoZSBzcGVjaWFsaXplZCBhbmltYXRpb24gZnVuY3Rpb24gYXR0cmlidXRlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0b3IucHJvdG90eXBlLl9oYW5kbGVQcmVJbml0RnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uIChub2RlcywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChmdW5jdGlvbmFsaXR5LmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtb3ZlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKG5vZGVzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBkaWZmZXJlbnQgc3BlY2lhbGl6ZWQgZnVuY3Rpb25hbGl0aWVzIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0IHBvcnRpb24gb2YgdGhlIGFuaW1hdGlvbiBjeWNsZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzIEFsbCB0aGUgbm9kZXMgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEVsZW1lbnQ+fSBlbGVtZW50Tm9kZXMgVGhlIGFuaW1hdGFibGUgbm9kZXMgYmVpbmcgYW5pbWF0ZWQgKG9ubHkgb2YgdHlwZSBOb2RlLkVMRU1FTlRfTk9ERSkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuYW5pbWF0aW9ucy5JQW5pbWF0aW9uRnVuY3Rpb259IGZ1bmN0aW9uYWxpdHkgVGhlIHNwZWNpYWxpemVkIGFuaW1hdGlvbiBmdW5jdGlvbiBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX2hhbmRsZVBvc3RJbml0RnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uIChub2RlcywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCwgaTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZ1bmN0aW9uYWxpdHkua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VudGVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmQ2hpbGQgPSBmdW5jdGlvbmFsaXR5LnJlZkNoaWxkLCBwYXJlbnRfMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGUocmVmQ2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzIgPSByZWZDaGlsZC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzIgPSBmdW5jdGlvbmFsaXR5LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZDaGlsZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShwYXJlbnRfMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF8yLmluc2VydEJlZm9yZShub2Rlc1tpXSwgcmVmQ2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Nob3cnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbWVudE5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROb2Rlc1tpXS5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBkaWZmZXJlbnQgc3BlY2lhbGl6ZWQgZnVuY3Rpb25hbGl0aWVzIGF0IHRoZSBlbmQgcG9ydGlvbiBvZiB0aGUgYW5pbWF0aW9uIGN5Y2xlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gbm9kZXMgQWxsIHRoZSBub2RlcyBiZWluZyBhbmltYXRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD59IGVsZW1lbnROb2RlcyBUaGUgYW5pbWF0YWJsZSBub2RlcyBiZWluZyBhbmltYXRlZCAob25seSBvZiB0eXBlIE5vZGUuRUxFTUVOVF9OT0RFKS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5hbmltYXRpb25zLklBbmltYXRpb25GdW5jdGlvbn0gZnVuY3Rpb25hbGl0eSBUaGUgc3BlY2lhbGl6ZWQgYW5pbWF0aW9uIGZ1bmN0aW9uIGF0dHJpYnV0ZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5faGFuZGxlRW5kRnVuY3Rpb25hbGl0eSA9IGZ1bmN0aW9uIChub2RlcywgZWxlbWVudE5vZGVzLCBmdW5jdGlvbmFsaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCwgaTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGZ1bmN0aW9uYWxpdHkua2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlYXZlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUobm9kZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hpZGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gZWxlbWVudE5vZGVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROb2Rlc1tpXS5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBuZXcsIHVuaXF1ZSBhbmltYXRpb24gSUQgYW5kIGRlbm90ZXMgdGhlIGVsZW1lbnRzIGFzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgYW5pbWF0aW9uIElELlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZWxlbWVudHMgVGhlIEFycmF5IG9mIEVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX19zZXRBbmltYXRpb25JZCA9IGZ1bmN0aW9uIChpZCwgZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZWRFbGVtZW50cyA9IHRoaXMuX2FuaW1hdGVkRWxlbWVudHMsIGFuaW1hdGVkRWxlbWVudCwgX3BsYXQsIHByb21pc2VzID0gW10sIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aCwgZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BsYXQgPSBlbGVtZW50Ll9fcGxhdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF9wbGF0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5fX3BsYXQgPSB7IGFuaW1hdGlvbjogaWQgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIF9fQW5pbWF0aW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmaW5lZChfcGxhdC5hbmltYXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGxhdC5hbmltYXRpb24gPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIF9fQW5pbWF0aW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudCA9IGFuaW1hdGVkRWxlbWVudHNbX3BsYXQuYW5pbWF0aW9uXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoYW5pbWF0ZWRFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goYW5pbWF0ZWRFbGVtZW50LnByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkRWxlbWVudC5hbmltYXRpb25FbmQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGxhdC5hbmltYXRpb24gPSBpZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgYW5pbWF0ZWQgZWxlbWVudCBmb3IgdGhlIEFuaW1hdG9yIHRvIGVhc2lseSByZWZlcmVuY2UgYW5kIGJlIGFibGVcclxuICAgICAgICAgICAgICAgICAqIHRvIGVuZCBsYXRlciBvbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgYW5pbWF0aW9uIElELlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pn0gZWxlbWVudHMgVGhlIEFycmF5IG9mIEVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLmFuaW1hdGlvbnMuQW5pbWF0aW9uUHJvbWlzZX0gYW5pbWF0aW9uUHJvbWlzZSBUaGUgYW5pbWF0aW9uJ3MgYXNzb2NpYXRlZCBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX19nZW5lcmF0ZUFuaW1hdGVkRWxlbWVudCA9IGZ1bmN0aW9uIChpZCwgZWxlbWVudHMsIGFuaW1hdGlvblByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZWRFbGVtZW50cyA9IHRoaXMuX2FuaW1hdGVkRWxlbWVudHMsIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGNhbmNlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3BsYXQsIGVsZW1lbnQsIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aCwgYW5pbWF0aW9uSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblByb21pc2UuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShhbmltYXRlZEVsZW1lbnRzLCBpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3BsYXQgPSBlbGVtZW50Ll9fcGxhdCB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbklkID0gX3BsYXQuYW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGFuaW1hdGlvbklkKSB8fCBhbmltYXRpb25JZCAhPT0gaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIF9fQW5pbWF0aW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KF9wbGF0LCAnYW5pbWF0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShfcGxhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShlbGVtZW50LCAnX19wbGF0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoYW5pbWF0ZWRFbGVtZW50cywgaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGVkRWxlbWVudHNbaWRdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25FbmQ6IHJlbW92ZUxpc3RlbmVyXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhbnkgcGFyZW50IGVsZW1lbnRzIGFyZSBhbmltYXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEVsZW1lbnQ+fSBlbGVtZW50cyBUaGUgRWxlbWVudHMgd2hvc2UgcGFyZW50cyB3ZSBuZWVkIHRvIGNoZWNrLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX19pc1BhcmVudEFuaW1hdGluZyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JZCwgZWxlbWVudCA9IGVsZW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICghKGlzRG9jdW1lbnQoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkgfHwgaXNOdWxsKGVsZW1lbnQpIHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MoZWxlbWVudCwgX19BbmltYXRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3BsYXQgPSBlbGVtZW50Ll9fcGxhdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbklkID0gKF9wbGF0IHx8IHt9KS5hbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoYW5pbWF0aW9uSWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGhpcy5fYW5pbWF0ZWRFbGVtZW50c1thbmltYXRpb25JZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25JZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoX3BsYXQsICdhbmltYXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShfcGxhdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoZWxlbWVudCwgJ19fcGxhdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBfX0FuaW1hdGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGb3JjZXMgY2hpbGQgbm9kZXMgb2YgYW4gYW5pbWF0aW5nIGVsZW1lbnQgdG8gc3RvcCBhbmltYXRpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEFuaW1hdG9yLnByb3RvdHlwZS5fX3N0b3BDaGlsZEFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW5nRWxlbWVudHMgPSB0aGlzLl9hbmltYXRlZEVsZW1lbnRzLCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSwgY3VzdG9tQW5pbWF0aW9uRWxlbWVudHMsIGFuaW1hdGVkRWxlbWVudCwgX3BsYXQsIGlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tQW5pbWF0aW9uRWxlbWVudHMgPSBzbGljZS5jYWxsKGVsZW1lbnRzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgX19BbmltYXRpbmcpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1c3RvbUFuaW1hdGlvbkVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wbGF0ID0gY3VzdG9tQW5pbWF0aW9uRWxlbWVudHMucG9wKCkuX19wbGF0IHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBfcGxhdC5hbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZWRFbGVtZW50ID0gYW5pbWF0aW5nRWxlbWVudHNbaWRdIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYW5pbWF0ZWRFbGVtZW50LmFuaW1hdGlvbkVuZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRlZEVsZW1lbnQuYW5pbWF0aW9uRW5kKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2lmdHMgdGhyb3VnaCBhbiBBcnJheSBvZiBOb2RlcyBhbmQgZmluZHMgYWxsIGFuaW1hdGFibGUgRWxlbWVudHMgYW5kIGNyZWF0ZXNcclxuICAgICAgICAgICAgICAgICAqIEJhc2VBbmltYXRpb25zIGZvciB0aGVtLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGVsZW1lbnRzIFRoZSBBcnJheSBvZiBOb2RlcywgRG9jdW1lbnRGcmFnbWVudCwgb3IgZWxlbWVudCB0byBzaWZ0IHRocm91Z2guXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZGVwZW5kZW5jeS5JbmplY3RvcjxwbGF0LnVpLmFuaW1hdGlvbnMuQmFzZUFuaW1hdGlvbj59IGFuaW1hdGlvbkluamVjdG9yIFRoZSBpbmplY3RvciB0byBpbnN0YW50aWF0ZVxyXG4gICAgICAgICAgICAgICAgICogQmFzZUFuaW1hdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEVsZW1lbnQ+fSBlbGVtZW50Tm9kZXMgVGhlIEFycmF5IG9mIG9ubHkgYW5pbWF0YWJsZSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC51aS5hbmltYXRpb25zLkJhc2VBbmltYXRpb24+Pn0gYW5pbWF0aW9uSW5zdGFuY2VzIEFuIGVtcHR5IEFycmF5IG9mIGFuaW1hdGlvbiBpbnN0YW5jZXMgdG8gYWRkIHRvLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5wcm90b3R5cGUuX19jb25zdHJ1Y3RBbmltYXRhYmxlRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGFuaW1hdGlvbkluamVjdG9yLCBlbGVtZW50Tm9kZXMsIGFuaW1hdGlvbkluc3RhbmNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShlbGVtZW50cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRGcmFnbWVudChlbGVtZW50cykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWxlbWVudHMuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheUxpa2UoZWxlbWVudHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghKGlzTm9kZShlbGVtZW50cykgJiYgZWxlbWVudHMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGUoZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnROb2Rlcy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5zdGFuY2VzLnB1c2goYW5pbWF0aW9uSW5qZWN0b3IuaW5qZWN0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBBbmltYXRvci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb21wYXQ6IF9fQ29tcGF0LFxyXG4gICAgICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEFuaW1hdG9yO1xyXG4gICAgICAgICAgICB9KCkpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLkFuaW1hdG9yID0gQW5pbWF0b3I7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19BbmltYXRvciwgQW5pbWF0b3IpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVzY3JpYmVzIGEgdHlwZSBvZiBQcm9taXNlIHRoYXQgY2FuIGJlIG9wdGlvbmFsbHkgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgKiBGdXJ0aGVyLCBpbiB0aGUgY2FzZSB3aGVyZSBpdCBtYXkgaGF2ZSBhIHBhcmVudCB0aGF0IGlzIGFuaW1hdGluZyAod2hpY2ggd2lsbCBjYXVzZSBpdCB0byBpbW1lZGlhdGVseSBjYW5jZWwgYW5kIGZ1bGZpbGxcclxuICAgICAgICAgICAgICogaXRzZWxmLCBpdCByZXNvbHZlcyB3aXRoIGEgSUdldEFuaW1hdGluZ1RoZW5hYmxlIGZvciBhY2NjZXNzaW5nXHJcbiAgICAgICAgICAgICAqIHRoZSBJQW5pbWF0aW9uVGhlbmFibGUgb2YgdGhlIGFuaW1hdGluZyBwYXJlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBBbmltYXRpb25Qcm9taXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhBbmltYXRpb25Qcm9taXNlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQW5pbWF0aW9uUHJvbWlzZShyZXNvbHZlRnVuY3Rpb24sIHByb21pc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCByZXNvbHZlRnVuY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgSVByb21pc2UgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlID0gYWNxdWlyZShfX1Byb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uLiAwIHByaW9yIHRvIHN0YXJ0LCAxIGlmIHN0YXJ0ZWQsIGFuZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIDIgaWYgY2FuY2VsZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FuaW1hdGlvblN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBbiBBcnJheSBvZiBhbmltYXRpb24gaW5zdGFuY2VzIGxpbmtlZCB0byB0aGlzIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19hbmltYXRpb25JbnN0YW5jZXMgPSBwcm9taXNlLl9fYW5pbWF0aW9uSW5zdGFuY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYW5pbWF0aW9uU3RhdGUgPSBwcm9taXNlLl9fYW5pbWF0aW9uU3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShpbnN0YW5jZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzID0gaW5zdGFuY2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGluc3RhbmNlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19hbmltYXRpb25JbnN0YW5jZXMgPSBbaW5zdGFuY2VzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGFzc29jaWF0ZWQgYW5pbWF0aW9uIGluc3RhbmNlcyBvciBhbmltYXRlZCBwcm9taXNlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUuZ2V0SW5zdGFuY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmlyZXMgdGhlIHN0YXJ0IG1ldGhvZCBvbiB0aGUgYW5pbWF0aW9uIGluc3RhbmNlcyB0byBraWNrb2ZmIHRoZSBhbmltYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBBbmltYXRpb25Qcm9taXNlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2FuaW1hdGlvblN0YXRlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbnN0YW5jZXMgPSB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzLCBhbmltYXRpb25JbnN0YW5jZSwgbGVuZ3RoID0gYW5pbWF0aW9uSW5zdGFuY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkluc3RhbmNlID0gYW5pbWF0aW9uSW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb25JbnN0YW5jZS5zdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkluc3RhbmNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2FuaW1hdGlvblN0YXRlID0gMTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpcmVzIHRoZSBwYXVzZSBtZXRob2Qgb24gdGhlIGFuaW1hdGlvbiBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX19hbmltYXRpb25TdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbnN0YW5jZXMgPSB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzLCBwYXVzZVByb21pc2VzID0gW10sIGFuaW1hdGlvbkluc3RhbmNlLCBsZW5ndGggPSBhbmltYXRpb25JbnN0YW5jZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSW5zdGFuY2UgPSBhbmltYXRpb25JbnN0YW5jZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGFuaW1hdGlvbkluc3RhbmNlLnBhdXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VQcm9taXNlcy5wdXNoKGFuaW1hdGlvbkluc3RhbmNlLnBhdXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbChwYXVzZVByb21pc2VzKS50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRmlyZXMgdGhlIHJlc3VtZSBtZXRob2Qgb24gdGhlIGFuaW1hdGlvbiBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fYW5pbWF0aW9uU3RhdGUgIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5zdGFuY2VzID0gdGhpcy5fX2FuaW1hdGlvbkluc3RhbmNlcywgcmVzdW1lUHJvbWlzZXMgPSBbXSwgYW5pbWF0aW9uSW5zdGFuY2UsIGxlbmd0aCA9IGFuaW1hdGlvbkluc3RhbmNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbnN0YW5jZSA9IGFuaW1hdGlvbkluc3RhbmNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYW5pbWF0aW9uSW5zdGFuY2UucmVzdW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdW1lUHJvbWlzZXMucHVzaChhbmltYXRpb25JbnN0YW5jZS5yZXN1bWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UuYWxsKHJlc3VtZVByb21pc2VzKS50aGVuKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBtZXRob2QgdG8gY2FuY2VsIHRoZSBhc3NvY2lhdGVkIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fYW5pbWF0aW9uU3RhdGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbnN0YW5jZXMgPSB0aGlzLl9fYW5pbWF0aW9uSW5zdGFuY2VzLCBhbmltYXRpb25JbnN0YW5jZSwgbGVuZ3RoID0gYW5pbWF0aW9uSW5zdGFuY2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkluc3RhbmNlID0gYW5pbWF0aW9uSW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb25JbnN0YW5jZS5jYW5jZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbnN0YW5jZS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhbmltYXRpb25JbnN0YW5jZS5lbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbnN0YW5jZS5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYW5pbWF0aW9uU3RhdGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoaXMgcHJvbWlzZSBoYXMgYmVlbiBjYW5jZWxlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQW5pbWF0aW9uUHJvbWlzZS5wcm90b3R5cGUuaXNDYW5jZWxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FuaW1hdGlvblN0YXRlID09PSAyO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcywgb25GdWxmaWxsZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEFuaW1hdGlvblByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5jYXRjaC5jYWxsKHRoaXMsIG9uUmVqZWN0ZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICB9KGFzeW5jLlByb21pc2UpKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5BbmltYXRpb25Qcm9taXNlID0gQW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgc2luZ2xlIGFuaW1hdGlvbiBmb3IgYSBzaW5nbGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBCYXNlQW5pbWF0aW9uID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VBbmltYXRpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQW4gQXJyYXkgb2YgcmVtb3ZlIGZ1bmN0aW9ucyB0byBkaXNwb3NlIG9mIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZXZlbnRMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgaW5pdGlhbGl6aW5nIHRoZSBhbmltYXRpb24gb3IgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGJlZm9yZSBzdGFydC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBkZW5vdGluZyB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBvdmVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBCYXNlQW5pbWF0aW9uLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fX2V2ZW50TGlzdGVuZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChldmVudExpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLnBvcCgpKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX3Jlc29sdmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdG8gcGF1c2UgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdG8gcmVzdW1lIGEgcGF1c2VkIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQmFzZUFuaW1hdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIGxldCBpdCBiZSBrbm93biB0aGUgYW5pbWF0aW9uIGlzIGJlaW5nIGNhbmNlbGxlZC4gQWx0aG91Z2ggbm90XHJcbiAgICAgICAgICAgICAgICAgKiBuZWNlc3NhcnksIHdlIGNhbGwgZW5kKCkgaW4gdGhpcyBmdW5jdGlvbiBhcyB3ZWxsIGZvciBzYWZlIG1lYXN1cmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEJhc2VBbmltYXRpb24ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgdG8gdGhpcyBhbmltYXRpb24ncyBlbGVtZW50LiBSZW1vdmFsIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgICogZXZlbnQgaXMgaGFuZGxlZCBhdXRvbWF0aWNhbGx5IHVwb24gYW5pbWF0aW9uIGVuZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFRoZSB0eXBlIG9mIGV2ZW50IHRvIGxpc3RlbiB0by5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGZpcmUgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB1c2VDYXB0dXJlPyBXaGV0aGVyIHRvIGZpcmUgdGhlIGV2ZW50IG9uIHRoZSBjYXB0dXJlIG9yIHRoZSBidWJibGUgcGhhc2VcclxuICAgICAgICAgICAgICAgICAqIG9mIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBCYXNlQW5pbWF0aW9uLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignQW4gYW5pbWF0aW9uXFwncyBcImFkZEV2ZW50TGlzdGVuZXJcIiBtdXN0IHRha2UgYSBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCB0eXBlLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCB1c2VDYXB0dXJlKSwgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9fZXZlbnRMaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChyZW1vdmVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gZXZlbnRMaXN0ZW5lcnMuaW5kZXhPZihyZW1vdmVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGVsZW1lbnQgYW5kIGtleSBwcm9wZXJ0aWVzIG9mIHRoaXMgYW5pbWF0aW9uIGFuZCBncmFicyBhXHJcbiAgICAgICAgICAgICAgICAgKiByZWZlcmVuY2UgdG8gaXRzIHJlc29sdmUgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGFuaW1hdGlvbiB3aWxsIG9jY3VyLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9wdGlvbnMgU3BlY2lmaWVkIG9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEJhc2VBbmltYXRpb24ucHJvdG90eXBlLmluc3RhbnRpYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBBbmltYXRpb25Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UuaW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBCYXNlQW5pbWF0aW9uLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgICAgICAgICAgX2xvZzogX19Mb2csXHJcbiAgICAgICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICBkb206IF9fRG9tLFxyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzOiBfX1V0aWxzXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJhc2VBbmltYXRpb247XHJcbiAgICAgICAgICAgIH0oKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuQmFzZUFuaW1hdGlvbiA9IEJhc2VBbmltYXRpb247XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIHNpbmdsZSBDU1MgYW5pbWF0aW9uIGZvciBhIHNpbmdsZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIENzc0FuaW1hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoQ3NzQW5pbWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gQ3NzQW5pbWF0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEEgc2V0IG9mIGJyb3dzZXIgY29tcGF0aWJsZSBDU1MgYW5pbWF0aW9uIGV2ZW50cyBjYXBhYmxlIG9mIGJlaW5nIGxpc3RlbmVkIHRvLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkV2ZW50cyA9IHRoaXMuX2NvbXBhdC5hbmltYXRpb25FdmVudHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gbGlzdGVuIHRvIHRoZSBzdGFydCBvZiBhbiBhbmltYXRpb24gZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geygpID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGFuaW1hdGlvbiBiZWdpbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIENzc0FuaW1hdGlvbi5wcm90b3R5cGUuYW5pbWF0aW9uU3RhcnQgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2FuaW1hdGlvbkV2ZW50cy4kYW5pbWF0aW9uU3RhcnQsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGxpc3RlbiB0byB0aGUgZW5kIG9mIGFuIGFuaW1hdGlvbiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7KGV2PzogQW5pbWF0aW9uRXZlbnQpID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGFuaW1hdGlvbiBlbmRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBDc3NBbmltYXRpb24ucHJvdG90eXBlLmFuaW1hdGlvbkVuZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fYW5pbWF0aW9uRXZlbnRzLiRhbmltYXRpb25FbmQsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGxpc3RlbiB0byB0aGUgY29tcGxldGlvbiBvZiBhbiBhbmltYXRpb24gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoZXY/OiBBbmltYXRpb25FdmVudCkgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgYW5pbWF0aW9uIGl0ZXJhdGlvbiBjb21wbGV0ZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIENzc0FuaW1hdGlvbi5wcm90b3R5cGUuYW5pbWF0aW9uSXRlcmF0aW9uID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9hbmltYXRpb25FdmVudHMuJGFuaW1hdGlvbkl0ZXJhdGlvbiwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gbGlzdGVuIHRvIHRoZSBzdGFydCBvZiBhIHRyYW5zaXRpb24gZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyhldj86IFRyYW5zaXRpb25FdmVudCkgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdHJhbnNpdGlvbiBiZWdpbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIENzc0FuaW1hdGlvbi5wcm90b3R5cGUudHJhbnNpdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9hbmltYXRpb25FdmVudHMuJHRyYW5zaXRpb25TdGFydCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gbGlzdGVuIHRvIHRoZSBlbmQgb2YgYSB0cmFuc2l0aW9uIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHsoZXY/OiBUcmFuc2l0aW9uRXZlbnQpID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIHRyYW5zaXRpb24gZW5kcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgQ3NzQW5pbWF0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uRW5kID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9hbmltYXRpb25FdmVudHMuJHRyYW5zaXRpb25FbmQsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENzc0FuaW1hdGlvbjtcclxuICAgICAgICAgICAgfShCYXNlQW5pbWF0aW9uKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuQ3NzQW5pbWF0aW9uID0gQ3NzQW5pbWF0aW9uO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBzaW1wbGUgQ1NTIEFuaW1hdGlvbiBjbGFzcyB0aGF0IHBsYWNlcyB0aGUgJ3BsYXQtYW5pbWF0aW9uJyBjbGFzcyBvbiBhblxyXG4gICAgICAgICAgICAgKiBlbGVtZW50LCBjaGVja3MgZm9yIGFuaW1hdGlvbiBwcm9wZXJ0aWVzLCBhbmQgd2FpdHMgZm9yIHRoZSBhbmltYXRpb24gdG8gZW5kLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFNpbXBsZUNzc0FuaW1hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoU2ltcGxlQ3NzQW5pbWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2ltcGxlQ3NzQW5pbWF0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBhbmltYXRlZCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gX19TaW1wbGVBbmltYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3Igc3RvcHBpbmcgYSBwb3RlbnRpYWwgY2FsbGJhY2sgaW4gdGhlIGFuaW1hdGlvbiBjaGFpbi5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxBbmltYXRpb24gPSBub29wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIHRoZSBjbGFzcyB0byBpbml0aWFsaXplIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc0FuaW1hdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuY2xhc3NOYW1lICsgX19JTklUX1NVRkZJWCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGRlbm90aW5nIHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NBbmltYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50LCBjbGFzc05hbWUgPSBfdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JZCA9IF90aGlzLl9hbmltYXRpb25FdmVudHMuJGFuaW1hdGlvbiwgb3B0aW9ucyA9IF90aGlzLm9wdGlvbnMgfHwge30sIGNvbXB1dGVkU3R5bGUgPSBfdGhpcy5fd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgb3B0aW9ucy5wc2V1ZG8pLCBhbmltYXRpb25OYW1lID0gY29tcHV0ZWRTdHlsZVsoYW5pbWF0aW9uSWQgKyAnTmFtZScpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk5hbWUgPT09ICcnIHx8IGFuaW1hdGlvbk5hbWUgPT09ICdub25lJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRTdHlsZVsoYW5pbWF0aW9uSWQgKyAnUGxheVN0YXRlJyldID09PSAncGF1c2VkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5wcmVzZXJ2ZUluaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSArIF9fSU5JVF9TVUZGSVgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jYW5jZWxBbmltYXRpb24gPSBfdGhpcy5hbmltYXRpb25FbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NhbmNlbEFuaW1hdGlvbiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIHBhdXNlIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc0FuaW1hdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FuY2VsQW5pbWF0aW9uID09PSBub29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkV2ZW50cyA9IHRoaXMuX2NvbXBhdC5hbmltYXRpb25FdmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2NhbmNlbEFuaW1hdGlvbiAhPT0gbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQuc3R5bGVbKGFuaW1hdGlvbkV2ZW50cy4kYW5pbWF0aW9uICsgJ1BsYXlTdGF0ZScpXSA9ICdwYXVzZWQnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHRvIHJlc3VtZSBhIHBhdXNlZCBhbmltYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc0FuaW1hdGlvbi5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbEFuaW1hdGlvbiA9PT0gbm9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25FdmVudHMgPSB0aGlzLl9jb21wYXQuYW5pbWF0aW9uRXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9jYW5jZWxBbmltYXRpb24gIT09IG5vb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LnN0eWxlWyhhbmltYXRpb25FdmVudHMuJGFuaW1hdGlvbiArICdQbGF5U3RhdGUnKV0gPSAncnVubmluZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdG8gbGV0IGl0IGJlIGtub3duIHRoZSBhbmltYXRpb24gaXMgYmVpbmcgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgYW5pbWF0aW9uIGNsYXNzIGFuZCB0aGUgYW5pbWF0aW9uIFwiLWluaXRcIiBjbGFzcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzQW5pbWF0aW9uLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQW5pbWF0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBhbmltYXRpb24gY2xhc3MgYW5kIHRoZSBhbmltYXRpb24gXCItaW5pdFwiIGNsYXNzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NBbmltYXRpb24ucHJvdG90eXBlLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIGNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZSArIF9fSU5JVF9TVUZGSVgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEFuaW1hdGlvbiA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpbXBsZUNzc0FuaW1hdGlvbjtcclxuICAgICAgICAgICAgfShDc3NBbmltYXRpb24pKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5TaW1wbGVDc3NBbmltYXRpb24gPSBTaW1wbGVDc3NBbmltYXRpb247XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmFuaW1hdGlvbihfX1NpbXBsZUFuaW1hdGlvbiwgU2ltcGxlQ3NzQW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGFuaW1hdGlvbiBjb250cm9sIHRoYXQgZmFkZXMgaW4gYW4gZWxlbWVudCBhcyBkZWZpbmVkIGJ5IHRoZSBpbmNsdWRlZCBDU1MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRmFkZUluID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhGYWRlSW4sIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGYWRlSW4oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgZmFkaW5nIGluLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gX19GYWRlSW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRmFkZUluO1xyXG4gICAgICAgICAgICB9KFNpbXBsZUNzc0FuaW1hdGlvbikpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLkZhZGVJbiA9IEZhZGVJbjtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuYW5pbWF0aW9uKF9fRmFkZUluLCBGYWRlSW4pO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gYW5pbWF0aW9uIGNvbnRyb2wgdGhhdCBmYWRlcyBvdXQgYW4gZWxlbWVudCBhcyBkZWZpbmVkIGJ5IHRoZSBpbmNsdWRlZCBDU1MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgRmFkZU91dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoRmFkZU91dCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZhZGVPdXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGVsZW1lbnQgZmFkaW5nIG91dC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fRmFkZU91dDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBGYWRlT3V0O1xyXG4gICAgICAgICAgICB9KFNpbXBsZUNzc0FuaW1hdGlvbikpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLkZhZGVPdXQgPSBGYWRlT3V0O1xyXG4gICAgICAgICAgICByZWdpc3Rlci5hbmltYXRpb24oX19GYWRlT3V0LCBGYWRlT3V0KTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGFuaW1hdGlvbiBjb250cm9sIHRoYXQgY2F1c2VzIGFuIGVsZW1lbnQgdG8gZW50ZXIgYXMgZGVmaW5lZCBieSB0aGUgaW5jbHVkZWQgQ1NTLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEVudGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhFbnRlciwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEVudGVyKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBjbGFzcyBuYW1lIGFkZGVkIHRvIHRoZSBlbnRlcmluZyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gX19FbnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBFbnRlcjtcclxuICAgICAgICAgICAgfShTaW1wbGVDc3NBbmltYXRpb24pKTtcclxuICAgICAgICAgICAgYW5pbWF0aW9ucy5FbnRlciA9IEVudGVyO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5hbmltYXRpb24oX19FbnRlciwgRW50ZXIpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gYW5pbWF0aW9uIGNvbnRyb2wgdGhhdCBjYXVzZXMgYW4gZWxlbWVudCB0byBsZWF2ZSBhcyBkZWZpbmVkIGJ5IHRoZSBpbmNsdWRlZCBDU1MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgTGVhdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKExlYXZlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTGVhdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGxlYXZpbmcgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fTGVhdmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTGVhdmU7XHJcbiAgICAgICAgICAgIH0oU2ltcGxlQ3NzQW5pbWF0aW9uKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuTGVhdmUgPSBMZWF2ZTtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuYW5pbWF0aW9uKF9fTGVhdmUsIExlYXZlKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGFuaW1hdGlvbiBjb250cm9sIHRoYXQgY2F1c2VzIGFuIGVsZW1lbnQgdG8gbW92ZSBhcyBkZWZpbmVkIGJ5IHRoZSBpbmNsdWRlZCBDU1MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgTW92ZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoTW92ZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1vdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGNsYXNzIG5hbWUgYWRkZWQgdG8gdGhlIGxlYXZpbmcgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fTW92ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBNb3ZlO1xyXG4gICAgICAgICAgICB9KFNpbXBsZUNzc0FuaW1hdGlvbikpO1xyXG4gICAgICAgICAgICBhbmltYXRpb25zLk1vdmUgPSBNb3ZlO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5hbmltYXRpb24oX19Nb3ZlLCBNb3ZlKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgc2ltcGxlIENTUyBBbmltYXRpb24gY2xhc3MgdGhhdCBwbGFjZXMgdGhlICdwbGF0LXRyYW5zaXRpb24nIGNsYXNzIG9uIGFuXHJcbiAgICAgICAgICAgICAqIGVsZW1lbnQsIGNoZWNrcyBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzLCBhbmQgd2FpdHMgZm9yIHRoZSB0cmFuc2l0aW9uIHRvIGVuZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBTaW1wbGVDc3NUcmFuc2l0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhTaW1wbGVDc3NUcmFuc2l0aW9uLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2ltcGxlQ3NzVHJhbnNpdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgYW5pbWF0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IF9fU2ltcGxlVHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBzdG9wcGluZyBhIHBvdGVudGlhbCBjYWxsYmFjayBpbiB0aGUgYW5pbWF0aW9uIGNoYWluLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbmNlbGVkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBub3JtYWxpemUgbW9kaWZpZWQgcHJvcGVydHkga2V5cy5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVSZWdleCA9IC8tL2c7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZ3JhYiBldmVyeXRoaW5nIHRoYXQgaXMgbm90IGEgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25vbk51bVJlZ2V4ID0gL1teXFwtMC05XFwuXS9nO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgbm9ybWFsaXplZCBrZXlzIG9mIG1vZGlmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZEtleXMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlciBjYWxsIGNvdW50LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25Db3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHVzZXIgZGVmaW5lZCBcInRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyIGNhbGwgY291bnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIERlbm90ZXMgd2hldGhlciBvciBub3QgdGhlIHRyYW5zaXRpb24gd2FzIGV2ZXIgc3RhcnRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogRGVub3RlcyB3aGV0aGVyIG9yIG5vdCB0aGUgdHJhbnNpdGlvbiBjaGFuZ2VzIGFyZSBiZWluZyBwZXJmb3JtZWRcclxuICAgICAgICAgICAgICAgICAgICAgKiB3aXRoIENTUyBvciB3aXRoIEpTIHRocm91Z2ggdGhpcy5vcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VzaW5nQ3NzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgdGhlIGNsYXNzIHRvIGVuYWJsZSB0aGUgdHJhbnNpdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzVHJhbnNpdGlvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLmVsZW1lbnQsIHRoaXMuY2xhc3NOYW1lICsgX19JTklUX1NVRkZJWCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIGRlbm90aW5nIHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NUcmFuc2l0aW9uLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbmNlbGVkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50LCBjbGFzc05hbWUgPSBfdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFBhcmVudCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1dGlscyA9IF90aGlzLnV0aWxzLCB0cmFuc2l0aW9uSWQgPSBfdGhpcy5fYW5pbWF0aW9uRXZlbnRzLiR0cmFuc2l0aW9uLCBvcHRpb25zID0gX3RoaXMub3B0aW9ucyB8fCB7fSwgY29tcHV0ZWRTdHlsZSA9IF90aGlzLl93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBvcHRpb25zLnBzZXVkbyksIHByb3BlcnRpZXMgPSBfdGhpcy5fcHJvcGVydGllcyA9IGNvbXB1dGVkU3R5bGVbKHRyYW5zaXRpb25JZCArICdQcm9wZXJ0eScpXS5zcGxpdCgnLCcpLCBkdXJhdGlvbnMgPSBjb21wdXRlZFN0eWxlWyh0cmFuc2l0aW9uSWQgKyAnRHVyYXRpb24nKV0uc3BsaXQoJywnKSwgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGgsIHByb3BMZW5ndGggPSBsZW5ndGgsIG5vVHJhbnNpdGlvbiA9IGZhbHNlLCBwcm9wO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gcHJvcGVydGllc1tsZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICcnIHx8IHByb3AgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuc3BsaWNlKGxlbmd0aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wTGVuZ3RoID4gMSAmJiBwcm9wID09PSAnYWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vc3QgbGlrZWx5IGRldmVsb3BlciBlcnJvciAoZXh0cmEgY29tbWEgYXQgZW5kIG9mIHNob3J0aGFuZCBtdWx0aSB0cmFuc2l0aW9uIGRlY2xhcmF0aW9uKSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyB3ZSB3aWxsIHNwbGljZSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKFwiSW1wcm9wZXIgdHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiBjbGFzcyBcXFwiXCIgKyBlbGVtZW50LmNsYXNzTmFtZSArIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnNwbGljZShsZW5ndGgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9UcmFuc2l0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGR1cmF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGR1cmF0aW9uc1tsZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHByb3AgPT09ICcnIHx8IHByb3AgPT09ICcwcycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9UcmFuc2l0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9UcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Rpc3Bvc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihvcHRpb25zLmNvdW50KSAmJiBvcHRpb25zLmNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NvdW50ID0gb3B0aW9ucy5jb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmVzZXJ2ZUluaXQgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUgKyBfX0lOSVRfU1VGRklYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uQ2FuY2VsZWQgPSBfdGhpcy50cmFuc2l0aW9uRW5kKF90aGlzLl9kb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9hbmltYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlscy5pc0VtcHR5KG9wdGlvbnMucHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fY3NzVHJhbnNpdGlvbihjb21wdXRlZFN0eWxlLCBkdXJhdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgdG8gbGV0IGl0IGJlIGtub3duIHRoZSBhbmltYXRpb24gaXMgYmVpbmcgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NUcmFuc2l0aW9uLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ2FuY2VsZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIGFuaW1hdGlvbiBjbGFzcyBhbmQgdGhlIGFuaW1hdGlvbiBcIi1pbml0XCIgY2xhc3MuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc1RyYW5zaXRpb24ucHJvdG90eXBlLl9kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnQsIGNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZSArIF9fSU5JVF9TVUZGSVgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkNhbmNlbGVkID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgaGFuZGxlciBmb3IgdGhlIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LiBXaWxsIGNsZWFuIHVwIHRoZSBjbGFzcyBhbmQgcmVzb2x2ZSB0aGVcclxuICAgICAgICAgICAgICAgICAqIHByb21pc2Ugd2hlbiBuZWNlc3NhcnkgYmFzZWQgb24gdGhlIG9wdGlvbnMgdGhhdCB3ZXJlIGlucHV0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGV2PyBUaGUgdHJhbnNpdGlvbiBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGltbWVkaWF0ZT8gV2hldGhlciBjbGVhbiB1cCBzaG91bGQgYmUgaW1tZWRpYXRlIG9yIGNvbmRpdGlvbmFsLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NUcmFuc2l0aW9uLnByb3RvdHlwZS5fZG9uZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBldi5wcm9wZXJ0eU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHByb3BlcnR5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gKyt0aGlzLl90cmFuc2l0aW9uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZS5yZXBsYWNlKHRoaXMuX25vcm1hbGl6ZVJlZ2V4LCAnJykudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudCA8IHRoaXMuX2NvdW50KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCF0aGlzLl91c2luZ0NzcyAmJiB0aGlzLl9ub3JtYWxpemVkS2V5c1twcm9wZXJ0eU5hbWVdID09PSB0cnVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPCB0aGlzLl9wcm9wZXJ0aWVzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuaW1hdGUgdGhlIGVsZW1lbnQgYmFzZWQgb24gdGhlIG9wdGlvbnMgcGFzc2VkIGluLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTaW1wbGVDc3NUcmFuc2l0aW9uLnByb3RvdHlwZS5fYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGUgfHwge30sIHByb3BlcnRpZXMgPSAodGhpcy5vcHRpb25zIHx8IHt9KS5wcm9wZXJ0aWVzIHx8IHt9LCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIG5vcm1hbGl6ZWRLZXlzID0gdGhpcy5fbm9ybWFsaXplZEtleXMsIG5vcm1hbGl6ZVJlZ2V4ID0gdGhpcy5fbm9ybWFsaXplUmVnZXgsIGN1cnJlbnRQcm9wZXJ0eSwgbmV3UHJvcGVydHksIHVuY2hhbmdlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGtleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IHN0eWxlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Byb3BlcnR5ID0gcHJvcGVydGllc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKG5ld1Byb3BlcnR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jaGFuZ2VkKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVtrZXldID0gbmV3UHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UHJvcGVydHkgPT09IHN0eWxlW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2hhbmdlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEtleXNba2V5LnJlcGxhY2Uobm9ybWFsaXplUmVnZXgsICcnKS50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuY2hhbmdlZCA8IGxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgZWxlbWVudCB0cmFuc2l0aW9ucyB0aGF0IGFyZSBkZWZpbmVkIHdpdGggQ1NTLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBjb21wdXRlZFN0eWxlIFRoZSBjb21wdXRlZCBzdHlsZSBvZiB0aGVcclxuICAgICAgICAgICAgICAgICAqIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGR1cmF0aW9ucyBUaGUgYXJyYXkgb2YgZGVjbGFyZWQgdHJhbnNpdGlvbiBkdXJhdGlvbiB2YWx1ZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNpbXBsZUNzc1RyYW5zaXRpb24ucHJvdG90eXBlLl9fY3NzVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChjb21wdXRlZFN0eWxlLCBkdXJhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uSWQgPSB0aGlzLl9hbmltYXRpb25FdmVudHMuJHRyYW5zaXRpb24sIGRlbGF5cyA9IGNvbXB1dGVkU3R5bGVbKHRyYW5zaXRpb25JZCArICdEZWxheScpXS5zcGxpdCgnLCcpLCBwcm9wZXJ0aWVzID0gdGhpcy5fcHJvcGVydGllcywgcHJvcGVydHksIGR1cmF0aW9uLCBkZWxheSwgbGVuZ3RoID0gcHJvcGVydGllcy5sZW5ndGgsIGNvbXB1dGVkUHJvcGVydHksIG5vcm1hbGl6ZWRLZXlzID0gdGhpcy5fbm9ybWFsaXplZEtleXMsIG5vcm1hbGl6ZVJlZ2V4ID0gdGhpcy5fbm9ybWFsaXplUmVnZXgsIGkgPSAwLCBjb3VudCA9IDAsIGNoYW5nZWQgPSBmYWxzZSwgZGVmZXIgPSB0aGlzLnV0aWxzLmRlZmVyLmJpbmQodGhpcywgZnVuY3Rpb24gKHByb3AsIGNvbXB1dGVkUHJvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2FuaW1hdGlvbkNhbmNlbGVkID09PSBub29wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXNwb3NhbCBoYXMgYWxyZWFkeSBvY2N1cnJlZCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wID09PSAnYWxsJyB8fCBjb21wdXRlZFN0eWxlW3Byb3BdICE9PSBjb21wdXRlZFByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbid0IGtub3cgaWYgdGhlIHRyYW5zaXRpb24gc3RhcnRlZCBkdWUgdG8gJ2FsbCcgYmVpbmcgc2V0IGFuZCBoYXZlIHRvIHJlbHkgb24gdGhpcy5vcHRpb25zLmNvdW50IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3IgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoZSB0cmFuc2l0aW9uIHN0YXJ0ZWQgZHVlIHRvIHRoZSBwcm9wZXJ0aWVzIGJlaW5nIGRpZmZlcmVudCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2NvdW50IDwgbGVuZ3RoIHx8IGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbmQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2luZ0NzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY291bnQgPSB0aGlzLl9jb3VudCB8fCBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV0gPSBwcm9wZXJ0aWVzW2ldLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbnMubGVuZ3RoID4gaSA/IGR1cmF0aW9uc1tpXS50cmltKCkgOiBkdXJhdGlvbnNbZHVyYXRpb25zLmxlbmd0aCAtIDFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBkZWxheXMubGVuZ3RoID4gaSA/IGRlbGF5c1tpXS50cmltKCkgOiBkZWxheXNbZGVsYXlzLmxlbmd0aCAtIDFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEtleXNbcHJvcGVydHkucmVwbGFjZShub3JtYWxpemVSZWdleCwgJycpLnRvTG93ZXJDYXNlKCldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRQcm9wZXJ0eSA9IGNvbXB1dGVkU3R5bGVbcHJvcGVydHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcih0aGlzLl90b01zKGR1cmF0aW9uKSArIHRoaXMuX3RvTXMoZGVsYXkpLCBbcHJvcGVydHksIGNvbXB1dGVkUHJvcGVydHldKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgYSBzdHJpbmcgdmFsdWUgZXhwcmVzc2VkIGFzIGVpdGhlciBzZWNvbmRzIG9yIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAgICAgICAgICogdG8gYSBudW1lcmljYWwgbWlsbGlzZWNvbmQgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHVyYXRpb24gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gc3BlY2lmaWVkIGJ5IHRoZSBjb21wdXRlZCBzdHlsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2ltcGxlQ3NzVHJhbnNpdGlvbi5wcm90b3R5cGUuX3RvTXMgPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXggPSB0aGlzLl9ub25OdW1SZWdleCwgdW5pdHMgPSBkdXJhdGlvbi5tYXRjaChyZWdleClbMF0sIHRpbWUgPSBOdW1iZXIoZHVyYXRpb24ucmVwbGFjZShyZWdleCwgJycpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOdW1iZXIodGltZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVuaXRzID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWUgKiAxMDAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1bml0cyA9PT0gJ21zJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpbXBsZUNzc1RyYW5zaXRpb247XHJcbiAgICAgICAgICAgIH0oQ3NzQW5pbWF0aW9uKSk7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMuU2ltcGxlQ3NzVHJhbnNpdGlvbiA9IFNpbXBsZUNzc1RyYW5zaXRpb247XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmFuaW1hdGlvbihfX1NpbXBsZVRyYW5zaXRpb24sIFNpbXBsZUNzc1RyYW5zaXRpb24pO1xyXG4gICAgICAgIH0pKGFuaW1hdGlvbnMgPSB1aS5hbmltYXRpb25zIHx8ICh1aS5hbmltYXRpb25zID0ge30pKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gVUkgY29udHJvbCBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBjb250cm9scztcclxuICAgICAgICAoZnVuY3Rpb24gKGNvbnRyb2xzXzEpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHJvdXRpbmcgYmV0d2VlbiBWaWV3Q29udHJvbHMuIEEgVmlld3BvcnQgaXNcclxuICAgICAgICAgICAgICogdGhlIGxpbmsgYmV0d2VlbiBhIFZpZXdDb250cm9sLCBhIE5hdmlnYXRvciwgYW5kIGEgUm91dGVyLlxyXG4gICAgICAgICAgICAgKiBJdCByZWdpc3RlcnMgd2l0aCBhIHJvdXRlciBhbmQgcmVjZWl2ZXMgcm91dGUgY2hhbmdlIGV2ZW50cy4gSXQgdGhlbiBpbnN0YW50aWF0ZXMgdGhlIHByb3BlciB2aWV3Y29udHJvbCBhbmQgYXBwZW5kcyBpdFxyXG4gICAgICAgICAgICAgKiB0byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFZpZXdwb3J0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhWaWV3cG9ydCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFZpZXdwb3J0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbGxvd3MgdGhlIHZpZXdwb3J0IHRvIGluaXRpYWxpemUgaXRzIG5hdmlnYXRvciB3aXRoIHRoZSBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgKiByb3V0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLl9yb3V0ZXIgPSB0aGlzLl9Sb3V0ZXIuY3VycmVudFJvdXRlcigpLCBwYXJlbnRWaWV3cG9ydCA9IHRoaXMuX2dldFBhcmVudFZpZXdwb3J0KCksIHBhcmVudFJvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShpc051bGwocGFyZW50Vmlld3BvcnQpIHx8IGlzTnVsbChwYXJlbnRWaWV3cG9ydC5fcm91dGVyKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Um91dGVyID0gdGhpcy5fcGFyZW50Um91dGVyID0gcGFyZW50Vmlld3BvcnQuX3JvdXRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Um91dGVyLmFkZENoaWxkKHJvdXRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25hdmlnYXRvci5pbml0aWFsaXplKHJvdXRlcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdmlld3BvcnQgcmVnaXN0ZXJzIGl0c2VsZiB3aXRoIGl0cyByb3V0ZXIsIG5vdGlmeWluZyB0aGVcclxuICAgICAgICAgICAgICAgICAqIHJvdXRlciB0aGF0IGl0IGlzIHJlYWR5IHRvIHJlY2VpdmUgbmF2aWdhdGlvbiBldmVudHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0LnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodGhpcy5vcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0ZSA9IHRoaXMub3B0aW9ucy52YWx1ZS5hbmltYXRlID09PSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBfX1ZpZXdwb3J0ICsgJy1hbmltYXRlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZSA9IGFuaW1hdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX1Byb21pc2UucmVzb2x2ZSh0aGlzLl9yb3V0ZXIuZmluaXNoTmF2aWdhdGluZykudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yb3V0ZXIucmVnaXN0ZXIoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZpZXdwb3J0J3Mgcm91dGVyIGhhcyBtYXRjaGVkIGEgcm91dGUgYW5kIGlzIGFza2luZyB0aGUgdmlld3BvcnQgaWYgaXQgaXMgc2FmZSB0b1xyXG4gICAgICAgICAgICAgICAgICogbmF2aWdhdGUuIEhlcmUgdGhlIHZpZXdwb3J0IGNhbiBpbnN0YW50aWF0ZSB0aGUgbmV3IHZpZXcgYW5kIGFzayBpdCBpZiBpdCBpcyBzYWZlIHRvXHJcbiAgICAgICAgICAgICAgICAgKiBuYXZpZ2F0ZSB0byB0aGUgdmlldy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZUluZm99IHJvdXRlSW5mbyBDb250YWlucyB0aGUgaW5mb3JtYXRpb24gbmVjZXNzYXJ5IHRvIGluc3RhbnRpYXRlXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgdmlldyBhbmQgZmVlZCBpdCB0aGUgcm91dGUgcGFyYW1ldGVycy9xdWVyeS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLmNhbk5hdmlnYXRlVG8gPSBmdW5jdGlvbiAocm91dGVJbmZvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Um91dGVyID0gdGhpcy5fUm91dGVyLmN1cnJlbnRSb3V0ZXIsIGN1cnJlbnRSb3V0ZXIgPSBnZXRSb3V0ZXIoKSwgcmVzcG9uc2UgPSB0cnVlLCBpbmplY3RvciA9IHRoaXMuX0luamVjdG9yLmdldERlcGVuZGVuY3kocm91dGVJbmZvLmRlbGVnYXRlLnZpZXcpLCB2aWV3ID0gaW5qZWN0b3IuaW5qZWN0KCksIHBhcmFtZXRlcnMgPSByb3V0ZUluZm8ucGFyYW1ldGVycywgbmV4dFJvdXRlciA9IGdldFJvdXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QodmlldykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSb3V0ZXIgIT09IG5leHRSb3V0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFJvdXRlci5pbml0aWFsaXplKHRoaXMuX3JvdXRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYXZpZ2F0b3JfMSA9IGFjcXVpcmUoX19OYXZpZ2F0b3JJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcubmF2aWdhdG9yID0gbmF2aWdhdG9yXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvcl8xLmluaXRpYWxpemUobmV4dFJvdXRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Lm5hdmlnYXRvciA9IHRoaXMuX25hdmlnYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmlldy5jYW5OYXZpZ2F0ZVRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHZpZXcuY2FuTmF2aWdhdGVUbyhwYXJhbWV0ZXJzLCByb3V0ZUluZm8ucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKS50aGVuKGZ1bmN0aW9uIChjYW5OYXZpZ2F0ZVRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9uZXh0SW5qZWN0b3IgPSBpbmplY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX25leHRWaWV3ID0gdmlldztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbk5hdmlnYXRlVG87XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdmlld3BvcnQncyByb3V0ZXIgaGFzIG1hdGNoZWQgYSByb3V0ZSBhbmQgaXMgYXNraW5nIHRoZSB2aWV3cG9ydCBpZiBpdCBpcyBzYWZlIHRvXHJcbiAgICAgICAgICAgICAgICAgKiBuYXZpZ2F0ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLiBIZXJlIHRoZSB2aWV3cG9ydCBjYW4gcXVlcnkgdGhlIGN1cnJlbnQgVmlld0NvbnRyb2wgYW5kXHJcbiAgICAgICAgICAgICAgICAgKiBhc2sgaXQgaWYgaXQgaXMgc2FmZSB0byBuYXZpZ2F0ZSBmcm9tIGl0cyBjdXJyZW50IHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydC5wcm90b3R5cGUuY2FuTmF2aWdhdGVGcm9tID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5jb250cm9sc1swXSwgcmVzcG9uc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2aWV3KSAmJiBpc0Z1bmN0aW9uKHZpZXcuY2FuTmF2aWdhdGVGcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHZpZXcuY2FuTmF2aWdhdGVGcm9tKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZpZXdwb3J0J3Mgcm91dGVyIGhhcyBtYXRjaGVkIGEgcm91dGUgYW5kIGRldGVybWluZWQgdGhhdCBpdCBpcyBzYWZlIHRvIG5hdmlnYXRlIHRvIHRoZVxyXG4gICAgICAgICAgICAgICAgICogbmV4dCB2aWV3LiBUaGUgdmlld3BvcnQgd2lsbCBub3cgZ28gdGhyb3VnaCB0aGUgc3RlcHMgdG8gY29tcGlsZSBhbmQgbGluayB0aGUgbmV4dCB2aWV3IHRoZW4gYXBwZW5kXHJcbiAgICAgICAgICAgICAgICAgKiBpdCB0byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlSW5mb30gcm91dGVJbmZvIENvbnRhaW5zIHRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gaW5zdGFudGlhdGVcclxuICAgICAgICAgICAgICAgICAqIHRoZSB2aWV3IGFuZCBmZWVkIGl0IHRoZSByb3V0ZSBwYXJhbWV0ZXJzL3F1ZXJ5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydC5wcm90b3R5cGUubmF2aWdhdGVUbyA9IGZ1bmN0aW9uIChyb3V0ZUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5qZWN0b3IgPSB0aGlzLl9uZXh0SW5qZWN0b3IgfHwgdGhpcy5fSW5qZWN0b3IuZ2V0RGVwZW5kZW5jeShyb3V0ZUluZm8uZGVsZWdhdGUudmlldyksIG5vZGVNYXAgPSB0aGlzLl9jcmVhdGVOb2RlTWFwKGluamVjdG9yKSwgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgbm9kZSA9IG5vZGVNYXAuZWxlbWVudCwgcGFyYW1ldGVycyA9IHJvdXRlSW5mby5wYXJhbWV0ZXJzLCBxdWVyeSA9IHJvdXRlSW5mby5xdWVyeSwgY29udHJvbCA9IG5vZGVNYXAudWlDb250cm9sTm9kZS5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25leHRJbmplY3RvciA9IHRoaXMuX25leHRWaWV3ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yLCBkb21fMSA9IHRoaXMuZG9tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbmF2aWdhdG9yLmlzQmFja05hdmlnYXRpb24oKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tXzEuYWRkQ2xhc3Mobm9kZSwgX19OYXZpZ2F0aW5nQmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRvci5lbnRlcihub2RlLCBfX0VudGVyLCBlbGVtZW50KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21fMS5yZW1vdmVDbGFzcyhub2RlLCBfX05hdmlnYXRpbmdCYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3IuZW50ZXIobm9kZSwgX19FbnRlciwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRNYW5hZ2VyID0gdGhpcy5fbWFuYWdlckNhY2hlLnJlYWQodGhpcy51aWQpLCBtYW5hZ2VyID0gdGhpcy5fRWxlbWVudE1hbmFnZXJGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRNYW5hZ2VyLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKG5vZGVNYXAsIHZpZXdwb3J0TWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udHJvbC5uYXZpZ2F0ZWRUbykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5uYXZpZ2F0ZWRUbyhyb3V0ZUluZm8ucGFyYW1ldGVycywgcXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLnNldFVpQ29udHJvbFRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuaGFzT3duQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlci5vYnNlcnZlUm9vdENvbnRleHQoY29udHJvbCwgbWFuYWdlci5mdWxmaWxsQW5kTG9hZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLmZ1bGZpbGxBbmRMb2FkKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdmlld3BvcnQncyByb3V0ZXIgaGFzIG1hdGNoZWQgYSByb3V0ZSBhbmQgZGV0ZXJtaW5lZCB0aGF0IGl0IGlzIHNhZmUgdG8gbmF2aWdhdGUgdG8gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBuZXh0IHZpZXcuIEl0IGlzIG5vdyBzYWZlIGZvciB0aGUgdmlld3BvcnQgdG8gZGlzcG9zZSBvZiB0aGUgY3VycmVudCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLm5hdmlnYXRlRnJvbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5jb250cm9sc1swXSwgcHJvbWlzZSwgdmlld0V4aXN0cyA9IGlzT2JqZWN0KHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3RXhpc3RzICYmIGlzRnVuY3Rpb24odmlldy5uYXZpZ2F0aW5nRnJvbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuX1Byb21pc2UucmVzb2x2ZSh2aWV3Lm5hdmlnYXRpbmdGcm9tKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yLm1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhfdGhpcy50eXBlICsgJyBlcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoX3RoaXMudHlwZSArICcgZXJyb3I6ICcgKyBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfdGhpcy5fYW5pbWF0ZSAmJiB2aWV3RXhpc3RzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29udHJvbC5kaXNwb3NlKHZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRFbGVtZW50ID0gdmlldy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX25hdmlnYXRvci5pc0JhY2tOYXZpZ2F0aW9uKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5hZGRDbGFzcyhvbGRFbGVtZW50LCBfX05hdmlnYXRpbmdCYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0b3IubGVhdmUob2xkRWxlbWVudCwgX19MZWF2ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb250cm9sLmRpc3Bvc2Uodmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHZpZXdwb3J0IGlzIGdvaW5nIG91dCBvZiBzY29wZSwgc28gaXQgbmVlZHMgdG8gdW5yZWdpc3RlciBmcm9tIGl0cyByb3V0ZXIgaW4gb3JkZXIgdG8gc3RvcCByZWNlaXZpbmcgcm91dGluZ1xyXG4gICAgICAgICAgICAgICAgICogZXZlbnRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBWaWV3cG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb3V0ZXIudW5yZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uYXZpZ2F0b3IuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhbiBJTm9kZU1hcCBmb3IgYSBWaWV3Q29udHJvbCBpbiBvcmRlciB0byBjb21waWxlIGl0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LmRlcGVuZGVuY3kuSW5qZWN0b3I8cGxhdC51aS5WaWV3Q29udHJvbD59IFRoZSBpbmplY3RvciB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBWaWV3Q29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLl9jcmVhdGVOb2RlTWFwID0gZnVuY3Rpb24gKGluamVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9uZXh0VmlldyB8fCBpbmplY3Rvci5pbmplY3QoKSwgZG9jID0gdGhpcy5fZG9jdW1lbnQsIHR5cGUgPSBpbmplY3Rvci5uYW1lLCByZXBsYWNlV2l0aCA9IGNvbnRyb2wucmVwbGFjZVdpdGgsIG5vZGUgPSAoaXNFbXB0eShyZXBsYWNlV2l0aCkgfHwgcmVwbGFjZVdpdGggPT09ICdhbnknKSA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IGRvYy5jcmVhdGVFbGVtZW50KHJlcGxhY2VXaXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShfX0NvbnRyb2wsIHR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NOYW1lID0gX19WaWV3Q29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xOb2RlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBjb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvcjogaW5qZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyB0aGUgZmlyc3QgVmlld3BvcnQgaW4gdGhlIHBhcmVudCBjaGFpbi4gVGhpcyBpcyB1c2VmdWwgaW4gb3JkZXIgdG8gcHJvcGVybHkgaW5pdGlhbGl6ZSB0aGUgdmlld3BvcnQnc1xyXG4gICAgICAgICAgICAgICAgICogcm91dGVyIGFzIGEgY2hpbGQgb2YgdGhlIHBhcmVudCB2aWV3cG9ydCdzIHJvdXRlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVmlld3BvcnQucHJvdG90eXBlLl9nZXRQYXJlbnRWaWV3cG9ydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLnBhcmVudCwgdHlwZSA9IHRoaXMudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIWlzTnVsbCh2aWV3cG9ydCkgJiYgdmlld3BvcnQudHlwZSAhPT0gdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydCA9IHZpZXdwb3J0LnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdwb3J0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIFZpZXdwb3J0Ll9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX1JvdXRlcjogX19Sb3V0ZXJTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICBfSW5qZWN0b3I6IF9fSW5qZWN0b3JTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICAgICAgX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeTogX19FbGVtZW50TWFuYWdlckZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIF9tYW5hZ2VyQ2FjaGU6IF9fTWFuYWdlckNhY2hlLFxyXG4gICAgICAgICAgICAgICAgICAgIF9hbmltYXRvcjogX19BbmltYXRvcixcclxuICAgICAgICAgICAgICAgICAgICBfbmF2aWdhdG9yOiBfX05hdmlnYXRvckluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFZpZXdwb3J0O1xyXG4gICAgICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgICAgICBjb250cm9sc18xLlZpZXdwb3J0ID0gVmlld3BvcnQ7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19WaWV3cG9ydCwgVmlld3BvcnQpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBUZW1wbGF0ZUNvbnRyb2wgZm9yIGVhc2lseSByZXVzaW5nIGFcclxuICAgICAgICAgICAgICogZGVmaW5lZCBIVE1MIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIFRlbXBsYXRlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhUZW1wbGF0ZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIFRlbXBsYXRlLiBDcmVhdGVzIHRoZSBjb250cm9sIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBUZW1wbGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBgPHBsYXQtdGVtcGxhdGU+YCBub2RlIGZyb20gdGhlIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGggPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBjb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgICAqIHNwZWNpZnlpbmcgdGhhdCBpdCBkZWZpbmVzIHRoZSB0ZW1wbGF0ZSB0byBjb3B5LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19pc0ZpcnN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9DYWNoZUZhY3RvcnkgPSBhY3F1aXJlKF9fQ2FjaGVGYWN0b3J5KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGVtcGxhdGVDb250cm9sQ2FjaGUgPSBfQ2FjaGVGYWN0b3J5LmNyZWF0ZShfX1RlbXBsYXRlQ29udHJvbENhY2hlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSB0ZW1wbGF0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnNPYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25zT2JqLnZhbHVlIHx8IHt9LCBpZCA9IHRoaXMuX2lkID0gb3B0aW9ucy5pZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLnR5cGUgKyAnIGluc3RhbnRpYXRlZCB3aXRob3V0IGFuIGlkIG9wdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VybCA9IG9wdGlvbnMudGVtcGxhdGVVcmw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlUHJvbWlzZSA9IHRoaXMuX190ZW1wbGF0ZUNvbnRyb2xDYWNoZS5yZWFkKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0ZW1wbGF0ZVByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZVByb21pc2UgPSB0ZW1wbGF0ZVByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2lzRmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGVjaWRlcyBpZiB0aGlzIGlzIGEgdGVtcGxhdGUgZGVmaW5pdGlvbiBvclxyXG4gICAgICAgICAgICAgICAgICogYSB0ZW1wbGF0ZSBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX19pc0ZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhaXRGb3JUZW1wbGF0ZUNvbnRyb2wodGhpcy5fX3RlbXBsYXRlUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgdGVtcGxhdGUgZnJvbSB0aGUgdGVtcGxhdGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNGaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLl9fdGVtcGxhdGVDb250cm9sQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnJlbW92ZSh0aGlzLl9pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZS5pbmZvKCkuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgVVJMIG9yIGlubmVySFRNTCBpcyBiZWluZyB1c2VkLFxyXG4gICAgICAgICAgICAgICAgICogY3JlYXRlcyB0aGUgYmluZGFibGUgdGVtcGxhdGUsIGFuZCBzdG9yZXMgdGhlIHRlbXBsYXRlXHJcbiAgICAgICAgICAgICAgICAgKiBpbiBhIHRlbXBsYXRlIGNhY2hlIGZvciBsYXRlciB1c2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFRlbXBsYXRlLnByb3RvdHlwZS5faW5pdGlhbGl6ZVRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5faWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuZW5kTm9kZS5wYXJlbnROb2RlLCB1cmwgPSB0aGlzLl91cmwsIHRlbXBsYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHVybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLl90ZW1wbGF0ZUNhY2hlLnJlYWQodXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJOb2RlQmxvY2sodGhpcy5lbGVtZW50Tm9kZXMsIHBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKHRoaXMuZWxlbWVudE5vZGVzLCB0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sUHJvbWlzZSA9IHRlbXBsYXRlLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGVtcGxhdGVDb250cm9sLmRldGVybWluZVRlbXBsYXRlKF90aGlzLCB1cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKGlkLCB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKGlkLCB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sUHJvbWlzZSA9IHRoaXMuX1Byb21pc2UucmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RlbXBsYXRlQ29udHJvbENhY2hlLnB1dChpZCwgY29udHJvbFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2FpdHMgZm9yIHRoZSB0ZW1wbGF0ZSBwcm9taXNlIHRvIHJlc29sdmUsIHRoZW4gaW5pdGlhbGl6ZXNcclxuICAgICAgICAgICAgICAgICAqIHRoZSBiaW5kaW5nIG9mIHRoZSBiaW5kYWJsZSB0ZW1wbGF0ZSBhbmQgcGxhY2VzIGl0IGludG8gdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBET00uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQuYXN5bmMuSVRoZW5hYmxlPHBsYXQudWkuY29udHJvbHMuVGVtcGxhdGU+fSB0ZW1wbGF0ZVByb21pc2UgVGhlIHByb21pc2VcclxuICAgICAgICAgICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGNvbnRyb2wgd2l0aCB0aGlzIElELlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuX3dhaXRGb3JUZW1wbGF0ZUNvbnRyb2wgPSBmdW5jdGlvbiAodGVtcGxhdGVQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUHJvbWlzZSh0ZW1wbGF0ZVByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHRlbXBsYXRlQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpc051bGwoX3RoaXMuX3VybCkgfHwgKF90aGlzLl91cmwgPT09IHRlbXBsYXRlQ29udHJvbC5fdXJsKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignVGhlIHNwZWNpZmllZCB1cmw6ICcgKyBfdGhpcy5fdXJsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGRvZXMgbm90IG1hdGNoIHRoZSBvcmlnaW5hbCAnICsgX3RoaXMudHlwZSArICcgd2l0aCBpZDogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1wiJyArIF90aGlzLl9pZCArICdcIi4gVGhlIG9yaWdpbmFsIHVybCB3aWxsIGJlIGxvYWRlZC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX21hcEJpbmRhYmxlVGVtcGxhdGVzKHRlbXBsYXRlQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5iaW5kKF90aGlzLl9pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoY2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSBfdGhpcy5lbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZW5kTm9kZS5wYXJlbnROb2RlLCBjbG9uZSwgZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignUHJvYmxlbSByZXNvbHZpbmcgJyArIF90aGlzLnR5cGUgKyAnIHVybDogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1hcHMgdGhlIGJpbmRhYmxlIHRlbXBsYXRlcyBjYWNoZSBhbmQgaHRtbCB0ZW1wbGF0ZXMgb2YgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgKiBjb250cm9sIHdpdGggdGhlIHByb3BlciBJRCB0byB0aGlzIGNvbnRyb2wncyBiaW5kYWJsZSB0ZW1wbGF0ZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuY29udHJvbHMuVGVtcGxhdGV9IGNvbnRyb2wgVGhlIGZpcnN0IG9mIHRoZSBjb250cm9sc1xyXG4gICAgICAgICAgICAgICAgICogd2l0aCB0aGlzIGNvcnJlc3BvbmRpbmcgSUQgdGhhdCBkZWZpbmVkIHRoZSBIVE1MIHRlbXBsYXRlIHRvIHJldXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBUZW1wbGF0ZS5wcm90b3R5cGUuX19tYXBCaW5kYWJsZVRlbXBsYXRlcyA9IGZ1bmN0aW9uIChjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRhYmxlVGVtcGxhdGVzID0gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICAgICAgICAgICAgICBiaW5kYWJsZVRlbXBsYXRlcy5jYWNoZSA9IGNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMuY2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMudGVtcGxhdGVzID0gY29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcy50ZW1wbGF0ZXM7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgVGVtcGxhdGUuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIF90ZW1wbGF0ZUNhY2hlOiBfX1RlbXBsYXRlQ2FjaGUsXHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRlbXBsYXRlO1xyXG4gICAgICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgICAgICBjb250cm9sc18xLlRlbXBsYXRlID0gVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19UZW1wbGF0ZSwgVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBUZW1wbGF0ZUNvbnRyb2wgZm9yIGlubmVyIEhUTUwgdGhhdCBjb250YWlucyBjb250cm9sc1xyXG4gICAgICAgICAgICAgKiBhbmQvb3IgbWFya3VwIGFuZCBub3QgaGF2aW5nIGl0IGJpbmQgb3IgZXZhbHVhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgSWdub3JlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhJZ25vcmUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBJZ25vcmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIGlubmVySFRNTCBmcm9tIHRoZSBET00gYW5kIHNhdmVzIGl0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJZ25vcmUucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJUZW1wbGF0ZSA9IGFwcGVuZENoaWxkcmVuKHRoaXMuZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFBsYWNlcyB0aGUgc2F2ZWQgaW5uZXJIVE1MIGJhY2sgaW50byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJZ25vcmUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lclRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIElnbm9yZTtcclxuICAgICAgICAgICAgfShUZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5JZ25vcmUgPSBJZ25vcmU7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19JZ25vcmUsIElnbm9yZSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIFRlbXBsYXRlQ29udHJvbCBmb3IgcmVwZWF0aW5nIGEgYmxvY2sgb2ZcclxuICAgICAgICAgICAgICogRE9NIG5vZGVzIGJvdW5kIHRvIGFuIGFycmF5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIEZvckVhY2ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKEZvckVhY2gsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBGb3JFYWNoLiBDcmVhdGVzIHRoZSBpdGVtc0xvYWRlZCBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBGb3JFYWNoKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGxvYWQgcHJpb3JpdHkgb2YgdGhlIGNvbnRyb2wgKG5lZWRzIHRvIGxvYWQgYmVmb3JlIGEgQmluZCBjb250cm9sKS5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW9yaXR5ID0gMTIwO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gaG9sZCB0aGUgYWxpYXMgdG9rZW5zIGZvciB0aGUgYnVpbHQtaW4gZm9yZWFjaCBhbGlhc2VzLiBZb3VcclxuICAgICAgICAgICAgICAgICAgICAgKiBjYW4gb3ZlcndyaXRlIHRoZXNlIHdpdGggdGhlIG9wdGlvbnMgZm9yXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIEZvckVhY2ggY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbGlhc2VzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogX19mb3JFYWNoQWxpYXNPcHRpb25zLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVuOiBfX2ZvckVhY2hBbGlhc09wdGlvbnMuZXZlbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2RkOiBfX2ZvckVhY2hBbGlhc09wdGlvbnMub2RkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdDogX19mb3JFYWNoQWxpYXNPcHRpb25zLmZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0OiBfX2ZvckVhY2hBbGlhc09wdGlvbnMubGFzdFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIG5vZGUgbGVuZ3RoIG9mIGVhY2ggaXRlbSdzIGNoaWxkTm9kZXMgKGlubmVySFRNTCkuXHJcbiAgICAgICAgICAgICAgICAgICAgICogRm9yIHRoZSBGb3JFYWNoIGl0IHNob3VsZCBiZSBhXHJcbiAgICAgICAgICAgICAgICAgICAgICogc2luZ2xlIGNvbnN0YW50IG51bWJlci5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ibG9ja0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQSBxdWV1ZSByZXByZXNlbnRpbmcgYWxsIGN1cnJlbnQgYWRkIG9wZXJhdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIGN1cnJlbnRseSBpbiB0aGUgbGlzdCBvciBpbiB0aGUgcHJvY2VzcyBvZiBiZWluZyBhZGRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIG9yIHJlbW92ZWQgZnJvbSB0aGUgbGlzdC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgQXJyYXkgbGlzdGVuZXIgaGFzIGJlZW4gc2V0LlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19saXN0ZW5lclNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZWplY3RGbiA9IHJlamVjdDtcclxuICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChub29wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlcyBhIGJpbmRhYmxlIHRlbXBsYXRlIHdpdGggdGhlIGNvbnRyb2wgZWxlbWVudCdzIGNoaWxkTm9kZXMgKGlubmVySFRNTCkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKCdpdGVtJywgdGhpcy5lbGVtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmUtc3luY3MgdGhlIEZvckVhY2ggY2hpbGQgY29udHJvbHMgYW5kIERPTSB3aXRoIHRoZSBuZXdcclxuICAgICAgICAgICAgICAgICAqIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBuZXdWYWx1ZSBUaGUgbmV3IEFycmF5XHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IG9sZFZhbHVlIFRoZSBvbGQgQXJyYXlcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuY29udGV4dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9leGVjdXRlRXZlbnQoW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3BsaWNlJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBPYnNlcnZlcyB0aGUgQXJyYXkgY29udGV4dCBmb3IgY2hhbmdlcyBhbmQgYWRkcyBpbml0aWFsIGl0ZW1zIHRvIHRoZSBET00uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgYW5pbWF0aW5nID0gdGhpcy5fYW5pbWF0ZSA9ICFpc1VuZGVmaW5lZChvcHRpb25zKSAmJiBvcHRpb25zLnZhbHVlLmFuaW1hdGUgPT09IHRydWUsIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uUXVldWUgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0QWxpYXNlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRRdWV1ZSA9IHRoaXMuX2FkZFF1ZXVlLCBpdGVtQ291bnQgPSBjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUHJvbWlzZSA9IHRoaXMuX2FkZEl0ZW1zKDAsIGl0ZW1Db3VudCwgMCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFkZFF1ZXVlLmluZGV4T2YoYWRkUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGFueSBwb3RlbnRpYWxseSBoZWxkIG1lbW9yeS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0Z1bmN0aW9uKHRoaXMuX19yZWplY3RGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlamVjdEZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZXNvbHZlRm4gPSB0aGlzLl9fcmVqZWN0Rm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FkZFF1ZXVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIGFsaWFzIHRva2VucyB0byB1c2UgZm9yIGFsbCB0aGUgaXRlbXMgaW4gdGhlIEZvckVhY2ggY29udGV4dCBBcnJheS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3NldEFsaWFzZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzZXMgPSBvcHRpb25zLnZhbHVlLmFsaWFzZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChhbGlhc2VzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYWxpYXNlcyA9IHRoaXMuX2FsaWFzZXMsIGtleXMgPSBPYmplY3Qua2V5cyhfYWxpYXNlcyksIGxlbmd0aCA9IGtleXMubGVuZ3RoLCB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWxpYXNlc1trZXlzW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FsaWFzZXNba2V5c1tpXV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgbmV3IGl0ZW1zIHRvIHRoZSBjb250cm9sJ3MgZWxlbWVudCB3aGVuIGl0ZW1zIGFyZSBhZGRlZCB0b1xyXG4gICAgICAgICAgICAgICAgICogdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBwb2ludCBpbiB0aGUgYXJyYXkgdG8gc3RhcnQgYWRkaW5nIGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byBhZGQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0ZUl0ZW1zIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX2FkZEl0ZW1zID0gZnVuY3Rpb24gKGluZGV4LCBudW1iZXJPZkl0ZW1zLCBhbmltYXRlSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSArKGluZGV4ICsgbnVtYmVyT2ZJdGVtcyksIHByb21pc2VzID0gW10sIGluaXRpYWxJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1MZW5ndGggKz0gbnVtYmVyT2ZJdGVtcztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9iaW5kSXRlbShpbmRleCsrKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQgPSB0aGlzLl9Qcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAodGVtcGxhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0QmxvY2tMZW5ndGgodGVtcGxhdGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRlSXRlbXMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xMCA9IHRlbXBsYXRlcy5sZW5ndGgsIGNvbnRhaW5lciA9IF90aGlzLl9jb250YWluZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMTA7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGFuaW1hdGVJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGVuZEFuaW1hdGVkSXRlbSh0ZW1wbGF0ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh0ZW1wbGF0ZXNbaV0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGVuZEl0ZW1zKHRlbXBsYXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlUmVzb3VyY2UoaW5pdGlhbEluZGV4IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5fX3Jlc29sdmVGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuID0gX3RoaXMuX19yZWplY3RGbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNMb2FkZWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIGFuIEFycmF5IG9mIGl0ZW1zIHRvIHRoZSBlbGVtZW50IHdpdGhvdXQgYW5pbWF0aW5nLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gaXRlbXMgVGhlIEFycmF5IG9mIGl0ZW1zIHRvIGFkZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX2FwcGVuZEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2hpbGRyZW4oaXRlbXMsIHRoaXMuX2NvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50IGFuaW1hdGluZyBpdHMgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGl0ZW0gVGhlIEhUTUwgZnJhZ21lbnQgcmVwcmVzZW50aW5nIGEgc2luZ2xlIGl0ZW0uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9hcHBlbmRBbmltYXRlZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gdGhpcy5fYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLl9hbmltYXRvci5lbnRlcihpdGVtLCBfX0VudGVyLCB0aGlzLl9jb250YWluZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogbnVsbFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBpdGVtcyBmcm9tIHRoZSBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgZGlzcG9zaW5nIGZyb20uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIHJlbW92ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3JlbW92ZUl0ZW1zID0gZnVuY3Rpb24gKGluZGV4LCBudW1iZXJPZkl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSBUZW1wbGF0ZUNvbnRyb2wuZGlzcG9zZSwgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzLCBsYXN0ID0gaW5kZXggKyBudW1iZXJPZkl0ZW1zO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsYXN0LS0gPiBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlKGNvbnRyb2xzW2xhc3RdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVzb3VyY2UoY29udHJvbHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCaW5kcyB0aGUgaXRlbSB0byBhIHRlbXBsYXRlIGF0IHRoYXQgaW5kZXguXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9iaW5kSXRlbSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmJpbmQoJ2l0ZW0nLCBpbmRleCwgdGhpcy5fZ2V0QWxpYXNlcyhpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgY29ycmVzcG9uZGluZyBibG9jayBsZW5ndGggZm9yIGFuaW1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3NldEJsb2NrTGVuZ3RoID0gZnVuY3Rpb24gKHRlbXBsYXRlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ibG9ja0xlbmd0aCA+IDAgfHwgdGVtcGxhdGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jsb2NrTGVuZ3RoID0gdGVtcGxhdGVzWzBdLmNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyBhIGNoaWxkIHJlc291cmNlIG9iamVjdCB3aGVuXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXJyYXkgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgY29udHJvbCB3aG9zZSByZXNvdXJjZXMgd2Ugd2lsbCB1cGRhdGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl91cGRhdGVSZXNvdXJjZSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9scyA9IHRoaXMuY29udHJvbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBjb250cm9scy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sc1tpbmRleF0ucmVzb3VyY2VzLmFkZCh0aGlzLl9nZXRBbGlhc2VzKGluZGV4KSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIGEgbGlzdGVuZXIgZm9yIHRoZSBjaGFuZ2VzIHRvIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3NldExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fX2xpc3RlbmVyU2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHRoaXMuX2V4ZWN1dGVFdmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19saXN0ZW5lclNldCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVjZWl2ZXMgYW4gZXZlbnQgd2hlbiBhIG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQgb24gYW4gYXJyYXkgYW5kIG1hcHMgdGhlIGFycmF5XHJcbiAgICAgICAgICAgICAgICAgKiBtZXRob2QgdG8gaXRzIGFzc29jaWF0ZWQgbWV0aG9kIGhhbmRsZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX2V4ZWN1dGVFdmVudCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9ICdfJyArIGNoYW5nZXNbMF0udHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXR1cm5zIGEgcmVzb3VyY2UgYWxpYXMgb2JqZWN0IGZvciBhbiBpdGVtIGluIHRoZSBhcnJheS4gVGhlXHJcbiAgICAgICAgICAgICAgICAgKiByZXNvdXJjZSBvYmplY3QgY29udGFpbnMgaW5kZXg6bnVtYmVyLCBldmVuOmJvb2xlYW4sIG9kZDpib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICogZmlyc3Q6Ym9vbGVhbiwgYW5kIGxhc3Q6Ym9vbGVhbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdXNlZCB0byBjcmVhdGUgdGhlIHJlc291cmNlIGFsaWFzZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9nZXRBbGlhc2VzID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzRXZlbiA9IChpbmRleCAmIDEpID09PSAwLCBhbGlhc2VzID0ge30sIF9hbGlhc2VzID0gdGhpcy5fYWxpYXNlcywgdHlwZSA9IF9fTElURVJBTF9SRVNPVVJDRTtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmluZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmV2ZW5dID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXNFdmVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLm9kZF0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAhaXNFdmVuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmZpcnN0XSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluZGV4ID09PSAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmxhc3RdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5kZXggPT09ICh0aGlzLmNvbnRleHQubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGlhc2VzO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyBwdXNoZWQgaW50byB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBhZGRRdWV1ZSA9IHRoaXMuX2FkZFF1ZXVlLCBpdGVtQ291bnQgPSBjaGFuZ2UuYWRkZWRDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUHJvbWlzZSA9IHRoaXMuX2FkZEl0ZW1zKGNoYW5nZS5pbmRleCwgaXRlbUNvdW50LCB0aGlzLl9hbmltYXRlID8gaXRlbUNvdW50IDogMCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFkZFF1ZXVlLmluZGV4T2YoYWRkUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyBwb3BwZWQgb2ZmIHRoZSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fcG9wID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBzdGFydCA9IGNoYW5nZS5vYmplY3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVtb3ZlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSBjaGFuZ2Uub2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXRlbUxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlLmFsbCh0aGlzLl9hZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGVJdGVtcyhzdGFydCwgMSwgX19MZWF2ZSwgJ2xlYXZlJywgZmFsc2UpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhyZW1vdmVJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyB1bnNoaWZ0ZWQgaW50byB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3Vuc2hpZnQgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBhZGRlZENvdW50ID0gY2hhbmdlLmFkZGVkQ291bnQsIGFkZFF1ZXVlID0gdGhpcy5fYWRkUXVldWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gdGhpcy5fYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbkxlbmd0aCA9IGFuaW1hdGlvblF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUl0ZW1zKDAsIGFkZGVkQ291bnQsIF9fRW50ZXIsIG51bGwsIGFuaW1hdGlvbkxlbmd0aCA+IDAgJiYgYW5pbWF0aW9uUXVldWVbYW5pbWF0aW9uTGVuZ3RoIC0gMV0ub3AgPT09ICdjbG9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUHJvbWlzZSA9IHRoaXMuX2FkZEl0ZW1zKGNoYW5nZS5vYmplY3QubGVuZ3RoIC0gYWRkZWRDb3VudCwgYWRkZWRDb3VudCwgMCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFkZFF1ZXVlLmluZGV4T2YoYWRkUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyBzaGlmdGVkIG9mZiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRRdWV1ZSA9IHRoaXMuX2FkZFF1ZXVlLCBjaGFuZ2UgPSBjaGFuZ2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucmVtb3ZlZC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hbmltYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGRRdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlID0gYWRkUXVldWUuY29uY2F0KFt0aGlzLl9hbmltYXRlSXRlbXMoMCwgMSwgX19MZWF2ZSwgJ2Nsb25lJywgdHJ1ZSldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlSW5kZXggPSBjaGFuZ2Uub2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXRlbUxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlLmFsbChhZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhyZW1vdmVJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBIYW5kbGVzIGFkZGluZy9yZW1vdmluZyBpdGVtcyB3aGVuIGFuIGFycmF5IGlzIHNwbGljZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX3NwbGljZSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkQ291bnQgPSBjaGFuZ2UuYWRkZWRDb3VudCwgYWRkUXVldWUgPSB0aGlzLl9hZGRRdWV1ZSwgY3VycmVudExlbmd0aCA9IHRoaXMuX2l0ZW1MZW5ndGgsIGFkZFByb21pc2UsIGFuaW1hdGluZyA9IHRoaXMuX2FuaW1hdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChhZGRDb3VudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gY2hhbmdlLm9iamVjdC5sZW5ndGgsIGl0ZW1Db3VudF8xID0gY3VycmVudExlbmd0aCAtIG5ld0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0xlbmd0aCA+IGN1cnJlbnRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW1Db3VudCB3aWxsIGJlIG5lZ2F0aXZlIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUHJvbWlzZSA9IHRoaXMuX2FkZEl0ZW1zKGN1cnJlbnRMZW5ndGgsIC1pdGVtQ291bnRfMSwgMCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWRkUXVldWUuaW5kZXhPZihhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRMZW5ndGggPiBuZXdMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGVuZ3RoID49IGl0ZW1Db3VudF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXRlbUxlbmd0aCAtPSBpdGVtQ291bnRfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1MZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhjdXJyZW50TGVuZ3RoIC0gaXRlbUNvdW50XzEsIGl0ZW1Db3VudF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUNvdW50ID0gY2hhbmdlLnJlbW92ZWQubGVuZ3RoLCBhbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FuaW1hdGlvblF1ZXVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRDb3VudCA+IHJlbW92ZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtQWRkQ291bnQgPSBhZGRDb3VudCAtIHJlbW92ZUNvdW50LCBhbmltYXRpb25Db3VudCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ291bnQgPSBhZGRDb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25MZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGgsIHN0YXJ0SW5kZXggPSBjaGFuZ2UuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlbmd0aCA8IGFkZENvdW50IC0gc3RhcnRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNvdW50ID0gY3VycmVudExlbmd0aCAtIHN0YXJ0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbmltYXRlSXRlbXMoc3RhcnRJbmRleCwgYW5pbWF0aW9uQ291bnQsIF9fRW50ZXIsIG51bGwsIGFuaW1hdGlvbkxlbmd0aCA+IDAgJiYgYW5pbWF0aW9uUXVldWVbYW5pbWF0aW9uTGVuZ3RoIC0gMV0ub3AgPT09ICdjbG9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ291bnQgPSBhZGRDb3VudCAtIGFuaW1hdGlvbkNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFByb21pc2UgPSB0aGlzLl9hZGRJdGVtcyhjaGFuZ2Uub2JqZWN0Lmxlbmd0aCAtIGl0ZW1BZGRDb3VudCwgaXRlbUFkZENvdW50LCBhbmltYXRpb25Db3VudCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhZGRRdWV1ZS5pbmRleE9mKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZS5wdXNoKGFkZFByb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVDb3VudCA+IGFkZENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRpbmdfMSA9IGFkZENvdW50ID4gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZyAmJiAhYWRkaW5nXzEgJiYgYWRkUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZSA9IGFkZFF1ZXVlLmNvbmNhdChbdGhpcy5fYW5pbWF0ZUl0ZW1zKGNoYW5nZS5pbmRleCwgcmVtb3ZlQ291bnQsIF9fTGVhdmUsICdjbG9uZScsIHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUNvdW50XzEgPSByZW1vdmVDb3VudCAtIGFkZENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlbmd0aCA+PSBkZWxldGVDb3VudF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtTGVuZ3RoIC09IGRlbGV0ZUNvdW50XzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9Qcm9taXNlLmFsbChhZGRRdWV1ZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW5nICYmIGFkZGluZ18xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1MZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FuaW1hdGVJdGVtcyhjaGFuZ2UuaW5kZXgsIGFkZENvdW50LCBfX0VudGVyLCBudWxsLCBhbmltTGVuZ3RoID4gMCAmJiBhbmltYXRpb25RdWV1ZVthbmltTGVuZ3RoIC0gMV0ub3AgPT09ICdjbG9uZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUl0ZW1zKGN1cnJlbnRMZW5ndGggLSBkZWxldGVDb3VudF8xLCBkZWxldGVDb3VudF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR3JhYnMgdGhlIHRvdGFsIGJsb2NrbGVuZ3RoIG9mIHRoZSBzcGVjaWZpZWQgaXRlbXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBUaGUgc3RhcnRpbmcgaW5kZXggb2YgaXRlbXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGl0ZW1zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5fY2FsY3VsYXRlQmxvY2tMZW5ndGggPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgbnVtYmVyT2ZJdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ibG9ja0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHRoZSBpbmRpY2F0ZWQgaXRlbXMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCBUaGUgc3RhcnRpbmcgaW5kZXggb2YgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkl0ZW1zIFRoZSBudW1iZXIgb2YgY29uc2VjdXRpdmUgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25PcCBEZW5vdGVzIGFuaW1hdGlvbiBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbmNlbCBXaGV0aGVyIG9yIG5vdCB0byBjYW5jZWwgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGJlZm9yZSBiZWdpbm5pbmcgdGhpcyBvbmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9hbmltYXRlSXRlbXMgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgbnVtYmVyT2ZJdGVtcywga2V5LCBhbmltYXRpb25PcCwgY2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTGVuZ3RoID0gdGhpcy5fY2FsY3VsYXRlQmxvY2tMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tMZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydEluZGV4ICogYmxvY2tMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChhbmltYXRpb25PcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjbG9uZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlQ2xvbmVkQ29udGFpbmVyQW5pbWF0aW9uKHN0YXJ0LCBudW1iZXJPZkl0ZW1zICogYmxvY2tMZW5ndGggKyBzdGFydCwga2V5LCBjYW5jZWwgPT09IHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWF2ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTGVhdmUoc3RhcnQsIG51bWJlck9mSXRlbXMgKiBibG9ja0xlbmd0aCArIHN0YXJ0LCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVNpbXBsZUFuaW1hdGlvbihzdGFydCwgbnVtYmVyT2ZJdGVtcyAqIGJsb2NrTGVuZ3RoICsgc3RhcnQsIGtleSwgY2FuY2VsID09PSB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBIYW5kbGVzIGEgc2ltcGxlIGFuaW1hdGlvbiBvZiBhIGJsb2NrIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0Tm9kZSBUaGUgc3RhcnRpbmcgY2hpbGROb2RlIG9mIHRoZSBGb3JFYWNoIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kTm9kZSBUaGUgZW5kaW5nIGNoaWxkTm9kZSBvZiB0aGUgRm9yRWFjaCB0byBhbmltYXRlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgYW5pbWF0aW9uIGtleS90eXBlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjYW5jZWwgV2hldGhlciBvciBub3QgdG8gY2FuY2VsIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBiZWZvcmUgYmVnaW5uaW5nIHRoaXMgb25lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBGb3JFYWNoLnByb3RvdHlwZS5faGFuZGxlU2ltcGxlQW5pbWF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwga2V5LCBjYW5jZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLCBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRhaW5lci5jaGlsZE5vZGVzLCBzdGFydE5vZGUsIGVuZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uUXVldWUgPSB0aGlzLl9hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9uQ3JlYXRpb24gPSB0aGlzLl9hbmltYXRvci5jcmVhdGUobm9kZXMsIGtleSksIGFuaW1hdGlvblByb21pc2UgPSBhbmltYXRpb25DcmVhdGlvbi5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbmltYXRpb25RdWV1ZS5pbmRleE9mKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ3JlYXRpb24ucHJldmlvdXMudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwgJiYgYW5pbWF0aW9uUXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuY2VsUHJvbWlzZSA9IHRoaXMuX2NhbmNlbEN1cnJlbnRBbmltYXRpb25zKCkudGhlbihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEhhbmRsZXMgYSBzaW1wbGUgYW5pbWF0aW9uIG9mIGEgYmxvY2sgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnROb2RlIFRoZSBzdGFydGluZyBjaGlsZE5vZGUgb2YgdGhlIEZvckVhY2ggdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmROb2RlIFRoZSBlbmRpbmcgY2hpbGROb2RlIG9mIHRoZSBGb3JFYWNoIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhbmltYXRpb24ga2V5L3R5cGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9oYW5kbGVMZWF2ZSA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIGtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZSA9IHRoaXMuX2FuaW1hdGlvblF1ZXVlLCBhbmltYXRpb25Qcm9taXNlID0gdGhpcy5fYW5pbWF0b3IubGVhdmUobm9kZXMsIGtleSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuaW1hdGlvblF1ZXVlLmluZGV4T2YoYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb25Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogJ2xlYXZlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSGFuZGxlcyBhIHNpbXBsZSBhbmltYXRpb24gb2YgYSBibG9jayBvZiBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydE5vZGUgVGhlIHN0YXJ0aW5nIGNoaWxkTm9kZSBvZiB0aGUgRm9yRWFjaCB0byBhbmltYXRlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE5vZGUgVGhlIGVuZGluZyBjaGlsZE5vZGUgb2YgdGhlIEZvckVhY2ggdG8gYW5pbWF0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuY2VsIFdoZXRoZXIgb3Igbm90IHRvIGNhbmNlbCB0aGUgY3VycmVudCBhbmltYXRpb24gYmVmb3JlIGJlZ2lubmluZyB0aGlzIG9uZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgRm9yRWFjaC5wcm90b3R5cGUuX2hhbmRsZUNsb25lZENvbnRhaW5lckFuaW1hdGlvbiA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGVuZE5vZGUsIGtleSwgY2FuY2VsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciwgY2xvbmVkQ29udGFpbmVyID0gY29udGFpbmVyLmNsb25lTm9kZSh0cnVlKSwgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjbG9uZWRDb250YWluZXIuY2hpbGROb2Rlcywgc3RhcnROb2RlLCBlbmROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUsIGFuaW1hdGlvblF1ZXVlID0gdGhpcy5fYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbkNyZWF0aW9uID0gdGhpcy5fYW5pbWF0b3IuY3JlYXRlKG5vZGVzLCBrZXkpLCBhbmltYXRpb25Qcm9taXNlID0gYW5pbWF0aW9uQ3JlYXRpb24uY3VycmVudC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29udGFpbmVyLCBjbG9uZWRDb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLCBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudE5vZGUpIHx8IGFuaW1hdGlvblByb21pc2UuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjbG9uZWRDb250YWluZXIsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkNyZWF0aW9uLnByZXZpb3VzLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZS5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvblByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvblByb21pc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wOiAnY2xvbmUnXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsICYmIGFuaW1hdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbmNlbFByb21pc2UgPSB0aGlzLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucygpLnRoZW4oY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDYW5jZWxzIGFsbCBjdXJyZW50IGFuaW1hdGlvbnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEZvckVhY2gucHJvdG90eXBlLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uUXVldWUgPSB0aGlzLl9hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9ucyA9IFtdLCBsZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uUXVldWVbaV0uYW5pbWF0aW9uLmNhbmNlbCgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIEZvckVhY2guX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBGb3JFYWNoO1xyXG4gICAgICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgICAgICBjb250cm9sc18xLkZvckVhY2ggPSBGb3JFYWNoO1xyXG4gICAgICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fRm9yRWFjaCwgRm9yRWFjaCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHNwZWNpYWwgdHlwZSBvZiBUZW1wbGF0ZUNvbnRyb2wgZm9yIG1hbmFnaW5nIG1ldGEgdGFncywgdXNlZnVsIGZvciBTRU8uIFRoaXNcclxuICAgICAgICAgICAgICogY29udHJvbCB3aWxsIG5vdCBleGlzdCB1bmxlc3MgeW91IHJlZ2lzdGVyIGl0IGFzIGEgY29udHJvbCB3aXRoIHRoZSBuYW1lICdoZWFkJy4gSXQgaXMgc3RhdGljLCBzbyB5b3UgY2FuIGluamVjdFxyXG4gICAgICAgICAgICAgKiBpdCBpbnRvIG90aGVyIGNvbXBvbmVudHMgYW5kIGdldCBhY2Nlc3MgdG8gaXRzIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB2YXIgSGVhZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoSGVhZCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEhlYWQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmF0aGVyIHRoYW4gYmUgcmVwbGFjZWQgYnkgYSAnZGl2JywgdGhpcyBjb250cm9sIHdhbnRzIHRvIGJlIGEgJ2hlYWQnIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aCA9IF9fSGVhZDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byBhbGwgdGhlIHN0cnVjdHVyZWQgZGF0YSBlbGVtZW50cyBhZGRlZCB0byB0aGUgRE9NIGZvciB0aGlzIHBhZ2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RydWN0dXJlZERhdGFFbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZWdpc3RlcnMgZm9yIHRoZSBuYXZpZ2F0aW5nIGV2ZW50IHRvIGtub3cgd2hlbiB0byByZW1vdmUgYWxsIHRoZSBlbGVtZW50cyBzbyB0aGV5XHJcbiAgICAgICAgICAgICAgICAgKiBkb24ndCBibGVlZCBvbnRvIHRoZSBuZXh0IHBhZ2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKF9fbmF2aWdhdGluZywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1ha2VzIHN1cmUgYWxsIHRoZSBlbGVtZW50cyBleGlzdC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGEgPSBfX01ldGEsIHRpdGxlID0gX19UaXRsZSwgbGluayA9IF9fTWV0YUxpbmssIGF1dGhvciA9IF9fQXV0aG9yLCB0eXBlID0gX19NZXRhVHlwZSwgY3JlYXRvciA9IF9fQ3JlYXRvciwgaW1hZ2UgPSBfX01ldGFJbWFnZSwgdmlkZW8gPSBfX01ldGFWaWRlbywgZGVzY3JpcHRpb24gPSBfX0Rlc2NyaXB0aW9uLCB1cmwgPSBfX1VybCwgb2cgPSBfX09wZW5HcmFwaCwgYXJ0aWNsZSA9IF9fQXJ0aWNsZSwgdHdpdHRlciA9IF9fVHdpdHRlcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aXRsZUVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KHRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ1RpdGxlRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgb2cgKyB0aXRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlclRpdGxlRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgdHdpdHRlciArIHRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbkVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ0Rlc2NyaXB0aW9uRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgb2cgKyBkZXNjcmlwdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlckRlc2NyaXB0aW9uRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgdHdpdHRlciArIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ1VybEVsZW1lbnQgPSB0aGlzLl9jcmVhdGVFbGVtZW50KG1ldGEsIG9nICsgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90d2l0dGVyVXJsRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgdHdpdHRlciArIHVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgYXV0aG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nb29nbGVBdXRob3JFbGVtZW50ID0gdGhpcy5fY3JlYXRlRWxlbWVudChsaW5rLCBhdXRob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZiQXV0aG9yRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgYXJ0aWNsZSArIGF1dGhvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlckNyZWF0b3JFbGVtZW50ID0gdGhpcy5fY3JlYXRlRWxlbWVudChtZXRhLCB0d2l0dGVyICsgY3JlYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2dUeXBlRWxlbWVudCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgb2cgKyB0eXBlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHRpdGxlIG9yIHNldHMgdGhlIHRpdGxlIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlPyBJZiBzdXBwbGllZCwgdGhlIHRpdGxlIGVsZW1lbnRzIHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLnRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRlbnQodGhpcy5fdGl0bGVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGl0bGVFbGVtZW50LmlubmVyVGV4dCA9IHRpdGxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ1RpdGxlRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlclRpdGxlRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHRpdGxlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGl0bGU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBkZXNjcmlwdGlvbiBvciBzZXRzIHRoZSBkZXNjcmlwdGlvbiBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZXNjcmlwdGlvbj8gSWYgc3VwcGxpZWQsIHRoZSBkZXNjcmlwdGlvbiBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5kZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoZGVzY3JpcHRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX2Rlc2NyaXB0aW9uRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbkVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29nRGVzY3JpcHRpb25FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90d2l0dGVyRGVzY3JpcHRpb25FbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgXSwgZGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdGlvbjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIHVybCBvciBzZXRzIHRoZSB1cmwgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsPyBJZiBzdXBwbGllZCwgdGhlIHVybCBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX29nVXJsRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ1VybEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3R3aXR0ZXJVcmxFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgXSwgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgYXV0aG9yIG9yIHNldHMgdGhlIGF1dGhvciBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdXRob3I/IElmIHN1cHBsaWVkLCB0aGUgYXV0aG9yIGVsZW1lbnRzIHdpbGwgYmUgc2V0IHRvIHRoaXMgdmFsdWUuIFRoZSB2YWx1ZSBzaG91bGQgYmUgdGhlXHJcbiAgICAgICAgICAgICAgICAgKiBkaXNwbGF5IG5hbWUgb2YgdGhlIGNvbnRlbnQgYXV0aG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5hdXRob3IgPSBmdW5jdGlvbiAoYXV0aG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhhdXRob3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZW50KHRoaXMuX2F1dGhvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBdLCBhdXRob3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3I7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBhdXRob3Igb3Igc2V0cyB0aGUgYXV0aG9yIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhvcj8gSWYgc3VwcGxpZWQsIHRoZSBhdXRob3IgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4gVGhlIHZhbHVlIHNob3VsZCBiZSB0aGVcclxuICAgICAgICAgICAgICAgICAqIEdvb2dsZSsgcHJvZmlsZSB1cmwgZm9yIHRoZSBhdXRob3IuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLmdvb2dsZUF1dGhvciA9IGZ1bmN0aW9uIChhdXRob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGF1dGhvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRlbnQodGhpcy5fZ29vZ2xlQXV0aG9yRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nb29nbGVBdXRob3JFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGF1dGhvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGF1dGhvciBvciBzZXRzIHRoZSBhdXRob3IgZWxlbWVudHMuIFRoaXMgbWV0aG9kIGlzIGZvciB1c2Ugd2l0aCB0aGUgRmFjZWJvb2sgcHJvZmlsZSBhdXRob3JzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF1dGhvcj8gSWYgc3VwcGxpZWQsIHRoZSBhdXRob3IgZWxlbWVudHMgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS4gVGhlIHZhbHVlIHNob3VsZCBiZVxyXG4gICAgICAgICAgICAgICAgICogdGhlIGBodHRwczovL3d3dy5mYWNlYm9vay5jb20vdXNlcm5hbWVgIGFjY291bnQsIGFuZCBtYWtlIHN1cmUgdGhlIHVzZXIgc3VwcG9ydHMgZm9sbG93ZXJzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5mYkF1dGhvciA9IGZ1bmN0aW9uIChhdXRob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGF1dGhvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRlbnQodGhpcy5fZmJBdXRob3JFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29udGVudChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZiQXV0aG9yRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIGF1dGhvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGNyZWF0b3Igb3Igc2V0cyB0aGUgY3JlYXRvciBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNyZWF0b3I/IElmIHN1cHBsaWVkLCB0aGUgY3JlYXRvciBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLiBUaGVcclxuICAgICAgICAgICAgICAgICAqIHZhbHVlIHNob3VsZCBiZSB0aGUgdHdpdHRlciBgQHVzZXJuYW1lYCBvZiB0aGUgY3JlYXRvclxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS50d2l0dGVyQ3JlYXRvciA9IGZ1bmN0aW9uIChjcmVhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhjcmVhdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGVudCh0aGlzLl90d2l0dGVyQ3JlYXRvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb250ZW50KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdHdpdHRlckNyZWF0b3JFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgXSwgY3JlYXRvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0b3I7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB0eXBlIG9yIHNldHMgdGhlIHR5cGUgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZT8gSWYgc3VwcGxpZWQsIHRoZSBpbWFnZSBlbGVtZW50cyB3aWxsIGJlIHNldCB0byB0aGlzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5mYlR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldENvbnRlbnQodGhpcy5fb2dUeXBlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbnRlbnQoW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vZ1R5cGVFbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgXSwgdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBpbWFnZSBlbGVtZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaW1hZ2VzIEZvciBlYWNoIGltYWdlLCBhIHRhZyB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuaW1hZ2VzID0gZnVuY3Rpb24gKGltYWdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGltYWdlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YSA9IF9fTWV0YSwgb2cgPSBfX09wZW5HcmFwaCwgdHdpdHRlciA9IF9fVHdpdHRlciwgb2dFbGVtZW50LCB0d2l0dGVyRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGZ1bmN0aW9uIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZ0VsZW1lbnQgPSBfdGhpcy5fY3JlYXRlRWxlbWVudChtZXRhLCBvZyArIF9fTWV0YUltYWdlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHdpdHRlckVsZW1lbnQgPSBfdGhpcy5fY3JlYXRlRWxlbWVudChtZXRhLCB0d2l0dGVyICsgX19NZXRhSW1hZ2UsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IF90aGlzLl9icm93c2VyLnVybFV0aWxzKGltYWdlKS5ocmVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0Q29udGVudChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZ0VsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d2l0dGVyRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLCBpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIHZpZGVvIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSB2aWRlb3MgRm9yIGVhY2ggdmlkZW8sIGEgdGFnIHdpbGwgYmUgY3JlYXRlZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS52aWRlb3MgPSBmdW5jdGlvbiAodmlkZW9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkodmlkZW9zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRhID0gX19NZXRhLCBvZyA9IF9fT3BlbkdyYXBoLCBtZXRhVmlkZW8gPSBfX01ldGFWaWRlbywgX2Jyb3dzZXIgPSB0aGlzLl9icm93c2VyLCBvZ0VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChmdW5jdGlvbiAodmlkZW8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2dFbGVtZW50ID0gX3RoaXMuX2NyZWF0ZUVsZW1lbnQobWV0YSwgb2cgKyBtZXRhVmlkZW8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWRlbyA9IF9icm93c2VyLnVybFV0aWxzKHZpZGVvKS5ocmVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0Q29udGVudChbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZ0VsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgdmlkZW8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHZpZGVvcyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIGEgc3RydWN0dXJlZCBkYXRhIGxkK2pzb24gZWxlbWVudCB0byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IFRoZSBvYmplY3QsIGl0IHdpbGwgYmUgc3RyaW5naWZpZWQgYW5kIHB1dCBpbiB0aGUgbGQranNvbiB0YWcuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLnN0cnVjdHVyZWREYXRhID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSwgc2libGluZyA9IHRoaXMuX3RpdGxlRWxlbWVudC5uZXh0U2libGluZztcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnYXBwbGljYXRpb24vbGQranNvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdHJ1Y3R1cmVkRGF0YUVsZW1lbnRzLnB1c2goZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZSh0aGlzLmVsZW1lbnQsIGVsLCBzaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRha2VzIGluIG9uZSBvciBtb3JlIEJsb2dQb3N0aW5nIDxodHRwOi8vc2NoZW1hLm9yZy9CbG9nUG9zdGluZz4gb2JqZWN0cyBhbmQgc2V0cyB0aGVtIGFzIGxkK2pzb24gdGFncyBpbiB0aGUgaGVhZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5jb250cm9scy5JQmxvZ1Bvc3Rpbmd9IFRoZSBwb3N0aW5nIG9iamVjdCwgaXQgd2lsbCBiZSBzdHJpbmdpZmllZCBhbmQgcHV0IGluIHRoZSBsZCtqc29uIHRhZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUuYmxvZ1Bvc3RpbmdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0aW5ncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RpbmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzExID0gcG9zdGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoXzExOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJ1Y3R1cmVkRGF0YShwb3N0aW5nc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgdXJsIGVsZW1lbnRzIGluaXRpYWxseS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSGVhZC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXJsKHRoaXMuX2Jyb3dzZXIudXJsKCkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU2V0cyB0aGUgdXJsIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5uYXZpZ2F0ZWQgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cmwodXJsKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGlubmVyVGV4dC9jb250ZW50L2hyZWYgb2YgYW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBnZXQgdGhlIGNvbnRlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLl9nZXRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSBfX1RpdGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmlubmVyVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT09IF9fTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoX19Db250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZU5hbWUgPT09IF9fTWV0YUxpbmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKF9fTWV0YUhyZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIGlubmVyVGV4dC9jb250ZW50L2hyZWYgb2YgYSBsaXN0IGVsZW1lbnRzLiBJZiBhbiBlbGVtZW50IGlzIG5vdCBpbiB0aGUgRE9NLCBpdFxyXG4gICAgICAgICAgICAgICAgICogaXMgYWRkZWQgdG8gdGhlIGRvbSByaWdodCBhZnRlciB0aGUgPHRpdGxlIC8+IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PEhUTUxFbGVtZW50Pn0gZWxlbWVudHMgVGhlIGVsZW1lbnRzIGZvciB3aGljaCB0byBzZXQgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5fc2V0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50cywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLmVsZW1lbnQsIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGRyZW4pLCBsZW5ndGggPSBlbGVtZW50cy5sZW5ndGgsIGNvbnRlbnQgPSBfX0NvbnRlbnQsIGhyZWYgPSBfX01ldGFIcmVmLCBzaWJsaW5nID0gdGhpcy5fdGl0bGVFbGVtZW50Lm5leHRTaWJsaW5nLCBkb20gPSB0aGlzLmRvbSwgbm9kZU5hbWUsIGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IF9fTWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY29udGVudCwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoaHJlZiwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2Rlcy5pbmRleE9mKGVsZW1lbnQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmluc2VydEJlZm9yZShlbCwgZWxlbWVudCwgc2libGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIGFuIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRhZyBhbmQgbmFtZS4gVGhlIG5hbWUgY29ycmVzcG9uZHMgdG9cclxuICAgICAgICAgICAgICAgICAqIHRoZSB0eXBlIG9mIHRoZSBtZXRhL2xpbmsgdGFnIChpLmUuIHRpdGxlL2Rlc2NyaXB0aW9uL2F1dGhvciBldGMpLCBhbmQgaXMgYWxzbyB0aGVcclxuICAgICAgICAgICAgICAgICAqIHZhbHVlIHRoYXQgd2lsbCBiZSBzZXQgZm9yIHRoZSBwcm9wZXIgYXR0cmlidXRlLiBUaGUgYXR0cmlidXRlIGlzIGRldGVybWluZWQgYmFzZWQgb25cclxuICAgICAgICAgICAgICAgICAqIHRoZSB0YWcvbmFtZSBjb21iaW5hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIHRhZyBuYW1lIGZvciB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lPyBUaGUgbmFtZSBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlIG9mIG1ldGEvbGluayB0YWcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGxlPyBXaGV0aGVyIG9yIG5vdCB0aGVyZSBjYW4gYmUgbXVsdGlwbGUgb2YgdGhpcyB0YWcvbmFtZSBpbiB0aGUgZG9tXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIEhlYWQucHJvdG90eXBlLl9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHRhZywgbmFtZSwgbXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwsIGhhc05hbWUgPSBpc1N0cmluZyhuYW1lKSwgYXR0ciA9IChoYXNOYW1lICYmIChuYW1lLmluZGV4T2YoX19PcGVuR3JhcGgpID09PSAwIHx8IG5hbWUuaW5kZXhPZihfX0FydGljbGUpID09PSAwKSkgPyBfX01ldGFQcm9wZXJ0eSA6IF9fTWV0YU5hbWUsIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gX19NZXRhTGluaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gX19SZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbXVsdGlwbGUgJiYgaGFzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcih0YWcgKyAnWycgKyBhdHRyICsgJz1cIicgKyBuYW1lICsgJ1wiXScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghbXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGFnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlbW92ZXMgYWxsIHRoZSB1bm5lY2Vzc2FyeSBlbGVtZW50cyBmcm9tIHRoZSA8aGVhZCAvPiB0byBhdm9pZCBoYXZpbmdcclxuICAgICAgICAgICAgICAgICAqIGluY29ycmVjdCB0YWdzIG9uIHRoZSBwYWdlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5fcmVtb3ZlQWxsRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBvZyA9IHRoaXMuX2RvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbCgnbWV0YVsnICsgX19NZXRhUHJvcGVydHkgKyAnXj1cIicgKyBfX09wZW5HcmFwaCArICdcIl0nKSwgdHdpdHRlciA9IHRoaXMuX2RvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvckFsbCgnbWV0YVsnICsgX19NZXRhTmFtZSArICdePVwiJyArIF9fVHdpdHRlciArICdcIl0nKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cy5hcHBseSh0aGlzLCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ29vZ2xlQXV0aG9yRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHNsaWNlLmNhbGwob2cpLCBzbGljZS5jYWxsKHR3aXR0ZXIpLCBzbGljZS5jYWxsKHRoaXMuX3N0cnVjdHVyZWREYXRhRWxlbWVudHMpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RydWN0dXJlZERhdGFFbGVtZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIHRoZSA8aGVhZCAvPlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBIZWFkLnByb3RvdHlwZS5fcmVtb3ZlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZWxlbWVudCwgbm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlbC5jaGlsZHJlbiksIGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aCwgZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVzLmluZGV4T2YoZWxlbWVudCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVDaGlsZChlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBIZWFkLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIF9icm93c2VyOiBfX0Jyb3dzZXJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSGVhZDtcclxuICAgICAgICAgICAgfSh1aS5UZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5IZWFkID0gSGVhZDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgVGVtcGxhdGVDb250cm9sIGZvciBhZGRpbmcgSFRNTCB0byB0aGVcclxuICAgICAgICAgICAgICogRE9NIHRocm91Z2ggYm91bmQgY29udGV4dCBzdHJpbmdzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIElubmVySHRtbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoSW5uZXJIdG1sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSW5uZXJIdG1sKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDbGVhcnMgdGhlIGlubmVyIHRlbXBsYXRlIGlmIG9uZSBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElubmVySHRtbC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uY2xlYXJOb2RlKHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3Mgb3B0aW9ucyBhbmQgaW5pdGlhbGl6ZXMgYmluZGluZ3MuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElubmVySHRtbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk9wdGlvbnNDaGFuZ2VkKG9wdGlvbnMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub2JzZXJ2ZSh0aGlzLl9vbk9wdGlvbnNDaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhbnkgb2YgdGhlIG9wdGlvbnMgZm9yIHRoaXMgY29udHJvbCBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtJSW5uZXJIdG1sT3B0aW9uc30gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgb3B0aW9ucyBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7SUlubmVySHRtbE9wdGlvbnN9IG9sZFZhbHVlPyBUaGUgb2xkIHZhbHVlIG9mIHRoZSBvcHRpb25zIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJbm5lckh0bWwucHJvdG90eXBlLl9vbk9wdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdwbGF0LW9wdGlvbnMgZm9yICcgKyB0aGlzLnR5cGUgKyAnIG11c3QgYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBodG1sID0gbmV3VmFsdWUuaHRtbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaHRtbCA9PT0gdGhpcy5faHRtbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2h0bWwgPSBodG1sO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBodG1sSXNTdHJpbmcgPSBpc1N0cmluZyhodG1sKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGh0bWwpIHx8IChodG1sSXNTdHJpbmcgJiYgaHRtbC50cmltKCkgPT09ICcnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250cm9scy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmRpc3Bvc2UodGhpcy5jb250cm9sc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbS5jbGVhck5vZGUodGhpcy5lbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFodG1sSXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKCdUcnlpbmcgdG8gYmluZCBhIG5vbi1zdHJpbmcgdmFsdWUgdG8gJyArIHRoaXMudHlwZSArICcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUuY29tcGlsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzQ29udHJvbF8xID0gdGhpcy5jb250cm9scy5sZW5ndGggPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLm9uY2UoaHRtbCkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb250cm9sXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kaXNwb3NlKF90aGlzLmNvbnRyb2xzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbS5jbGVhck5vZGUoX3RoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNldElubmVySHRtbCh0aGlzLmVsZW1lbnQsIGh0bWwpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIElubmVySHRtbC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5OiBfX1RlbXBsYXRlQ29udHJvbEZhY3RvcnlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5uZXJIdG1sO1xyXG4gICAgICAgICAgICB9KFRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgICAgICAgICBjb250cm9sc18xLklubmVySHRtbCA9IElubmVySHRtbDtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0h0bWwsIElubmVySHRtbCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIEJpbmRDb250cm9sIGZvciBiaW5kaW5nIGFuIEhUTUwgc2VsZWN0IGVsZW1lbnRcclxuICAgICAgICAgICAgICogdG8gYW4gQXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBTZWxlY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICAgICAgX19leHRlbmRzKFNlbGVjdCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIFNlbGVjdC4gQ3JlYXRlcyB0aGUgaXRlbXNMb2FkZWQgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2VsZWN0KCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogUmVwbGFjZXMgdGhlIGA8cGxhdC1zZWxlY3Q+YCBub2RlIHdpdGhcclxuICAgICAgICAgICAgICAgICAgICAgKiBhIDxzZWxlY3Q+IG5vZGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlV2l0aCA9ICdzZWxlY3QnO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSBsb2FkIHByaW9yaXR5IG9mIHRoZSBjb250cm9sIChuZWVkcyB0byBsb2FkIGJlZm9yZSBhIEJpbmQgY29udHJvbCkuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmlvcml0eSA9IDEyMDtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgdGhhdCBrZWVwcyB0cmFjayBvZiB1bmlxdWVcclxuICAgICAgICAgICAgICAgICAgICAgKiBvcHRncm91cHMuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbiA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVqZWN0Rm4gPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2gobm9vcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgdGhlIGJpbmRhYmxlIG9wdGlvbiB0ZW1wbGF0ZSBhbmQgZ3JvdXBpbmdcclxuICAgICAgICAgICAgICAgICAqIHRlbXBsYXRlIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZCgnb3B0aW9uJywgdGhpcy5lbGVtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9LCBwbGF0T3B0aW9ucyA9IG9wdGlvbnMudmFsdWUgfHwge30sIGRlZmF1bHRPcHRpb25WYWx1ZXMgPSBwbGF0T3B0aW9ucy5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkZWZhdWx0T3B0aW9uVmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpLCBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0T3B0aW9uVmFsdWVzLnZhbHVlLCBkZWZhdWx0VGV4dENvbnRlbnQgPSBkZWZhdWx0T3B0aW9uVmFsdWVzLnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uLnZhbHVlID0gaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRUZXh0Q29udGVudCA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdE9wdGlvbi50ZXh0Q29udGVudCA9IGlzVW5kZWZpbmVkKGRlZmF1bHRUZXh0Q29udGVudCkgPyBkZWZhdWx0VmFsdWUgOiBkZWZhdWx0VGV4dENvbnRlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUoZGVmYXVsdE9wdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHBsYXRPcHRpb25zLmdyb3VwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCA9IHBsYXRPcHRpb25zLmdyb3VwLCBvcHRpb25Hcm91cCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbkdyb3VwLmxhYmVsID0gX19zdGFydFN5bWJvbCArIGdyb3VwICsgX19lbmRTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYWRkKCdncm91cCcsIG9wdGlvbkdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNHcm91cGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzR3JvdXBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlLW9ic2VydmVzIHRoZSBuZXcgYXJyYXkgY29udGV4dCBhbmQgbW9kaWZpZXNcclxuICAgICAgICAgICAgICAgICAqIHRoZSBvcHRpb25zIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBuZXdWYWx1ZSBUaGUgbmV3IGFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IG9sZFZhbHVlIFRoZSBvbGQgYXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkob2xkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhfdGhpcy5jb250cm9scy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gaXNBcnJheShuZXdWYWx1ZSkgPyBuZXdWYWx1ZS5sZW5ndGggOiAwLCBvbGRMZW5ndGggPSBpc0FycmF5KG9sZFZhbHVlKSA/IG9sZFZhbHVlLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3TGVuZ3RoID4gb2xkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEl0ZW1zKG5ld0xlbmd0aCAtIG9sZExlbmd0aCwgb2xkTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3TGVuZ3RoIDwgb2xkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW1zKG9sZExlbmd0aCAtIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogT2JzZXJ2ZXMgdGhlIG5ldyBhcnJheSBjb250ZXh0IGFuZCBhZGRzXHJcbiAgICAgICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuX2lzR3JvdXBlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge30sIHBsYXRPcHRpb25zID0gb3B0aW9ucy52YWx1ZSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNHcm91cGVkID0gIWlzTnVsbCgodGhpcy5fZ3JvdXAgPSBwbGF0T3B0aW9ucy5ncm91cCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0T3B0aW9uID0gdGhpcy5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEl0ZW1zKGNvbnRleHQubGVuZ3RoLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBhbnkgcG90ZW50aWFsbHkgaGVsZCBtZW1vcnkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0Z1bmN0aW9uKHRoaXMuX19yZWplY3RGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3JlamVjdEZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZXNvbHZlRm4gPSB0aGlzLl9fcmVqZWN0Rm4gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0T3B0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGJpbmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmluZGVyID0gYmluZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoYmluZGVyLmV2YWx1YXRlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRTZWxlY3RlZEluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaW5kZXIub2JzZXJ2ZUFycmF5Q2hhbmdlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRTZWxlY3RlZEluZGljZXMoYmluZGVyLmV2YWx1YXRlKCksIG51bGwsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0U2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY2hhbmdlJywgdGhpcy5fb2JzZXJ2ZUNoYW5nZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgc2VsZWN0ZWQgaW5kZXggaWYgYm91bmQgdG8gYSBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBib3VuZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGNhbGxlZCBhcyBhIHNldHRlci5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fc2V0U2VsZWN0ZWRJbmRleCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHZhbHVlID0gZWxlbWVudC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlIHx8ICF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoX3RoaXMuX2JpbmRlci5ldmFsdWF0ZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoZWxlbWVudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzU3RyaW5nKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4obmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihuZXdWYWx1ZS50b1N0cmluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnVHJ5aW5nIHRvIGJpbmQgdGhlIGludmFsaWQgdmFsdWUgXCInICsgbmV3VmFsdWUgKyAnXCIgdG8gYSAnICsgdGhpcy50eXBlICsgJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlucHV0Q2hhbmdlZChfdGhpcy5fY2FzdFZhbHVlKGVsZW1lbnQudmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgdXNlciBjaGFuZ2VkIHRvIGEgdmFsaWQgdmFsdWUgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlY29uZCBib29sZWFuIGFyZ3VtZW50IGlzIGFuIGllIGZpeCBmb3IgaW5jb25zaXN0ZW5jeSBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgIT09IG5ld1ZhbHVlIHx8IGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBzZWxlY3RlZCBpbmRleCBpZiBib3VuZCB0byBhIHByb3BlcnR5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIEFycmF5IG9mIHRoZSBib3VuZCBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBBcnJheSBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRlbnRpZmllciBUaGUgY2hpbGQgaWRlbnRpZmllciBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBiZWluZyBjYWxsZWQgYXMgYSBzZXR0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3NldFNlbGVjdGVkSW5kaWNlcyA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50LCBvcHRpb25zID0gZWxlbWVudC5vcHRpb25zLCBsZW5ndGggPSBpc051bGwob3B0aW9ucykgPyAwIDogb3B0aW9ucy5sZW5ndGgsIG9wdGlvbiwgbnVsbFZhbHVlID0gaXNOdWxsKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bGxWYWx1ZSB8fCAhaXNBcnJheShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUgJiYgaXNOdWxsKF90aGlzLl9iaW5kZXIuZXZhbHVhdGUoKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dENoYW5nZWQoX3RoaXMuX2dldFNlbGVjdGVkVmFsdWVzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5zZWxlY3RzIHRoZSBvcHRpb25zIHVubGVzcyBhIG1hdGNoIGlzIGZvdW5kIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW51bGxWYWx1ZSAmJiBvcHRpb24udmFsdWUgPT09ICcnICsgbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUsIG51bWJlclZhbHVlLCBpbmRleCwgaGlnaGVzdEluZGV4ID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXJWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIobnVtYmVyVmFsdWUpICYmIChpbmRleCA9IG5ld1ZhbHVlLmluZGV4T2YobnVtYmVyVmFsdWUpKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBoaWdoZXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb3BlcnR5VHlwZSA9ICdudW1iZXInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdoZXN0SW5kZXggPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSA9PT0gJ3RydWUnICYmIChpbmRleCA9IG5ld1ZhbHVlLmluZGV4T2YodHJ1ZSkpICE9PSAtMSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gJ2ZhbHNlJyAmJiAoaW5kZXggPSBuZXdWYWx1ZS5pbmRleE9mKGZhbHNlKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgaGlnaGVzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcm9wZXJ0eVR5cGUgPSAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZpcmVzIHRoZSBpbnB1dENoYW5nZWQgZXZlbnQgd2hlbiB0aGUgc2VsZWN0J3MgdmFsdWUgY2hhbmdlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fb2JzZXJ2ZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChlbGVtZW50Lm11bHRpcGxlID8gdGhpcy5fZ2V0U2VsZWN0ZWRWYWx1ZXMoKSA6IHRoaXMuX2Nhc3RWYWx1ZShlbGVtZW50LnZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXR0ZXIgZm9yIHNlbGVjdC1tdWx0aXBsZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fZ2V0U2VsZWN0ZWRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQub3B0aW9ucywgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGgsIG9wdGlvbiwgc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzLnB1c2godGhpcy5fY2FzdFZhbHVlKG9wdGlvbi52YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFZhbHVlcztcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENhc3RzIGEgdmFsdWUgdG8gdGhlIGRldGVybWluZWQgaW5pdGlhbCBwcm9wZXJ0eSB0eXBlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9jYXN0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX3Byb3BlcnR5VHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhc3RWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IGlzRW1wdHkodmFsdWUpID8gdW5kZWZpbmVkIDogTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFsc2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSAhIXZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhc3RWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgYSBsaXN0ZW5lciBmb3IgdGhlIGNoYW5nZXMgdG8gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9zZXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX19saXN0ZW5lclNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh0aGlzLl9leGVjdXRlRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fbGlzdGVuZXJTZXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlY2VpdmVzIGFuIGV2ZW50IHdoZW4gYSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIG9uIGFuIGFycmF5IGFuZCBtYXBzIHRoZSBhcnJheVxyXG4gICAgICAgICAgICAgICAgICogbWV0aG9kIHRvIGl0cyBhc3NvY2lhdGVkIG1ldGhvZCBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX2V4ZWN1dGVFdmVudCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9ICdfJyArIGNoYW5nZXNbMF0udHlwZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kXShjaGFuZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIHRoZSBvcHRpb25zIHRvIHRoZSBzZWxlY3QgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkl0ZW1zIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYWRkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBzdGFydGluZyBpbmRleCBvZiB0aGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICogc2V0IG9mIGl0ZW1zIHRvIGFkZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fYWRkSXRlbXMgPSBmdW5jdGlvbiAobnVtYmVyT2ZJdGVtcywgaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kYWJsZVRlbXBsYXRlcyA9IHRoaXMuYmluZGFibGVUZW1wbGF0ZXMsIHByb21pc2VzID0gW10sIGluc2VydE9wdGlvbiA9IHRoaXMuX2luc2VydE9wdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobnVtYmVyT2ZJdGVtcy0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGJpbmRhYmxlVGVtcGxhdGVzLmJpbmQoJ29wdGlvbicsIGluZGV4KS50aGVuKGluc2VydE9wdGlvbi5iaW5kKHRoaXMsIGluZGV4KyspKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQgPSB0aGlzLl9Qcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihfdGhpcy5fX3Jlc29sdmVGbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX3Jlc29sdmVGbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuID0gX3RoaXMuX19yZWplY3RGbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhlcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNMb2FkZWQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgY2FsbGJhY2sgdXNlZCB0byBhZGQgYW4gb3B0aW9uIGFmdGVyXHJcbiAgICAgICAgICAgICAgICAgKiBpdHMgdGVtcGxhdGUgaGFzIGJlZW4gYm91bmQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGl0ZW0gYmVpbmcgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IG9wdGlvbiBUaGUgYm91bmQgRG9jdW1lbnRGcmFnbWVudCB0byBiZVxyXG4gICAgICAgICAgICAgICAgICogaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9pbnNlcnRPcHRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIG9wdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3Vwc18xID0gdGhpcy5ncm91cHMsIG5ld0dyb3VwXzEgPSAodGhpcy5jb250ZXh0W2luZGV4XSB8fCB7fSlbdGhpcy5fZ3JvdXBdLCBvcHRncm91cF8xID0gZ3JvdXBzXzFbbmV3R3JvdXBfMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwob3B0Z3JvdXBfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZ3JvdXBzXzFbbmV3R3JvdXBfMV0gPSB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmJpbmQoJ2dyb3VwJywgaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGdyb3VwRnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cF8xID0gZ3JvdXBzXzFbbmV3R3JvdXBfMV0gPSBncm91cEZyYWdtZW50LmNoaWxkTm9kZXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0Z3JvdXBfMS5pbnNlcnRCZWZvcmUob3B0aW9uLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZShncm91cEZyYWdtZW50LCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0Z3JvdXBfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1Byb21pc2Uob3B0Z3JvdXBfMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRncm91cF8xLnRoZW4oZnVuY3Rpb24gKGdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAuaW5zZXJ0QmVmb3JlKG9wdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cF8xLmluc2VydEJlZm9yZShvcHRpb24sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKG9wdGlvbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVtb3ZlcyBhIHNwZWNpZmllZCBudW1iZXIgb2YgZWxlbWVudHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZJdGVtcyBUaGUgbnVtYmVyIG9mIGl0ZW1zXHJcbiAgICAgICAgICAgICAgICAgKiB0byByZW1vdmUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3JlbW92ZUl0ZW1zID0gZnVuY3Rpb24gKG51bWJlck9mSXRlbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcG9zZSA9IFRlbXBsYXRlQ29udHJvbC5kaXNwb3NlLCBjb250cm9scyA9IHRoaXMuY29udHJvbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG51bWJlck9mSXRlbXMtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZShjb250cm9scy5wb3AoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaGFzIGJlZW4gcmVtb3ZlZFxyXG4gICAgICAgICAgICAgICAgICogZnJvbSB0aGUgQXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNHcm91cGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0U2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSXRlbXMoMSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNldHMgdGhlIHNlbGVjdCBlbGVtZW50IGJ5IHJlbW92aW5nIGFsbCBpdHNcclxuICAgICAgICAgICAgICAgICAqIGl0ZW1zIGFuZCBhZGRpbmcgdGhlbSBiYWNrLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9yZXNldFNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJdGVtcyh0aGlzLmNvbnRyb2xzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncm91cHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0aGlzLl9kZWZhdWx0T3B0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuX2RlZmF1bHRPcHRpb24uY2xvbmVOb2RlKHRydWUpLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSXRlbXModGhpcy5jb250ZXh0Lmxlbmd0aCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gYW4gZWxlbWVudCBpcyBwdXNoZWQgdG9cclxuICAgICAgICAgICAgICAgICAqIHRoZSBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEl0ZW1zKGNoYW5nZS5hZGRlZENvdW50LCBjaGFuZ2UuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGFuIGl0ZW0gaXMgcG9wcGVkXHJcbiAgICAgICAgICAgICAgICAgKiBmcm9tIHRoZSBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3BvcCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlc1swXS5yZW1vdmVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyB1bnNoaWZ0ZWRcclxuICAgICAgICAgICAgICAgICAqIG9udG8gdGhlIGFycmF5IGNvbnRleHQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fdW5zaGlmdCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBhZGRlZENvdW50ID0gY2hhbmdlLmFkZGVkQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkSXRlbXMoYWRkZWRDb3VudCwgY2hhbmdlLm9iamVjdC5sZW5ndGggLSBhZGRlZENvdW50IC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyBzaGlmdGVkXHJcbiAgICAgICAgICAgICAgICAgKiBmcm9tIHRoZSBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgbXV0YXRpb24gZXZlbnQgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIFNlbGVjdC5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VzWzBdLnJlbW92ZWQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUl0ZW0oKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiBpdGVtcyBhcmUgc3BsaWNlZFxyXG4gICAgICAgICAgICAgICAgICogZnJvbSB0aGUgYXJyYXkgY29udGV4dC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IG11dGF0aW9uIGV2ZW50IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBTZWxlY3QucHJvdG90eXBlLl9zcGxpY2UgPSBmdW5jdGlvbiAoY2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBjaGFuZ2VzWzBdLCBhZGRDb3VudCA9IGNoYW5nZS5hZGRlZENvdW50LCByZW1vdmVDb3VudCA9IGNoYW5nZS5yZW1vdmVkLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkQ291bnQgPiByZW1vdmVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJdGVtcyhhZGRDb3VudCAtIHJlbW92ZUNvdW50LCBjaGFuZ2Uub2JqZWN0Lmxlbmd0aCAtIGFkZENvdW50IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlbW92ZUNvdW50ID4gYWRkQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVJdGVtcyhyZW1vdmVDb3VudCAtIGFkZENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBhcnJheSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgKiBpcyBzb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fc29ydCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYXJyYXkgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICogaXMgcmV2ZXJzZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5fcmV2ZXJzZSA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNldFNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBTZWxlY3QuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBTZWxlY3Q7XHJcbiAgICAgICAgICAgIH0oQmluZENvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5TZWxlY3QgPSBTZWxlY3Q7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19TZWxlY3QsIFNlbGVjdCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIFRlbXBsYXRlQ29udHJvbCBjb25kaXRpb25hbGx5IGFkZGluZyBvciByZW1vdmluZ1xyXG4gICAgICAgICAgICAgKiBhIGJsb2NrIG9mIG5vZGVzIHRvIG9yIGZyb20gdGhlIERPTS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBJZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICBfX2V4dGVuZHMoSWYsIF9zdXBlcik7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBJZi4gQ3JlYXRlcyB0aGUgY29tbWVudCBub2RlIGFuZCBkb2N1bWVudCBmcmFnbWVudCBzdG9yYWdlXHJcbiAgICAgICAgICAgICAgICAgKiB1c2VkIGJ5IHRoaXMgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gSWYoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgZXZhbHVhdGVkIGNvbmRpdGlvbiAod2hldGhlciBvciBub3QgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICogY29udHJvbCBpcyB2aXNpYmxlKSBvZiB0aGUgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fY29uZGl0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBBIGJvb2xlYW4gdmFsdWUgc3RhdGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgY29uZGl0aW9uIGhhcyBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgICogYmVlbiBldmFsdWF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2ZpcnN0VGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWVudE5vZGUgPSBfZG9jdW1lbnQuY3JlYXRlQ29tbWVudChfX0lmICsgX19CT1VORF9QUkVGSVggKyAncGxhY2Vob2xkZXInKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50U3RvcmUgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3MgdGhlIG9wdGlvbnMgYW5kIGluaXRpYWxpemVzIHRoZVxyXG4gICAgICAgICAgICAgICAgICogZXZhbHVhdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldHRlcihvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENyZWF0ZXMgYSBiaW5kYWJsZSB0ZW1wbGF0ZSB3aXRoIHRoZSBjb250cm9sIGVsZW1lbnQncyBjaGlsZE5vZGVzIChpbm5lckhUTUwpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJZi5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5hZGQoJ3RlbXBsYXRlJywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbGVtZW50LmNoaWxkTm9kZXMpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNldHMgdGhlIHZpc2liaWxpdHkgdG8gdHJ1ZSBpZiBubyBvcHRpb25zIGFyZVxyXG4gICAgICAgICAgICAgICAgICogZGVmaW5lZCwga2lja3Mgb2ZmIHRoZSBldmFsdWF0aW9uLCBhbmQgb2JzZXJ2ZXNcclxuICAgICAgICAgICAgICAgICAqIHRoZSBvcHRpb25zIGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJZi5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5vcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignTm8gY29uZGl0aW9uIHNwZWNpZmllZCBpbiAnICsgX19PcHRpb25zICsgJyBmb3IgJyArIHRoaXMudHlwZSArICcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZTogbm9vcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuY29udGV4dENoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLm9wdGlvbnMub2JzZXJ2ZSh0aGlzLl9zZXR0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3RvcHMgbGlzdGVuaW5nIHRvIHRoZSBvcHRpb25zIGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBJZi5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9fcmVtb3ZlTGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1lbnROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50U3RvcmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIHRoZSBjb25kaXRpb24gYW5kIGRlY2lkZXNcclxuICAgICAgICAgICAgICAgICAqIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBvciByZW1vdmVcclxuICAgICAgICAgICAgICAgICAqIHRoZSBub2RlIGZyb20gdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLl9zZXR0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gISFvcHRpb25zLmNvbmRpdGlvbiwgcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuX19jb25kaXRpb24gJiYgIXRoaXMuX19maXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRoaXMuX19sZWF2ZUFuaW1hdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9fbGVhdmVBbmltYXRpb24uY2FuY2VsKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19sZWF2ZUFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hZGRJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9hZGRJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRoaXMuX19lbnRlckFuaW1hdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9fZW50ZXJBbmltYXRpb24uY2FuY2VsKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19lbnRlckFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yZW1vdmVJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUl0ZW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLl9Qcm9taXNlLnJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbmRpdGlvbiA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyB0aGUgY29uZGl0aW9uYWwgbm9kZXMgdG8gdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLl9hZGRJdGVtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUodGhpcy5jb21tZW50Tm9kZS5wYXJlbnROb2RlKSAmJiAhdGhpcy5fX2ZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19pbml0aWFsQmluZCA9IHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYmluZCgndGVtcGxhdGUnKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19pbml0aWFsQmluZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlID09PSBfdGhpcy5mcmFnbWVudFN0b3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGVtcGxhdGUsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYW5pbWF0ZUVudHJhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2VudGVyQW5pbWF0aW9uID0gX3RoaXMuX2FuaW1hdG9yLmFuaW1hdGUoZWxlbWVudCwgX19FbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZSh0ZW1wbGF0ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX19lbnRlckFuaW1hdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fX2VudGVyQW5pbWF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9faW5pdGlhbEJpbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UodGhpcy5fX2luaXRpYWxCaW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2luaXRpYWxCaW5kLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hbmltYXRlRW50cmFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlRW50cmFuY2UoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHRoZSB0ZW1wbGF0ZSBhcyBpdCBlbnRlcnMgdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLl9hbmltYXRlRW50cmFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWVudE5vZGUgPSB0aGlzLmNvbW1lbnROb2RlLCBwYXJlbnROb2RlID0gY29tbWVudE5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShwYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0b3IucmVzb2x2ZSgpLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZW50ZXJBbmltYXRpb24gPSB0aGlzLl9hbmltYXRvci5lbnRlcih0aGlzLmVsZW1lbnQsIF9fRW50ZXIsIHBhcmVudE5vZGUsIGNvbW1lbnROb2RlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19lbnRlckFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIHRoZSBjb25kaXRpb25hbCBub2RlcyBmcm9tIHRoZSBET00uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIElmLnByb3RvdHlwZS5fcmVtb3ZlSXRlbSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2UodGhpcy5fX2luaXRpYWxCaW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2luaXRpYWxCaW5kLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9hbmltYXRlTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRlTGVhdmUoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuaW1hdGVzIHRoZSB0ZW1wbGF0ZSBhcyBpdCBsZWF2ZXMgdGhlIERPTS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgSWYucHJvdG90eXBlLl9hbmltYXRlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50LCBuZXh0U2libGluZyA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0b3IucmVzb2x2ZSgpLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbGVhdmVBbmltYXRpb24gPSB0aGlzLl9hbmltYXRvci5sZWF2ZShlbGVtZW50LCBfX0xlYXZlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19sZWF2ZUFuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoX3RoaXMuY29tbWVudE5vZGUsIG5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZnJhZ21lbnRTdG9yZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgSWYuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBfYW5pbWF0b3I6IF9fQW5pbWF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSWY7XHJcbiAgICAgICAgICAgIH0oVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICAgICAgICAgIGNvbnRyb2xzXzEuSWYgPSBJZjtcclxuICAgICAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0lmLCBJZik7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIFRlbXBsYXRlQ29udHJvbCBmb3IgYWRkaW5nIGFkZGl0b25hbFxyXG4gICAgICAgICAgICAgKiBmdW5jdGlvbmFsaXR5IHRvIGEgbmF0aXZlIEhUTUwgYW5jaG9yIHRhZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHZhciBMaW5rID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgICAgIF9fZXh0ZW5kcyhMaW5rLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gTGluaygpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBSZXBsYWNlcyB0aGUgTGluaydzIGVsZW1lbnQgd2l0aCBhIG5hdGl2ZSBhbmNob3IgdGFnLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVdpdGggPSAnYSc7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHJvdXRlciBhc3NvY2lhdGVkIHdpdGggdGhpcyBsaW5rLlxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuX1JvdXRlci5jdXJyZW50Um91dGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGNsaWNrIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBMaW5rLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNsaWNrTGlzdGVuZXIgPSB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgJ2NsaWNrJywgdGhpcy5faGFuZGxlQ2xpY2ssIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENhbGxzIHRvIG5vcm1hbGl6ZSB0aGUgaHJlZiBmb3IgaW50ZXJuYWwgbGlua3MgYW5kIGluaXRpYWxpemVzIHRoZSB0YXAgZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExpbmsucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucywgc2V0SHJlZiA9IHRoaXMuc2V0SHJlZi5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ05vIG9wdGlvbnMgc3BlY2lmaWVkIGZvciAnICsgdGhpcy50eXBlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuIFBsZWFzZSBzZW5kIGluIG9wdGlvbnMgb2YgdHlwZSBwbGF0LnVpLmNvbnRyb2xzLklMaW5rT3B0aW9ucy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnZhbHVlID0geyB2aWV3OiAnJyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhyZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNPYmplY3Qob3B0aW9ucy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy52YWx1ZSA9IHsgdmlldzogJycgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgX190YXAsIHRoaXMuX2hhbmRsZVRhcCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEhyZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9ic2VydmUoc2V0SHJlZik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBlbGVtZW50IGhyZWYgdG8gdGhlIG9uZSBmb3JtZWQgdXNpbmcgdGhlIGFzc29jaWF0ZWQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTGluay5wcm90b3R5cGUuc2V0SHJlZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IHRoaXMuZ2V0SHJlZigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eShocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5ocmVmID0gaHJlZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBocmVmIGJhc2VkIG9uIHRoZSBpbnB1dCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBMaW5rLnByb3RvdHlwZS5nZXRIcmVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5fcm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZSwgaHJlZiA9IHZhbHVlLnZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmlzVXJsICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbWV0ZXJzID0gdmFsdWUucGFyYW1ldGVycywgcXVlcnkgPSB2YWx1ZS5xdWVyeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoaHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBocmVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWYgPSB0aGlzLl9yb3V0ZXIuZ2VuZXJhdGUoaHJlZiwgcGFyYW1ldGVycywgcXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnJvd3Nlci5mb3JtYXRVcmwoaHJlZik7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIFdoZXRoZXIgb3Igbm90IHRoZSBkZWZhdWx0IGNsaWNrIGJlaGF2aW9yIHNob3VsZCBiZSBwcmV2ZW50ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExpbmsucHJvdG90eXBlLl9oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBidXR0b25zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihldi5idXR0b25zKSAmJiBldi5idXR0b25zICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSBldi5idXR0b25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bWJlcihldi53aGljaCkgJiYgZXYud2hpY2ggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSBldi53aGljaDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZXYuYnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIC0xOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSAxNjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9ucyA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbnMgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHRoZSBwcm9wZXIgbGluayB1cG9uICR0YXAuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIExpbmsucHJvdG90eXBlLl9oYW5kbGVUYXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5idXR0b25zICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhyZWYgPSB0aGlzLmdldEhyZWYoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoaHJlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9icm93c2VyLnVybChocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENhbGxzIHRvIHJlbW92ZSB0aGUgY2xpY2sgZWF0ZXIgYWZ0ZXIgYSBkZWxheS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgTGluay5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcih0aGlzLl9yZW1vdmVDbGlja0xpc3RlbmVyLCAzMDAwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBMaW5rLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX1JvdXRlcjogX19Sb3V0ZXJTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICAgICAgX0luamVjdG9yOiBfX0luamVjdG9yU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgICAgIF9icm93c2VyOiBfX0Jyb3dzZXJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTGluaztcclxuICAgICAgICAgICAgfShUZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgICAgICAgICAgY29udHJvbHNfMS5MaW5rID0gTGluaztcclxuICAgICAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0xpbmssIExpbmspO1xyXG4gICAgICAgIH0pKGNvbnRyb2xzID0gdWkuY29udHJvbHMgfHwgKHVpLmNvbnRyb2xzID0ge30pKTtcclxuICAgIH0pKHVpID0gcGxhdF8xLnVpIHx8IChwbGF0XzEudWkgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIHJlbGF0ZWQgdG8gRG9jdW1lbnQgcHJvY2Vzc2luZyBpbiBwbGF0eXB1cy5cclxuICAgICAqL1xyXG4gICAgdmFyIHByb2Nlc3Npbmc7XHJcbiAgICAoZnVuY3Rpb24gKHByb2Nlc3NpbmcpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNwb25zaWJsZSBmb3IgaXRlcmF0aW5nIHRocm91Z2ggdGhlIERPTSBhbmQgY29sbGVjdGluZyBjb250cm9scy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ29tcGlsZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDb21waWxlcigpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDb21waWxlci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChub2RlLCBjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGUuY2hpbGROb2RlcywgbGVuZ3RoLCBuZXdMZW5ndGgsIGNoaWxkTm9kZSwgaGFzQ29udHJvbCA9ICFpc051bGwoY29udHJvbCksIG1hbmFnZXIgPSAoaGFzQ29udHJvbCA/IHRoaXMuX21hbmFnZXJDYWNoZS5yZWFkKGNvbnRyb2wudWlkKSA6IG51bGwpLCBjcmVhdGUgPSB0aGlzLl9FbGVtZW50TWFuYWdlckZhY3RvcnkuY3JlYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjaGlsZE5vZGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24obm9kZS5wdXNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChtYW5hZ2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNyZWF0ZShjaGlsZE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZShjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IG5ld0xlbmd0aCAtIGxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbmV3TGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBpbGVOb2RlcyhjaGlsZE5vZGVzLCBtYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGFycmF5IG9mIG5vZGVzIGNyZWF0aW5nIEVsZW1lbnRNYW5hZ2VycyBvbiBFbGVtZW50XHJcbiAgICAgICAgICAgICAqIG5vZGVzLCBUZXh0TWFuYWdlcnMgb24gdGV4dCBub2RlcywgYW5kXHJcbiAgICAgICAgICAgICAqIENvbW1lbnRNYW5hZ2VycyBvbiBjb21tZW50IG5vZGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2RlcyBUaGUgYXJyYXkgb2Ygbm9kZXMgdG8gYmUgY29tcGlsZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBtYW5hZ2VyIFRoZSBwYXJlbnQgRWxlbWVudE1hbmFnZXJzXHJcbiAgICAgICAgICAgICAqIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVzIFRoZSBOb2RlTGlzdCB0byBiZSBjb21waWxlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIG1hbmFnZXIgVGhlIHBhcmVudCBFbGVtZW50IE1hbmFnZXIgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBub2Rlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENvbXBpbGVyLnByb3RvdHlwZS5fY29tcGlsZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBtYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbm9kZXMubGVuZ3RoLCBub2RlLCBuZXdNYW5hZ2VyLCBuZXdMZW5ndGgsIGNyZWF0ZSA9IHRoaXMuX0VsZW1lbnRNYW5hZ2VyRmFjdG9yeS5jcmVhdGUsIGNvbW1lbnRDcmVhdGUgPSB0aGlzLl9Db21tZW50TWFuYWdlckZhY3RvcnkuY3JlYXRlLCB0ZXh0Q3JlYXRlID0gdGhpcy5fVGV4dE1hbmFnZXJGYWN0b3J5LmNyZWF0ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdNYW5hZ2VyID0gY3JlYXRlKG5vZGUsIG1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwobmV3TWFuYWdlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21waWxlTm9kZXMoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzKSwgbmV3TWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLlRFWFRfTk9ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRDcmVhdGUobm9kZSwgbWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLkNPTU1FTlRfTk9ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnRDcmVhdGUobm9kZSwgbWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gbmV3TGVuZ3RoIC0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IG5ld0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQ29tcGlsZXIuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9FbGVtZW50TWFuYWdlckZhY3Rvcnk6IF9fRWxlbWVudE1hbmFnZXJGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX1RleHRNYW5hZ2VyRmFjdG9yeTogX19UZXh0TWFuYWdlckZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICBfQ29tbWVudE1hbmFnZXJGYWN0b3J5OiBfX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeSxcclxuICAgICAgICAgICAgICAgIF9tYW5hZ2VyQ2FjaGU6IF9fTWFuYWdlckNhY2hlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBDb21waWxlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHByb2Nlc3NpbmcuQ29tcGlsZXIgPSBDb21waWxlcjtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ29tcGlsZXIsIENvbXBpbGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXNwb25zaWJsZSBmb3IgZGF0YSBiaW5kaW5nIGEgZGF0YSBjb250ZXh0IHRvIGEgTm9kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgTm9kZU1hbmFnZXIgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBOb2RlTWFuYWdlcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyBOb2RlTWFuYWdlciBpcyBhIGNsb25lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzQ2xvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHN0cmluZyBoYXMgdGhlIG1hcmt1cCBub3RhdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgc3RyaW5nIGluIHdoaWNoIHRvIHNlYXJjaCBmb3IgbWFya3VwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuaGFzTWFya3VwID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBOb2RlTWFuYWdlci5fbWFya3VwUmVnZXgudGVzdCh0ZXh0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdpdmVuIGEgc3RyaW5nLCBmaW5kcyBtYXJrdXAgaW4gdGhlIHN0cmluZyBhbmQgY3JlYXRlcyBhbiBhcnJheSBvZlxyXG4gICAgICAgICAgICAgKiBJUGFyc2VkRXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgc3RyaW5nIGluIHdoaWNoIHRvIHNlYXJjaCBmb3IgbWFya3VwLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuZmluZE1hcmt1cCA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQsIGVuZCwgcGFyc2VkRXhwcmVzc2lvbnMgPSBbXSwgd3JhcEV4cHJlc3Npb24gPSBOb2RlTWFuYWdlci5fd3JhcEV4cHJlc3Npb24sIHN1YnN0cmluZywgZXhwcmVzc2lvbiwgX3BhcnNlciA9IE5vZGVNYW5hZ2VyLl9wYXJzZXI7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKE5vZGVNYW5hZ2VyLl9uZXdMaW5lUmVnZXgsICcnKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoc3RhcnQgPSB0ZXh0LmluZGV4T2YoX19zdGFydFN5bWJvbCkpICE9PSAtMSAmJiAoZW5kID0gdGV4dC5pbmRleE9mKF9fZW5kU3ltYm9sKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEV4cHJlc3Npb25zLnB1c2god3JhcEV4cHJlc3Npb24odGV4dC5zbGljZSgwLCBzdGFydCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVtZW1lbnQgd2l0aCB3aGlsZSBsb29wIGluc3RlYWQgb2YganVzdCArPSAyIGZvciBuZXN0ZWQgb2JqZWN0IGxpdGVyYWwgY2FzZS4gXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRleHRbKytlbmRdID09PSAnfScpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnN0cmluZyA9IHRleHQuc2xpY2Uoc3RhcnQgKyAyLCBlbmQgLSAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igb25lLXRpbWUgZGF0YWJpbmRpbmcgXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnN0cmluZ1swXSA9PT0gJz0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBfcGFyc2VyLnBhcnNlKHN1YnN0cmluZy5zbGljZSgxKS50cmltKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLm9uZVRpbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRFeHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkRXhwcmVzc2lvbnMucHVzaChfcGFyc2VyLnBhcnNlKHN1YnN0cmluZy50cmltKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoZW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCA+IC0xICYmIGVuZCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRXhwcmVzc2lvbnMucHVzaCh3cmFwRXhwcmVzc2lvbih0ZXh0LnNsaWNlKGVuZCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkRXhwcmVzc2lvbnMucHVzaCh3cmFwRXhwcmVzc2lvbih0ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkRXhwcmVzc2lvbnM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUYWtlcyBpbiBhIGNvbnRyb2wgd2l0aCBhIGRhdGEgY29udGV4dCBhbmQgYW4gYXJyYXkgb2YgSVBhcnNlZEV4cHJlc3Npb25cclxuICAgICAgICAgICAgICogYW5kIG91dHB1dHMgYSBzdHJpbmcgb2YgdGhlIGV2YWx1YXRlZCBleHByZXNzaW9ucy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LmV4cHJlc3Npb25zLklQYXJzZWRFeHByZXNzaW9uPn0gZXhwcmVzc2lvbnMgVGhlIGNvbXBvc2l0aW9uIGFycmF5IHRvIGV2YWx1YXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sPyBUaGUgVGVtcGxhdGVDb250cm9sIHVzZWQgdG8gcGFyc2VcclxuICAgICAgICAgICAgICogdGhlIGV4cHJlc3Npb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuYnVpbGQgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbnMsIGNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gJycsIGxlbmd0aCA9IGV4cHJlc3Npb25zLmxlbmd0aCwgcmVzb3VyY2VzID0ge30sIGV4cHJlc3Npb24sIHZhbHVlLCBldmFsdWF0ZUV4cHJlc3Npb24gPSBOb2RlTWFuYWdlci5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5ldmFsdWF0ZUV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIGNvbnRyb2wsIHJlc291cmNlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGUuZGVzY3JpcHRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5kZXNjcmlwdGlvbiA9ICdDYW5ub3Qgc3RyaW5naWZ5IG9iamVjdDogJyArIGUuZGVzY3JpcHRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLm1lc3NhZ2UgPSAnQ2Fubm90IHN0cmluZ2lmeSBvYmplY3Q6ICcgKyBlLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb2RlTWFuYWdlci5fbG9nLndhcm4oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mIGEgY2hhbmdlIGluIGFueSBhc3NvY2lhdGVkIGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5leHByZXNzaW9ucy5JUGFyc2VkRXhwcmVzc2lvbj59IGV4cHJlc3Npb25zIEFuIEFycmF5IG9mXHJcbiAgICAgICAgICAgICAqIElQYXJzZWRFeHByZXNzaW9ucyB0byBvYnNlcnZlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBUZW1wbGF0ZUNvbnRyb2wgYXNzb2NpYXRlZFxyXG4gICAgICAgICAgICAgKiB0byB0aGUgaWRlbnRpZmllcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KC4uLmFyZ3M6IEFycmF5PGFueT4pID0+IHZvaWR9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsIHdoZW4gYW55IGlkZW50aWZpZXIgcHJvcGVydHkgY2hhbmdlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLm9ic2VydmVFeHByZXNzaW9ucyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucywgY29udHJvbCwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1bmlxdWVJZGVudGlmaWVycyA9IE5vZGVNYW5hZ2VyLl9fZmluZFVuaXF1ZUlkZW50aWZpZXJzKGV4cHJlc3Npb25zKSwgaWRlbnRpZmllcnMgPSB1bmlxdWVJZGVudGlmaWVycy5pZGVudGlmaWVycywgb25lVGltZUlkZW50aWZpZXJzID0gdW5pcXVlSWRlbnRpZmllcnMub25lVGltZUlkZW50aWZpZXJzLCBvbmVUaW1lSWRlbnRpZmllciwgb2JzZXJ2YWJsZUNhbGxiYWNrID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcclxuICAgICAgICAgICAgICAgICAgICB1aWQ6IGNvbnRyb2wudWlkXHJcbiAgICAgICAgICAgICAgICB9LCBvYnNlcnZhdGlvbkRldGFpbHMsIG1hbmFnZXIsIGFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpZGVudGlmaWVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YXRpb25EZXRhaWxzID0gTm9kZU1hbmFnZXIuX19nZXRPYnNlcnZhdGlvbkRldGFpbHMoaWRlbnRpZmllcnMucG9wKCksIGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBvYnNlcnZhdGlvbkRldGFpbHMubWFuYWdlcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChtYW5hZ2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLm9ic2VydmUob2JzZXJ2YXRpb25EZXRhaWxzLmFic29sdXRlSWRlbnRpZmllciwgb2JzZXJ2YWJsZUNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAob25lVGltZUlkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmVUaW1lSWRlbnRpZmllciA9IG9uZVRpbWVJZGVudGlmaWVycy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhdGlvbkRldGFpbHMgPSBOb2RlTWFuYWdlci5fX2dldE9ic2VydmF0aW9uRGV0YWlscyhvbmVUaW1lSWRlbnRpZmllciwgY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlciA9IG9ic2VydmF0aW9uRGV0YWlscy5tYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlzTnVsbChtYW5hZ2VyKSB8fCBvYnNlcnZhdGlvbkRldGFpbHMuaXNEZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUlkZW50aWZpZXIgPSBvYnNlcnZhdGlvbkRldGFpbHMuYWJzb2x1dGVJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcE9ic2VydmluZyA9IG1hbmFnZXIub2JzZXJ2ZShhYnNvbHV0ZUlkZW50aWZpZXIsIG9ic2VydmFibGVDYWxsYmFjayksIHN0b3BMaXN0ZW5pbmcgPSBtYW5hZ2VyLm9ic2VydmUoYWJzb2x1dGVJZGVudGlmaWVyLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IGNvbnRyb2wudWlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wT2JzZXJ2aW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcExpc3RlbmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXcmFwcyBjb25zdGFudCB0ZXh0IGFzIGEgc3RhdGljIElQYXJzZWRFeHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byB3cmFwIGludG8gYSBzdGF0aWMgZXhwcmVzc2lvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl93cmFwRXhwcmVzc2lvbiA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXh0OyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB0ZXh0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2l2ZW4gYW4gSVBhcnNlZEV4cHJlc3Npb24gYXJyYXksIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIGlkZW50aWZlcnNcclxuICAgICAgICAgICAgICogdG8gdXNlIHdpdGggYmluZGluZy4gVGhpcyBhbGxvd3MgdXMgdG8gYXZvaWQgY3JlYXRpbmcgbXVsdGlwbGUgbGlzdGVuZXJzIGZvciB0aGUgaWRlbnRpZmllciBhbmQgbm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LmV4cHJlc3Npb25zLklQYXJzZWRFeHByZXNzaW9uPn0gZXhwcmVzc2lvbnMgQW4gYXJyYXkgb2YgcGFyc2VkIGV4cHJlc3Npb25zIHRvIHNlYXJjaCBmb3IgaWRlbnRpZmllcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5fX2ZpbmRVbmlxdWVJZGVudGlmaWVycyA9IGZ1bmN0aW9uIChleHByZXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGV4cHJlc3Npb25zLmxlbmd0aCwgZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24ub25lVGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZUlkZW50aWZpZXJzOiBleHByZXNzaW9uLmlkZW50aWZpZXJzLnNsaWNlKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzOiBleHByZXNzaW9uLmlkZW50aWZpZXJzLnNsaWNlKDApLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmVUaW1lSWRlbnRpZmllcnM6IFtdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB1bmlxdWVJZGVudGlmaWVyT2JqZWN0ID0ge30sIG9uZVRpbWVJZGVudGlmaWVyT2JqZWN0ID0ge30sIHVuaXF1ZUlkZW50aWZpZXJzID0gW10sIG9uZVRpbWVJZGVudGlmaWVycyA9IFtdLCBpZGVudGlmaWVycywgaWRlbnRpZmllciwgaiwgakxlbmd0aCwgb25lVGltZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgb25lVGltZSA9IGV4cHJlc3Npb24ub25lVGltZTtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVycyA9IGV4cHJlc3Npb24uaWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgakxlbmd0aCA9IGlkZW50aWZpZXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBpZGVudGlmaWVyc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZVRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmlxdWVJZGVudGlmaWVyT2JqZWN0W2lkZW50aWZpZXJdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9uZVRpbWVJZGVudGlmaWVyT2JqZWN0W2lkZW50aWZpZXJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZUlkZW50aWZpZXJPYmplY3RbaWRlbnRpZmllcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVJZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVJZGVudGlmaWVyT2JqZWN0W2lkZW50aWZpZXJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlSWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbmVUaW1lSWRlbnRpZmllck9iamVjdFtpZGVudGlmaWVyXSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZVRpbWVJZGVudGlmaWVyT2JqZWN0W2lkZW50aWZpZXJdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZUlkZW50aWZpZXJzLnNwbGljZShvbmVUaW1lSWRlbnRpZmllcnMuaW5kZXhPZihpZGVudGlmaWVyKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzOiB1bmlxdWVJZGVudGlmaWVycyxcclxuICAgICAgICAgICAgICAgICAgICBvbmVUaW1lSWRlbnRpZmllcnM6IG9uZVRpbWVJZGVudGlmaWVyc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRha2VzIGluIGFuIGlkZW50aWZpZXIgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYm90aCBpdHMgY29udmVydGVkIGFic29sdXRlIHBhdGggYW5kIHRoZVxyXG4gICAgICAgICAgICAgKiBDb250ZXh0TWFuYWdlciBuZWVkZWQgdG8gb2JzZXJ2ZSBpdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgbG9va2luZyB0byBiZSBvYnNlcnZlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgVGVtcGxhdGVDb250cm9sIGFzc29jaWF0ZWRcclxuICAgICAgICAgICAgICogdG8gdGhlIGlkZW50aWZpZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuX19nZXRPYnNlcnZhdGlvbkRldGFpbHMgPSBmdW5jdGlvbiAoaWRlbnRpZmllciwgY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9Db250ZXh0TWFuYWdlciA9IE5vZGVNYW5hZ2VyLl9Db250ZXh0TWFuYWdlciwgbWFuYWdlciwgc3BsaXQgPSBpZGVudGlmaWVyLnNwbGl0KCcuJyksIGFic29sdXRlSWRlbnRpZmllciA9ICcnLCBpc0RlZmluZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVyWzBdID09PSAnQCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBmb3VuZCBhbiBhbGlhcyBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VPYmogPSB2b2lkIDAsIHJlc291cmNlcyA9IHt9LCB0b3BJZGVudGlmaWVyID0gc3BsaXQuc2hpZnQoKSwgYWxpYXMgPSB0b3BJZGVudGlmaWVyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9ICcuJyArIHNwbGl0LmpvaW4oJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VPYmogPSByZXNvdXJjZXNbYWxpYXNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwocmVzb3VyY2VPYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlT2JqID0gcmVzb3VyY2VzW2FsaWFzXSA9IGNvbnRyb2wuZmluZFJlc291cmNlKGFsaWFzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwocmVzb3VyY2VPYmopICYmICFpc051bGwocmVzb3VyY2VPYmoucmVzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gcmVzb3VyY2VPYmoucmVzb3VyY2UudHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsaWFzID09PSBfX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlcihDb250cm9sLmdldFJvb3RDb250cm9sKGNvbnRyb2wpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCArIGFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGlhcyA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlcihyZXNvdXJjZXNbYWxpYXNdLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gJ2NvbnRleHQnICsgYWJzb2x1dGVJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IF9fT0JTRVJWQUJMRV9SRVNPVVJDRSB8fCB0eXBlID09PSBfX0xJVEVSQUxfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmFnZXIgPSBfQ29udGV4dE1hbmFnZXIuZ2V0TWFuYWdlcihyZXNvdXJjZXNbYWxpYXNdLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVJZGVudGlmaWVyID0gJ3Jlc291cmNlcy4nICsgYWxpYXMgKyAnLnZhbHVlJyArIGFic29sdXRlSWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb2sgb24gdGhlIGNvbnRyb2wuY29udGV4dCBcclxuICAgICAgICAgICAgICAgICAgICBpc0RlZmluZWQgPSAhaXNVbmRlZmluZWQoX0NvbnRleHRNYW5hZ2VyLmdldENvbnRleHQoY29udHJvbC5jb250ZXh0LCBzcGxpdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZmluZWQgfHwgaXNVbmRlZmluZWQoX0NvbnRleHRNYW5hZ2VyLmdldENvbnRleHQoY29udHJvbCwgc3BsaXQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIoQ29udHJvbC5nZXRSb290Q29udHJvbChjb250cm9sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllciA9IGNvbnRyb2wuYWJzb2x1dGVDb250ZXh0UGF0aCArICcuJyArIGlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFic29sdXRlSWRlbnRpZmllcjogYWJzb2x1dGVJZGVudGlmaWVyLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXI6IG1hbmFnZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNEZWZpbmVkOiBpc0RlZmluZWRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGUgbWFuYWdlcidzIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBub2RlTWFwIFRoZSBtYXBwaW5nIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hbmFnZXIuIFdlIGhhdmUgdG8gdXNlIGFuXHJcbiAgICAgICAgICAgICAqIFVzZWQgdG8gdHJlYXQgYWxsIE5vZGVNYW5hZ2VycyB0aGUgc2FtZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudCBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobm9kZU1hcCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVNYXAgPSBub2RlTWFwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Nsb25lID0gcGFyZW50LmlzQ2xvbmU7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIHBhcmVudCBjb250cm9sIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGFyZW50IG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOb2RlTWFuYWdlci5wcm90b3R5cGUuZ2V0UGFyZW50Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCwgY29udHJvbDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBwYXJlbnQuZ2V0VWlDb250cm9sKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIHRoaXMgTm9kZU1hbmFnZXIgd2l0aCB0aGUgbmV3IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZSBUaGUgbmV3IG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBuZXcgbWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudE1hbmFnZXIgVGhlIHBhcmVudFxyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlciBmb3IgdGhlIGNsb25lLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKG5ld05vZGUsIHBhcmVudE1hbmFnZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIHVzZWQgZm9yIGRhdGEtYmluZGluZyBhIGRhdGEgY29udGV4dCB0byB0aGUgRE9NLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgIHJldHVybiBOb2RlTWFuYWdlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHByb2Nlc3NpbmcuTm9kZU1hbmFnZXIgPSBOb2RlTWFuYWdlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJTm9kZU1hbmFnZXJTdGF0aWMoX3JlZ2V4LCBfQ29udGV4dE1hbmFnZXIsIF9wYXJzZXIsIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LCBfbG9nKSB7XHJcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgbm90IGFkdmlzZWQgYnkgVHlwZVNjcmlwdCwgYnV0IHdlIHdhbnQgdG8gZG8gdGhpcy4gXHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9tYXJrdXBSZWdleCA9IF9yZWdleC5tYXJrdXBSZWdleDtcclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuX25ld0xpbmVSZWdleCA9IF9yZWdleC5uZXdMaW5lUmVnZXg7XHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9Db250ZXh0TWFuYWdlciA9IF9Db250ZXh0TWFuYWdlcjtcclxuICAgICAgICAgICAgTm9kZU1hbmFnZXIuX3BhcnNlciA9IF9wYXJzZXI7XHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gX1RlbXBsYXRlQ29udHJvbEZhY3Rvcnk7XHJcbiAgICAgICAgICAgIE5vZGVNYW5hZ2VyLl9sb2cgPSBfbG9nO1xyXG4gICAgICAgICAgICByZXR1cm4gTm9kZU1hbmFnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2Nlc3NpbmcuSU5vZGVNYW5hZ2VyU3RhdGljID0gSU5vZGVNYW5hZ2VyU3RhdGljO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Ob2RlTWFuYWdlclN0YXRpYywgSU5vZGVNYW5hZ2VyU3RhdGljLCBbXHJcbiAgICAgICAgICAgIF9fUmVnZXgsXHJcbiAgICAgICAgICAgIF9fQ29udGV4dE1hbmFnZXJTdGF0aWMsXHJcbiAgICAgICAgICAgIF9fUGFyc2VyLFxyXG4gICAgICAgICAgICBfX1RlbXBsYXRlQ29udHJvbEZhY3RvcnksXHJcbiAgICAgICAgICAgIF9fTG9nXHJcbiAgICAgICAgXSwgX19TVEFUSUMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgdXNlZCB0byBtYW5hZ2UgZWxlbWVudCBub2Rlcy4gUHJvdmlkZXMgYSB3YXkgZm9yIGNvbXBpbGluZyBhbmQgYmluZGluZyB0aGVcclxuICAgICAgICAgKiBlbGVtZW50L3RlbXBsYXRlLiBBbHNvIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGNsb25pbmcgYW5cclxuICAgICAgICAgKiBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRWxlbWVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoRWxlbWVudE1hbmFnZXIsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRNYW5hZ2VyKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjaGlsZCBtYW5hZ2VycyBmb3IgdGhpcyBtYW5hZ2VyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpZmllcyB0aGUgdHlwZSBmb3IgdGhpcyBOb2RlTWFuYWdlci5cclxuICAgICAgICAgICAgICAgICAqIEl0J3MgdmFsdWUgaXMgXCJlbGVtZW50XCIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdlbGVtZW50JztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgbWFuYWdlciBoYXMgYSBUZW1wbGF0ZUNvbnRyb2wgd2hpY2ggaGFzIGFcclxuICAgICAgICAgICAgICAgICAqIHJlcGxhY2VXaXRoIHByb3BlcnR5IHNldCB0byBudWxsIG9yIGVtcHR5IHN0cmluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBUZW1wbGF0ZUNvbnRyb2wgZm9yIHRoaXMgbWFuYWdlciBoYXMgaXRzIG93biBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgKiBvciBpbmhlcml0cyBpdCBmcm9tIGEgcGFyZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc093bkNvbnRleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgYXNzb2NpYXRlZCBFbGVtZW50IGhhcyBjb250cm9scyB0aGF0IG5lZWQgdG8gYmUgaW5zdGFudGlhdGVkIG9yIEF0dHIgbm9kZXNcclxuICAgICAgICAgICAgICogY29udGFpbmluZyB0ZXh0IG1hcmt1cC4gSWYgY29udHJvbHMgZXhpc3Qgb3IgbWFya3VwIGlzIGZvdW5kIGEgbmV3XHJcbiAgICAgICAgICAgICAqIEVsZW1lbnRNYW5hZ2VyIHdpbGwgYmUgY3JlYXRlZCxcclxuICAgICAgICAgICAgICogZWxzZSBhbiBlbXB0eSBOb2RlTWFuYWdlciB3aWxsIGJlIGFkZGVkIHRvIHRoZSBBcnJheSBvZlxyXG4gICAgICAgICAgICAgKiBOb2RlTWFuYWdlcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgRWxlbWVudCB0byB1c2UgdG8gaWRlbnRpZmllciBtYXJrdXAgYW5kIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gcGFyZW50PyBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIHVzZWQgZm9yIGNvbnRleHQgaW5oZXJpdGFuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5jcmVhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgbm9kZU5hbWUgPSBuYW1lLCBpbmplY3RvciA9IGNvbnRyb2xJbmplY3RvcnNbbmFtZV0gfHwgdmlld0NvbnRyb2xJbmplY3RvcnNbbmFtZV0sIG5vQ29udHJvbEF0dHJpYnV0ZSA9IHRydWUsIGhhc1VpQ29udHJvbCA9IGZhbHNlLCB1aUNvbnRyb2xOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoX19Db250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoX19Db250cm9sKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IGNvbnRyb2xJbmplY3RvcnNbbmFtZV0gfHwgdmlld0NvbnRyb2xJbmplY3RvcnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQ29udHJvbEF0dHJpYnV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShfX0F0dHJpYnV0ZVByZWZpeCArIF9fQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKF9fQXR0cmlidXRlUHJlZml4ICsgX19Db250cm9sKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IGNvbnRyb2xJbmplY3RvcnNbbmFtZV0gfHwgdmlld0NvbnRyb2xJbmplY3RvcnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vQ29udHJvbEF0dHJpYnV0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1aUNvbnRyb2wgPSBpbmplY3Rvci5pbmplY3QoKSwgcmVzb3VyY2VFbGVtZW50ID0gRWxlbWVudE1hbmFnZXIubG9jYXRlUmVzb3VyY2VzKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbE5vZGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IHVpQ29udHJvbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VFbGVtZW50OiByZXNvdXJjZUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluamVjdG9yOiBpbmplY3RvclxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVWlDb250cm9sID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9Db250cm9sQXR0cmlidXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKF9fQ29udHJvbCwgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudFR5cGUgPSB1aUNvbnRyb2wucmVwbGFjZVdpdGgsIHJlcGxhY2VXaXRoRGl2ID0gcmVwbGFjZW1lbnRUeXBlID09PSAnYW55JyAmJiBub0NvbnRyb2xBdHRyaWJ1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHJlcGxhY2VtZW50VHlwZSkgJiYgKHJlcGxhY2VtZW50VHlwZSAhPT0gJ2FueScgfHwgcmVwbGFjZVdpdGhEaXYpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50VHlwZS50b0xvd2VyQ2FzZSgpICE9PSBub2RlTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZVdpdGhEaXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50VHlwZSA9ICdkaXYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IEVsZW1lbnRNYW5hZ2VyLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KHJlcGxhY2VtZW50VHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQgPSByZXBsYWNlV2l0aChlbGVtZW50LCByZXBsYWNlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE1hcCA9IEVsZW1lbnRNYW5hZ2VyLl9jb2xsZWN0QXR0cmlidXRlcyhlbGVtZW50LmF0dHJpYnV0ZXMpLCBtYW5hZ2VyID0gRWxlbWVudE1hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRNYXAuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1VpQ29udHJvbCAmJiBpc1N0cmluZyhlbGVtZW50TWFwLmNoaWxkQ29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmplY3RvciA9IGluamVjdGFibGVJbmplY3RvcnNbX19UZW1wbGF0ZUNvbnRyb2xJbnN0YW5jZV07XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzVWlDb250cm9sID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50TWFwLnVpQ29udHJvbE5vZGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IGluamVjdG9yLmluamVjdCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZUVsZW1lbnQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVOYW1lOiBfX1RlbXBsYXRlQ29udGV4dCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvcjogaW5qZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudE1hcC51aUNvbnRyb2xOb2RlID0gdWlDb250cm9sTm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShlbGVtZW50TWFwLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoZWxlbWVudE1hcC5oYXNDb250cm9sIHx8IGhhc1VpQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmJpbmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXTsgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuc2V0VWlDb250cm9sVGVtcGxhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzVWlDb250cm9sID8gbnVsbCA6IG1hbmFnZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExvb2tzIHRocm91Z2ggdGhlIE5vZGUncyBjaGlsZCBub2RlcyB0byB0cnkgYW5kIGZpbmQgYW55XHJcbiAgICAgICAgICAgICAqIGRlZmluZWQgUmVzb3VyY2VzIGluIGEgPHBsYXQtcmVzb3VyY2VzPiB0YWdzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgd2hvc2UgY2hpbGQgbm9kZXMgbWF5IGNvbnRhaW4gUmVzb3VyY2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIubG9jYXRlUmVzb3VyY2VzID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzKSwgY2hpbGROb2RlLCBub2RlTmFtZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IF9fUmVzb3VyY2VzIHx8IG5vZGVOYW1lID09PSAneC0nICsgX19SZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyBhbiBFbGVtZW50TWFuYWdlciB3aXRoIGEgbmV3IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLkVsZW1lbnRNYW5hZ2VyfSBzb3VyY2VNYW5hZ2VyIFRoZSBvcmlnaW5hbCBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudCBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIGZvciB0aGUgbmV3IGNsb25lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIG5ldyBlbGVtZW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBjbG9uZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gbmV3Q29udHJvbD8gQW4gb3B0aW9uYWwgY29udHJvbCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBub2RlTWFwPyBUaGUge0BsaW5rIHBsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gdXNlZCB0byBjbG9uZSB0aGlzXHJcbiAgICAgICAgICAgICAqIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuY2xvbmUgPSBmdW5jdGlvbiAoc291cmNlTWFuYWdlciwgcGFyZW50LCBlbGVtZW50LCBuZXdDb250cm9sLCBub2RlTWFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG5vZGVNYXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU1hcCA9IEVsZW1lbnRNYW5hZ2VyLl9jbG9uZU5vZGVNYXAoc291cmNlTWFuYWdlci5ub2RlTWFwLCBlbGVtZW50LCBwYXJlbnQuZ2V0VWlDb250cm9sKCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmdldFBhcmVudENvbnRyb2woKSwgbmV3Q29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFuYWdlciA9IEVsZW1lbnRNYW5hZ2VyLmdldEluc3RhbmNlKCksIGhhc05ld0NvbnRyb2wgPSAhaXNOdWxsKG5ld0NvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5ub2RlTWFwID0gbm9kZU1hcDtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5wdXNoKG1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5yZXBsYWNlID0gc291cmNlTWFuYWdlci5yZXBsYWNlO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5yZXBsYWNlTm9kZUxlbmd0aCA9IHNvdXJjZU1hbmFnZXIucmVwbGFjZU5vZGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLmhhc093bkNvbnRleHQgPSBzb3VyY2VNYW5hZ2VyLmhhc093bkNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLmlzQ2xvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEobm9kZU1hcC5oYXNDb250cm9sIHx8IGhhc05ld0NvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5iaW5kID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzTmV3Q29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9tYW5hZ2VyQ2FjaGUucHV0KG5ld0NvbnRyb2wudWlkLCBtYW5hZ2VyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIGFuIFRlbXBsYXRlQ29udHJvbCB3aXRoIGEgbmV3IElOb2RlTWFwLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gc291cmNlTWFwIFRoZSBzb3VyY2UgSU5vZGVNYXAgdXNlZCB0byBjbG9uZSB0aGVcclxuICAgICAgICAgICAgICogVGVtcGxhdGVDb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBwYXJlbnQgVGhlIHBhcmVudCBjb250cm9sIG9mIHRoZSBjbG9uZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLmNsb25lVWlDb250cm9sID0gZnVuY3Rpb24gKHNvdXJjZU1hcCwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdWlDb250cm9sTm9kZSA9IHNvdXJjZU1hcC51aUNvbnRyb2xOb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh1aUNvbnRyb2xOb2RlKSB8fCBpc051bGwodWlDb250cm9sTm9kZS5pbmplY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdWlDb250cm9sID0gdWlDb250cm9sTm9kZS5jb250cm9sLCBuZXdVaUNvbnRyb2wgPSB1aUNvbnRyb2xOb2RlLmluamVjdG9yLmluamVjdCgpLCByZXNvdXJjZXMgPSBFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeS5nZXRJbnN0YW5jZSgpLCBhdHRyaWJ1dGVzID0gRWxlbWVudE1hbmFnZXIuX0F0dHJpYnV0ZXNGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbnRyb2xzLnB1c2gobmV3VWlDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIG5ld1VpQ29udHJvbC5jb250cm9scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5pbml0aWFsaXplKG5ld1VpQ29udHJvbCwgc291cmNlTWFwLmF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICAgICAgbmV3VWlDb250cm9sLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzLmluaXRpYWxpemUobmV3VWlDb250cm9sLCB1aUNvbnRyb2wucmVzb3VyY2VzKTtcclxuICAgICAgICAgICAgICAgIG5ld1VpQ29udHJvbC5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XHJcbiAgICAgICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeS5hZGRDb250cm9sUmVzb3VyY2VzKG5ld1VpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh1aUNvbnRyb2wuaW5uZXJUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wuaW5uZXJUZW1wbGF0ZSA9IHVpQ29udHJvbC5pbm5lclRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5ld1VpQ29udHJvbC50eXBlID0gdWlDb250cm9sLnR5cGU7XHJcbiAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMgPSBFbGVtZW50TWFuYWdlci5fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5LmNyZWF0ZShuZXdVaUNvbnRyb2wsIHVpQ29udHJvbC5iaW5kYWJsZVRlbXBsYXRlcyk7XHJcbiAgICAgICAgICAgICAgICBuZXdVaUNvbnRyb2wucmVwbGFjZVdpdGggPSB1aUNvbnRyb2wucmVwbGFjZVdpdGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3VWlDb250cm9sO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBuZXcgSU5vZGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSBJTm9kZU1hcCBvciB0aGUgcGFzc2VkLWluIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBub2RlTWFwIFRoZSBJTm9kZU1hcCB0aGF0IGNvbnRhaW5zXHJcbiAgICAgICAgICAgICAqIHRoZSBhdHRyaWJ1dGUgbm9kZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHBhcmVudCBUaGUgcGFyZW50IFRlbXBsYXRlQ29udHJvbCBmb3JcclxuICAgICAgICAgICAgICogdGhlIG5ld2x5IGNyZWF0ZWQgY29udHJvbHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHRlbXBsYXRlQ29udHJvbD8gVGhlIFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiBsaW5rZWQgdG8gdGhlc2UgY3JlYXRlZCBjb250cm9scyBpZiBvbmUgZXhpc3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5ld0VsZW1lbnQ/IEFuIG9wdGlvbmFsIGVsZW1lbnQgdG8gdXNlIGZvciBhdHRyaWJ1dGVzICh1c2VkIGluIGNsb25pbmcpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2xvbmU/IFdoZXRoZXIgb3Igbm90IHRoZXNlIGNvbnRyb2xzIGFyZSBjbG9uZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5jcmVhdGVBdHRyaWJ1dGVDb250cm9scyA9IGZ1bmN0aW9uIChub2RlTWFwLCBwYXJlbnQsIHRlbXBsYXRlQ29udHJvbCwgbmV3RWxlbWVudCwgaXNDbG9uZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gbm9kZU1hcC5ub2RlcywgZWxlbWVudCA9IGlzQ2xvbmUgPT09IHRydWUgPyBuZXdFbGVtZW50IDogbm9kZU1hcC5lbGVtZW50LCBhdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzQ2xvbmUgPT09IHRydWUgPyBFbGVtZW50TWFuYWdlci5fY29weUF0dHJpYnV0ZU5vZGVzKG5vZGVzKSA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gbm9kZU1hcC5hdHRyaWJ1dGVzLCBuZXdBdHRyaWJ1dGVzLCBub2RlLCBpbmplY3RvciwgY29udHJvbCwgbmV3Tm9kZXMgPSBbXSwgbGVuZ3RoID0gbm9kZXMubGVuZ3RoLCBub2RlTmFtZSwgaTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBub2RlLmluamVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGluamVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gaW5qZWN0b3IuaW5qZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY29udHJvbCA9IGNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzID0gRWxlbWVudE1hbmFnZXIuX0F0dHJpYnV0ZXNGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0F0dHJpYnV0ZXMuaW5pdGlhbGl6ZShjb250cm9sLCBhdHRycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuYXR0cmlidXRlcyA9IG5ld0F0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wudHlwZSA9IG5vZGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGNvbnRyb2wudWlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC51aWQgPSB1bmlxdWVJZChfX1BsYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wudGVtcGxhdGVDb250cm9sID0gdGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDbG9uZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IGNvbnRyb2wsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogbm9kZS5leHByZXNzaW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6ICFhdHRyaWJ1dGVzID8gbnVsbCA6IChhdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShub2RlTmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShfX0F0dHJpYnV0ZVByZWZpeCArIG5vZGVOYW1lKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogbm9kZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvcjogaW5qZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb250cm9sLmluaXRpYWxpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2Rlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhQ29udHJvbCA9IGEuY29udHJvbCwgYkNvbnRyb2wgPSBiLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoYUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bGwoYkNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFQcmlvcml0eSA9IGlzTnVtYmVyKGFDb250cm9sLnByaW9yaXR5KSA/IGFDb250cm9sLnByaW9yaXR5IDogMCwgYlByaW9yaXR5ID0gaXNOdW1iZXIoYkNvbnRyb2wucHJpb3JpdHkpID8gYkNvbnRyb2wucHJpb3JpdHkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYlByaW9yaXR5IC0gYVByaW9yaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBub2RlLmNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNvbnRyb2xzLnB1c2goY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjb250cm9sLmluaXRpYWxpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Tm9kZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIGFuIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFuYWdlciA9IG5ldyBFbGVtZW50TWFuYWdlcigpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fUHJvbWlzZSA9IGFjcXVpcmUoX19Qcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuX0NvbnRleHRNYW5hZ2VyID0gTm9kZU1hbmFnZXIuX0NvbnRleHRNYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fY29tcGlsZXIgPSBhY3F1aXJlKF9fQ29tcGlsZXIpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fQ29tbWVudE1hbmFnZXJGYWN0b3J5ID0gYWNxdWlyZShfX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLl9Db250cm9sRmFjdG9yeSA9IGFjcXVpcmUoX19Db250cm9sRmFjdG9yeSk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5ID0gTm9kZU1hbmFnZXIuX1RlbXBsYXRlQ29udHJvbEZhY3Rvcnk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgPSBFbGVtZW50TWFuYWdlci5fQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5O1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5fbG9nID0gRWxlbWVudE1hbmFnZXIuX2xvZztcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgYXR0cmlidXRlcyAoTmFtZWROb2RlTWFwKSwgY3JlYXRpbmcgYW4gSU5vZGVNYXAuXHJcbiAgICAgICAgICAgICAqIFRoaXMgbWFwIHdpbGwgY29udGFpbiBpbmplY3RvcnMgZm9yIGFsbCB0aGUgQ29udHJvbHMgYXMgd2VsbCBhcyBwYXJzZWQgZXhwcmVzc2lvbnNcclxuICAgICAgICAgICAgICogYW5kIGlkZW50aWZpZXJzIGZvdW5kIGZvciBlYWNoIEF0dHJpYnV0ZSAodXNlZnVsIGZvciBkYXRhIGJpbmRpbmcpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05hbWVkTm9kZU1hcH0gYXR0cmlidXRlcyBUaGUgYXR0cmlidXRlcyB1c2VkIHRvIGNyZWF0ZSB0aGUgSU5vZGVNYXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fY29sbGVjdEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gW10sIGF0dHJpYnV0ZSwgbmFtZSwgdmFsdWUsIGNoaWxkQ29udGV4dCwgY2hpbGRJZGVudGlmaWVyLCBoYXNNYXJrdXAsIGhhc01hcmt1cEZuID0gTm9kZU1hbmFnZXIuaGFzTWFya3VwLCBmaW5kTWFya3VwID0gTm9kZU1hbmFnZXIuZmluZE1hcmt1cCwgX3BhcnNlciA9IE5vZGVNYW5hZ2VyLl9wYXJzZXIsIGV4cHJlc3Npb25zLCBoYXNDb250cm9sID0gZmFsc2UsIGluamVjdG9yLCBsZW5ndGggPSBhdHRyaWJ1dGVzLmxlbmd0aCwgY29udHJvbEF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyaWJ1dGUubmFtZS5yZXBsYWNlKC9eZGF0YS0vaSwgJycpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0b3IgPSBjb250cm9sSW5qZWN0b3JzW25hbWVdIHx8IHZpZXdDb250cm9sSW5qZWN0b3JzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBfX0NvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ID0gX3BhcnNlci5wYXJzZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRDb250ZXh0LmlkZW50aWZpZXJzLmxlbmd0aCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9sb2cud2FybignSW5jb3JyZWN0ICcgKyBfX0NvbnRleHQgKyAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKyAnLCBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgaWRlbnRpZmllci4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSWRlbnRpZmllciA9IGNoaWxkQ29udGV4dC5pZGVudGlmaWVyc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lICE9PSBfX0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzTWFya3VwID0gaGFzTWFya3VwRm4odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IGhhc01hcmt1cCA/IGZpbmRNYXJrdXAodmFsdWUpIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzQ29udHJvbCAmJiAoaGFzTWFya3VwIHx8ICFpc051bGwoaW5qZWN0b3IpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udHJvbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogYXR0cmlidXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uczogZXhwcmVzc2lvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmplY3RvcjogaW5qZWN0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xBdHRyaWJ1dGVzW2NhbWVsQ2FzZShuYW1lKV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBjb250cm9sQXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICBub2Rlczogbm9kZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0OiBjaGlsZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29udHJvbDogaGFzQ29udHJvbFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFVzZWQgdG8gY29weSB0aGUgYXR0cmlidXRlIG5vZGVzIGR1cmluZyB0aGUgY2xvbmluZyBwcm9jZXNzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQucHJvY2Vzc2luZy5JTm9kZT59IG5vZGVzIFRoZSBjb21waWxlZCBJTm9kZXNcclxuICAgICAgICAgICAgICogdG8gYmUgY2xvbmVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX2NvcHlBdHRyaWJ1dGVOb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGVzID0gW10sIGxlbmd0aCA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBub2RlLmV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlTmFtZTogbm9kZS5ub2RlTmFtZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld05vZGVzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xvbmVzIGFuIElOb2RlIHdpdGggYSBuZXcgbm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGV9IHNvdXJjZU5vZGUgVGhlIG9yaWdpbmFsIElOb2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5ldyBub2RlIHVzZWQgZm9yIGNsb25pbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IG5ld0NvbnRyb2w/IEFuIG9wdGlvbmFsIG5ldyBjb250cm9sIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBjbG9uZWQgbm9kZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9jbG9uZU5vZGUgPSBmdW5jdGlvbiAoc291cmNlTm9kZSwgbm9kZSwgbmV3Q29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiBuZXdDb250cm9sLFxyXG4gICAgICAgICAgICAgICAgICAgIGluamVjdG9yOiBzb3VyY2VOb2RlLmluamVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBzb3VyY2VOb2RlLmV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IHNvdXJjZU5vZGUubm9kZU5hbWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbG9uZXMgYW4gSU5vZGVNYXAgd2l0aCBhIG5ldyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gc291cmNlTWFwIFRoZSBvcmlnaW5hbCBJTm9kZU1hcC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBuZXcgRWxlbWVudCB1c2VkIGZvciBjbG9uaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBwYXJlbnQgVGhlIFRlbXBsYXRlQ29udHJvbCBhc3NvY2lhdGVkXHJcbiAgICAgICAgICAgICAqIHdpdGggdGhlIHBhcmVudCBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gbmV3Q29udHJvbD8gQW4gb3B0aW9uYWwgbmV3IFRlbXBsYXRlQ29udHJvbFxyXG4gICAgICAgICAgICAgKiB0byBhc3NvY2lhdGUgd2l0aCB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9jbG9uZU5vZGVNYXAgPSBmdW5jdGlvbiAoc291cmNlTWFwLCBlbGVtZW50LCBwYXJlbnQsIG5ld0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNDb250cm9sID0gc291cmNlTWFwLmhhc0NvbnRyb2wsIG5vZGVNYXAgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogc291cmNlTWFwLmF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0OiBzb3VyY2VNYXAuY2hpbGRDb250ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbE5vZGU6ICFpc051bGwoc291cmNlTWFwLnVpQ29udHJvbE5vZGUpID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuX2Nsb25lTm9kZShzb3VyY2VNYXAudWlDb250cm9sTm9kZSwgZWxlbWVudCwgbmV3Q29udHJvbCkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NvbnRyb2w6IGhhc0NvbnRyb2xcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVNYXAubm9kZXMgPSBFbGVtZW50TWFuYWdlci5jcmVhdGVBdHRyaWJ1dGVDb250cm9scyhzb3VyY2VNYXAsIHBhcmVudCwgbmV3Q29udHJvbCwgZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZU1hcDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyB0aGUgRWxlbWVudE1hbmFnZXIgd2l0aCBhIG5ldyBub2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgVGhlIG5ldyBlbGVtZW50IHVzZWQgdG8gY2xvbmUgdGhlIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gcGFyZW50TWFuYWdlciBUaGUgcGFyZW50IG1hbmFnZXIgZm9yIHRoZSBjbG9uZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IG5vZGVNYXA/IEFuIG9wdGlvbmFsIElOb2RlTWFwIHRvIGNsb25lIGEgdWkgY29udHJvbCBpZiBuZWVkZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobmV3Tm9kZSwgcGFyZW50TWFuYWdlciwgbm9kZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMsIGNsb25lZE1hbmFnZXIsIHJlcGxhY2UgPSB0aGlzLnJlcGxhY2UsIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbmV3Q29udHJvbCA9ICFpc051bGwobm9kZU1hcCkgPyBub2RlTWFwLnVpQ29udHJvbE5vZGUuY29udHJvbCA6IG51bGwsIG5ld0NvbnRyb2xFeGlzdHMgPSAhaXNOdWxsKG5ld0NvbnRyb2wpLCBzdGFydE5vZGVNYW5hZ2VyLCBlbmROb2RlTWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIGlmICghbmV3Q29udHJvbEV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgY29udHJvbCBcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sID0gRWxlbWVudE1hbmFnZXIuY2xvbmVVaUNvbnRyb2wodGhpcy5ub2RlTWFwLCAocGFyZW50TWFuYWdlci5nZXRVaUNvbnRyb2woKSB8fCBwYXJlbnRNYW5hZ2VyLmdldFBhcmVudENvbnRyb2woKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2xFeGlzdHMgPSAhaXNOdWxsKG5ld0NvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZWZpbml0ZWx5IGhhdmUgbmV3Q29udHJvbCBcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBuZXdOb2RlLnBhcmVudE5vZGUuY2hpbGROb2RlcywgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgc3RhcnRJbmRleCA9IGFycmF5UHJvdG8uaW5kZXhPZi5jYWxsKG5vZGVzLCBuZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gYXJyYXlQcm90by5zbGljZS5jYWxsKG5vZGVzLCBzdGFydEluZGV4ICsgMSwgc3RhcnRJbmRleCArIHRoaXMucmVwbGFjZU5vZGVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb25lZE1hbmFnZXIgPSBFbGVtZW50TWFuYWdlci5jbG9uZSh0aGlzLCBwYXJlbnRNYW5hZ2VyLCBudWxsLCBuZXdDb250cm9sLCBub2RlTWFwKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sLmVsZW1lbnROb2RlcyA9IGNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udHJvbC5zdGFydE5vZGUgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyb2wuZW5kTm9kZSA9IGNoaWxkTm9kZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROb2RlTWFuYWdlciA9IGNoaWxkcmVuLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZU1hbmFnZXIgPSBjaGlsZHJlbi5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZU1hbmFnZXIuY2xvbmUobmV3Q29udHJvbC5zdGFydE5vZGUsIGNsb25lZE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVuZE5vZGVNYW5hZ2VyLmNsb25lKG5ld0NvbnRyb2wuZW5kTm9kZSwgY2xvbmVkTWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obmV3Q29udHJvbC5pbml0aWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobmV3Tm9kZS5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBjbG9uZWRNYW5hZ2VyID0gRWxlbWVudE1hbmFnZXIuY2xvbmUodGhpcywgcGFyZW50TWFuYWdlciwgbmV3Tm9kZSwgbmV3Q29udHJvbCwgbm9kZU1hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU1hcCA9IGNsb25lZE1hbmFnZXIubm9kZU1hcDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV3Q29udHJvbEV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sLmVsZW1lbnQgPSBuZXdOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihuZXdDb250cm9sLmluaXRpYWxpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250cm9sLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGgsIGNoaWxkTm9kZU9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvbmUgY2hpbGRyZW4gXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlT2Zmc2V0ICs9IGNoaWxkcmVuW2ldLmNsb25lKGNoaWxkTm9kZXNbY2hpbGROb2RlT2Zmc2V0XSwgY2xvbmVkTWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoZW5kTm9kZU1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnVuc2hpZnQoc3RhcnROb2RlTWFuYWdlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZU9mZnNldCArIDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGJvdGggdGhlIG1hbmFnZXIgaXRzZWxmIGFuZCBhbGwgdGhlIGNvbnRyb2xzIGFzc29jaWF0ZWQgdG8gdGhlIG1hbmFnZXInc1xyXG4gICAgICAgICAgICAgKiBJTm9kZU1hcC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuSU5vZGVNYXB9IG5vZGVNYXAgQSBtYXAgb2YgdGhlIG5vZGVzIChlbGVtZW50IGFuZCBhdHRyaWJ1dGVzKVxyXG4gICAgICAgICAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudCBUaGUgcGFyZW50XHJcbiAgICAgICAgICAgICAqIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvbnRJbml0aWFsaXplPyBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhlIGluaXRpYWxpemUgbWV0aG9kIHNob3VsZFxyXG4gICAgICAgICAgICAgKiBiZSBjYWxsZWQgZm9yIGEgVGVtcGxhdGVDb250cm9sIGlmIG9uZSBpcyBhdHRhY2hlZFxyXG4gICAgICAgICAgICAgKiB0byB0aGlzIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobm9kZU1hcCwgcGFyZW50LCBkb250SW5pdGlhbGl6ZSkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbm9kZU1hcCwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sTm9kZSA9IG5vZGVNYXAudWlDb250cm9sTm9kZSwgaGFzVWlDb250cm9sID0gIWlzTnVsbChjb250cm9sTm9kZSksIGNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzVWlDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcG9wdWxhdGVVaUNvbnRyb2woKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbE5vZGUuY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc093bkNvbnRleHQgPSBjb250cm9sLmhhc093bkNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZU1hcC5oYXNDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIuY3JlYXRlQXR0cmlidXRlQ29udHJvbHMobm9kZU1hcCwgdGhpcy5nZXRQYXJlbnRDb250cm9sKCksIGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkb250SW5pdGlhbGl6ZSAmJiBoYXNVaUNvbnRyb2wgJiYgaXNGdW5jdGlvbihjb250cm9sLmluaXRpYWxpemUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMaW5rcyB0aGUgZGF0YSBjb250ZXh0IHRvIHRoZSBET00gKGRhdGEtYmluZGluZykuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZU1hcCA9IHRoaXMubm9kZU1hcCwgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRDb250cm9sKCksIGNvbnRyb2xOb2RlID0gbm9kZU1hcC51aUNvbnRyb2xOb2RlLCBjb250cm9scyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY29udHJvbE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVpQ29udHJvbF8xID0gY29udHJvbE5vZGUuY29udHJvbCwgY2hpbGRDb250ZXh0ID0gbm9kZU1hcC5jaGlsZENvbnRleHQsIGdldE1hbmFnZXIgPSB0aGlzLl9Db250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyLCBjb250ZXh0TWFuYWdlcl8xLCBhYnNvbHV0ZUNvbnRleHRQYXRoXzEgPSBpc051bGwocGFyZW50KSA/IF9fQ09OVEVYVCA6IHBhcmVudC5hYnNvbHV0ZUNvbnRleHRQYXRoLCBfVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IHRoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnksIGluaGVyaXRzQ29udGV4dCA9ICF1aUNvbnRyb2xfMS5oYXNPd25Db250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzLnB1c2godWlDb250cm9sXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmhlcml0c0NvbnRleHQgJiYgIWlzTnVsbChjaGlsZENvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZENvbnRleHRbMF0gPT09ICdAJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0ID0gY2hpbGRDb250ZXh0LnNwbGl0KCcuJyksIHRvcElkZW50aWZpZXIgPSBzcGxpdC5zaGlmdCgpLCBhbGlhcyA9IHRvcElkZW50aWZpZXIuc2xpY2UoMSksIHJlc291cmNlT2JqID0gX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZmluZFJlc291cmNlKHVpQ29udHJvbF8xLCBhbGlhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocmVzb3VyY2VPYmopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc291cmNlID0gcmVzb3VyY2VPYmoucmVzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRDb250ZXh0ID0gKHNwbGl0Lmxlbmd0aCA+IDAgPyAoJy4nICsgc3BsaXQuam9pbignLicpKSA6ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXMgPT09IF9fQ09OVEVYVF9SRVNPVVJDRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUNvbnRleHRQYXRoXzEgKz0gY2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhbGlhcyA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVDb250ZXh0UGF0aF8xID0gX19DT05URVhUICsgY2hpbGRDb250ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNvdXJjZS50eXBlID09PSBfX09CU0VSVkFCTEVfUkVTT1VSQ0UgfHwgcmVzb3VyY2UudHlwZSA9PT0gX19MSVRFUkFMX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlQ29udGV4dFBhdGhfMSA9ICdyZXNvdXJjZXMuJyArIGFsaWFzICsgJy52YWx1ZScgKyBjaGlsZENvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbF8xLnJvb3QgPSByZXNvdXJjZU9iai5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ09ubHkgcmVzb3VyY2VzIG9mIHR5cGUgXCJvYnNlcnZhYmxlXCIgY2FuIGJlIHNldCBhcyBjb250ZXh0LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdDb3VsZCBub3Qgc2V0IHRoZSBjb250ZXh0IG9mICcgKyB1aUNvbnRyb2xfMS50eXBlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIHRoZSByZXNvdXJjZSBzcGVjaWZpZWQgYXMgXCInICsgY2hpbGRDb250ZXh0ICsgJ1wiLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVDb250ZXh0UGF0aF8xICs9ICcuJyArIGNoaWxkQ29udGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHVpQ29udHJvbF8xLnJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbF8xLnJvb3QgPSB0aGlzLl9Db250cm9sRmFjdG9yeS5nZXRSb290Q29udHJvbCh1aUNvbnRyb2xfMSkgfHwgdWlDb250cm9sXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRNYW5hZ2VyXzEgPSBnZXRNYW5hZ2VyKHVpQ29udHJvbF8xLnJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhd2FpdENvbnRleHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5oZXJpdHNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbF8xLmNvbnRleHQgPSBjb250ZXh0TWFuYWdlcl8xLmdldENvbnRleHQoYWJzb2x1dGVDb250ZXh0UGF0aF8xLnNwbGl0KCcuJyksIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXRDb250ZXh0ID0gaXNVbmRlZmluZWQodWlDb250cm9sXzEuY29udGV4dCkgJiYgIXRoaXMuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeS5pc0JvdW5kQ29udHJvbCh1aUNvbnRyb2xfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZUNvbnRleHRQYXRoXzEgPSBfX0NPTlRFWFQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhd2FpdENvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0UHJvbWlzZSA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lciA9IGNvbnRleHRNYW5hZ2VyXzEub2JzZXJ2ZShhYnNvbHV0ZUNvbnRleHRQYXRoXzEsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aWQ6IHVpQ29udHJvbF8xLnVpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sXzEuY29udGV4dCA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmVmb3JlTG9hZCh1aUNvbnRyb2xfMSwgYWJzb2x1dGVDb250ZXh0UGF0aF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZUxvYWQodWlDb250cm9sXzEsIGFic29sdXRlQ29udGV4dFBhdGhfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZUNvbnRyb2xJZGVudGlmaWVycyhub2RlTWFwLm5vZGVzLCBwYXJlbnQsIGNvbnRyb2xzLCBub2RlTWFwLmVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgdGVtcGxhdGUgZm9yIGFuIG1hbmFnZXIgYnkgb2J0YWluaW5nIGFueSBuZWVkZWQgSFRNTCB0ZW1wbGF0ZXMgYW5kXHJcbiAgICAgICAgICAgICAqIGNhbGxpbmcgaXRzIGFzc29jaWF0ZWQgVGVtcGxhdGVDb250cm9sJ3NcclxuICAgICAgICAgICAgICogc2V0VGVtcGxhdGUgbWV0aG9kLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVVcmw/IFRoZSBVUkwgZm9yIHRoZSBhc3NvY2lhdGVkIFRlbXBsYXRlQ29udHJvbCdzXHJcbiAgICAgICAgICAgICAqIEhUTUwgdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuc2V0VWlDb250cm9sVGVtcGxhdGUgPSBmdW5jdGlvbiAodGVtcGxhdGVVcmwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbE5vZGUgPSB0aGlzLm5vZGVNYXAudWlDb250cm9sTm9kZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKGNvbnRyb2xOb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sXzEgPSBjb250cm9sTm9kZS5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcGxhdGVQcm9taXNlID0gdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kZXRlcm1pbmVUZW1wbGF0ZShjb250cm9sXzEsIHRlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZW1wbGF0ZVByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZUNvbnRyb2woY29udHJvbF8xLCB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZW1wbGF0ZVByb21pc2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeS5pc0JvdW5kQ29udHJvbChjb250cm9sXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBhcHBlbmRDaGlsZHJlbihjb250cm9sXzEuZWxlbWVudC5jaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWFsaXplQ29udHJvbChjb250cm9sXzEsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHRoaXMucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYmluZEFuZExvYWQoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJldHJpZXZlcyB0aGUgVGVtcGxhdGVDb250cm9sIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLmdldFVpQ29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1aUNvbnRyb2xOb2RlID0gdGhpcy5ub2RlTWFwLnVpQ29udHJvbE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHVpQ29udHJvbE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVpQ29udHJvbE5vZGUuY29udHJvbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZ1bGxmaWxscyBhbnkgdGVtcGxhdGUgcHJvbWlzZXMgYW5kIGZpbmlzaGVzIHRoZSBjb21waWxlIHBoYXNlIGZvciB0aGUgSFRNTCB0ZW1wbGF0ZSBhc3NvY2lhdGVkXHJcbiAgICAgICAgICAgICAqIHdpdGggdGhpcyBFbGVtZW50TWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5mdWxmaWxsVGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bGwodGhpcy50ZW1wbGF0ZVByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2Z1bGZpbGxDaGlsZFRlbXBsYXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGZpbGxDaGlsZFRlbXBsYXRlcygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRnVsZmlsbHMgdGhlIHRlbXBsYXRlIHByb21pc2UgcHJpb3IgdG8gYmluZGluZyBhbmQgbG9hZGluZyB0aGUgY29udHJvbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5mdWxmaWxsQW5kTG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxmaWxsVGVtcGxhdGUoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYmluZEFuZExvYWQoKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCaW5kcyBjb250ZXh0IHRvIHRoZSBET00gYW5kIGxvYWRzIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLmJpbmRBbmRMb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9scyA9IHRoaXMuYmluZCgpLCBwcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSh0aGlzLmNvbnRleHRQcm9taXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSB0aGlzLmNvbnRleHRQcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2JpbmRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMuX2JpbmRDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9sb2FkQ29udHJvbHMoY29udHJvbHMsIF90aGlzLmdldFVpQ29udHJvbCgpKTtcclxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyB0aGUgcm9vdCBjb250ZXh0IGZvciBjb250cm9scyB0aGF0IHNwZWNpZnkgdGhlaXIgb3duIGNvbnRleHQsIGFuZCBpbml0aWF0ZXNcclxuICAgICAgICAgICAgICogYSBsb2FkIHVwb24gYSBzdWNjZXNzZnVsIHNldCBvZiB0aGUgY29udGV4dC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gcm9vdCBUaGUgVGVtcGxhdGVDb250cm9sIHNwZWNpZnlpbmcgaXRzIG93biBjb250ZXh0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0geygpID0+IGFzeW5jLklUaGVuYWJsZTx2b2lkPn0gbG9hZE1ldGhvZCBUaGUgZnVuY3Rpb24gdG8gaW5pdGlhdGUgdGhlIGxvYWRpbmcgb2YgdGhlIHJvb3QgY29udHJvbCBhbmQgaXRzXHJcbiAgICAgICAgICAgICAqIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgRWxlbWVudE1hbmFnZXIucHJvdG90eXBlLm9ic2VydmVSb290Q29udGV4dCA9IGZ1bmN0aW9uIChyb290LCBsb2FkTWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgbG9hZE1ldGhvZCA9IGxvYWRNZXRob2QuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHJvb3QuY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9hZE1ldGhvZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVyID0gX3RoaXMuX0NvbnRleHRNYW5hZ2VyLmdldE1hbmFnZXIocm9vdCkub2JzZXJ2ZShfX0NPTlRFWFQsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkTWV0aG9kKCkudGhlbihyZXNvbHZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWlkOiByb290LnVpZFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmFsaXplcyBhbGwgdGhlIHByb3BlcnRpZXMgb24gYW4gVGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAqIGJlZm9yZSBsb2FkaW5nLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSB1aUNvbnRyb2wgVGhlIGNvbnRyb2wgdG8gZmluYWxpemUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNvbHV0ZUNvbnRleHRQYXRoIFRoZSBhYnNvbHV0ZUNvbnRleHRQYXRoIG9mIHRoZSB1aUNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX2JlZm9yZUxvYWQgPSBmdW5jdGlvbiAodWlDb250cm9sLCBhYnNvbHV0ZUNvbnRleHRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dE1hbmFnZXIgPSB0aGlzLl9Db250ZXh0TWFuYWdlci5nZXRNYW5hZ2VyKHVpQ29udHJvbC5yb290KSwgX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkgPSB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5O1xyXG4gICAgICAgICAgICAgICAgdWlDb250cm9sLnpDQ19fcGxhdCA9IGNvbnRleHRNYW5hZ2VyLm9ic2VydmUoYWJzb2x1dGVDb250ZXh0UGF0aCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHVpZDogdWlDb250cm9sLnVpZCxcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogX19DT05URVhUX0NIQU5HRURfUFJJT1JJVFksXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sLmNvbnRleHQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LnNldEFic29sdXRlQ29udGV4dFBhdGgodWlDb250cm9sLCBhYnNvbHV0ZUNvbnRleHRQYXRoKTtcclxuICAgICAgICAgICAgICAgIF9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LnNldENvbnRleHRSZXNvdXJjZXModWlDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9SZXNvdXJjZXNGYWN0b3J5LmJpbmRSZXNvdXJjZXModWlDb250cm9sLnJlc291cmNlcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCaW5kcyBjb250ZXh0IHRvIHRoZSBET00gYW5kIGNhbGxzIGJpbmRBbmRMb2FkIG9uIGFsbCBjaGlsZHJlbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5fYmluZENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoLCBjaGlsZCwgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5oYXNPd25Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY2hpbGQub2JzZXJ2ZVJvb3RDb250ZXh0KGNoaWxkLmdldFVpQ29udHJvbCgpLCBjaGlsZC5iaW5kQW5kTG9hZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjaGlsZC5vYnNlcnZlUm9vdENvbnRleHQoY2hpbGQuZ2V0VWlDb250cm9sKCksIGNoaWxkLmZ1bGZpbGxBbmRMb2FkKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzVW5kZWZpbmVkKGNoaWxkLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoaWxkLmJpbmRBbmRMb2FkKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuYmluZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbChwcm9taXNlcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMb2FkcyB0aGUgcG90ZW50aWFsIGF0dHJpYnV0ZSBiYXNlZCBjb250cm9scyBhc3NvY2lhdGVkIHdpdGggdGhpc1xyXG4gICAgICAgICAgICAgKiBFbGVtZW50TWFuYWdlciBhbmRcclxuICAgICAgICAgICAgICogYXR0YWNoZXMgdGhlIGNvcnJlc3BvbmRpbmcgVGVtcGxhdGVDb250cm9sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LkF0dHJpYnV0ZUNvbnRyb2w+fSBjb250cm9scyBUaGUgYXJyYXkgb2YgYXR0cmlidXRlIGJhc2VkIGNvbnRyb2xzIHRvIGxvYWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHRlbXBsYXRlQ29udHJvbCBUaGUgVGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX2xvYWRDb250cm9scyA9IGZ1bmN0aW9uIChjb250cm9scywgdGVtcGxhdGVDb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29udHJvbHMubGVuZ3RoLCBjb250cm9sLCBsb2FkID0gdGhpcy5fQ29udHJvbEZhY3RvcnkubG9hZCwgdGVtcGxhdGVDb250cm9sTG9hZGVkID0gaXNOdWxsKHRlbXBsYXRlQ29udHJvbCksIHByb21pc2UsIHRlbXBsYXRlQ29udHJvbFByaW9yaXR5LCBpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlQ29udHJvbExvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IG5lZWQgdG8gc2V0IHRlbXBsYXRlQ29udHJvbFByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBuZXZlciBiZSBjaGVja2VkLiBcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmlvcml0eSA9IHRlbXBsYXRlQ29udHJvbC5wcmlvcml0eTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUNvbnRyb2xQcmlvcml0eSA9IGlzTnVtYmVyKHByaW9yaXR5KSA/IHByaW9yaXR5IDogMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBjb250cm9sc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sLnRlbXBsYXRlQ29udHJvbCA9IHRlbXBsYXRlQ29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlbXBsYXRlQ29udHJvbExvYWRlZCAmJiB0ZW1wbGF0ZUNvbnRyb2xQcmlvcml0eSA+IGNvbnRyb2wucHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVDb250cm9sTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGxvYWQodGVtcGxhdGVDb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGVtcGxhdGVDb250cm9sTG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IGxvYWQodGVtcGxhdGVDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUG9wdWxhdGVzIHRoZSBUZW1wbGF0ZUNvbnRyb2wgcHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIGlmIG9uZSBleGlzdHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX3BvcHVsYXRlVWlDb250cm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVNYXAgPSB0aGlzLm5vZGVNYXAsIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Q29udHJvbCgpLCBjb250cm9sTm9kZSA9IG5vZGVNYXAudWlDb250cm9sTm9kZSwgdWlDb250cm9sID0gY29udHJvbE5vZGUuY29udHJvbCwgdWlkID0gdWlDb250cm9sLnVpZCwgcmVzb3VyY2VzID0gdWlDb250cm9sLnJlc291cmNlcywgZWxlbWVudCA9IG5vZGVNYXAuZWxlbWVudCwgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcyksIG5ld0F0dHJpYnV0ZXMgPSBFbGVtZW50TWFuYWdlci5fQXR0cmlidXRlc0ZhY3RvcnkuZ2V0SW5zdGFuY2UoKSwgcmVwbGFjZSA9IHRoaXMucmVwbGFjZSA9ICh1aUNvbnRyb2wucmVwbGFjZVdpdGggPT09IG51bGwgfHwgdWlDb250cm9sLnJlcGxhY2VXaXRoID09PSAnJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHVpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1aWQgPSB1aUNvbnRyb2wudWlkID0gdW5pcXVlSWQoX19QbGF0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9tYW5hZ2VyQ2FjaGUucHV0KHVpZCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChwYXJlbnQpICYmIHVpQ29udHJvbC5wYXJlbnQgIT09IHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5jb250cm9scy5wdXNoKHVpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGVsZW1lbnQuc2V0QXR0cmlidXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdWlDb250cm9sLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdWlDb250cm9sLmNvbnRyb2xzID0gW107XHJcbiAgICAgICAgICAgICAgICBuZXdBdHRyaWJ1dGVzLmluaXRpYWxpemUodWlDb250cm9sLCBub2RlTWFwLmF0dHJpYnV0ZXMpO1xyXG4gICAgICAgICAgICAgICAgdWlDb250cm9sLmF0dHJpYnV0ZXMgPSBuZXdBdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHJlc291cmNlcykgJiYgaXNGdW5jdGlvbihyZXNvdXJjZXMuYWRkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlcy5hZGQoY29udHJvbE5vZGUucmVzb3VyY2VFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlcyA9IEVsZW1lbnRNYW5hZ2VyLl9SZXNvdXJjZXNGYWN0b3J5LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzLmluaXRpYWxpemUodWlDb250cm9sLCBjb250cm9sTm9kZS5yZXNvdXJjZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5yZXNvdXJjZXMgPSByZXNvdXJjZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeS5hZGRDb250cm9sUmVzb3VyY2VzKHVpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICB1aUNvbnRyb2wudHlwZSA9IGNvbnRyb2xOb2RlLm5vZGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgdWlDb250cm9sLmJpbmRhYmxlVGVtcGxhdGVzID0gdWlDb250cm9sLmJpbmRhYmxlVGVtcGxhdGVzIHx8IHRoaXMuX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeS5jcmVhdGUodWlDb250cm9sKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgKCFpc0VtcHR5KHVpQ29udHJvbC50ZW1wbGF0ZVN0cmluZykgfHwgIWlzRW1wdHkodWlDb250cm9sLnRlbXBsYXRlVXJsKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2wuaW5uZXJUZW1wbGF0ZSA9IGFwcGVuZENoaWxkcmVuKGNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBsYWNlRWxlbWVudCh1aUNvbnRyb2wsIG5vZGVNYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyB0aGUgVGVtcGxhdGVDb250cm9sJ3MgZWxlbWVudC4gQ2FsbGVkIGlmIGl0cyByZXBsYWNlV2l0aCBwcm9wZXJ0eSBpc1xyXG4gICAgICAgICAgICAgKiBudWxsIG9yIGVtcHR5IHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgVGVtcGxhdGVDb250cm9sIHdob3NlIGVsZW1lbnRcclxuICAgICAgICAgICAgICogd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5JTm9kZU1hcH0gbm9kZU1hcCBUaGUgSU5vZGVNYXAgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFuYWdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5fcmVwbGFjZUVsZW1lbnQgPSBmdW5jdGlvbiAoY29udHJvbCwgbm9kZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBub2RlTWFwLmVsZW1lbnQsIHBhcmVudE5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGUsIF9kb2N1bWVudCA9IEVsZW1lbnRNYW5hZ2VyLl9kb2N1bWVudCwgY29udHJvbFR5cGUgPSBjb250cm9sLnR5cGUsIGNvbnRyb2xVaWQgPSBjb250cm9sLnVpZCwgc3RhcnROb2RlID0gY29udHJvbC5zdGFydE5vZGUgPSBfZG9jdW1lbnQuY3JlYXRlQ29tbWVudChjb250cm9sVHlwZSArICcgJyArIGNvbnRyb2xVaWQgKyBfX1NUQVJUX05PREUpLCBlbmROb2RlID0gY29udHJvbC5lbmROb2RlID0gX2RvY3VtZW50LmNyZWF0ZUNvbW1lbnQoY29udHJvbFR5cGUgKyAnICcgKyBjb250cm9sVWlkICsgX19FTkRfTk9ERSksIGNyZWF0ZSA9IHRoaXMuX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeS5jcmVhdGU7XHJcbiAgICAgICAgICAgICAgICBjcmVhdGUoc3RhcnROb2RlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZShlbmROb2RlLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0YXJ0Tm9kZSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbmROb2RlLCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZWxlbWVudE5vZGVzID0gcmVwbGFjZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2wuZWxlbWVudCA9IG5vZGVNYXAuZWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIGNvbnRyb2wncyB0ZW1wbGF0ZSBhbmQgY29tcGlsZXMgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHVpQ29udHJvbCBUaGUgVGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hbmFnZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGUgVGhlIGFzc29jaWF0ZWQgVGVtcGxhdGVDb250cm9sJ3NcclxuICAgICAgICAgICAgICogdGVtcGxhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5wcm90b3R5cGUuX2luaXRpYWxpemVDb250cm9sID0gZnVuY3Rpb24gKHVpQ29udHJvbCwgdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5ub2RlTWFwLmVsZW1lbnQsIFxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBjaGVjayBpZiBudWxsIHNpbmNlIGlzTnVsbCBjaGVja3MgZm9yIHVuZGVmaW5lZCBjYXNlIFxyXG4gICAgICAgICAgICAgICAgcmVwbGFjZUVsZW1lbnQgPSB0aGlzLnJlcGxhY2UsIGVuZE5vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0ZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb3VyY2VFbGVtZW50ID0gRWxlbWVudE1hbmFnZXIubG9jYXRlUmVzb3VyY2VzKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyZXNvdXJjZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5yZXNvdXJjZXMuYWRkKEVsZW1lbnRNYW5hZ2VyLl9SZXNvdXJjZXNGYWN0b3J5LnBhcnNlRWxlbWVudChyZXNvdXJjZUVsZW1lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZE5vZGUgPSB1aUNvbnRyb2wuZW5kTm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sLmVsZW1lbnROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRlbXBsYXRlLmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZW5kTm9kZS5wYXJlbnROb2RlLCB0ZW1wbGF0ZSwgZW5kTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoZWxlbWVudCwgdGVtcGxhdGUsIGVsZW1lbnQubGFzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih1aUNvbnRyb2wuc2V0VGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sLnNldFRlbXBsYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb21waWxlci5jb21waWxlKHVpQ29udHJvbC5lbGVtZW50Tm9kZXMsIHVpQ29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0Tm9kZSA9IHVpQ29udHJvbC5zdGFydE5vZGUsIHBhcmVudE5vZGUgPSBzdGFydE5vZGUucGFyZW50Tm9kZSwgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhcmVudE5vZGUuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTm9kZSA9IHVpQ29udHJvbC5lbmROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbC5lbGVtZW50Tm9kZXMgPSBjaGlsZE5vZGVzLnNsaWNlKGNoaWxkTm9kZXMuaW5kZXhPZihzdGFydE5vZGUpICsgMSwgY2hpbGROb2Rlcy5pbmRleE9mKGVuZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VOb2RlTGVuZ3RoID0gdWlDb250cm9sLmVsZW1lbnROb2Rlcy5sZW5ndGggKyAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGlsZXIuY29tcGlsZShlbGVtZW50LCB1aUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh1aUNvbnRyb2wucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnVsZmlsbEFuZExvYWQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9ic2VydmVzIHRoZSBpZGVudGlmaWVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyBtYW5hZ2VyJ3MgSU5vZGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQucHJvY2Vzc2luZy5JTm9kZT59IG5vZGVzIFRoZSBhcnJheSBvZiBJTm9kZXMgdG8gaXRlcmF0ZSB0aHJvdWdoLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBwYXJlbnQgVGhlIHBhcmVudCBUZW1wbGF0ZUNvbnRyb2wgZm9yIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5Db250cm9sPn0gY29udHJvbHMgVGhlIGFycmF5IG9mIGNvbnRyb2xzIHdob3NlIGF0dHJpYnV0ZXMgd2lsbCBuZWVkIHRvIGJlIHVwZGF0ZWRcclxuICAgICAgICAgICAgICogdXBvbiB0aGUgY29udGV4dCBjaGFuZ2luZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5fb2JzZXJ2ZUNvbnRyb2xJZGVudGlmaWVycyA9IGZ1bmN0aW9uIChub2RlcywgcGFyZW50LCBjb250cm9scywgZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IG5vZGVzLmxlbmd0aCwgaGFzUGFyZW50ID0gIWlzTnVsbChwYXJlbnQpLCBub2RlLCBjb250cm9sLCBpID0gMCwgcmVwbGFjZSA9IHRoaXMucmVwbGFjZSwgbWFuYWdlcnMgPSBbXSwgbWFuYWdlcjtcclxuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IG5vZGUuY29udHJvbDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzUGFyZW50ICYmIG5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyID0gQXR0cmlidXRlTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2Vycy5wdXNoKG1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmluaXRpYWxpemUoZWxlbWVudCwgbm9kZSwgcGFyZW50LCBjb250cm9scywgcmVwbGFjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vZGVNYW5hZ2VyLm9ic2VydmVFeHByZXNzaW9ucyhub2RlLmV4cHJlc3Npb25zLCBwYXJlbnQsIG1hbmFnZXIuYXR0cmlidXRlQ2hhbmdlZC5iaW5kKG1hbmFnZXIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbHMucHVzaChjb250cm9sKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBtYW5hZ2Vycy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2Vyc1tpXS5hdHRyaWJ1dGVDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSdW5zIHRocm91Z2ggYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG1hbmFnZXIgYW5kIGNhbGxzIGZ1bGZpbGxUZW1wbGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLnByb3RvdHlwZS5fZnVsZmlsbENoaWxkVGVtcGxhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGNoaWxkLCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGgsIHByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGNoaWxkLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoaWxkLmZ1bGZpbGxUZW1wbGF0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwocHJvbWlzZXMpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgX0NvbnRleHRNYW5hZ2VyOiBfX0NvbnRleHRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX2NvbXBpbGVyOiBfX0NvbXBpbGVyLFxyXG4gICAgICAgICAgICAgICAgX0NvbW1lbnRNYW5hZ2VyRmFjdG9yeTogX19Db21tZW50TWFuYWdlckZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICBfQ29udHJvbEZhY3Rvcnk6IF9fQ29udHJvbEZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICBfVGVtcGxhdGVDb250cm9sRmFjdG9yeTogX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LFxyXG4gICAgICAgICAgICAgICAgX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeTogX19CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnksXHJcbiAgICAgICAgICAgICAgICBfbG9nOiBfX0xvZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudE1hbmFnZXI7XHJcbiAgICAgICAgfShOb2RlTWFuYWdlcikpO1xyXG4gICAgICAgIHByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXIgPSBFbGVtZW50TWFuYWdlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJRWxlbWVudE1hbmFnZXJGYWN0b3J5KF9kb2N1bWVudCwgX21hbmFnZXJDYWNoZSwgX1Jlc291cmNlc0ZhY3RvcnksIF9BdHRyaWJ1dGVzRmFjdG9yeSwgX0JpbmRhYmxlVGVtcGxhdGVzRmFjdG9yeSwgX2xvZykge1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9tYW5hZ2VyQ2FjaGUgPSBfbWFuYWdlckNhY2hlO1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fUmVzb3VyY2VzRmFjdG9yeSA9IF9SZXNvdXJjZXNGYWN0b3J5O1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fQXR0cmlidXRlc0ZhY3RvcnkgPSBfQXR0cmlidXRlc0ZhY3Rvcnk7XHJcbiAgICAgICAgICAgIEVsZW1lbnRNYW5hZ2VyLl9CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnkgPSBfQmluZGFibGVUZW1wbGF0ZXNGYWN0b3J5O1xyXG4gICAgICAgICAgICBFbGVtZW50TWFuYWdlci5fbG9nID0gX2xvZztcclxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRNYW5hZ2VyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9jZXNzaW5nLklFbGVtZW50TWFuYWdlckZhY3RvcnkgPSBJRWxlbWVudE1hbmFnZXJGYWN0b3J5O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19FbGVtZW50TWFuYWdlckZhY3RvcnksIElFbGVtZW50TWFuYWdlckZhY3RvcnksIFtcclxuICAgICAgICAgICAgX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgX19NYW5hZ2VyQ2FjaGUsXHJcbiAgICAgICAgICAgIF9fUmVzb3VyY2VzRmFjdG9yeSxcclxuICAgICAgICAgICAgX19BdHRyaWJ1dGVzRmFjdG9yeSxcclxuICAgICAgICAgICAgX19CaW5kYWJsZVRlbXBsYXRlc0ZhY3RvcnksXHJcbiAgICAgICAgICAgIF9fTG9nXHJcbiAgICAgICAgXSwgX19GQUNUT1JZKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fRWxlbWVudE1hbmFnZXJJbnN0YW5jZSwgRWxlbWVudE1hbmFnZXIsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjbGFzcyByZXNwb25zaWJsZSBmb3IgaW5pdGlhbGl6aW5nIGFuZCBkYXRhLWJpbmRpbmcgdmFsdWVzIHRvIHRleHQgbm9kZXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRleHRNYW5hZ2VyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRleHRNYW5hZ2VyLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUZXh0TWFuYWdlcigpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTcGVjaWZpZXMgdGhlIHR5cGUgZm9yIHRoaXMgTm9kZU1hbmFnZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBJdCdzIHZhbHVlIGlzIFwidGV4dFwiLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgYSB0ZXh0IG5vZGUgaGFzIG1hcmt1cCwgYW5kIGNyZWF0ZXMgYSBUZXh0TWFuYWdlciBpZiBpdCBkb2VzLlxyXG4gICAgICAgICAgICAgKiBBbiBUZXh0TWFuYWdlciByZXNwb25zaWJsZSBmb3IgbWFya3VwIGluIHRoZSBwYXNzZWQgaW4gbm9kZSBvciBhbiBlbXB0eVxyXG4gICAgICAgICAgICAgKiBUZXh0TWFuYWdlciBpZiBub3QgbWFya3VwIGlzIGZvdW5kIHdpbGwgYmUgYWRkZWQgdG8gdGhlIG1hbmFnZXJzIGFycmF5LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIE5vZGUgdXNlZCB0byBmaW5kIG1hcmt1cC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudCBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIGZvciB0aGUgbm9kZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRleHRNYW5hZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUubm9kZVZhbHVlLCBtYW5hZ2VyID0gbmV3IFRleHRNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoTm9kZU1hbmFnZXIuaGFzTWFya3VwKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uc18xID0gTm9kZU1hbmFnZXIuZmluZE1hcmt1cCh2YWx1ZSksIG1hcF8xID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBleHByZXNzaW9uc18xXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKG1hcF8xLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKG51bGwsIHBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VyLmJpbmQgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbG9uZXMgYW4gSU5vZGVNYXAgd2l0aCBhIG5ldyB0ZXh0IG5vZGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlTWFwfSBzb3VyY2VNYXAgVGhlIG9yaWdpbmFsIElOb2RlTWFwLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgVGhlIG5ldyB0ZXh0IG5vZGUgdXNlZCBmb3IgY2xvbmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFRleHRNYW5hZ2VyLl9jbG9uZU5vZGVNYXAgPSBmdW5jdGlvbiAoc291cmNlTWFwLCBuZXdOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHNvdXJjZU1hcC5ub2Rlc1swXSwgbm9kZU1hcCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlczogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25zOiBub2RlLmV4cHJlc3Npb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU5hbWU6IG5vZGUubm9kZU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBuZXdOb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVNYXA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDbG9uZXMgYSBUZXh0TWFuYWdlciB3aXRoIGEgbmV3IHRleHQgbm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuTm9kZU1hbmFnZXJ9IHNvdXJjZU1hbmFnZXIgVGhlIG9yaWdpbmFsIE5vZGVNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5ldyB0ZXh0IG5vZGUgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGNsb25lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gcGFyZW50IFRoZSBwYXJlbnQgRWxlbWVudE1hbmFnZXJcclxuICAgICAgICAgICAgICogZm9yIHRoZSBuZXcgY2xvbmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZXh0TWFuYWdlci5fY2xvbmUgPSBmdW5jdGlvbiAoc291cmNlTWFuYWdlciwgbm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gc291cmNlTWFuYWdlci5ub2RlTWFwLCBtYW5hZ2VyID0gbmV3IFRleHRNYW5hZ2VyKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChtYXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFuYWdlci5pbml0aWFsaXplKFRleHRNYW5hZ2VyLl9jbG9uZU5vZGVNYXAobWFwLCBub2RlKSwgcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZShudWxsLCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZXIuYmluZCA9IG5vb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFuYWdlcjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsb25lcyB0aGlzIFRleHRNYW5hZ2VyIHdpdGggYSBuZXcgbm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlIFRoZSBuZXcgbm9kZSBhdHRhY2hlZCB0byB0aGUgY2xvbmVkIFRleHRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gcGFyZW50TWFuYWdlciBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIGZvciB0aGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZXh0TWFuYWdlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobmV3Tm9kZSwgcGFyZW50TWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgVGV4dE1hbmFnZXIuX2Nsb25lKHRoaXMsIG5ld05vZGUsIHBhcmVudE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdXNlZCBmb3IgZGF0YS1iaW5kaW5nIGEgZGF0YSBjb250ZXh0IHRvIHRoZSBET00uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBUZXh0TWFuYWdlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudENvbnRyb2woKSwgbm9kZSA9IHRoaXMubm9kZU1hcC5ub2Rlc1swXSwgdGV4dE5vZGUgPSBub2RlLm5vZGUsIGV4cHJlc3Npb25zID0gbm9kZS5leHByZXNzaW9ucztcclxuICAgICAgICAgICAgICAgIE5vZGVNYW5hZ2VyLm9ic2VydmVFeHByZXNzaW9ucyhub2RlLmV4cHJlc3Npb25zLCBwYXJlbnQsIHRoaXMuX3NldFRleHQuYmluZCh0aGlzLCB0ZXh0Tm9kZSwgcGFyZW50LCBleHByZXNzaW9ucykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VGV4dCh0ZXh0Tm9kZSwgcGFyZW50LCBleHByZXNzaW9ucyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBCdWlsZHMgdGhlIG5vZGUgZXhwcmVzc2lvbiBhbmQgc2V0cyB0aGUgdmFsdWUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gTm9kZSBUaGUgYXNzb2NpYXRlZCBub2RlIHdob3NlIHZhbHVlIHdpbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuVGVtcGxhdGVDb250cm9sfSBjb250cm9sIFRoZSBjb250cm9sIHdob3NlIGNvbnRleHQgd2lsbCBiZSB1c2VkIHRvIGJpbmRcclxuICAgICAgICAgICAgICogdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5leHByZXNzaW9ucy5JUGFyc2VkRXhwcmVzc2lvbj59IGV4cHJlc3Npb25zIEFuIGFycmF5IG9mIHBhcnNlZCBleHByZXNzaW9ucyB1c2VkIHRvIGJ1aWxkXHJcbiAgICAgICAgICAgICAqIHRoZSBub2RlIHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVGV4dE1hbmFnZXIucHJvdG90eXBlLl9zZXRUZXh0ID0gZnVuY3Rpb24gKG5vZGUsIGNvbnRyb2wsIGV4cHJlc3Npb25zKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9IE5vZGVNYW5hZ2VyLmJ1aWxkKGV4cHJlc3Npb25zLCAoY29udHJvbCB8fCB7fSkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dE1hbmFnZXI7XHJcbiAgICAgICAgfShOb2RlTWFuYWdlcikpO1xyXG4gICAgICAgIHByb2Nlc3NpbmcuVGV4dE1hbmFnZXIgPSBUZXh0TWFuYWdlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBJVGV4dE1hbmFnZXJGYWN0b3J5KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gVGV4dE1hbmFnZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb2Nlc3NpbmcuSVRleHRNYW5hZ2VyRmFjdG9yeSA9IElUZXh0TWFuYWdlckZhY3Rvcnk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1RleHRNYW5hZ2VyRmFjdG9yeSwgSVRleHRNYW5hZ2VyRmFjdG9yeSwgbnVsbCwgX19GQUNUT1JZKTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fVGV4dE1hbmFnZXJJbnN0YW5jZSwgVGV4dE1hbmFnZXIsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2xhc3MgdXNlZCB0byBtYW5hZ2UgQ29tbWVudCBub2Rlcy4gUHJvdmlkZXMgYSB3YXkgdG9cclxuICAgICAgICAgKiBjbG9uZSBhIENvbW1lbnQgbm9kZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ29tbWVudE1hbmFnZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQ29tbWVudE1hbmFnZXIsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvbW1lbnRNYW5hZ2VyKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNwZWNpZmllcyB0aGUgdHlwZSBmb3IgdGhpcyBOb2RlTWFuYWdlci5cclxuICAgICAgICAgICAgICAgICAqIEl0J3MgdmFsdWUgaXMgXCJjb21tZW50XCIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9ICdjb21tZW50JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDb21tZW50TWFuYWdlciBmb3IgdGhlIGdpdmVuIENvbW1lbnQgbm9kZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBDb21tZW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBuZXcgbWFuYWdlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnByb2Nlc3NpbmcuRWxlbWVudE1hbmFnZXJ9IHBhcmVudCBUaGUgcGFyZW50XHJcbiAgICAgICAgICAgICAqIEVsZW1lbnRNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ29tbWVudE1hbmFnZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbmFnZXIgPSBuZXcgQ29tbWVudE1hbmFnZXIoKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuaW5pdGlhbGl6ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZXM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgICAgICAgICB9LCBwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hbmFnZXI7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG1ldGhvZCBmb3IgY2xvbmluZyB0aGlzIG1hbmFnZXIgd2l0aCBhIG5ldyBDb21tZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgVGhlIG5ldyBDb21tZW50IG5vZGUgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGNsb25lZFxyXG4gICAgICAgICAgICAgKiBtYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucHJvY2Vzc2luZy5FbGVtZW50TWFuYWdlcn0gcGFyZW50TWFuYWdlciBUaGUgcGFyZW50IEVsZW1lbnRNYW5hZ2VyXHJcbiAgICAgICAgICAgICAqIGZvciB0aGUgY2xvbmUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBDb21tZW50TWFuYWdlci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAobmV3Tm9kZSwgcGFyZW50TWFuYWdlcikge1xyXG4gICAgICAgICAgICAgICAgQ29tbWVudE1hbmFnZXIuY3JlYXRlKG5ld05vZGUsIHBhcmVudE1hbmFnZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBDb21tZW50TWFuYWdlcjtcclxuICAgICAgICB9KE5vZGVNYW5hZ2VyKSk7XHJcbiAgICAgICAgcHJvY2Vzc2luZy5Db21tZW50TWFuYWdlciA9IENvbW1lbnRNYW5hZ2VyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElDb21tZW50TWFuYWdlckZhY3RvcnkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb21tZW50TWFuYWdlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvY2Vzc2luZy5JQ29tbWVudE1hbmFnZXJGYWN0b3J5ID0gSUNvbW1lbnRNYW5hZ2VyRmFjdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQ29tbWVudE1hbmFnZXJGYWN0b3J5LCBJQ29tbWVudE1hbmFnZXJGYWN0b3J5LCBudWxsLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19Db21tZW50TWFuYWdlckluc3RhbmNlLCBDb21tZW50TWFuYWdlciwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCB0byBmYWNpbGl0YXRlIG9ic2VydmluZyBleHByZXNzaW9ucyBvbiBhdHRyaWJ1dGVzLiBIYXMgdGhlIGFiaWxpdHkgdG8gYWxlcnQgQXR0cmlidXRlc1xyXG4gICAgICAgICAqIHdpdGggY2hhbmdlcy4gSGFuZGxlcyBkeW5hbWljIGFuZCBzdGF0aWMgYXR0cmlidXRlcyAoZHluYW1pYyBtZWFuaW5nIFwiY2xhc3NcIi1saWtlIGF0dHJpYnV0ZXMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBBdHRyaWJ1dGVNYW5hZ2VyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQXR0cmlidXRlTWFuYWdlcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIGZpbmRpbmcgbWFya3VwIGluIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrdXBSZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgKyBfX3N0YXJ0U3ltYm9sICsgXCJbXFxcXFNcXFxcc10qP1wiICsgX19lbmRTeW1ib2wgKyBcIlxcXFxTKlxcXFxzKnxcXFxccypcXFxcUypcIiArIF9fc3RhcnRTeW1ib2wgKyBcIltcXFxcU1xcXFxzXSo/XCIgKyBfX2VuZFN5bWJvbCArIFwiXFxcXFMqXCIsICdnJyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBib3VuZCB2YWx1ZXMgb2YgYSBcImR5bmFtaWNcIiBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RWYWx1ZXMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBBdHRyaWJ1dGVNYW5hZ2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQXR0cmlidXRlTWFuYWdlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW5hZ2VyID0gbmV3IEF0dHJpYnV0ZU1hbmFnZXIoKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZXIuX05vZGVNYW5hZ2VyID0gYWNxdWlyZShfX05vZGVNYW5hZ2VyU3RhdGljKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIG1hbmFnZXIgYW5kIGRldGVybWluZXMgd2hhdCBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gaGFuZGxlIGF0dHJpYnV0ZSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhpcyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5wcm9jZXNzaW5nLklOb2RlfSBub2RlIFRoZSBJTm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5UZW1wbGF0ZUNvbnRyb2x9IHBhcmVudCBUaGUgcGFyZW50IGNvbnRyb2wgZm9yIGFsbCB0aGUgY29udHJvbHMgYXNzb2NpYXRlZCB3aXRoXHJcbiAgICAgICAgICAgICAqIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQuQ29udHJvbD59IGNvbnRyb2xzIFRoZSBjb250cm9scyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVwbGFjZT8gV2hldGhlciBvciBub3QgdGhlIGVsZW1lbnQgaXMgcmVwbGFjZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBBdHRyaWJ1dGVNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5vZGUsIHBhcmVudCwgY29udHJvbHMsIHJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9scyA9IGNvbnRyb2xzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlID0gcmVwbGFjZTtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lICE9PSAnY2xhc3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkID0gdGhpcy5fc3RhdGljQXR0cmlidXRlQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZCA9IHRoaXMuX2R5bmFtaWNBdHRyaWJ1dGVDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBjaGFuZ2VzIHRvIGR5bmFtaWMgYXR0cmlidXRlcy4gVGFrZXMgaW50byBhY2NvdW50IHRoYXQgdGhlIGF0dHJpYnV0ZSBtYXkgaGF2ZSBiZWVuIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseSwgYW5kXHJcbiAgICAgICAgICAgICAqIHdlIG5lZWQgdG8gb25seSBtdXRhdGUgdGhlIHBpZWNlIG9mIHRoZSBhdHRyaWJ1dGUgY29ycmVzcG9uZGluZyB0byBleHByZXNzaW9ucyB3aXRoIG1hcmt1cC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEF0dHJpYnV0ZU1hbmFnZXIucHJvdG90eXBlLl9keW5hbWljQXR0cmlidXRlQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLCBhdHRyID0gbm9kZS5ub2RlLCBub2RlVmFsdWUgPSBhdHRyLnZhbHVlLCBjbGFzc2VzID0gdGhpcy5fTm9kZU1hbmFnZXIuYnVpbGQobm9kZS5leHByZXNzaW9ucywgdGhpcy5wYXJlbnQpLnRyaW0oKS5zcGxpdCgvXFxzLyksIGxhc3QgPSB0aGlzLl9sYXN0VmFsdWVzLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBjLCBsZW5ndGggPSBjbGFzc2VzLmxlbmd0aCwgaTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9Ob2RlTWFuYWdlci5oYXNNYXJrdXAobm9kZVZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHIudmFsdWUgPSBub2RlVmFsdWUucmVwbGFjZSh0aGlzLl9tYXJrdXBSZWdleCwgJycpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RbY2xhc3Nlc1tpXV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IE9iamVjdC5rZXlzKGxhc3QpO1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gY2xhc3Nlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gY2xhc3Nlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFtjXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhlbGVtZW50LCBjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFtjXSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkobGFzdCwgYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX25vdGlmeUF0dHJpYnV0ZXMobm9kZS5ub2RlTmFtZSwgYXR0ci52YWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGNoYW5nZXMgdG8gc3RhdGljIGF0dHJpYnV0ZXMuIEJ1aWxkcyBhIHN0cmluZyBmcm9tIHRoZSBub2RlIGV4cHJlc3Npb25zLCB0aGVuIHNldHMgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBhbmQgbm90aWZpZXMgdGhlIGFzc29jaWF0ZWQgQXR0cmlidXRlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEF0dHJpYnV0ZU1hbmFnZXIucHJvdG90eXBlLl9zdGF0aWNBdHRyaWJ1dGVDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gdGhpcy5fY29udHJvbHMsIG5vZGUgPSB0aGlzLm5vZGUsIGtleSA9IGNhbWVsQ2FzZShub2RlLm5vZGVOYW1lKSwgdmFsdWUgPSB0aGlzLl9Ob2RlTWFuYWdlci5idWlsZChub2RlLmV4cHJlc3Npb25zLCB0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnlBdHRyaWJ1dGVzKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGxhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGUudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vdGlmaWVzIHRoZSBuZWNlc3NhcnkgQXR0cmlidXRlcyBvZiBjaGFuZ2VzIHRvIGFuIGF0dHJpYnV0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEF0dHJpYnV0ZU1hbmFnZXIucHJvdG90eXBlLl9ub3RpZnlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9scyA9IHRoaXMuX2NvbnRyb2xzLCBsZW5ndGggPSBjb250cm9scy5sZW5ndGgsIGF0dHJpYnV0ZXMsIG9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBjb250cm9sc1tpXS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gYXR0cmlidXRlc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuX2F0dHJpYnV0ZUNoYW5nZWQoa2V5LCB2YWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQXR0cmlidXRlTWFuYWdlcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHByb2Nlc3NpbmcuQXR0cmlidXRlTWFuYWdlciA9IEF0dHJpYnV0ZU1hbmFnZXI7XHJcbiAgICB9KShwcm9jZXNzaW5nID0gcGxhdF8xLnByb2Nlc3NpbmcgfHwgKHBsYXRfMS5wcm9jZXNzaW5nID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgYWxsIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byByb3V0aW5nIGNvbXBvbmVudHMgaW4gcGxhdHlwdXMuXHJcbiAgICAgKi9cclxuICAgIHZhciByb3V0aW5nO1xyXG4gICAgKGZ1bmN0aW9uIChyb3V0aW5nKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGllcyB0aGUgYnJvd3NlciBhbmQgcm91dGVycyB0b2dldGhlciwgZmFjaWxpdGF0aW5nIGFwcCBuYXZpZ2F0aW9uIGF0IGV2ZXJ5IHJvdXRlciBsZXZlbC5cclxuICAgICAgICAgKiBMaXN0ZW5zIGZvciB1cmwgY2hhbmdlcyBhbmQgcmVzcG9uZHMgYWNjb3JkaW5nbHkuIEFsc28gY29udGFpbnMgZnVuY3Rpb25hbGl0eSBmb3IgZ2VuZXJhdGluZ1xyXG4gICAgICAgICAqIGFuZCBjaGFuZ2luZyB0aGUgdXJsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBOYXZpZ2F0b3IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBOYXZpZ2F0b3IoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgdW5pcXVlIGlkLCBjcmVhdGVkIGR1cmluZyBpbnN0YW50aWF0aW9uIGFuZCBmb3VuZCBvbiBldmVyeSBOYXZpZ2F0b3IuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudWlkID0gdW5pcXVlSWQoX19QbGF0KTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3RhdGVzIHdoZXRoZXIgb3Igbm90IHRoZSBOYXZpZ2F0b3IgaXMgdGhlIHJvb3QgTmF2aWdhdG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzUm9vdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIG1ldGhvZCB0byBjYWxsIHRvIHN0b3AgbGlzdGVuaW5nIGZvciB1cmwgY2hhbmdlcywgb25seSB3b3JrcyBvbiB0aGUgcm9vdCBuYXZpZ2F0b3IuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVVybExpc3RlbmVyID0gbm9vcDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSBtZXRob2QgdG8gY2FsbCB0byBzdG9wIGxpc3RlbmluZyBmb3IgdXJsIGNoYW5nZXMsIG9ubHkgd29ya3Mgb24gdGhlIHJvb3QgbmF2aWdhdG9yLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pZ25vcmVPbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IG5hdmlnYXRpb24gaXMgYSBiYWNrd2FyZCBuYXZpZ2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tOYXZpZ2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyB0aGlzIE5hdmlnYXRvciB3aXRoIGEgcm91dGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5Sb3V0ZXJ9IHJvdXRlciBUaGUgcm91dGVyIHRoYXQgdGhlIG5hdmlnYXRvciBzaG91bGQgdXNlIHRvIG1hdGNoL2dlbmVyYXRlIHJvdXRlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JvdXRlciA9IHJvdXRlcjtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChyb3V0ZXIpICYmIHJvdXRlci5pc1Jvb3QgJiYgIWlzT2JqZWN0KE5hdmlnYXRvci5fcm9vdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUm9vdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgTmF2aWdhdG9yLl9yb290ID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vYnNlcnZlVXJsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUZWxscyB0aGUgbmF2aWdhdG9yIHRvIG5hdmlnYXRlIHRvIHRoZSB1cmwgcmVnaXN0ZXJlZCBmb3IgYSBwYXJ0aWN1bGFyIHZpZXcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2aWV3IFRoZSB2aWV3IHRvIHdoaWNoIHRoZSBOYXZpZ2F0b3Igc2hvdWxkIG5hdmlnYXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JTmF2aWdhdGVPcHRpb25zfSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHVybCBhbmQgcGVyZm9ybSBuYXZpZ2F0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmF2aWdhdG9yLnByb3RvdHlwZS5uYXZpZ2F0ZSA9IGZ1bmN0aW9uICh2aWV3LCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGlzT2JqZWN0KG9wdGlvbnMpID8gb3B0aW9ucyA6IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5hdmlnYXRpbmcoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pc1VybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSB2aWV3O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gX3RoaXMuX2dlbmVyYXRlKHZpZXcsIG9wdGlvbnMucGFyYW1ldGVycywgb3B0aW9ucy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXJpYWxpemUgdXJsIGZyb20gaW5wdXQgcGFyYW1ldGVycywgY2hlY2sgeW91ciB2aWV3IHJlZmVyZW5jZS4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcihlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fbmF2aWdhdGUodXJsLCBvcHRpb25zLnJlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIG5hdmlnYXRpb24gaGFzIGZpbmlzaGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmF2aWdhdG9yLnByb3RvdHlwZS5maW5pc2hOYXZpZ2F0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlciA9IE5hdmlnYXRvci5fcm9vdC5fcm91dGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlci5uYXZpZ2F0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlci5maW5pc2hOYXZpZ2F0aW5nLmNhdGNoKG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVsbHMgdGhlIHJvdXRlciB0byBnbyBiYWNrIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLmdvQmFjayA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGlzT2JqZWN0KG9wdGlvbnMpID8gb3B0aW9ucyA6IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IE51bWJlcihvcHRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOYXZpZ2F0b3IuX3Jvb3QuZ29CYWNrKG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTmF2aWdhdGluZygpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9iYWNrTmF2aWdhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZ29CYWNrKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGlzIGEgYmFja3dhcmQgbmF2aWdhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUuaXNCYWNrTmF2aWdhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF2aWdhdG9yLl9yb290LmlzQmFja05hdmlnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iYWNrTmF2aWdhdGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMZXRzIHRoZSByb3V0ZXIgZGlzcG9zZSBvZiBhbGwgb2YgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmF2aWdhdG9yLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVXJsTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHRoaXMsICdyb3V0ZXInKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludGVybmFsIG1ldGhvZCBmb3IgbmF2aWdhdGluZyB0byB0aGUgc3BlY2lmaWVkIHVybC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUuX25hdmlnYXRlID0gZnVuY3Rpb24gKHVybCwgcmVwbGFjZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTmF2aWdhdG9yLl9yb290Ll9uYXZpZ2F0ZSh1cmwsIHJlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVqZWN0TmF2aWdhdGUgPSByZWplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBfdGhpcy5fYnJvd3Nlci51cmwoKSwgbmV4dCA9IF90aGlzLl9icm93c2VyLnVybCh1cmwsIHJlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlTmF2aWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEludGVybmFsIG1ldGhvZCBmb3IgZ29pbmcgYmFjayBhIGNlcnRhaW4gbGVuZ3RoIGluIGhpc3RvcnlcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE5hdmlnYXRvci5wcm90b3R5cGUuX2dvQmFjayA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNvbHZlTmF2aWdhdGUgPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWplY3ROYXZpZ2F0ZSA9IHJlamVjdDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYnJvd3Nlci5iYWNrKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSByb290IG5hdmlnYXRvciB3aWxsIGFsd2F5cyBvYnNlcnZlIGZvciB1cmwgY2hhbmdlcyBhbmQgaGFuZGxlIHRoZW0gYWNjb3JkaW5nbHkuIFRoaXMgbWVhbnMgaW5zdHJ1Y3RpbmcgdGhlXHJcbiAgICAgICAgICAgICAqIHJvdXRlciB0byBuYXZpZ2F0ZSwgYW5kIGRldGVybWluaW5nIHdoYXQgdG8gZG8gaW4gdGhlIGV2ZW50IHRoYXQgbmF2aWdhdGlvbiBpcyBwcmV2ZW50ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLl9vYnNlcnZlVXJsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QodGhpcy5fcm91dGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBFdmVudE1hbmFnZXIgPSB0aGlzLl9FdmVudE1hbmFnZXIsIHByZXZpb3VzVXJsLCBoZWFkQ29udHJvbCA9IGFjcXVpcmUoX19IZWFkKSwgaGVhZEV4aXN0cyA9IGlzT2JqZWN0KGhlYWRDb250cm9sKSAmJiBpc0Z1bmN0aW9uKGhlYWRDb250cm9sLm5hdmlnYXRlZCksIG9uRmFpbGVkTmF2aWdhdG9uID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmlvdXNVcmwgPSBwcmV2aW91c1VybDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2hpc3RvcnkgPSBfdGhpcy5faGlzdG9yeSwgc3RhdGUgPSBfaGlzdG9yeS5zdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faWdub3JlT25jZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChzdGF0ZS5wcmV2aW91c0xvY2F0aW9uKSB8fCBzdGF0ZS5wcmV2aW91c0xvY2F0aW9uID09PSBwcmV2aW91c1VybCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGlzdG9yeS5nbygtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGlzdG9yeS5nbygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2JhY2tOYXZpZ2F0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLl9yZWplY3ROYXZpZ2F0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlamVjdE5hdmlnYXRlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1VybCA9IHRoaXMuX2Jyb3dzZXIudXJsKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgYWNjaWRlbnRhbGx5IGNhbGxpbmcgdGhpcyBtZXRob2QgdHdpY2UuIFxyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLmRpc3Bvc2UodGhpcy51aWQpO1xyXG4gICAgICAgICAgICAgICAgRXZlbnRNYW5hZ2VyLm9uKHRoaXMudWlkLCBfX2JhY2tCdXR0b24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXYgPSBFdmVudE1hbmFnZXIuZGlzcGF0Y2goX19iYWNrQnV0dG9uUHJlc3NlZCwgX3RoaXMsIEV2ZW50TWFuYWdlci5ESVJFQ1QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ29CYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5vbih0aGlzLnVpZCwgX191cmxDaGFuZ2VkLCBmdW5jdGlvbiAoZXYsIHV0aWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pZ25vcmVPbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pZ25vcmVPbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLl9yZXNvbHZlTmF2aWdhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmFja05hdmlnYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1VybCA9IF90aGlzLl9wcmV2aW91c1VybDtcclxuICAgICAgICAgICAgICAgICAgICBldiA9IEV2ZW50TWFuYWdlci5kaXNwYXRjaChfX2JlZm9yZU5hdmlnYXRlLCBfdGhpcywgRXZlbnRNYW5hZ2VyLkRJUkVDVCwgW3V0aWxzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25GYWlsZWROYXZpZ2F0b24obmV3IEVycm9yKCdOYXZpZ2F0aW9uIHByZXZlbnRlZCBkdXJpbmcgJyArIF9fYmVmb3JlTmF2aWdhdGUgKyAnIGV2ZW50JykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmlzaE5hdmlnYXRpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50TWFuYWdlci5kaXNwYXRjaChfX25hdmlnYXRpbmcsIF90aGlzLCBFdmVudE1hbmFnZXIuRElSRUNULCBbdXRpbHNdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9yb3V0ZXIubmF2aWdhdGUodXRpbHMucGF0aG5hbWUsIHV0aWxzLnF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzVXJsID0gdXRpbHMucGF0aG5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKF90aGlzLl9yZXNvbHZlTmF2aWdhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYmFja05hdmlnYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZU5hdmlnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRDb250cm9sLm5hdmlnYXRlZCh1dGlscy5ocmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBFdmVudE1hbmFnZXIuZGlzcGF0Y2goX19uYXZpZ2F0ZWQsIF90aGlzLCBFdmVudE1hbmFnZXIuRElSRUNULCBbdXRpbHNdKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBvbkZhaWxlZE5hdmlnYXRvbik7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdlbmVyYXRlcyBhIHVybCB3aXRoIHRoZSBnaXZlbiB2aWV3LCBwYXJhbWV0ZXJzLCBhbmQgcXVlcnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IucHJvdG90eXBlLl9nZW5lcmF0ZSA9IGZ1bmN0aW9uICh2aWV3LCBwYXJhbWV0ZXJzLCBxdWVyeSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLl9yb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodmlldykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlldztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXIuZ2VuZXJhdGUodmlldywgcGFyYW1ldGVycywgcXVlcnkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBOYXZpZ2F0b3IuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgICAgICBfSW5qZWN0b3I6IF9fSW5qZWN0b3JTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBfYnJvd3NlckNvbmZpZzogX19Ccm93c2VyQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgX2Jyb3dzZXI6IF9fQnJvd3NlcixcclxuICAgICAgICAgICAgICAgIF9FdmVudE1hbmFnZXI6IF9fRXZlbnRNYW5hZ2VyU3RhdGljLFxyXG4gICAgICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgICAgICBfbG9nOiBfX0xvZyxcclxuICAgICAgICAgICAgICAgIF9oaXN0b3J5OiBfX0hpc3RvcnlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIE5hdmlnYXRvcjtcclxuICAgICAgICB9KCkpO1xyXG4gICAgICAgIHJvdXRpbmcuTmF2aWdhdG9yID0gTmF2aWdhdG9yO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19OYXZpZ2F0b3JJbnN0YW5jZSwgTmF2aWdhdG9yLCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBIaXN0b3J5KF93aW5kb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF93aW5kb3cuaGlzdG9yeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm91dGluZy5IaXN0b3J5ID0gSGlzdG9yeTtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fSGlzdG9yeSwgSGlzdG9yeSwgW19fV2luZG93XSk7XHJcbiAgICAgICAgdmFyIHNwZWNpYWxDaGFyYWN0ZXJzID0gW1xyXG4gICAgICAgICAgICAnLycsICcuJywgJyonLCAnKycsICc/JywgJ3wnLFxyXG4gICAgICAgICAgICAnKCcsICcpJywgJ1snLCAnXScsICd7JywgJ30nLCAnXFxcXCdcclxuICAgICAgICBdLCBlc2NhcGVSZWdleCA9IG5ldyBSZWdFeHAoJyhcXFxcJyArIHNwZWNpYWxDaGFyYWN0ZXJzLmpvaW4oJ3xcXFxcJykgKyAnKScsICdnJyk7XHJcbiAgICAgICAgdmFyIGJhc2VTZWdtZW50LCBkeW5hbWljU2VnbWVudHMgPSB7fSwgc3BsYXRTZWdtZW50cyA9IHt9LCBzdGF0aWNTZWdtZW50cyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHNlZ21lbnQsIHB1Ymxpc2hlcyBhIHJlZ2V4IGZvciBtYXRjaGluZyB0aGUgc2VnbWVudCBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyB0aGUgc2VnbWVudCBhbmQgaXRlcmF0aW5nIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJhc2VTZWdtZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZVNlZ21lbnQoKSB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlbm90ZXMgdGhlIHR5cGUgb2Ygc2VnbWVudCBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gX19CQVNFX1NFR01FTlRfVFlQRTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucmVnZXggPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUGFyc2VzIGEgcm91dGUgaW50byBzZWdtZW50cywgcG9wdWxhdGluZyBhbiBhcnJheSBvZiBuYW1lcyAoZm9yIGR5bmFtaWMgYW5kIHNwbGF0IHNlZ21lbnRzKSBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICAgICAqIGFuIElTZWdtZW50VHlwZUNvdW50IG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlIFRoZSByb3V0ZSB0byBwYXJzZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBuYW1lcyBBbiBhcnJheSB0byBwb3B1bGF0ZSB3aXRoIGR5bmFtaWMvc3BsYXQgc2VnbWVudCBuYW1lc1xyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JU2VnbWVudFR5cGVDb3VudH0gdHlwZXMgQW4gb2JqZWN0IHRvIHVzZSBmb3IgY291bnRpbmcgc2VnbWVudCB0eXBlcyBpbiB0aGUgcm91dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU2VnbWVudC5wYXJzZSA9IGZ1bmN0aW9uIChyb3V0ZSwgbmFtZXMsIHR5cGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHJvdXRlKSB8fCAhaXNBcnJheShuYW1lcykgfHwgIWlzT2JqZWN0KHR5cGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJvdXRlWzBdID09PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJvdXRlLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gcm91dGUuc3BsaXQoJy8nKSwgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoLCBmaW5kU2VnbWVudCA9IEJhc2VTZWdtZW50Ll9fZmluZFNlZ21lbnQsIHJlc3VsdHMgPSBbXSwgc2VnbWVudCwgbmFtZSwgbWF0Y2gsIF9yZWdleCA9IEJhc2VTZWdtZW50Ll9yZWdleDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QoYmFzZVNlZ21lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlU2VnbWVudCA9IGFjcXVpcmUoX19CYXNlU2VnbWVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goYmFzZVNlZ21lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaCA9IHNlZ21lbnQubWF0Y2goX3JlZ2V4LmR5bmFtaWNTZWdtZW50c1JlZ2V4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaW5kU2VnbWVudChuYW1lLCBfX0R5bmFtaWNTZWdtZW50SW5zdGFuY2UsIGR5bmFtaWNTZWdtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlcy5keW5hbWljcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaCA9IHNlZ21lbnQubWF0Y2goX3JlZ2V4LnNwbGF0U2VnbWVudFJlZ2V4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gbWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaW5kU2VnbWVudChuYW1lLCBfX1NwbGF0U2VnbWVudEluc3RhbmNlLCBzcGxhdFNlZ21lbnRzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzLnNwbGF0cysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpbmRTZWdtZW50KHNlZ21lbnQsIF9fU3RhdGljU2VnbWVudEluc3RhbmNlLCBzdGF0aWNTZWdtZW50cykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlcy5zdGF0aWNzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSByb3V0ZSBpbnRvIHNlZ21lbnRzLCBwb3B1bGF0aW5nIGFuIGFycmF5IG9mIG5hbWVzIChmb3IgZHluYW1pYyBhbmQgc3BsYXQgc2VnbWVudHMpIGFzIHdlbGwgYXNcclxuICAgICAgICAgICAgICogYW4gSVNlZ21lbnRUeXBlQ291bnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc2VnbWVudCB0byBsb29rIGZvci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB1c2VkIHRvIGFjcXVpcmUgYSBuZXcgc2VnbWVudCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHBsYXQucm91dGluZy5CYXNlU2VnbWVudD59IGNhY2hlIFRoZSBjYWNoZSBpbiB3aGljaCB0byBsb29rIGZvci9zdG9yZSB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJhc2VTZWdtZW50Ll9fZmluZFNlZ21lbnQgPSBmdW5jdGlvbiAobmFtZSwgdG9rZW4sIGNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudCA9IGNhY2hlW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChzZWdtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBjYWNoZVtuYW1lXSA9IGFjcXVpcmUodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQuaW5pdGlhbGl6ZShuYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWdtZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lPyBUaGUgbmFtZSBmb3IgdGhlIG5ldyBzZWdtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmFzZVNlZ21lbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQsIGNhbGxpbmcgYW4gaXRlcmF0b3IgbWV0aG9kIGFuZCBhY2N1bXVsYXRpbmcgdGhlIHJlc3VsdCBvZiBlYWNoIGNhbGwgaW5cclxuICAgICAgICAgICAgICogYSBkZWZpbmVkIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsocHJldmlvdXNWYWx1ZTogVCwgc3BlYzogcGxhdC5yb3V0aW5nLklDaGFyYWN0ZXJTcGVjaWZpY2F0aW9uKSA9PiBUfSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY2FsbCB3aXRoIGVhY2ggY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1R9IGluaXRpYWxWYWx1ZT8gQW4gb3B0aW9uYWwgaW5pdGlhbCB2YWx1ZSB3aXRoIHdoaWNoIHRvIHN0YXJ0IHRoZSBhY2N1bXVsYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCYXNlU2VnbWVudC5wcm90b3R5cGUucmVkdWNlQ2hhcmFjdGVycyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgaW5pdGlhbFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QodGhpcy5fc3BlY2lmaWNhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBpdGVyYXRvcihpbml0aWFsVmFsdWUsIHRoaXMuX3NwZWNpZmljYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdlbmVyYXRlcyBhIG5ldyBzZWdtZW50LCB1c2luZyB0aGUgaW5wdXQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHN0cmluZz59IHBhcmFtZXRlcnM/IFRoZSBpbnB1dCBwYXJhbWV0ZXJzIGZvciB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJhc2VTZWdtZW50LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQmFzZVNlZ21lbnQ7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICByb3V0aW5nLkJhc2VTZWdtZW50ID0gQmFzZVNlZ21lbnQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gSUJhc2VTZWdtZW50RmFjdG9yeShfcmVnZXgpIHtcclxuICAgICAgICAgICAgQmFzZVNlZ21lbnQuX3JlZ2V4ID0gX3JlZ2V4O1xyXG4gICAgICAgICAgICByZXR1cm4gQmFzZVNlZ21lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvdXRpbmcuSUJhc2VTZWdtZW50RmFjdG9yeSA9IElCYXNlU2VnbWVudEZhY3Rvcnk7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX0Jhc2VTZWdtZW50RmFjdG9yeSwgSUJhc2VTZWdtZW50RmFjdG9yeSwgW19fUmVnZXhdLCBfX0ZBQ1RPUlkpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19CYXNlU2VnbWVudEluc3RhbmNlLCBCYXNlU2VnbWVudCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgc3RhdGljIHNlZ21lbnQsIHB1Ymxpc2hlcyBhIHJlZ2V4IGZvciBtYXRjaGluZyB0aGUgc2VnbWVudCBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyB0aGUgc2VnbWVudCBhbmQgaXRlcmF0aW5nIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFN0YXRpY1NlZ21lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3RhdGljU2VnbWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3RhdGljU2VnbWVudCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZW5vdGVzIHRoYXQgdGhpcyBpcyBhIHN0YXRpYyBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBfX1NUQVRJQ19TRUdNRU5UX1RZUEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZT8gVGhlIG5hbWUgZm9yIHRoZSBuZXcgc2VnbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0YXRpY1NlZ21lbnQucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbmFtZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4ID0gdGhpcy5uYW1lLnJlcGxhY2UoZXNjYXBlUmVnZXgsICdcXFxcJDEnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQsIGNhbGxpbmcgYW4gaXRlcmF0b3IgbWV0aG9kIGFuZCBhY2N1bXVsYXRpbmcgdGhlIHJlc3VsdCBvZiBlYWNoIGNhbGwgaW5cclxuICAgICAgICAgICAgICogYSBkZWZpbmVkIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsocHJldmlvdXNWYWx1ZTogVCwgc3BlYzogcGxhdC5yb3V0aW5nLklDaGFyYWN0ZXJTcGVjaWZpY2F0aW9uKSA9PiBUfSBpdGVyYXRvciBUaGUgaXRlcmF0b3IgdG8gY2FsbCB3aXRoIGVhY2ggY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1R9IGluaXRpYWxWYWx1ZT8gQW4gb3B0aW9uYWwgaW5pdGlhbCB2YWx1ZSB3aXRoIHdoaWNoIHRvIHN0YXJ0IHRoZSBhY2N1bXVsYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0aWNTZWdtZW50LnByb3RvdHlwZS5yZWR1Y2VDaGFyYWN0ZXJzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBpbml0aWFsVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lLCBsZW5ndGggPSBuYW1lLmxlbmd0aCwgdmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRvcih2YWx1ZSwgeyB2YWxpZENoYXJhY3RlcnM6IG5hbWVbaV0gfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTdGF0aWNTZWdtZW50O1xyXG4gICAgICAgIH0oQmFzZVNlZ21lbnQpKTtcclxuICAgICAgICByb3V0aW5nLlN0YXRpY1NlZ21lbnQgPSBTdGF0aWNTZWdtZW50O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19TdGF0aWNTZWdtZW50SW5zdGFuY2UsIFN0YXRpY1NlZ21lbnQsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCBhIHZhcmlhYmxlIHNlZ21lbnQgKGVpdGhlciBkeW5hbWljIG9yIHNwbGF0KSwgcHVibGlzaGVzIGEgcmVnZXggZm9yIG1hdGNoaW5nIHRoZSBzZWdtZW50IGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBtZXRob2RzIGZvciBnZW5lcmF0aW5nIHRoZSBzZWdtZW50IGFuZCBpdGVyYXRpbmcgb3ZlciB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2VnbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVmFyaWFibGVTZWdtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFZhcmlhYmxlU2VnbWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVmFyaWFibGVTZWdtZW50KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlbm90ZXMgdGhhdCB0aGlzIGlzIGEgdmFyaWFibGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gX19WQVJJQUJMRV9TRUdNRU5UX1RZUEU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdlbmVyYXRlcyBhIG5ldyBzZWdtZW50LCB1c2luZyB0aGUgaW5wdXQgcGFyYW1ldGVycy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklPYmplY3Q8c3RyaW5nPn0gcGFyYW1ldGVycz8gVGhlIGlucHV0IHBhcmFtZXRlcnMgZm9yIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgVmFyaWFibGVTZWdtZW50LnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyYW1ldGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1ldGVyc1t0aGlzLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVmFyaWFibGVTZWdtZW50O1xyXG4gICAgICAgIH0oQmFzZVNlZ21lbnQpKTtcclxuICAgICAgICByb3V0aW5nLlZhcmlhYmxlU2VnbWVudCA9IFZhcmlhYmxlU2VnbWVudDtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fVmFyaWFibGVTZWdtZW50SW5zdGFuY2UsIFZhcmlhYmxlU2VnbWVudCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BsYXQgc2VnbWVudCwgcHVibGlzaGVzIGEgcmVnZXggZm9yIG1hdGNoaW5nIHRoZSBzZWdtZW50IGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBtZXRob2RzIGZvciBnZW5lcmF0aW5nIHRoZSBzZWdtZW50IGFuZCBpdGVyYXRpbmcgb3ZlciB0aGUgY2hhcmFjdGVycyBpbiB0aGUgc2VnbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3BsYXRTZWdtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFNwbGF0U2VnbWVudCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3BsYXRTZWdtZW50KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERlbm90ZXMgdGhhdCB0aGlzIGlzIGEgc3BsYXQgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gX19TUExBVF9TRUdNRU5UX1RZUEU7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZyB3aGljaCBjYW4gYmUgdXNlZCB0byBtYXRjaCB0aGUgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWdleCA9ICcoLispJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGVjaWZpY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRDaGFyYWN0ZXJzOiAnJyxcclxuICAgICAgICAgICAgICAgICAgICByZXBlYXQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFNwbGF0U2VnbWVudDtcclxuICAgICAgICB9KFZhcmlhYmxlU2VnbWVudCkpO1xyXG4gICAgICAgIHJvdXRpbmcuU3BsYXRTZWdtZW50ID0gU3BsYXRTZWdtZW50O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19TcGxhdFNlZ21lbnRJbnN0YW5jZSwgU3BsYXRTZWdtZW50LCBudWxsLCBfX0lOU1RBTkNFKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBkeW5hbWljIHNlZ21lbnQsIHB1Ymxpc2hlcyBhIHJlZ2V4IGZvciBtYXRjaGluZyB0aGUgc2VnbWVudCBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyB0aGUgc2VnbWVudCBhbmQgaXRlcmF0aW5nIG92ZXIgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIER5bmFtaWNTZWdtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKER5bmFtaWNTZWdtZW50LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBEeW5hbWljU2VnbWVudCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZW5vdGVzIHRoYXQgdGhpcyBpcyBhIGR5bmFtaWMgc2VnbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gX19EWU5BTUlDX1NFR01FTlRfVFlQRTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hdGNoIHRoZSBzZWdtZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlZ2V4ID0gJyhbXi9dKyknO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWF0Y2ggdGhlIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwZWNpZmljYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZENoYXJhY3RlcnM6ICcvJyxcclxuICAgICAgICAgICAgICAgICAgICByZXBlYXQ6IHRydWVcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIER5bmFtaWNTZWdtZW50O1xyXG4gICAgICAgIH0oVmFyaWFibGVTZWdtZW50KSk7XHJcbiAgICAgICAgcm91dGluZy5EeW5hbWljU2VnbWVudCA9IER5bmFtaWNTZWdtZW50O1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19EeW5hbWljU2VnbWVudEluc3RhbmNlLCBEeW5hbWljU2VnbWVudCwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUm91dGUgc2VnbWVudCBtYXRjaGluZyBpcyBkb25lIHVzaW5nIGEgc3RhdGUgbWFjaGluZS4gRWFjaCBzdGF0ZSBjb250YWluc1xyXG4gICAgICAgICAqIGEgc3BlY2lmaWNhdGlvbiBpbmRpY2F0aW5nIHZhbGlkIGFuZCBpbnZhbGlkIGNoYXJhY3RlcnMuIEVhY2ggU3RhdGUgaGFzIGFcclxuICAgICAgICAgKiBsaXN0IG9mIHBvdGVudGlhbCBuZXh0IHN0YXRlcy4gV2hlbiBtYXRjaGluZyBhIHJvdXRlIHNlZ21lbnQgeW91IHN0YXJ0IHdpdGhcclxuICAgICAgICAgKiBhIHJvb3Qgc3RhdGUgYW5kIHRoZW4gaXRlcmF0aXZlbHkgbWF0Y2ggbmV4dCBzdGF0ZXMgdW50aWwgeW91IGNvbXBsZXRlIHRoZVxyXG4gICAgICAgICAqIHNlZ21lbnQgb3IgaW52YWxpZGF0ZSB0aGUgc2VnbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3RhdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIFN0YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZnVuY3Rpb24gU3RhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29tcGlsZXMgYSBzZWdtZW50IGludG8gYSBzdGF0ZSB0cmVlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5CYXNlU2VnbWVudH0gc2VnbWVudCBUaGUgc2VnbWVudCB0byBjb21waWxlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5TdGF0ZX0gc3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgd2l0aCB3aGljaCB0byBzdGFydCBjb21waWxhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0YXRlLmNvbXBpbGUgPSBmdW5jdGlvbiAoc2VnbWVudCwgc3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWdtZW50LnJlZHVjZUNoYXJhY3RlcnMoZnVuY3Rpb24gKHMsIGNoYXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5hZGQoY2hhcik7XHJcbiAgICAgICAgICAgICAgICB9LCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBMaW5rcyBhIHBhdGggdG8gYSBjb21waWxlZCBzdGF0ZSwgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuU3RhdGV9IHN0YXRlIFRoZSBzdGF0ZSB3aXRoIHdoaWNoIHRvIGxpbmsgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gbGluayB0byB0aGUgZ2l2ZW4gc3RhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5saW5rID0gZnVuY3Rpb24gKHN0YXRlLCBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVsZWdhdGVzID0gc3RhdGUuZGVsZWdhdGVzLCByZWdleCA9IHN0YXRlLnJlZ2V4LCBsZW5ndGggPSBkZWxlZ2F0ZXMubGVuZ3RoLCBtYXRjaGVzID0gcGF0aC5tYXRjaChyZWdleCksIG1hdGNoSW5kZXggPSAxLCByZXN1bHQgPSBbXSwgbmFtZXMsIHBhcmFtZXRlcnMsIGosIGpMZW5ndGgsIGRlbGVnYXRlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlID0gZGVsZWdhdGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWVzID0gZGVsZWdhdGUubmFtZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVycyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGpMZW5ndGggPSBuYW1lcy5sZW5ndGg7IGogPCBqTGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc1tuYW1lc1tqXV0gPSBtYXRjaGVzW21hdGNoSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGU6IGRlbGVnYXRlLmRlbGVnYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0R5bmFtaWM6IGpMZW5ndGggPiAwXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgYWxsIHRoZSBuZXh0IHN0YXRlcyBmb3IgYSBnaXZlbiBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjaGFyYWN0ZXIgdXNlZCB0byBtYXRjaCBuZXh0IHN0YXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnJvdXRpbmcuU3RhdGU+fSBzdGF0ZXMgVGhlIHN0YXRlcyB3aXRoIHdoaWNoIHRvIG1hdGNoIHRoZSBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5yZWNvZ25pemUgPSBmdW5jdGlvbiAoY2hhciwgc3RhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlcyA9IFtdLCBsZW5ndGggPSBzdGF0ZXMubGVuZ3RoLCBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGVzID0gbmV4dFN0YXRlcy5jb25jYXQoc3RhdGUubWF0Y2goY2hhcikpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTb3J0cyBzdGF0ZXMgYnkgc3RhdGljcy9keW5hbWljcy9zcGxhdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5yb3V0aW5nLlN0YXRlPn0gc3RhdGVzIFRoZSBzdGF0ZXMgdG8gc29ydC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0YXRlLnNvcnQgPSBmdW5jdGlvbiAoc3RhdGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoc3RhdGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYVR5cGVzLCBhU3BsYXRzLCBhU3RhdGljcywgYUR5bmFtaWNzLCBiVHlwZXMsIGJTcGxhdHMsIGJTdGF0aWNzLCBiRHluYW1pY3M7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhVHlwZXMgPSBhLnR5cGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJUeXBlcyA9IGIudHlwZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgYVNwbGF0cyA9IGFUeXBlcy5zcGxhdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgYlNwbGF0cyA9IGJUeXBlcy5zcGxhdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFTcGxhdHMgIT09IGJTcGxhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFTcGxhdHMgLSBiU3BsYXRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhU3RhdGljcyA9IGFUeXBlcy5zdGF0aWNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGFEeW5hbWljcyA9IGFUeXBlcy5keW5hbWljcztcclxuICAgICAgICAgICAgICAgICAgICBiU3RhdGljcyA9IGJUeXBlcy5zdGF0aWNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJEeW5hbWljcyA9IGJUeXBlcy5keW5hbWljcztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVNwbGF0cyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFTdGF0aWNzICE9PSBiU3RhdGljcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJTdGF0aWNzIC0gYVN0YXRpY3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFEeW5hbWljcyAhPT0gYkR5bmFtaWNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYkR5bmFtaWNzIC0gYUR5bmFtaWNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhRHluYW1pY3MgIT09IGJEeW5hbWljcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUR5bmFtaWNzIC0gYkR5bmFtaWNzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYVN0YXRpY3MgIT09IGJTdGF0aWNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiU3RhdGljcyA9IGFTdGF0aWNzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHN0YXRlIHdpdGggdGhlIGdpdmVuIHNwZWNpZmljYXRpb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklDaGFyYWN0ZXJTcGVjaWZpY2F0aW9ufSBzcGVjaWZpY2F0aW9uPyBUaGUgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gZm9yIHRoZSBzdGF0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHNwZWNpZmljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BlY2lmaWNhdGlvbiA9IHNwZWNpZmljYXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGF0ZXMgPSBbXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBuZXcgc3BlY2lmaWNhdGlvbiB0byB0aGUgbmV4dCBzdGF0ZXMuIElmIHRoZSBzcGVjaWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAqIGFscmVhZHkgZXhpc3RzIGFzIGEgbmV4dCBzdGF0ZSBhIG5ldyBvbmUgd29uJ3QgYmUgdXNlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSUNoYXJhY3RlclNwZWNpZmljYXRpb259IHNwZWNpZmljYXRpb24/IFRoZSBjaGFyYWN0ZXIgc3BlY2lmaWNhdGlvbiB1c2VkIHRvIGNyZWF0ZVxyXG4gICAgICAgICAgICAgKiB0aGUgbmV4dCBzdGF0ZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdGF0ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHNwZWNpZmljYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2ZpbmQoc3BlY2lmaWNhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhdGUgPSBhY3F1aXJlKFN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLmluaXRpYWxpemUoc3BlY2lmaWNhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGF0ZXMucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3BlY2lmaWNhdGlvbi5yZXBlYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5uZXh0U3RhdGVzLnB1c2goc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgbmV4dCBzdGF0ZXMgdGhhdCBtYXRjaCB0aGUgaW5wdXQgY2hhcmFjdGVyLiBJZiB0aGUgY2hhcmFjdGVyIGV4aXN0c1xyXG4gICAgICAgICAgICAgKiBpbiB0aGUgc3RhdGUncyBzcGVjaWZpY2F0aW9uIGZvciB2YWxpZCBjaGFyYWN0ZXJzLCBvciBpZiBpdCBkb2VzIG5vdFxyXG4gICAgICAgICAgICAgKiBleGlzdCBpbiB0aGUgc3BlY2lmaWNhdGlvbiBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLCB0aGVuIHRoZSBzdGF0ZSBpcyBjb25zaWRlcmVkXHJcbiAgICAgICAgICAgICAqIGEgbWF0Y2guXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIFRoZSBjaGFyYWN0ZXIgd2l0aCB3aGljaCB0byBtYXRjaCBuZXh0IHN0YXRlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChjaGFyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IFtdLCBzcGVjLCBjaGFycztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NvbWVDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVjID0gY2hpbGQuc3BlY2lmaWNhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgdmFsaWQgY2hhcmFjdGVycyBmaXJzdCBcclxuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IHNwZWMudmFsaWRDaGFyYWN0ZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyhjaGFycykgJiYgY2hhcnMuaW5kZXhPZihjaGFyKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG5vIGludmFsaWQgY2hhcmFjdGVycyBcclxuICAgICAgICAgICAgICAgICAgICBjaGFycyA9IHNwZWMuaW52YWxpZENoYXJhY3RlcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGNoYXJzKSAmJiBjaGFycy5pbmRleE9mKGNoYXIpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyB0aGUgbmV4dCBzdGF0ZSB0aGF0IHNoYXJlcyB0aGUgc2FtZSBzcGVjaWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAqIGFzIHRoZSBpbnB1dCBzcGVjLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JQ2hhcmFjdGVyU3BlY2lmaWNhdGlvbn0gc3BlYyBUaGUgY2hhcmFjdGVyIHNwZWNpZmljYXRpb24gdXNlZCB0byBmaW5kXHJcbiAgICAgICAgICAgICAqIHRoZSBuZXh0IHN0YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3RhdGUucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWxpZENoYXJzID0gc3BlYy52YWxpZENoYXJhY3RlcnMsIGludmFsaWRDaGFycyA9IHNwZWMuaW52YWxpZENoYXJhY3RlcnMsIHMsIGZvdW5kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc29tZUNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBjaGlsZC5zcGVjaWZpY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnZhbGlkQ2hhcmFjdGVycyA9PT0gdmFsaWRDaGFycyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzLmludmFsaWRDaGFyYWN0ZXJzID09PSBpbnZhbGlkQ2hhcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZS5fc29tZUNoaWxkcmVuID0gZnVuY3Rpb24gKGl0ZXJhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFN0YXRlcyA9IHRoaXMubmV4dFN0YXRlcywgbGVuZ3RoID0gbmV4dFN0YXRlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yKG5leHRTdGF0ZXNbaV0pID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFN0YXRlO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcm91dGluZy5TdGF0ZSA9IFN0YXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElTdGF0ZVN0YXRpYygpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb3V0aW5nLklTdGF0ZVN0YXRpYyA9IElTdGF0ZVN0YXRpYztcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fU3RhdGVTdGF0aWMsIElTdGF0ZVN0YXRpYywgbnVsbCwgX19TVEFUSUMpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmluamVjdGFibGUoX19TdGF0ZUluc3RhbmNlLCBTdGF0ZSwgbnVsbCwgX19JTlNUQU5DRSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQXNzaXN0cyBpbiBjb21waWxpbmcgYW5kIGxpbmtpbmcgcm91dGUgc3RyaW5ncy4gWW91IGNhbiByZWdpc3RlciByb3V0ZSBzdHJpbmdzIHVzaW5nXHJcbiAgICAgICAgICogYSBkZWZpbmVkIHNjaGVtZSwgYW5kIGl0IHdpbGwgY29tcGlsZSB0aGUgcm91dGVzLiBXaGVuIHlvdSB3YW50IHRvIG1hdGNoIGEgcm91dGUsIGl0IHdpbGxcclxuICAgICAgICAgKiBmaW5kIHRoZSBhc3NvY2lhdGVkIGNvbXBpbGVkIHJvdXRlIGFuZCBsaW5rIGl0IHRvIHRoZSBkYXRhIGdpdmVuIHdpdGggdGhlIHBhc3NlZC1pbiByb3V0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUm91dGVSZWNvZ25pemVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUm91dGVSZWNvZ25pemVyKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbGwgdGhlIG5hbWVkIHJvdXRlcyBmb3IgdGhpcyByZWNvZ25pemVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uYW1lZFJvdXRlcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG1ldGhvZCBmb3IgcmVnaXN0ZXJpbmcgcm91dGVzIHRvIGJlIGlkZW50aWZpZWQgbGF0ZXIuIEludGVybmFsbHkgdGhlXHJcbiAgICAgICAgICAgICAqIHJvdXRlcyB3aWxsIGJlIGNvbXBpbGVkIGludG8gYSBzZXJpZXMgb2Ygc3RhdGVzXHJcbiAgICAgICAgICAgICAqIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZWNvZ25pemUgdGhlIHJvdXRlIGxhdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQucm91dGluZy5JUm91dGVEZWxlZ2F0ZT59IHJvdXRlcyBUaGUgcm91dGVzIHRvIHJlZ2lzdGVyLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUmVnaXN0ZXJPcHRpb25zfSBvcHRpb25zPyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGVcclxuICAgICAgICAgICAgICogcmVnaXN0ZXJlZCByb3V0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAocm91dGVzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkocm91dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBmaW5hbFN0YXRlID0gdGhpcy5fcm9vdFN0YXRlLCBsZW5ndGggPSByb3V0ZXMubGVuZ3RoLCByZWdleCA9IFsnXiddLCB0eXBlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0aWNzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNzOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHNwbGF0czogMFxyXG4gICAgICAgICAgICAgICAgfSwgZGVsZWdhdGVzID0gW10sIGFsbFNlZ21lbnRzID0gW10sIHNlZ21lbnRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzID0gdGhpcy5fcGFyc2Uocm91dGVzW2ldLCBkZWxlZ2F0ZXMsIHR5cGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBhbGxTZWdtZW50cyA9IGFsbFNlZ21lbnRzLmNvbmNhdChzZWdtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTdGF0ZSA9IHRoaXMuX2NvbXBpbGUoc2VnbWVudHMsIGZpbmFsU3RhdGUsIHJlZ2V4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsU3RhdGUgPSB0aGlzLl9maW5hbGl6ZShmaW5hbFN0YXRlLCByZWdleCk7XHJcbiAgICAgICAgICAgICAgICBmaW5hbFN0YXRlLmRlbGVnYXRlcyA9IGRlbGVnYXRlcztcclxuICAgICAgICAgICAgICAgIGZpbmFsU3RhdGUucmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4LmpvaW4oJycpICsgJyQnKTtcclxuICAgICAgICAgICAgICAgIGZpbmFsU3RhdGUudHlwZXMgPSB0eXBlcztcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSAmJiBpc1N0cmluZyhvcHRpb25zLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmFtZWRSb3V0ZXNbdGhpcy5fdG9Mb3dlckNhc2Uob3B0aW9ucy5uYW1lKV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRzOiBhbGxTZWdtZW50cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZWdhdGVzOiBkZWxlZ2F0ZXNcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2VhcmNoZXMgZm9yIGEgbWF0Y2ggdG8gdGhlIHByb3ZpZGVkIHBhdGguIElmIGEgbWF0Y2ggaXMgZm91bmQsIHRoZSBwYXRoIGlzIGRlY29uc3RydWN0ZWRcclxuICAgICAgICAgICAgICogdG8gcG9wdWxhdGUgYSBwYXJhbWV0ZXJzIG9iamVjdCAoaWYgdGhlIHJlZ2lzdGVyZWQgcm91dGUgd2FzIGEgZHluYW1pYy9zcGxhdCByb3V0ZSkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHJlY29nbml6ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUucmVjb2duaXplID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc1RyYWlsaW5nU2xhc2hEcm9wcGVkID0gZmFsc2UsIHNvbHV0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMuX2FkZExlYWRpbmdTbGFzaChwYXRoKTtcclxuICAgICAgICAgICAgICAgIGlzVHJhaWxpbmdTbGFzaERyb3BwZWQgPSB0aGlzLl9oYXNUcmFpbGluZ1NsYXNoKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVHJhaWxpbmdTbGFzaERyb3BwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcGF0aC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvbHV0aW9ucyA9IHRoaXMuX2ZpbHRlcih0aGlzLl9maW5kU3RhdGVzKHBhdGgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5rKHNvbHV0aW9uc1swXSwgcGF0aCwgaXNUcmFpbGluZ1NsYXNoRHJvcHBlZCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5kcyBhIElOYW1lZFJvdXRlIGFuZCBnZW5lcmF0ZXMgYSBzdHJpbmdcclxuICAgICAgICAgICAgICogaWYgaXQgZXhpc3RzLiBVc2VzIHRoZSBwYXJhbWV0ZXJzIG9iamVjdCB0byBnZW5lcmF0ZSBkeW5hbWljIHJvdXRlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWVkIHJvdXRlIHdpdGggd2hpY2ggdG8gZ2VuZXJhdGUgdGhlIHJvdXRlIHN0cmluZy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklPYmplY3Q8c3RyaW5nPn0gcGFyYW1ldGVycyBUaGUgcm91dGUgcGFyYW1ldGVycywgaW4gdGhlIGNhc2UgdGhhdCB0aGVcclxuICAgICAgICAgICAgICogbmFtZWQgcm91dGUgaXMgZHluYW1pYy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuX3RvTG93ZXJDYXNlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlID0gdGhpcy5fbmFtZWRSb3V0ZXNbbmFtZV0sIG91dHB1dCA9ICcnLCBzZWdtZW50cywgbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChyb3V0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50cyA9IHJvdXRlLnNlZ21lbnRzO1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQudHlwZSA9PT0gX19CQVNFX1NFR01FTlRfVFlQRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9ICcvJztcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc2VnbWVudC5nZW5lcmF0ZShwYXJhbWV0ZXJzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMuX2FkZExlYWRpbmdTbGFzaChvdXRwdXQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIHRoZSBkZWxlZ2F0ZXMgZm9yIGFuIElOYW1lZFJvdXRlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lZCByb3V0ZSBmcm9tIHdoaWNoIHRvIGdldCB0aGUgZGVsZWdhdGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5kZWxlZ2F0ZXNGb3IgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMuX3RvTG93ZXJDYXNlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWVkUm91dGUgPSB0aGlzLl9uYW1lZFJvdXRlc1tuYW1lXSwgZGVsZWdhdGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChuYW1lZFJvdXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGVnYXRlcyA9IG5hbWVkUm91dGUuZGVsZWdhdGVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGRlbGVnYXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVzLnNsaWNlKDApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBhbiBJTmFtZWRSb3V0ZSBpcyByZWdpc3RlcmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZWQgcm91dGUgdG8gc2VhcmNoIGZvci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuZXhpc3RzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdCh0aGlzLl9uYW1lZFJvdXRlc1t0aGlzLl90b0xvd2VyQ2FzZShuYW1lKV0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2FmZWx5IGNvbnZlcnRzIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIGxvd2VyIGNhc2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl90b0xvd2VyQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaW5hbGl6ZXMgYSBjb21waWxlZCByb3V0ZSwgYWRkaW5nIGEgZmluYWwgc3RhdGUgaWYgbmVjZXNzYXJ5LiBJZiB0aGUgc3RhdGUgaXMgZXF1YWwgdG8gdGhlXHJcbiAgICAgICAgICAgICAqIHJvb3Qgc3RhdGUgZm9yIHRoZSByZWNvZ25pemVyLCBhIG5ldyBzdGF0ZSB3aWxsIGJlIGNyZWF0ZWQuIFRoaXMgaXMgYmVjYXVzZSB0aGUgcm9vdCBzdGF0ZSBkb2VzIG5vdFxyXG4gICAgICAgICAgICAgKiByZXByZXNlbnQgYW55IHJvdXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5TdGF0ZX0gc3RhdGUgVGhlIHN0YXRlIHRvIGZpbmFsaXplLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnZXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcgYnVpbHQgZm9yIHRoZSBjb21waWxlZCByb3V0ZXMuIFVzZWQgdG8gcmVjb2duaXplXHJcbiAgICAgICAgICAgICAqIHJvdXRlcyBhbmQgYXNzb2NpYXRlIHRoZW0gd2l0aCB0aGUgY29tcGlsZWQgcm91dGVzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fZmluYWxpemUgPSBmdW5jdGlvbiAoc3RhdGUsIHJlZ2V4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IHRoaXMuX3Jvb3RTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGUuYWRkKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRDaGFyYWN0ZXJzOiAnLydcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZWdleC5wdXNoKCcvJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgYSByb3V0ZSBpbnRvIGRpZmZlcmVudCBzZWdtZW50cztcclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVJvdXRlRGVsZWdhdGV9IHJvdXRlIFRoZSByb3V0ZSBvcHRpb25zIHRvIGJlIHBhcnNlZC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0LnJvdXRpbmcuSURlbGVnYXRlUGFyYW1ldGVyTmFtZXM+fSBkZWxlZ2F0ZXMgVGhlIGRlbGVnYXRlcyBhbmQgYXNzb2NpYXRlZCBuYW1lcyBmb3IgbWFwcGluZyBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JU2VnbWVudFR5cGVDb3VudH0gdHlwZXMgQSBjb3VudCBvZiBhbGwgdGhlIHNlZ21lbnQgdHlwZXMgaW4gdGhlIHJvdXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5fcGFyc2UgPSBmdW5jdGlvbiAocm91dGUsIGRlbGVnYXRlcywgdHlwZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZGVsZWdhdGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlOiByb3V0ZS5kZWxlZ2F0ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYW1lczogbmFtZXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX0Jhc2VTZWdtZW50RmFjdG9yeS5wYXJzZShyb3V0ZS5wYXR0ZXJuLCBuYW1lcywgdHlwZXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29tcGlsZXMgYSBsaXN0IG9mIHNlZ21lbnRzIGludG8gYSBzZXJpZXMgb2Ygc3RhdGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQucm91dGluZy5CYXNlU2VnbWVudD59IHNlZ21lbnRzIFRoZSBzZWdtZW50cyB0byBjb21waWxlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5TdGF0ZX0gc3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgdXNlZCB0byBjb21waWxlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHJlZ2V4IEEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZyB0byBidWlsZCBpbiBvcmRlciB0byBtYXRjaCB0aGUgc2VnbWVudHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9jb21waWxlID0gZnVuY3Rpb24gKHNlZ21lbnRzLCBzdGF0ZSwgcmVnZXgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsIGNvbXBpbGUgPSB0aGlzLl9TdGF0ZS5jb21waWxlLCBzZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC50eXBlID09PSBfX0JBU0VfU0VHTUVOVF9UWVBFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmFkZCh7IHZhbGlkQ2hhcmFjdGVyczogJy8nIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gY29tcGlsZShzZWdtZW50LCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnZXgucHVzaCgnLycgKyBzZWdtZW50LnJlZ2V4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBsZWFkaW5nIHNsYXNoIHRvIHRoZSBwYXNzZWQtaW4gc3RyaW5nIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gd2hpY2ggdG8gYWRkIHRoZSBzbGFzaC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuX2FkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIChwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoID0gZGVjb2RlVVJJKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSAnLycgKyBwYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgZm9yIGEgdHJhaWxpbmcgc2xhc2ggb24gYSBnaXZlbiBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9uIHdoaWNoIHRvIGxvb2sgZm9yIGEgdHJhaWxpbmcgc2xhc2guXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9oYXNUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZW5ndGggPiAxICYmIHBhdGhbbGVuZ3RoIC0gMV0gPT09ICcvJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbmRzIHRoZSBjb21waWxlZCBzdGF0ZXMgZm9yIGEgZ2l2ZW4gcGF0aC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggd2l0aCB3aGljaCB0byBsb29rIGZvciBjb21waWxlZCBzdGF0ZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9maW5kU3RhdGVzID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdFN0YXRlXHJcbiAgICAgICAgICAgICAgICBdLCByZWNvZ25pemUgPSB0aGlzLl9TdGF0ZS5yZWNvZ25pemUsIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlcyA9IHJlY29nbml6ZShwYXRoW2ldLCBzdGF0ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBGaWx0ZXJzIG91dCBzdGF0ZXMgd2l0aCBubyBkZWxlZ2F0ZXMsIGFuZCBzb3J0cyB0aGUgc3RhdGVzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQucm91dGluZy5TdGF0ZT59IHN0YXRlcyBUaGUgc3RhdGVzIHRvIGZpbHRlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlUmVjb2duaXplci5wcm90b3R5cGUuX2ZpbHRlciA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBzdGF0ZXMubGVuZ3RoLCBzb2x1dGlvbnMgPSBbXSwgc3RhdGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3RhdGUuZGVsZWdhdGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x1dGlvbnMucHVzaChzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1N0YXRlLnNvcnQoc29sdXRpb25zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIExpbmtzIGEgc3RhdGUgdG8gYSBwYXRoLCBwcm9kdWNpbmcgYW4gSVJlY29nbml6ZVJlc3VsdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuU3RhdGV9IHN0YXRlcyBUaGUgc3RhdGUgdG8gbGluay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gbGluay5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1RyYWlsaW5nU2xhc2hEcm9wcGVkIFdoZXRoZXIgb3Igbm90IHRoZSB0cmFpbGluZyBzbGFzaCBpcyBkcm9wcGVkIGZyb20gdGhlIHBhdGguXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZVJlY29nbml6ZXIucHJvdG90eXBlLl9saW5rID0gZnVuY3Rpb24gKHN0YXRlLCBwYXRoLCBpc1RyYWlsaW5nU2xhc2hEcm9wcGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3RhdGUpICYmIGlzQXJyYXkoc3RhdGUuZGVsZWdhdGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RyYWlsaW5nU2xhc2hEcm9wcGVkICYmIHRoaXMuX2lzRHluYW1pYyhzdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHBhdGggKyAnLyc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9TdGF0ZS5saW5rKHN0YXRlLCBwYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHN0YXRlIGlzIGR5bmFtaWMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLlN0YXRlfSBzdGF0ZXMgVGhlIHN0YXRlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIGR5bmFtaWMgb3Igbm90LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLnByb3RvdHlwZS5faXNEeW5hbWljID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUucmVnZXguc291cmNlLnNsaWNlKC01KSA9PT0gJyguKykkJztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUm91dGVSZWNvZ25pemVyLl9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgICAgICBfQmFzZVNlZ21lbnRGYWN0b3J5OiBfX0Jhc2VTZWdtZW50RmFjdG9yeSxcclxuICAgICAgICAgICAgICAgIF9TdGF0ZTogX19TdGF0ZVN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF9yb290U3RhdGU6IF9fU3RhdGVJbnN0YW5jZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gUm91dGVSZWNvZ25pemVyO1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAgICAgcm91dGluZy5Sb3V0ZVJlY29nbml6ZXIgPSBSb3V0ZVJlY29nbml6ZXI7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1JvdXRlUmVjb2duaXplckluc3RhbmNlLCBSb3V0ZVJlY29nbml6ZXIsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIDtcclxuICAgICAgICB2YXIgX19DSElMRF9ST1VURSA9ICcvKmNoaWxkUm91dGUnLCBfX0NISUxEX1JPVVRFX0xFTkdUSCA9IF9fQ0hJTERfUk9VVEUubGVuZ3RoO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hdGNoZXMgVVJMcyB0byByZWdpc3RlcmVkIHZpZXdzLiBBbGxvd3MgZm9yIHJlamVjdGluZyBuYXZpZ2F0aW9uLCBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcHJvY2Vzc2luZyByb3V0ZSBhbmQgcXVlcnkgcGFyYW1ldGVycy4gV2hlbiBhIHJvdXRlIGlzIG1hdGNoZXMsIHRoZSBjdXJyZW50IHZpZXdcclxuICAgICAgICAgKiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIHJlamVjdC9kZWxheSBuYXZpZ2F0aW9uLiBUaGUgbmV4dCB2aWV3IGNhbiBhbHNvIHJlamVjdCBuYXZpZ2F0aW9uLFxyXG4gICAgICAgICAqIG9yIHJlZGlyZWN0LlxyXG4gICAgICAgICAqIFRoaXMgaXMgZG9uZSBhc3luY2hyb25vdXNseSwgZ2l2aW5nIHRoZSBhcHBsaWNhdGlvbiB0aGUgYWJpbGl0eSB0byBtYWtlIHdlYiBzZXJ2aWNlIGNhbGxzXHJcbiAgICAgICAgICogdG8gZGV0ZXJtaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFJvdXRlciA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnN0YW50aWF0ZXMgYSBuZXcgcm91dGVyIGFuZCBzZXRzIGl0IGFzIHRoZSBjdXJyZW50IHJvdXRlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFJvdXRlcigpIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJvdXRlciBpcyBjdXJyZW50bHkgbmF2aWdhdGluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFsbCB0aGUgcmVnaXN0ZXJlZCBjaGlsZHJlbiBmb3IgdGhpcyByb3V0ZXIuIFVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBhbmQgbWF0Y2hpbmcgcm91dGVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgcm91dGVyIGlzIHRoZSByb290IHJvdXRlciAoaGFzIG5vIHBhcmVudCkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSb290ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRyYW5zZm9ybSBtZXRob2RzIGZvciByb3V0ZSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJhbVRyYW5zZm9ybXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgdHJhbnNmb3JtIG1ldGhvZHMgZm9yIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJ5VHJhbnNmb3JtcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBpbnRlcmNlcHRvciBtZXRob2RzIGZvciBwYXJ0aWN1bGFyIHJvdXRlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0b3JzID0ge307XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFsbCB0aGUgcmVnaXN0ZXJlZCBWaWV3cG9ydHMgZm9yIHRoZSByb3V0ZXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgc2hvcnRjdXQgdG8gdGhlIFByb21pc2UucmVzb2x2ZSBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IHRoaXMuX1Byb21pc2UucmVzb2x2ZS5iaW5kKHRoaXMuX1Byb21pc2UpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHNob3J0Y3V0IHRvIHRoZSBQcm9taXNlLnJlamVjdCBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0ID0gdGhpcy5fUHJvbWlzZS5yZWplY3QuYmluZCh0aGlzLl9Qcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudWlkID0gdW5pcXVlSWQoX19QbGF0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNSb290ID0gaXNOdWxsKFJvdXRlci5jdXJyZW50Um91dGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgUm91dGVyLmN1cnJlbnRSb3V0ZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRXhwb3NlcyB0aGUgY3VycmVudCByb3V0ZXIgcHJvcGVydHkuIEFsc28gcHJvdmlkZXMgdGhlXHJcbiAgICAgICAgICAgICAqIGFiaWxpdHkgdG8gc2V0IHRoZSBjdXJyZW50IHJvdXRlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuUm91dGVyfSByb3V0ZXIgV2lsbCBzZXQgdGhlIGN1cnJlbnQgcm91dGVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLmN1cnJlbnRSb3V0ZXIgPSBmdW5jdGlvbiAocm91dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChyb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLl9fY3VycmVudFJvdXRlciA9IHJvdXRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBSb3V0ZXIuX19jdXJyZW50Um91dGVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSByb3V0ZXIsIGdpdmluZyBpdCBhIHBhcmVudCByb3V0ZXIgdG8gbGluayB0byBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLlJvdXRlcn0gcGFyZW50PyBUaGUgcGFyZW50IHJvdXRlciB0byBsaW5rLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgYSBjaGlsZCByb3V0ZXIgd2l0aCB0aGUgY3VycmVudCByb3V0ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLlJvdXRlcn0gY2hpbGQgQSBjaGlsZCByb3V0ZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNoaWxkKSB8fCB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSByb3V0ZXIncyBjaGlsZHJlbiwgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5Sb3V0ZXJ9IGNoaWxkIFRoZSBjaGlsZCByb3V0ZXIgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiwgaW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBSb3V0ZXIuY3VycmVudFJvdXRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmN1cnJlbnRSb3V0ZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlcnMgYSBWaWV3cG9ydCAob3Igc2ltaWxhciBvYmplY3QpIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAqIHJvdXRlciwgYW5kIHRyaWdnZXJzIGEgbmF2aWdhdGlvbiBpZiBwb3NzaWJsZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVN1cHBvcnRSb3V0ZU5hdmlnYXRpb259IHBvcnQgQW4gb2JqZWN0IHRoYXQgc3VwcG9ydHMgYWxsIHRoZSBuYXZpZ2F0aW9uIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAocG9ydCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBwb3J0cyA9IHRoaXMuX3BvcnRzO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwb3J0KSB8fCBwb3J0cy5pbmRleE9mKHBvcnQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9ydHMucHVzaChwb3J0KTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QodGhpcy5jdXJyZW50Um91dGVJbmZvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodGhpcy5maW5pc2hOYXZpZ2F0aW5nKVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChub29wKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGVJbmZvID0gX2Nsb25lKF90aGlzLmN1cnJlbnRSb3V0ZUluZm8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5maW5pc2hOYXZpZ2F0aW5nID0gX3RoaXMuX2Nhbk5hdmlnYXRlVG8ocm91dGVJbmZvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2FuTmF2aWdhdGVUbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbk5hdmlnYXRlVG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50Um91dGVJbmZvID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3BlcmZvcm1OYXZpZ2F0aW9uKHJvdXRlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFJvdXRlSW5mbyA9IHJvdXRlSW5mbztcclxuICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVW5yZWdpc3RlcnMgYSBWaWV3cG9ydCAob3Igc2ltaWxhciBvYmplY3QpIHdpdGggdGhlXHJcbiAgICAgICAgICAgICAqIHJvdXRlciBpbiBvcmRlciB0byBzdG9wIHJlY2VpdmluZyBuYXZpZ2F0aW9uIGV2ZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LnJvdXRpbmcuSVN1cHBvcnRSb3V0ZU5hdmlnYXRpb259IHBvcnQgQW4gb2JqZWN0IHRoYXQgc3VwcG9ydHMgYWxsIHRoZSBuYXZpZ2F0aW9uIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9ydHMgPSB0aGlzLl9wb3J0cywgaW5kZXggPSBwb3J0cy5pbmRleE9mKHBvcnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvcnRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9ydHMubGVuZ3RoID09PSAwICYmICFpc051bGwodGhpcy5wYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuY29uZmlndXJlID0gZnVuY3Rpb24gKHJvdXRlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHJvdXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY29uZmlndXJlUm91dGUocm91dGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIHJvdXRlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25maWd1cmVSb3V0ZShyb3V0ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcmNlTmF2aWdhdGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFsbG93cyBmb3IgZHluYW1pYyByb3V0aW5nLiBDYWxsIHRoaXMgbWV0aG9kIGluIG9yZGVyIHRvIHJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgZHluYW1pY2FsbHkgZGV0ZXJtaW5pbmcgd2hhdCB2aWV3IHRvXHJcbiAgICAgICAgICAgICAqIHVzZSB3aGVuIGEgcmVnaXN0ZXJlZCByb3V0ZSBpcyBub3QgZm91bmQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7KGluZm86IElVbmtub3duUm91dGVJbmZvKSA9PiBhbnl9IGhhbmRsZXIgQSBtZXRob2QgY2FsbGVkIHRvIGRldGVybWluZSB3aGF0IHZpZXcgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcm91dGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLnVua25vd24gPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdW5rbm93bkhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUucGFyYW0gPSBmdW5jdGlvbiAoaGFuZGxlciwgcGFyYW1ldGVyLCB2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkSGFuZGxlcihoYW5kbGVyLCBwYXJhbWV0ZXIsIHZpZXcsIHRoaXMuX3BhcmFtVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUucXVlcnlQYXJhbSA9IGZ1bmN0aW9uIChoYW5kbGVyLCBwYXJhbWV0ZXIsIHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRIYW5kbGVyKGhhbmRsZXIsIHBhcmFtZXRlciwgdmlldywgdGhpcy5fcXVlcnlUcmFuc2Zvcm1zKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5pbnRlcmNlcHQgPSBmdW5jdGlvbiAoaW50ZXJjZXB0b3IsIHZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSAnKic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSB2aWV3O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXcgIT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLl9JbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jeSh2aWV3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2aWV3ID09PSBfX05PT1BfSU5KRUNUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gYWxpYXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJjZXB0b3JzID0gdGhpcy5faW50ZXJjZXB0b3JzW3ZpZXddO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGludGVyY2VwdG9ycykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcmNlcHRvcnMgPSB0aGlzLl9pbnRlcmNlcHRvcnNbdmlld10gPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGludGVyY2VwdG9ycy5wdXNoKGludGVyY2VwdG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGVsbHMgdGhlIHJvdXRlciB0byBtYXRjaCBhIG5ldyByb3V0ZS4gVGhlIHJvdXRlciB3aWxsIGF0dGVtcHQgdG8gZmluZCB0aGUgcm91dGUgYW5kIGlmIGl0IHN1Y2NlZWRzIGl0IHdpbGxcclxuICAgICAgICAgICAgICogYXR0ZW1wdCB0byBuYXZpZ2F0ZSB0byBpdC4gSWYgaXQgZmFpbHMsIGl0IHdpbGwgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlamVjdHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIG5ldyByb3V0ZSB0byBtYXRjaC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtwbGF0LklPYmplY3Q8YW55Pn0gcXVlcnkgVGhlIHF1ZXJ5IHBhcmFtZXRlcnMgZm9yIHRoZSByb3V0ZS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGV0aGVyIG9yIG5vdCB0byBmb3JjZSBuYXZpZ2F0aW9uLCBldmVuIGlmIHRoZSBzYW1lIHVybCBoYXMgYWxyZWFkeSBiZWVuIG1hdGNoZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLm5hdmlnYXRlID0gZnVuY3Rpb24gKHVybCwgcXVlcnksIGZvcmNlLCBwb2xsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbGwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9sbCA9ICFpc09iamVjdCh0aGlzLmN1cnJlbnRSb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChxdWVyeSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmUgPSB0aGlzLl9yZXNvbHZlLCBxdWVyeVN0cmluZyA9IHNlcmlhbGl6ZVF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIGlmICh1cmwgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yY2UgPSBmb3JjZSA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcodXJsKSB8fCB0aGlzLm5hdmlnYXRpbmcgfHwgKCFmb3JjZSAmJiB1cmwgPT09IHRoaXMuX3ByZXZpb3VzVXJsICYmIHF1ZXJ5U3RyaW5nID09PSB0aGlzLl9wcmV2aW91c1F1ZXJ5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hdmlnYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTmF2aWdhdGluZy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5uYXZpZ2F0ZSh1cmwsIHF1ZXJ5LCBmb3JjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJlY29nbml6ZXIgPSB0aGlzLl9yZWNvZ25pemVyLCByZXN1bHQgPSByZWNvZ25pemVyLnJlY29nbml6ZSh1cmwpLCByb3V0ZUluZm8sIGVtcHR5UmVzdWx0ID0gaXNFbXB0eShyZXN1bHQpLCBwYXR0ZXJuLCBzZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHJlc3VsdFswXTtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzYW1lUm91dGUgPSB0aGlzLl9pc1NhbWVSb3V0ZShyb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5UmVzdWx0IHx8IHNhbWVSb3V0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZFVybF8xID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1lUm91dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IHJlY29nbml6ZXIuZ2VuZXJhdGUocm91dGVJbmZvLmRlbGVnYXRlLmFsaWFzIHx8IHJvdXRlSW5mby5kZWxlZ2F0ZS52aWV3LCByb3V0ZUluZm8ucGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVXJsXzEgPSBjaGlsZFVybF8xLnJlcGxhY2Uoc2VnbWVudCwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRVcmxfMSA9PT0gJy8nIHx8IGNoaWxkVXJsXzEgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkVXJsXzEgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29tZShmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNoaWxkLl9yZWNvZ25pemVyLnJlY29nbml6ZShjaGlsZFVybF8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNFbXB0eShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuX2NoaWxkUmVjb2duaXplci5yZWNvZ25pemUoY2hpbGRVcmxfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbXB0eVJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVjb2duaXplci5yZWNvZ25pemUodXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHJlc3VsdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHJvdXRlSW5mby5kZWxlZ2F0ZS5wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91dGUgaGFzIG5vdCBiZWVuIG1hdGNoZWQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1VybCA9IGNoaWxkVXJsXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1F1ZXJ5ID0gcXVlcnlTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3V0ZUluZm8gPSByb3V0ZUluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl91bmtub3duSGFuZGxlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5rbm93blJvdXRlQ29uZmlnXzEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0aGlzLl91bmtub3duSGFuZGxlcih1bmtub3duUm91dGVDb25maWdfMSkpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHVua25vd25Sb3V0ZUNvbmZpZ18xLnZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb25maWd1cmUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdmlld1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mbyA9IHJlc3VsdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSByb3V0ZUluZm8uZGVsZWdhdGUucGF0dGVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMCwgcGF0dGVybi5sZW5ndGggLSBfX0NISUxEX1JPVVRFX0xFTkdUSCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW1wdHlSZXN1bHQgfHwgdGhpcy5faXNTYW1lUm91dGUocm91dGVJbmZvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBhdHRlcm4gZm9yIHRoaXMgcm91dGVyIGlzIHRoZSBzYW1lIGFzIHRoZSBsYXN0IHBhdHRlcm4gc28gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IG5hdmlnYXRlIGNoaWxkIHJvdXRlcnMuIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5hdmlnYXRpbmcgPSB0aGlzLl9uYXZpZ2F0ZUNoaWxkcmVuKHJvdXRlSW5mbylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzVXJsID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1F1ZXJ5ID0gcXVlcnlTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9IHJvdXRlSW5mby5kZWxlZ2F0ZS5wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudCA9IHJlY29nbml6ZXIuZ2VuZXJhdGUocm91dGVJbmZvLmRlbGVnYXRlLmFsaWFzIHx8IHJvdXRlSW5mby5kZWxlZ2F0ZS52aWV3LCByb3V0ZUluZm8ucGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNTZWdtZW50ID0gdGhpcy5fcHJldmlvdXNTZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTZWdtZW50ID0gc2VnbWVudDtcclxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm91dGVJbmZvQ29weSA9IHRoaXMuX25leHRSb3V0ZUluZm8gPSBfY2xvbmUocm91dGVJbmZvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5hdmlnYXRpbmcgPSB0aGlzLl9jYW5OYXZpZ2F0ZShyb3V0ZUluZm8sIHBvbGwpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNhbk5hdmlnYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5OYXZpZ2F0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGNsZWFyZWQgdG8gbmF2aWdhdGUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzVXJsID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmV2aW91c1F1ZXJ5ID0gcXVlcnlTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9wZXJmb3JtTmF2aWdhdGlvbihyb3V0ZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzUGF0dGVybiA9IHBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZXZpb3VzU2VnbWVudCA9IHNlZ21lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFJvdXRlSW5mbyA9IHJvdXRlSW5mb0NvcHk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubmF2aWdhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmlvdXNTZWdtZW50ID0gcHJldmlvdXNTZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hdmlnYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1ldGVycywgcXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGlhcyA9IG5hbWU7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5fSW5qZWN0b3IuY29udmVydERlcGVuZGVuY3kobmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gX19OT09QX0lOSkVDVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGFsaWFzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHJvdXRlciA9IHRoaXMsIHByZWZpeCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCEoaXNOdWxsKHJvdXRlcikgfHwgcm91dGVyLl9yZWNvZ25pemVyLmV4aXN0cyhuYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3V0ZXIgPSByb3V0ZXIucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChyb3V0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb3V0ZSBmb3IgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0LicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSByb3V0ZXIuX3JlY29nbml6ZXIuZ2VuZXJhdGUobmFtZSwgcGFyYW1ldGVycyksIHByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bGwocm91dGVyID0gcm91dGVyLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHJvdXRlci5fcHJldmlvdXNTZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gKCFpc051bGwocHJldmlvdXMpICYmIHByZXZpb3VzICE9PSAnLycpID8gcHJldmlvdXMgOiAnJztcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmV2aW91cyArIHByZWZpeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBwYXRoICsgc2VyaWFsaXplUXVlcnkocXVlcnkpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ29uZmlndXJlcyBhIHJvdXRlIG1hcHBpbmcgYW5kIHJlZ2lzdGVycyBpdCB3aXRoIHRoZSBSb3V0ZVJlY29nbml6ZXIgYW5kIHRoZSBjaGlsZFxyXG4gICAgICAgICAgICAgKiBSb3V0ZVJlY29nbml6ZXIuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZU1hcHBpbmd9IHJvdXRlIFRoZSBtYXBwaW5nIHVzZWQgdG8gY29uZmlndXJlIHRoZSByb3V0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2NvbmZpZ3VyZVJvdXRlID0gZnVuY3Rpb24gKHJvdXRlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMuX0luamVjdG9yLmNvbnZlcnREZXBlbmRlbmN5KHJvdXRlLnZpZXcpLCBhbGlhcyA9IHJvdXRlLmFsaWFzIHx8IHZpZXc7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlldyA9PT0gX19OT09QX0lOSkVDVE9SKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcm91dGUudmlldyA9IHZpZXc7XHJcbiAgICAgICAgICAgICAgICByb3V0ZS5hbGlhcyA9IGFsaWFzIHx8IHZpZXc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm91dGVEZWxlZ2F0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiByb3V0ZS5wYXR0ZXJuLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlOiByb3V0ZVxyXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRQYXR0ZXJuID0gcm91dGUucGF0dGVybiArIF9fQ0hJTERfUk9VVEUsIGNoaWxkRGVsZWdhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogY2hpbGRQYXR0ZXJuLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlbGVnYXRlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGNoaWxkUGF0dGVybixcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldzogdmlldyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpYXM6IGFsaWFzXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY29nbml6ZXIucmVnaXN0ZXIoW3JvdXRlRGVsZWdhdGVdLCB7IG5hbWU6IGFsaWFzIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRSZWNvZ25pemVyLnJlZ2lzdGVyKFtjaGlsZERlbGVnYXRlXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZW5lcmljIG1ldGhvZCBmb3IgYWRkaW5nIGEgcGFyYW0vcXVlcnlQYXJhbSBoYW5kbGVyIHRvIHRoZSByZWdpc3RlcmVkIGhhbmRsZXJzIG9iamVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHsodmFsdWU6IGFueSwgcXVlcnk6IGFueSkgPT4gYW55fSBoYW5kbGVyIEEgbWV0aG9kIHRoYXQgd2lsbCBtYW5pcHVsYXRlIHRoZSByZWdpc3RlcmVkIHBhcmFtZXRlci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtZXRlciBUaGUgcGFyYW1ldGVyIHRoYXQgdGhlIHJlZ2lzdGVyZWQgaGFuZGxlciB3aWxsIG1vZGlmeS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZpZXcgVGhlIHZpZXcgdXNlZCB0byBtYXRjaCB0aGUgcm91dGUuIElmIHVuZGVmaW5lZCwgYWxsIHJvdXRlcyB3aWxsIGJlIG1hdGNoZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JT2JqZWN0PHBsYXQucm91dGluZy5JUm91dGVUcmFuc2Zvcm1zPn0gaGFuZGxlcnMgVGhlIG9iamVjdCB0byB3aGljaCB0byBhZGQgdGhlIGhhbmRsZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9hZGRIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIsIHBhcmFtZXRlciwgdmlldywgaGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSAnKic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSB2aWV3O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZpZXcgIT09ICcqJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcgPSB0aGlzLl9JbmplY3Rvci5jb252ZXJ0RGVwZW5kZW5jeSh2aWV3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh2aWV3ID09PSBfX05PT1BfSU5KRUNUT1IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3ID0gYWxpYXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh2aWV3KSB8fCBpc0VtcHR5KHBhcmFtZXRlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2aWV3SGFuZGxlcnMgPSBoYW5kbGVyc1t2aWV3XTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qodmlld0hhbmRsZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXdIYW5kbGVycyA9IGhhbmRsZXJzW3ZpZXddID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtcyA9IHZpZXdIYW5kbGVyc1twYXJhbWV0ZXJdO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KHRyYW5zZm9ybXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtcyA9IHZpZXdIYW5kbGVyc1twYXJhbWV0ZXJdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZvcmNlcyBhIG5hdmlnYXRpb24gaWYgcG9zc2libGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9mb3JjZU5hdmlnYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gdGhpcy5fcmVzb2x2ZSwgcXVlcnk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTmF2aWdhdGluZy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9mb3JjZU5hdmlnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1Jvb3QgJiYgaXNFbXB0eSh0aGlzLl9wcmV2aW91c1VybCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLl9icm93c2VyLnVybFV0aWxzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNVcmwgPSB1dGlscy5wYXRobmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHV0aWxzLnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHRoaXMuX3ByZXZpb3VzUXVlcnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcnkgPSBkZXNlcmlhbGl6ZVF1ZXJ5KHRoaXMuX3ByZXZpb3VzUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHRoaXMuX3ByZXZpb3VzVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRlKHRoaXMuX3ByZXZpb3VzVXJsLCBxdWVyeSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTmF2aWdhdGVzIHRoZSBjaGlsZCByb3V0ZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gYnVpbGQgdGhlIGNoaWxkUm91dGUgZm9yIHRoZSBjaGlsZCByb3V0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fbmF2aWdhdGVDaGlsZHJlbiA9IGZ1bmN0aW9uIChpbmZvLCBwb2xsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9sbCA9PT0gdm9pZCAwKSB7IHBvbGwgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRSb3V0ZSA9IHRoaXMuX2dldENoaWxkUm91dGUoaW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNoaWxkUm91dGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luYyhmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQubmF2aWdhdGUoY2hpbGRSb3V0ZSwgaW5mby5xdWVyeSwgdW5kZWZpbmVkLCBwb2xsKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hpbGRyZW4pLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgb3V0IHRoZSBjaGlsZCByb3V0ZSBmcm9tIHJvdXRlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSBpbmZvcm1hdGlvbiBuZWNlc3NhcnkgdG8gZ2V0IHRoZSBjaGlsZCByb3V0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2dldENoaWxkUm91dGUgPSBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChpbmZvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZFJvdXRlID0gaW5mby5wYXJhbWV0ZXJzLmNoaWxkUm91dGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKGNoaWxkUm91dGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRSb3V0ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcvJyArIGNoaWxkUm91dGU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJdCBpcyBzYWZlIHRvIG5hdmlnYXRlLCBzbyBwZXJmb3JtIHRoZSBuYXZpZ2F0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX3BlcmZvcm1OYXZpZ2F0aW9uID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FtZVJvdXRlID0gdGhpcy5faXNTYW1lUm91dGUodGhpcy5fbmV4dFJvdXRlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcGVyZm9ybU5hdmlnYXRlRnJvbShzYW1lUm91dGUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzYW1lUm91dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoZnVuY3Rpb24gKHBvcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcnQubmF2aWdhdGVUbyhpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9uYXZpZ2F0ZUNoaWxkcmVuKGluZm8sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSXQgaXMgc2FmZSB0byBuYXZpZ2F0ZSwgc28gZmlyZSB0aGUgbmF2aWdhdGVGcm9tIGV2ZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpZ25vcmVQb3J0cz8gSWdub3JlcyB0aGUgcG9ydHMgaWYgbmVjZXNzYXJ5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fcGVyZm9ybU5hdmlnYXRlRnJvbSA9IGZ1bmN0aW9uIChpZ25vcmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luYyhmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuX3BlcmZvcm1OYXZpZ2F0ZUZyb20oKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hpbGRyZW4pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luYyhmdW5jdGlvbiAocG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9ydC5uYXZpZ2F0ZUZyb20oKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBfdGhpcy5fcG9ydHMpO1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihub29wKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgd2UgY2FuIG5hdmlnYXRlIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIG5hdmlnYXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2Nhbk5hdmlnYXRlID0gZnVuY3Rpb24gKGluZm8sIHBvbGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9sbCA9PT0gdm9pZCAwKSB7IHBvbGwgPSB0cnVlOyB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2FtZVJvdXRlID0gdGhpcy5faXNTYW1lUm91dGUodGhpcy5fbmV4dFJvdXRlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXBvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbEFsbEhhbmRsZXJzKGluZm8uZGVsZWdhdGUuYWxpYXMsIGluZm8ucGFyYW1ldGVycywgaW5mby5xdWVyeSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2FsbEludGVyY2VwdG9ycyhpbmZvKTtcclxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW5OYXZpZ2F0ZUZyb20oc2FtZVJvdXRlKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjYW5OYXZpZ2F0ZUZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuTmF2aWdhdGVGcm9tICYmIF90aGlzLl9jYW5OYXZpZ2F0ZVRvKGluZm8sIHNhbWVSb3V0ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgaWYgd2UgY2FuIG5hdmlnYXRlIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIG5hdmlnYXRlIHRvIHRoZSBuZXh0IHN0YXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVBvcnRzIElnbm9yZXMgdGhlIHBvcnRzIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2Nhbk5hdmlnYXRlRnJvbSA9IGZ1bmN0aW9uIChpZ25vcmVQb3J0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLmFsbCh0aGlzLmNoaWxkcmVuLnJlZHVjZShmdW5jdGlvbiAocHJvbWlzZXMsIGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VzLmNvbmNhdChjaGlsZC5fY2FuTmF2aWdhdGVGcm9tKCkpO1xyXG4gICAgICAgICAgICAgICAgfSwgW10pKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGJvb2xlYW5SZWR1Y2UpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNhbk5hdmlnYXRlRnJvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuTmF2aWdhdGVGcm9tIHx8IGlnbm9yZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY2FuTmF2aWdhdGVGcm9tXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jKGZ1bmN0aW9uIChwb3J0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3J0LmNhbk5hdmlnYXRlRnJvbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLl9wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGJvb2xlYW5SZWR1Y2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB3ZSBjYW4gbmF2aWdhdGUgdG8gdGhlIG5leHQgc3RhdGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZUluZm99IGluZm8gVGhlIHJvdXRlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVBvcnRzIElnbm9yZXMgdGhlIHBvcnRzIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2Nhbk5hdmlnYXRlVG8gPSBmdW5jdGlvbiAoaW5mbywgaWdub3JlUG9ydHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLl9wb3J0cykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWxsQWxsSGFuZGxlcnMoaW5mby5kZWxlZ2F0ZS5hbGlhcywgaW5mby5wYXJhbWV0ZXJzLCBpbmZvLnF1ZXJ5KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2NhbGxJbnRlcmNlcHRvcnMoaW5mbyk7XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChjYW5OYXZpZ2F0ZVRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlVG8gPT09IGZhbHNlIHx8IGlnbm9yZVBvcnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY2FuTmF2aWdhdGVUb107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBBc3luYyhmdW5jdGlvbiAocG9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9ydC5jYW5OYXZpZ2F0ZVRvKGluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLl9wb3J0cyk7XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGJvb2xlYW5SZWR1Y2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2FsbHMgYWxsIHRoZSByZWdpc3RlcmVkIHF1ZXJ5IGFuZCBwYXJhbSB0cmFuc2Zvcm1zIGZvciBhIHJvdXRlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmlldyBUaGUgYXNzb2NpYXRlZCB2aWV3IGZvciB0aGUgcm91dGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBwYXJhbWV0ZXJzIFRoZSByb3V0ZSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gcXVlcnk/IFRoZSBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fY2FsbEFsbEhhbmRsZXJzID0gZnVuY3Rpb24gKHZpZXcsIHBhcmFtZXRlcnMsIHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxIYW5kbGVycyh0aGlzLl9xdWVyeVRyYW5zZm9ybXNbJyonXSwgcXVlcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NhbGxIYW5kbGVycyhfdGhpcy5fcXVlcnlUcmFuc2Zvcm1zW3ZpZXddLCBxdWVyeSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2NhbGxIYW5kbGVycyhfdGhpcy5fcGFyYW1UcmFuc2Zvcm1zWycqJ10sIHBhcmFtZXRlcnMsIHF1ZXJ5KTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fY2FsbEhhbmRsZXJzKF90aGlzLl9wYXJhbVRyYW5zZm9ybXNbdmlld10sIHBhcmFtZXRlcnMsIHF1ZXJ5KTsgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihub29wKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxzIHRoZSBhc3NvY2lhdGVkIHRyYW5zZm9ybSBmdW5jdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZVRyYW5zZm9ybXN9IGFsbEhhbmRsZXJzIFRoZSB0cmFuc2Zvcm0gZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvYmogVGhlIHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBxdWVyeT8gVGhlIHF1ZXJ5IHBhcmFtZXRlcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSb3V0ZXIucHJvdG90eXBlLl9jYWxsSGFuZGxlcnMgPSBmdW5jdGlvbiAoYWxsSGFuZGxlcnMsIG9iaiwgcXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gdGhpcy5fcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jKGZ1bmN0aW9uIChoYW5kbGVycywga2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jSW5PcmRlcihmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShoYW5kbGVyKG9ialtrZXldLCBvYmosIHF1ZXJ5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgaGFuZGxlcnMpO1xyXG4gICAgICAgICAgICAgICAgfSwgYWxsSGFuZGxlcnMpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4obm9vcCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDYWxscyB0aGUgaW50ZXJjZXB0b3JzIGZvciBhIHBhcnRpY3VsYXIgcm91dGUuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZUluZm99IGluZm8gVGhlIHJvdXRlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fY2FsbEludGVyY2VwdG9ycyA9IGZ1bmN0aW9uIChpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc29sdmUgPSB0aGlzLl9yZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcEFzeW5jSW5PcmRlcihmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGhhbmRsZXIoaW5mbykpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5faW50ZXJjZXB0b3JzWycqJ10pXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYm9vbGVhblJlZHVjZSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2FuTmF2aWdhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbk5hdmlnYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY2FuTmF2aWdhdGVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwQXN5bmMoZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaGFuZGxlcihpbmZvKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMuX2ludGVyY2VwdG9yc1tpbmZvLmRlbGVnYXRlLmFsaWFzXSk7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGJvb2xlYW5SZWR1Y2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGEgcGFzc2VkLWluIHJvdXRlIGFnYWluc3QgdGhlIGN1cnJlbnQgcm91dGUgdG8gZGV0ZXJtaW5lIGlmIGl0IGlzIHRoZSBzYW1lLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3BsYXQucm91dGluZy5JUm91dGVJbmZvfSBpbmZvIFRoZSByb3V0ZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFJvdXRlci5wcm90b3R5cGUuX2lzU2FtZVJvdXRlID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Um91dGVJbmZvID0gX2Nsb25lKHRoaXMuY3VycmVudFJvdXRlSW5mbywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpbmZvID0gX2Nsb25lKGluZm8sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2FuaXRpemVSb3V0ZUluZm8oY3VycmVudFJvdXRlSW5mbyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zYW5pdGl6ZVJvdXRlSW5mbyhpbmZvKTtcclxuICAgICAgICAgICAgICAgIGlmICghKGlzT2JqZWN0KGN1cnJlbnRSb3V0ZUluZm8pICYmIGlzT2JqZWN0KGluZm8pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RGVsZWdhdGUgPSBjdXJyZW50Um91dGVJbmZvLmRlbGVnYXRlLCBkZWxlZ2F0ZSA9IGluZm8uZGVsZWdhdGUsIGN1cnJlbnRQYXJhbWV0ZXJzID0gc2VyaWFsaXplUXVlcnkoY3VycmVudFJvdXRlSW5mby5wYXJhbWV0ZXJzKSwgcGFyYW1ldGVycyA9IHNlcmlhbGl6ZVF1ZXJ5KGluZm8ucGFyYW1ldGVycyksIGN1cnJlbnRRdWVyeSA9IHNlcmlhbGl6ZVF1ZXJ5KGN1cnJlbnRSb3V0ZUluZm8ucXVlcnkpLCBxdWVyeSA9IHNlcmlhbGl6ZVF1ZXJ5KGluZm8ucXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREZWxlZ2F0ZS52aWV3ID09PSBkZWxlZ2F0ZS52aWV3ICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERlbGVnYXRlLmFsaWFzID09PSBkZWxlZ2F0ZS5hbGlhcyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxlZ2F0ZS5wYXR0ZXJuID09PSBkZWxlZ2F0ZS5wYXR0ZXJuICYmXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBhcmFtZXRlcnMgPT09IHBhcmFtZXRlcnMgJiZcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UXVlcnkgPT09IHF1ZXJ5O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVtb3ZlcyBjaGlsZFJvdXRlIGZyb20gcm91dGVJbmZvXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5yb3V0aW5nLklSb3V0ZUluZm99IGluZm8gVGhlIHJvdXRlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fc2FuaXRpemVSb3V0ZUluZm8gPSBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGluZm8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8ucGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eSgnY2hpbGRSb3V0ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxlZ2F0ZSA9IGluZm8uZGVsZWdhdGUsIHBhdHRlcm4gPSBkZWxlZ2F0ZS5wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZS5wYXR0ZXJuID0gcGF0dGVybi5zbGljZSgwLCBwYXR0ZXJuLmxlbmd0aCAtIF9fQ0hJTERfUk9VVEVfTEVOR1RIKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoaW5mby5wYXJhbWV0ZXJzLCAnY2hpbGRSb3V0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENsZWFycyBhbGwgdGhlIHJvdXRlciBpbmZvcm1hdGlvbiwgZXNzZW50aWFsbHkgc2V0dGluZyB0aGUgcm91dGVyIGJhY2sgdG8gaXRzIGluaXRpYWxpemVkIHN0YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgUm91dGVyLnByb3RvdHlwZS5fY2xlYXJJbmZvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTZWdtZW50ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNQYXR0ZXJuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNVcmwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1F1ZXJ5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Um91dGVJbmZvID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLl9jbGVhckluZm8oKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSb3V0ZXIuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2UsXHJcbiAgICAgICAgICAgICAgICBfSW5qZWN0b3I6IF9fSW5qZWN0b3JTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBfRXZlbnRNYW5hZ2VyOiBfX0V2ZW50TWFuYWdlclN0YXRpYyxcclxuICAgICAgICAgICAgICAgIF9icm93c2VyOiBfX0Jyb3dzZXIsXHJcbiAgICAgICAgICAgICAgICBfYnJvd3NlckNvbmZpZzogX19Ccm93c2VyQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgX3JlY29nbml6ZXI6IF9fUm91dGVSZWNvZ25pemVySW5zdGFuY2UsXHJcbiAgICAgICAgICAgICAgICBfY2hpbGRSZWNvZ25pemVyOiBfX1JvdXRlUmVjb2duaXplckluc3RhbmNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBSb3V0ZXI7XHJcbiAgICAgICAgfSgpKTtcclxuICAgICAgICByb3V0aW5nLlJvdXRlciA9IFJvdXRlcjtcclxuICAgICAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fUm91dGVyLCBSb3V0ZXIsIG51bGwsIF9fSU5TVEFOQ0UpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIElSb3V0ZXJTdGF0aWMoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSb3V0ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJvdXRpbmcuSVJvdXRlclN0YXRpYyA9IElSb3V0ZXJTdGF0aWM7XHJcbiAgICAgICAgcmVnaXN0ZXIuaW5qZWN0YWJsZShfX1JvdXRlclN0YXRpYywgSVJvdXRlclN0YXRpYyk7XHJcbiAgICB9KShyb3V0aW5nID0gcGxhdF8xLnJvdXRpbmcgfHwgKHBsYXRfMS5yb3V0aW5nID0ge30pKTtcclxuICAgIC8qKlxyXG4gICAgICogSG9sZHMgYWxsIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgcmVsYXRlZCB0byBhdHRyaWJ1dGUgY29udHJvbCBjb21wb25lbnRzIGluIHBsYXR5cHVzLlxyXG4gICAgICovXHJcbiAgICB2YXIgY29udHJvbHM7XHJcbiAgICAoZnVuY3Rpb24gKGNvbnRyb2xzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWxsb3dzIGZvciBhc3NpZ25pbmcgYSBuYW1lIHRvIGFuIEVsZW1lbnQgb3IgVGVtcGxhdGVDb250cm9sIGFuZCByZWZlcmVuY2luZyBpdFxyXG4gICAgICAgICAqIGZyb20gcGFyZW50IGNvbnRyb2xzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBOYW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKE5hbWUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE5hbWUoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyB0aGUgcHJvcGVydHkgc3BlY2lmaWVkIGJ5IHRoZSBhdHRyaWJ1dGUgdmFsdWUgYXMgdGhlIElOYW1lZEVsZW1lbnRcclxuICAgICAgICAgICAgICogb24gYWxsIHRoZSBhbmNlc3RvciBjb250cm9scywgaWdub3JpbmcgdGhvc2UgdGhhdCBhbHJlYWR5IGhhdmUgdGhlIHByb3BlcnR5IGRlZmluZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHIgPSBjYW1lbENhc2UodGhpcy50eXBlKSwgbmFtZSA9IHRoaXMuYXR0cmlidXRlc1thdHRyXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG5hbWUpIHx8IHRoaXMuX2lzUHJlY29tcGlsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xhYmVsID0gbmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmluZShuYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlbW92ZXMgdGhlIElOYW1lZEVsZW1lbnQgZnJvbSB0aGUgYW5jZXN0b3IgY29udHJvbHMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBOYW1lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLl9sYWJlbCwgY29udHJvbCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpc1VuZGVmaW5lZChuYW1lKSAmJiBpc09iamVjdChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChjb250cm9sW25hbWVdKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vZGUoY29udHJvbFtuYW1lXS5lbGVtZW50KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sW25hbWVdLmVsZW1lbnQgPT09IHRoaXMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9wZXJ0eShjb250cm9sLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGNvbnRyb2wucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGVmaW5lcyB0aGUgcHJvcGVydHkgc3BlY2lmaWVkIGJ5IHRoZSBhdHRyaWJ1dGUgdmFsdWUgYXMgdGhlIElOYW1lZEVsZW1lbnRcclxuICAgICAgICAgICAgICogb24gYWxsIHRoZSBhbmNlc3RvciBjb250cm9scywgaWdub3JpbmcgdGhvc2UgdGhhdCBhbHJlYWR5IGhhdmUgdGhlIHByb3BlcnR5IGRlZmluZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIHRvIGRlZmluZSBvbiBhbGwgdGhlIGFuY2VzdG9yIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZS5wcm90b3R5cGUuX2RlZmluZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGVDb250cm9sID0gdGhpcy50ZW1wbGF0ZUNvbnRyb2w7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbCh0ZW1wbGF0ZUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVDb250cm9sLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLnBhcmVudCwgbmFtZWRFbGVtZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sOiB0ZW1wbGF0ZUNvbnRyb2xcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXNPYmplY3QoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY29udHJvbFtuYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFtuYW1lXSA9IG5hbWVkRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbCA9IGNvbnRyb2wucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbnRyb2wgaXMgcGFydCBvZiBhIHByZS1jb21waWxlZCBjb250cm9sIHRyZWUuIEluIHRoZSBldmVudFxyXG4gICAgICAgICAgICAgKiB0aGF0IGl0IGlzLCBpdCBzaG91bGRuJ3Qgc2V0IGl0c2VsZiBvbiB0aGUgYW5jZXN0b3IgY29udHJvbHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIHRvIGRlZmluZSBvbiBhbGwgdGhlIGFuY2VzdG9yIGNvbnRyb2xzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTmFtZS5wcm90b3R5cGUuX2lzUHJlY29tcGlsZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFpc051bGwoY29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbC50eXBlLmluZGV4T2YoX19DT01QSUxFRCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0gY29udHJvbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBOYW1lO1xyXG4gICAgICAgIH0oQXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLk5hbWUgPSBOYW1lO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19OYW1lLCBOYW1lKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBBdHRyaWJ1dGVDb250cm9sIHRoYXQgYmluZHMgdG8gYSBzcGVjaWZpZWQgRE9NIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNpbXBsZUV2ZW50Q29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTaW1wbGVFdmVudENvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFNpbXBsZUV2ZW50Q29udHJvbCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHBhcnNlZCBmb3JtIG9mIHRoZSBleHByZXNzaW9uIGZvdW5kIGluIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwcmVzc2lvbiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgYWxpYXNlcyB1c2VkIGluIHRoZSBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGlhc2VzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEtpY2tzIG9mZiBmaW5kaW5nIGFuZCBzZXR0aW5nIHRoZSBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFNpbXBsZUV2ZW50Q29udHJvbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLmVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBjYW1lbENhc2UodGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgZnVuY3Rpb24gYXJncyBhbmQgc2V0cyB0aGUgZXZlbnQgbGlzdGVuZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTaW1wbGVFdmVudENvbnRyb2wucHJvdG90eXBlLl9zZXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmV2ZW50KSB8fCBpc0VtcHR5KGZuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnNlQXJncyhmbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhbnkgYW5kIGFsbCBuZWNlc3NhcnkgZXZlbnQgbGlzdGVuZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCB0aGlzLmV2ZW50LCB0aGlzLl9vbkV2ZW50LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIHRoZSBmdW5jdGlvbiB0byBldmFsdWF0ZSB3aXRoXHJcbiAgICAgICAgICAgICAqIHRoZSBldmFsdWF0ZWQgYXJndW1lbnRzIHRha2luZyByZXNvdXJjZXNcclxuICAgICAgICAgICAgICogaW50byBhY2NvdW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLl9leHByZXNzaW9uLnNsaWNlKDApLCBfcGFyc2VyID0gdGhpcy5fcGFyc2VyLCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgbGlzdGVuZXJTdHIgPSBleHByZXNzaW9uLnNoaWZ0KCksIGxpc3RlbmVyLCBjb250ZXh0LCBmbiwgYWxpYXNlcywgYXJnQ29udGV4dDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNOdWxsKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlhc2VzID0gcGFyZW50LmdldFJlc291cmNlcyh0aGlzLl9hbGlhc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICBhcmdDb250ZXh0ID0gcGFyZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJTdHJbMF0gIT09ICdAJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gdGhpcy5maW5kUHJvcGVydHkobGlzdGVuZXJTdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwobGlzdGVuZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdDb3VsZCBub3QgZmluZCBwcm9wZXJ0eSAnICsgbGlzdGVuZXJTdHIgKyAnIG9uIGFueSBwYXJlbnQgY29udHJvbC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyc2VkRXhwcmVzc2lvbiA9IGxpc3RlbmVyLmV4cHJlc3NzaW9uLCBpZGVudGlmaWVycyA9IHBhcnNlZEV4cHJlc3Npb24uaWRlbnRpZmllcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aWZpZXJzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ0Nhbm5vdCBoYXZlIG1vcmUgdGhhbiBvbmUgaWRlbnRpZmllciBpbiBhICcgKyB0aGlzLnR5cGUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcJ3MgZXhwcmVzc2lvbi4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDoge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWRlbnRpZmllciA9IGlkZW50aWZpZXJzWzBdLCBzcGxpdCA9IGlkZW50aWZpZXIuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwb3Aga2V5IFxyXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBzcGxpdC5sZW5ndGggPT09IDAgPyBsaXN0ZW5lci5jb250cm9sIDogX3BhcnNlci5wYXJzZShzcGxpdC5qb2luKCcuJykpLmV2YWx1YXRlKGxpc3RlbmVyLmNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZuID0gbGlzdGVuZXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmbiA9IGlzTnVsbChhbGlhc2VzKSA/IG5vb3AgOiAoYWxpYXNlc1tsaXN0ZW5lclN0cl0gfHwgbm9vcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBleHByZXNzaW9uLmxlbmd0aCwgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChfcGFyc2VyLnBhcnNlKGV4cHJlc3Npb25baV0pLmV2YWx1YXRlKGFyZ0NvbnRleHQsIGFsaWFzZXMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm46IGZuLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxzIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlbiB0aGUgRE9NIGV2ZW50IGlzIGZpcmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLl9idWlsZEV4cHJlc3Npb24oKSwgZm4gPSBleHByZXNzaW9uLmZuO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdDYW5ub3QgZmluZCByZWdpc3RlcmVkIGV2ZW50IG1ldGhvZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwcmVzc2lvblswXSArICcgZm9yIGNvbnRyb2w6ICcgKyB0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KGV4cHJlc3Npb24uY29udGV4dCwgZXhwcmVzc2lvbi5hcmdzLmNvbmNhdChldikpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogRmluZHMgYWxsIGFsaWFzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXJncyBUaGUgYXJyYXkgb2YgYXJndW1lbnRzIGFzIHN0cmluZ3MuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTaW1wbGVFdmVudENvbnRyb2wucHJvdG90eXBlLl9maW5kQWxpYXNlcyA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJncy5sZW5ndGgsIGFyZywgaGFzaCA9IHt9LCBhbGlhc2VzID0gW10sIHBhcnNlZEFsaWFzZXMgPSBbXSwgX3BhcnNlciA9IHRoaXMuX3BhcnNlcjtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmdzW2xlbmd0aF0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFsaWFzZXMgPSBwYXJzZWRBbGlhc2VzLmNvbmNhdChfcGFyc2VyLnBhcnNlKGFyZykuYWxpYXNlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyc2VkQWxpYXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gcGFyc2VkQWxpYXNlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc2hbYXJnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzLnB1c2goYXJnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFthcmddID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxpYXNlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyB0aGUgZXhwcmVzc2lvbiBhbmQgc2VwYXJhdGVzIHRoZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgKiBmcm9tIGl0cyBhcmd1bWVudHMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2ltcGxlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fcGFyc2VBcmdzID0gZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGV4cHJlc3Npb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGV4ZWMgPSB0aGlzLl9yZWdleC5hcmd1bWVudFJlZ2V4LmV4ZWMoZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVsbChleGVjKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cHJlc3Npb24gPSBbZXhwcmVzc2lvbi5zbGljZSgwLCBleGVjLmluZGV4KV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCgoZXhlY1sxXSAhPT0gJycpID8gZXhlY1sxXS5zcGxpdCgnLCcpIDogW10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwcmVzc2lvbi5wdXNoKGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpYXNlcyA9IHRoaXMuX2ZpbmRBbGlhc2VzKHRoaXMuX2V4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBTaW1wbGVFdmVudENvbnRyb2wuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9wYXJzZXI6IF9fUGFyc2VyLFxyXG4gICAgICAgICAgICAgICAgX3JlZ2V4OiBfX1JlZ2V4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTaW1wbGVFdmVudENvbnRyb2w7XHJcbiAgICAgICAgfShBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU2ltcGxlRXZlbnRDb250cm9sID0gU2ltcGxlRXZlbnRDb250cm9sO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0YXAnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVGFwLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUYXAoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVGFwO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVGFwID0gVGFwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJ2JsdXInIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBCbHVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEJsdXIsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJsdXIoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAnYmx1cic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEJsdXI7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5CbHVyID0gQmx1cjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdjaGFuZ2UnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDaGFuZ2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQ2hhbmdlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDaGFuZ2UoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAnY2hhbmdlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2hhbmdlO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQ2hhbmdlID0gQ2hhbmdlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJ2NvcHknIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDb3B5ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKENvcHksIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIENvcHkoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAnY29weSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIENvcHk7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Db3B5ID0gQ29weTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdjdXQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDdXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQ3V0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDdXQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAnY3V0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ3V0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuQ3V0ID0gQ3V0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJ3Bhc3RlJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUGFzdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoUGFzdGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhc3RlKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ3Bhc3RlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUGFzdGU7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5QYXN0ZSA9IFBhc3RlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyRkYmx0YXAnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBEYmxUYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoRGJsVGFwLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBEYmxUYXAoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX2RibHRhcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRGJsVGFwO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuRGJsVGFwID0gRGJsVGFwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJ2ZvY3VzJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRm9jdXMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoRm9jdXMsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZvY3VzKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2ZvY3VzJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRm9jdXM7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Gb2N1cyA9IEZvY3VzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0b3VjaHN0YXJ0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVG91Y2hTdGFydCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUb3VjaFN0YXJ0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUb3VjaFN0YXJ0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190b3VjaHN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUb3VjaFN0YXJ0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVG91Y2hTdGFydCA9IFRvdWNoU3RhcnQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHRvdWNoZW5kJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgVG91Y2hFbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVG91Y2hFbmQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRvdWNoRW5kKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX190b3VjaGVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVG91Y2hFbmQ7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Ub3VjaEVuZCA9IFRvdWNoRW5kO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0b3VjaG1vdmUnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUb3VjaE1vdmUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVG91Y2hNb3ZlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUb3VjaE1vdmUoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RvdWNobW92ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVG91Y2hNb3ZlO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVG91Y2hNb3ZlID0gVG91Y2hNb3ZlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0b3VjaGNhbmNlbCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRvdWNoQ2FuY2VsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRvdWNoQ2FuY2VsLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUb3VjaENhbmNlbCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fdG91Y2hjYW5jZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRvdWNoQ2FuY2VsO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVG91Y2hDYW5jZWwgPSBUb3VjaENhbmNlbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckaG9sZCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEhvbGQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoSG9sZCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gSG9sZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9faG9sZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gSG9sZDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLkhvbGQgPSBIb2xkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyRyZWxlYXNlJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgUmVsZWFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWxlYXNlLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBSZWxlYXNlKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19yZWxlYXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWxlYXNlO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuUmVsZWFzZSA9IFJlbGVhc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHN3aXBlJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3dpcGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3dpcGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN3aXBlKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19zd2lwZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU3dpcGU7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Td2lwZSA9IFN3aXBlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyRzd2lwZWxlZnQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTd2lwZUxlZnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3dpcGVMZWZ0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTd2lwZUxlZnQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3N3aXBlbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gU3dpcGVMZWZ0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU3dpcGVMZWZ0ID0gU3dpcGVMZWZ0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyRzd2lwZXJpZ2h0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3dpcGVSaWdodCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTd2lwZVJpZ2h0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTd2lwZVJpZ2h0KCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19zd2lwZXJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTd2lwZVJpZ2h0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU3dpcGVSaWdodCA9IFN3aXBlUmlnaHQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHN3aXBldXAnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTd2lwZVVwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN3aXBlVXAsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN3aXBlVXAoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3N3aXBldXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN3aXBlVXA7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5Td2lwZVVwID0gU3dpcGVVcDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckc3dpcGVkb3duJyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3dpcGVEb3duID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFN3aXBlRG93biwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3dpcGVEb3duKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gX19zd2lwZWRvd247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN3aXBlRG93bjtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlN3aXBlRG93biA9IFN3aXBlRG93bjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdHJhY2snIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmFjayA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUcmFjaywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHJhY2soKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RyYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFjaztcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRyYWNrID0gVHJhY2s7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHRyYWNrbGVmdCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRyYWNrTGVmdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhUcmFja0xlZnQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYWNrTGVmdCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fdHJhY2tsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBUcmFja0xlZnQ7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5UcmFja0xlZnQgPSBUcmFja0xlZnQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnJHRyYWNrcmlnaHQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmFja1JpZ2h0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRyYWNrUmlnaHQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyYWNrUmlnaHQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RyYWNrcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrUmlnaHQ7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5UcmFja1JpZ2h0ID0gVHJhY2tSaWdodDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICckdHJhY2t1cCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRyYWNrVXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhY2tVcCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVHJhY2tVcCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fdHJhY2t1cDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVHJhY2tVcDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlRyYWNrVXAgPSBUcmFja1VwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0cmFja2Rvd24nIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBUcmFja0Rvd24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVHJhY2tEb3duLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFja0Rvd24oKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBfX3RyYWNrZG93bjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gVHJhY2tEb3duO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVHJhY2tEb3duID0gVHJhY2tEb3duO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2ltcGxlRXZlbnRDb250cm9sIGZvciB0aGUgJyR0cmFja2VuZCcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFRyYWNrRW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFRyYWNrRW5kLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBUcmFja0VuZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudCA9IF9fdHJhY2tlbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFRyYWNrRW5kO1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuVHJhY2tFbmQgPSBUcmFja0VuZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNpbXBsZUV2ZW50Q29udHJvbCBmb3IgdGhlICdzdWJtaXQnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTdWJtaXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3VibWl0LCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTdWJtaXQoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAnc3VibWl0JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgc3VibWl0IGFjdGlvbiB1bmxlc3NcclxuICAgICAgICAgICAgICogdGhlIFwiYWN0aW9uXCIgYXR0cmlidXRlIGlzIHByZXNlbnQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTdWJtaXQucHJvdG90eXBlLl9vbkV2ZW50ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FjdGlvbicpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX29uRXZlbnQuY2FsbCh0aGlzLCBldik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBTdWJtaXQ7XHJcbiAgICAgICAgfShTaW1wbGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5TdWJtaXQgPSBTdWJtaXQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTaW1wbGVFdmVudENvbnRyb2wgZm9yIHRoZSAnaW5wdXQnIGV2ZW50LiBJZlxyXG4gICAgICAgICAqICdpbnB1dCcgaXMgbm90IGFuIGV2ZW50LCBpdCB3aWxsIHNpbXVsYXRlIGFuICdpbnB1dCcgdXNpbmcgb3RoZXIgZXZlbnRzIGxpa2UgJ2tleWRvd24nLFxyXG4gICAgICAgICAqICdjdXQnLCAncGFzdGUnLCBldGMuIEFsc28gZmlyZXMgb24gdGhlICdjaGFuZ2UnIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSZWFjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWFjdCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUmVhY3QoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAnaW5wdXQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGRzIGFueSBhbmQgYWxsIG5lY2Vzc2FyeSBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBSZWFjdC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBfY29tcGF0ID0gdGhpcy5fY29tcGF0LCBjb21wb3NpbmcgPSBmYWxzZSwgaW5wdXRGaXJlZCA9IGZhbHNlLCBpbnB1dCA9ICdpbnB1dCcsIHRpbWVvdXQsIGV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRXZlbnQoZXYpO1xyXG4gICAgICAgICAgICAgICAgfSwgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRpbWVvdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcihldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChfY29tcGF0LkFORFJPSUQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdjb21wb3NpdGlvbnN0YXJ0JywgZnVuY3Rpb24gKCkgeyBjb21wb3NpbmcgPSB0cnVlOyB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcihldik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGlucHV0LCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dEZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVyKGV2KTtcclxuICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY2hhbmdlJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RmlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRGaXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jb21wYXQuaGFzRXZlbnQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGV2LmtleUNvZGUsIGNvZGVzID0gY29udHJvbHMuS2V5Q29kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gY29kZXMubHdrIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0gY29kZXMucndrIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXkgPj0gY29kZXMuc2hpZnQgJiYga2V5IDw9IGNvZGVzLmVzY2FwZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGtleSA+IGNvZGVzLnNwYWNlICYmIGtleSA8PSBjb2Rlcy5kb3duKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvc3Rwb25lZEV2ZW50TGlzdGVuZXIoZXYpO1xyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdjdXQnLCBwb3N0cG9uZWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ3Bhc3RlJywgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBSZWFjdC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0O1xyXG4gICAgICAgIH0oU2ltcGxlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuUmVhY3QgPSBSZWFjdDtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVGFwLCBUYXApO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19CbHVyLCBCbHVyKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQ2hhbmdlLCBDaGFuZ2UpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Db3B5LCBDb3B5KTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQ3V0LCBDdXQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19QYXN0ZSwgUGFzdGUpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19EYmxUYXAsIERibFRhcCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0ZvY3VzLCBGb2N1cyk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1N1Ym1pdCwgU3VibWl0KTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVG91Y2hTdGFydCwgVG91Y2hTdGFydCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RvdWNoRW5kLCBUb3VjaEVuZCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RvdWNoTW92ZSwgVG91Y2hNb3ZlKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVG91Y2hDYW5jZWwsIFRvdWNoQ2FuY2VsKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fSG9sZCwgSG9sZCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1JlbGVhc2UsIFJlbGVhc2UpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Td2lwZSwgU3dpcGUpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Td2lwZUxlZnQsIFN3aXBlTGVmdCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1N3aXBlUmlnaHQsIFN3aXBlUmlnaHQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19Td2lwZVVwLCBTd2lwZVVwKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fU3dpcGVEb3duLCBTd2lwZURvd24pO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19UcmFjaywgVHJhY2spO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19UcmFja0xlZnQsIFRyYWNrTGVmdCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1RyYWNrUmlnaHQsIFRyYWNrUmlnaHQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19UcmFja1VwLCBUcmFja1VwKTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fVHJhY2tEb3duLCBUcmFja0Rvd24pO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19UcmFja0VuZCwgVHJhY2tFbmQpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19SZWFjdCwgUmVhY3QpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbWFwcGluZyBvZiBhbGwga2V5cyB0byB0aGVpciBlcXVpdmFsZW50IGtleUNvZGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29udHJvbHMuS2V5Q29kZXMgPSB7XHJcbiAgICAgICAgICAgICdiYWNrc3BhY2UnOiA4LFxyXG4gICAgICAgICAgICAndGFiJzogOSxcclxuICAgICAgICAgICAgJ2VudGVyJzogMTMsXHJcbiAgICAgICAgICAgICdzaGlmdCc6IDE2LFxyXG4gICAgICAgICAgICAnY3RybCc6IDE3LFxyXG4gICAgICAgICAgICAnYWx0JzogMTgsXHJcbiAgICAgICAgICAgICdwYXVzZSc6IDE5LCAnYnJlYWsnOiAxOSxcclxuICAgICAgICAgICAgJ2NhcHMgbG9jayc6IDIwLFxyXG4gICAgICAgICAgICAnZXNjYXBlJzogMjcsXHJcbiAgICAgICAgICAgICdzcGFjZSc6IDMyLFxyXG4gICAgICAgICAgICAncGFnZSB1cCc6IDMzLFxyXG4gICAgICAgICAgICAncGFnZSBkb3duJzogMzQsXHJcbiAgICAgICAgICAgICdlbmQnOiAzNSxcclxuICAgICAgICAgICAgJ2hvbWUnOiAzNixcclxuICAgICAgICAgICAgJ2xlZnQnOiAzNywgJ2xlZnQgYXJyb3cnOiAzNyxcclxuICAgICAgICAgICAgJ3VwJzogMzgsICd1cCBhcnJvdyc6IDM4LFxyXG4gICAgICAgICAgICAncmlnaHQnOiAzOSwgJ3JpZ2h0IGFycm93JzogMzksXHJcbiAgICAgICAgICAgICdkb3duJzogNDAsICdkb3duIGFycm93JzogNDAsXHJcbiAgICAgICAgICAgICdpbnNlcnQnOiA0NSxcclxuICAgICAgICAgICAgJ2RlbGV0ZSc6IDQ2LFxyXG4gICAgICAgICAgICAnMCc6IDQ4LCAnemVybyc6IDQ4LFxyXG4gICAgICAgICAgICAnKSc6IDQ4LCAncmlnaHQgcGFyZW50aGVzaXMnOiA0OCxcclxuICAgICAgICAgICAgJzEnOiA0OSwgJ29uZSc6IDQ5LFxyXG4gICAgICAgICAgICAnISc6IDQ5LCAnZXhjbGFtYXRpb24nOiA0OSwgJ2V4Y2xhbWF0aW9uIHBvaW50JzogNDksXHJcbiAgICAgICAgICAgICcyJzogNTAsICd0d28nOiA1MCxcclxuICAgICAgICAgICAgJ0AnOiA1MCwgJ2F0JzogNTAsXHJcbiAgICAgICAgICAgICczJzogNTEsICd0aHJlZSc6IDUxLFxyXG4gICAgICAgICAgICAnIyc6IDUxLCAnbnVtYmVyIHNpZ24nOiA1MSxcclxuICAgICAgICAgICAgJ2hhc2gnOiA1MSwgJ3BvdW5kJzogNTEsXHJcbiAgICAgICAgICAgICc0JzogNTIsICdmb3VyJzogNTIsXHJcbiAgICAgICAgICAgICckJzogNTIsICdkb2xsYXInOiA1MiwgJ2RvbGxhciBzaWduJzogNTIsXHJcbiAgICAgICAgICAgICc1JzogNTMsICdmaXZlJzogNTMsXHJcbiAgICAgICAgICAgICclJzogNTMsICdwZXJjZW50JzogNTMsICdwZXJjZW50IHNpZ24nOiA1MyxcclxuICAgICAgICAgICAgJzYnOiA1NCwgJ3NpeCc6IDU0LFxyXG4gICAgICAgICAgICAnXic6IDU0LCAnY2FyZXQnOiA1NCxcclxuICAgICAgICAgICAgJzcnOiA1NSwgJ3NldmVuJzogNTUsXHJcbiAgICAgICAgICAgICcmJzogNTUsICdhbXBlcnNhbmQnOiA1NSxcclxuICAgICAgICAgICAgJzgnOiA1NiwgJ2VpZ2h0JzogNTYsXHJcbiAgICAgICAgICAgICcqJzogNTYsICdhc3Rlcmlzayc6IDU2LFxyXG4gICAgICAgICAgICAnOSc6IDU3LCAnbmluZSc6IDU3LFxyXG4gICAgICAgICAgICAnKCc6IDU3LCAnbGVmdCBwYXJlbnRoZXNpcyc6IDU3LFxyXG4gICAgICAgICAgICAnYSc6IDY1LCAnYic6IDY2LCAnYyc6IDY3LCAnZCc6IDY4LCAnZSc6IDY5LFxyXG4gICAgICAgICAgICAnZic6IDcwLCAnZyc6IDcxLCAnaCc6IDcyLCAnaSc6IDczLCAnaic6IDc0LFxyXG4gICAgICAgICAgICAnayc6IDc1LCAnbCc6IDc2LCAnbSc6IDc3LCAnbic6IDc4LCAnbyc6IDc5LFxyXG4gICAgICAgICAgICAncCc6IDgwLCAncSc6IDgxLCAncic6IDgyLCAncyc6IDgzLCAndCc6IDg0LFxyXG4gICAgICAgICAgICAndSc6IDg1LCAndic6IDg2LCAndyc6IDg3LCAneCc6IDg4LCAneSc6IDg5LFxyXG4gICAgICAgICAgICAneic6IDkwLFxyXG4gICAgICAgICAgICAnbHdrJzogOTEsICdsZWZ0IHdpbmRvdyBrZXknOiA5MSxcclxuICAgICAgICAgICAgJ3J3ayc6IDkyLCAncmlnaHQgd2luZG93IGtleSc6IDkyLFxyXG4gICAgICAgICAgICAnc2VsZWN0JzogOTMsICdzZWxlY3Qga2V5JzogOTMsXHJcbiAgICAgICAgICAgICdudW1wYWQgMCc6IDk2LFxyXG4gICAgICAgICAgICAnbnVtcGFkIDEnOiA5NyxcclxuICAgICAgICAgICAgJ251bXBhZCAyJzogOTgsXHJcbiAgICAgICAgICAgICdudW1wYWQgMyc6IDk5LFxyXG4gICAgICAgICAgICAnbnVtcGFkIDQnOiAxMDAsXHJcbiAgICAgICAgICAgICdudW1wYWQgNSc6IDEwMSxcclxuICAgICAgICAgICAgJ251bXBhZCA2JzogMTAyLFxyXG4gICAgICAgICAgICAnbnVtcGFkIDcnOiAxMDMsXHJcbiAgICAgICAgICAgICdudW1wYWQgOCc6IDEwNCxcclxuICAgICAgICAgICAgJ251bXBhZCA5JzogMTA1LFxyXG4gICAgICAgICAgICAnbXVsdGlwbHknOiAxMDYsXHJcbiAgICAgICAgICAgICdhZGQnOiAxMDcsXHJcbiAgICAgICAgICAgICdzdWJ0cmFjdCc6IDEwOSxcclxuICAgICAgICAgICAgJ2RlY2ltYWwgcG9pbnQnOiAxMTAsXHJcbiAgICAgICAgICAgICdkaXZpZGUnOiAxMTEsXHJcbiAgICAgICAgICAgICdmMSc6IDExMiwgJ2YyJzogMTEzLCAnZjMnOiAxMTQsICdmNCc6IDExNSxcclxuICAgICAgICAgICAgJ2Y1JzogMTE2LCAnZjYnOiAxMTcsICdmNyc6IDExOCwgJ2Y4JzogMTE5LFxyXG4gICAgICAgICAgICAnZjknOiAxMjAsICdmMTAnOiAxMjEsICdmMTEnOiAxMjIsICdmMTInOiAxMjMsXHJcbiAgICAgICAgICAgICdudW0gbG9jayc6IDE0NCxcclxuICAgICAgICAgICAgJ3Njcm9sbCBsb2NrJzogMTQ1LFxyXG4gICAgICAgICAgICAnOyc6IDE4NiwgJ3NlbWktY29sb24nOiAxODYsXHJcbiAgICAgICAgICAgICc6JzogMTg2LCAnY29sb24nOiAxODYsXHJcbiAgICAgICAgICAgICc9JzogMTg3LCAnZXF1YWwnOiAxODcsICdlcXVhbCBzaWduJzogMTg3LFxyXG4gICAgICAgICAgICAnKyc6IDE4NywgJ3BsdXMnOiAxODcsXHJcbiAgICAgICAgICAgICcsJzogMTg4LCAnY29tbWEnOiAxODgsXHJcbiAgICAgICAgICAgICc8JzogMTg4LCAnbHQnOiAxODgsICdsZXNzIHRoYW4nOiAxODgsXHJcbiAgICAgICAgICAgICdsZWZ0IGFuZ2xlIGJyYWNrZXQnOiAxODgsXHJcbiAgICAgICAgICAgICctJzogMTg5LCAnZGFzaCc6IDE4OSxcclxuICAgICAgICAgICAgJ18nOiAxODksICd1bmRlcnNjb3JlJzogMTg5LFxyXG4gICAgICAgICAgICAnLic6IDE5MCwgJ3BlcmlvZCc6IDE5MCxcclxuICAgICAgICAgICAgJz4nOiAxOTAsICdndCc6IDE5MCwgJ2dyZWF0ZXIgdGhhbic6IDE5MCxcclxuICAgICAgICAgICAgJ3JpZ2h0IGFuZ2xlIGJyYWNrZXQnOiAxOTAsXHJcbiAgICAgICAgICAgICcvJzogMTkxLCAnZm9yd2FyZCBzbGFzaCc6IDE5MSxcclxuICAgICAgICAgICAgJz8nOiAxOTEsICdxdWVzdGlvbiBtYXJrJzogMTkxLFxyXG4gICAgICAgICAgICAnYCc6IDE5MiwgJ2dyYXZlIGFjY2VudCc6IDE5MixcclxuICAgICAgICAgICAgJ34nOiAxOTIsICd0aWxkZSc6IDE5MixcclxuICAgICAgICAgICAgJ1snOiAyMTksICdvcGVuIGJyYWNrZXQnOiAyMTksXHJcbiAgICAgICAgICAgICd7JzogMjE5LCAnb3BlbiBicmFjZSc6IDIxOSxcclxuICAgICAgICAgICAgJ1xcXFwnOiAyMjAsICdiYWNrIHNsYXNoJzogMjIwLFxyXG4gICAgICAgICAgICAnfCc6IDIyMCwgJ3BpcGUnOiAyMjAsXHJcbiAgICAgICAgICAgICddJzogMjIxLCAnY2xvc2UgYnJhY2tldCc6IDIyMSxcclxuICAgICAgICAgICAgJ30nOiAyMjEsICdjbG9zZSBicmFjZSc6IDIyMSxcclxuICAgICAgICAgICAgJ1xcJyc6IDIyMiwgJ3NpbmdsZSBxdW90ZSc6IDIyMixcclxuICAgICAgICAgICAgJ1wiJzogMjIyLCAnZG91YmxlIHF1b3RlJzogMjIyXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYXNlIGNsYXNzIHVzZWQgZm9yIGZpbHRlcmluZyBrZXlzIG9uIEtleWJvYXJkRXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBLZXlDb2RlRXZlbnRDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEtleUNvZGVFdmVudENvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEtleUNvZGVFdmVudENvbnRyb2woKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSG9sZHMgdGhlIGtleSBtYXBwaW5ncyB0byBmaWx0ZXIgZm9yIGluIGEgS2V5Ym9hcmRFdmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZXlDb2RlcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDaGVja3MgaWYgdGhlIElLZXlib2FyZEV2ZW50SW5wdXQgaXMgYW4gZXhwcmVzc2lvbiBvYmplY3RcclxuICAgICAgICAgICAgICogYW5kIHNldHMgdGhlIG5lY2Vzc2FyeSBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEtleUNvZGVFdmVudENvbnRyb2wucHJvdG90eXBlLl9zZXRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gdGhpcy5hdHRyaWJ1dGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmV2ZW50KSB8fCBpc0VtcHR5KGF0dHIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25bMF0gPT09ICd7Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudE9iamVjdCA9IHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24pIHx8IHsgbWV0aG9kOiAnJyB9LCBrZXlzID0gdGhpcy5fZmlsdGVyQXJncyhldmVudE9iamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0S2V5Q29kZXMoa2V5cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgdGhpcy5ldmVudCwgdGhpcy5fb25FdmVudCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3NldExpc3RlbmVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgdGhlIHByb3BlciBtZXRob2QgYXJncyBhbmQgZmluZHMgYW55IGtleSBjb2RlIGZpbHRlcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBLZXlDb2RlRXZlbnRDb250cm9sLnByb3RvdHlwZS5fZmlsdGVyQXJncyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGlucHV0LmtleSwga2V5cyA9IGlucHV0LmtleXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUFyZ3MoaW5wdXQubWV0aG9kKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGtleXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhrZXlzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBba2V5c107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBba2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlzTnVsbChpbnB1dC5jaGFyKSAmJiBpc051bGwoaW5wdXQuY2hhcnMpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLnR5cGUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBzaG91bGQgYmUgdXNpbmcgdGhlIHByb3BlcnR5IGtleSBvciBrZXlzIHRvIGRlbm90ZSBrZXkgY29kZXMgb3Iga2V5cyBhbmQgbm90IGNoYXIgY29kZXMgb3IgY2hhcmFjdGVycy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBNYXRjaGVzIHRoZSBldmVudCdzIGtleUNvZGUgaWYgbmVjZXNzYXJ5IGFuZCB0aGVuIGhhbmRsZXMgdGhlIGV2ZW50IGlmXHJcbiAgICAgICAgICAgICAqIGEgbWF0Y2ggaXMgZm91bmQgb3IgaWYgdGhlcmUgYXJlIG5vIGZpbHRlciBrZXlDb2Rlcy5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldiBUaGUga2V5Ym9hcmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgS2V5Q29kZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXJlS2V5cyhldikpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9vbkV2ZW50LmNhbGwodGhpcywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWF0Y2hlcyB0aGUgZXZlbnQncyBrZXlDb2RlIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldiBUaGUga2V5Ym9hcmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgS2V5Q29kZUV2ZW50Q29udHJvbC5wcm90b3R5cGUuX2NvbXBhcmVLZXlzID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZXMgPSB0aGlzLmtleUNvZGVzLCBrZXlDb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0VtcHR5KGtleUNvZGVzKSB8fCBrZXlDb2Rlc1trZXlDb2RlXSA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGRlZmluZWQga2V5IGNvZGVzIGFzIHRoZXkgY29ycmVzcG9uZCB0b1xyXG4gICAgICAgICAgICAgKiB0aGUgS2V5Q29kZXMgbWFwLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGtleXM/IFRoZSBhcnJheSBvZiBkZWZpbmVkIGtleXMgdG8gc2F0aXNmeSB0aGVcclxuICAgICAgICAgICAgICoga2V5IHByZXNzIGNvbmRpdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEtleUNvZGVFdmVudENvbnRyb2wucHJvdG90eXBlLl9zZXRLZXlDb2RlcyA9IGZ1bmN0aW9uIChrZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoa2V5cykpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGgsIGtleSwga2V5Q29kZXMgPSB0aGlzLmtleUNvZGVzLCBpbmRleDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaXNOdW1iZXIoa2V5KSA/IGtleSA6IGNvbnRyb2xzLktleUNvZGVzW2tleS50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBrZXlDb2Rlc1tpbmRleF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gS2V5Q29kZUV2ZW50Q29udHJvbDtcclxuICAgICAgICB9KFNpbXBsZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLktleUNvZGVFdmVudENvbnRyb2wgPSBLZXlDb2RlRXZlbnRDb250cm9sO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgZm9yIGZpbHRlcmluZyBrZXlzIG9uIGtleWRvd24gZXZlbnRzLiBEb2VzIG5vdCB0YWtlIGNhcGl0YWxpemF0aW9uIGludG8gYWNjb3VudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgS2V5RG93biA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhLZXlEb3duLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBLZXlEb3duKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBldmVudCBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50ID0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBLZXlEb3duO1xyXG4gICAgICAgIH0oS2V5Q29kZUV2ZW50Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLktleURvd24gPSBLZXlEb3duO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgZm9yIGZpbHRlcmluZyBvbmx5IHByaW50aW5nIGtleXMgKGEteiwgQS1aLCAwLTksIGFuZCBzcGVjaWFsIGNoYXJhY3RlcnMpIG9uIGtleWRvd24gZXZlbnRzLlxyXG4gICAgICAgICAqIERvZXMgbm90IHRha2UgY2FwaXRhbGl6YXRpb24gaW50byBhY2NvdW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBLZXlQcmVzcyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhLZXlQcmVzcywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gS2V5UHJlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEZpbHRlcnMgb25seSAncHJpbnRpbmcga2V5cycgKGEteiwgQS1aLCAwLTksIGFuZCBzcGVjaWFsIGNoYXJhY3RlcnMpLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2IFRoZSBLZXlib2FyZEV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEtleVByZXNzLnByb3RvdHlwZS5fb25FdmVudCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXYua2V5Q29kZSB8fCBldi53aGljaDtcclxuICAgICAgICAgICAgICAgIGlmIChfc3VwZXIucHJvdG90eXBlLl9jb21wYXJlS2V5cy5jYWxsKHRoaXMsIGV2KSAmJiAoKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA5MCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoa2V5Q29kZSA+PSAxODYpIHx8IChrZXlDb2RlID49IDk2ICYmIGtleUNvZGUgPD0gMTExKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlXzEgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCAna2V5cHJlc3MnLCBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9vbkV2ZW50LmNhbGwoX3RoaXMsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE1hdGNoZXMgdGhlIGV2ZW50J3Mga2V5Q29kZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEtleVByZXNzLnByb3RvdHlwZS5fY29tcGFyZUtleXMgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gS2V5UHJlc3M7XHJcbiAgICAgICAgfShLZXlDb2RlRXZlbnRDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuS2V5UHJlc3MgPSBLZXlQcmVzcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGZvciBmaWx0ZXJpbmcga2V5cyBvbiBrZXl1cCBldmVudHMuIERvZXMgbm90IHRha2UgY2FwaXRhbGl6YXRpb24gaW50byBhY2NvdW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBLZXlVcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhLZXlVcCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gS2V5VXAoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAna2V5dXAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBLZXlVcDtcclxuICAgICAgICB9KEtleUNvZGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5LZXlVcCA9IEtleVVwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgZm9yIGZpbHRlcmluZyBrZXlzIG9uIGtleXByZXNzIGV2ZW50cy4gVGFrZXMgY2FwaXRhbGl6YXRpb24gaW50byBhY2NvdW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBDaGFyUHJlc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQ2hhclByZXNzLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDaGFyUHJlc3MoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGV2ZW50IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnQgPSAna2V5cHJlc3MnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQYXJzZXMgdGhlIHByb3BlciBtZXRob2QgYXJncyBhbmQgZmluZHMgYW55IGNoYXIgY29kZSBmaWx0ZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2hhclByZXNzLnByb3RvdHlwZS5fZmlsdGVyQXJncyA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBpbnB1dC5jaGFyLCBjaGFycyA9IGlucHV0LmNoYXJzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VBcmdzKGlucHV0Lm1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjaGFycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhcnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhjaGFycykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NoYXJzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoY2hhcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjaGFyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGlzTnVsbChpbnB1dC5rZXkpICYmIGlzTnVsbChpbnB1dC5rZXlzKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgc2hvdWxkIGJlIHVzaW5nIHRoZSBwcm9wZXJ0eSBrZXkgb3Iga2V5cyB0byBkZW5vdGUga2V5IGNvZGVzIG9yIGtleXMgYW5kIG5vdCBjaGFyIGNvZGVzIG9yIGNoYXJhY3RlcnMuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWF0Y2hlcyB0aGUgZXZlbnQncyBrZXlDb2RlIGlmIG5lY2Vzc2FyeSBhbmQgdGhlbiBoYW5kbGVzIHRoZSBldmVudCBpZlxyXG4gICAgICAgICAgICAgKiBhIG1hdGNoIGlzIGZvdW5kIG9yIGlmIHRoZXJlIGFyZSBubyBmaWx0ZXIga2V5Q29kZXMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXYgVGhlIGtleWJvYXJkIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIENoYXJQcmVzcy5wcm90b3R5cGUuX29uRXZlbnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlcyA9IHRoaXMua2V5Q29kZXMsIGtleUNvZGUgPSBldi5jaGFyQ29kZSB8fCBldi53aGljaCwga2V5O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFrZXlDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZXYua2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgha2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkoa2V5Q29kZXMpIHx8IGtleUNvZGVzW2tleV0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9vbkV2ZW50LmNhbGwodGhpcywgZXYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogTWF0Y2hlcyB0aGUgZXZlbnQncyBrZXlDb2RlIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldiBUaGUga2V5Ym9hcmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2hhclByZXNzLnByb3RvdHlwZS5fY29tcGFyZUtleXMgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgZGVmaW5lZCBrZXkgY29kZXMgYXMgdGhleSBjb3JyZXNwb25kIHRvXHJcbiAgICAgICAgICAgICAqIHRoZSBLZXlDb2RlcyBtYXAuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0ga2V5cz8gVGhlIGFycmF5IG9mIGRlZmluZWQga2V5cyB0byBzYXRpc2Z5IHRoZVxyXG4gICAgICAgICAgICAgKiBrZXkgcHJlc3MgY29uZGl0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQ2hhclByZXNzLnByb3RvdHlwZS5fc2V0S2V5Q29kZXMgPSBmdW5jdGlvbiAoa2V5cykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGtleXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoLCBrZXksIGtleUNvZGVzID0gdGhpcy5rZXlDb2RlcywgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGlzTnVtYmVyKGtleSkgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleSkgOiBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5Q29kZXNbaW5kZXhdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIENoYXJQcmVzcztcclxuICAgICAgICB9KEtleUNvZGVFdmVudENvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5DaGFyUHJlc3MgPSBDaGFyUHJlc3M7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0tleURvd24sIEtleURvd24pO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19LZXlQcmVzcywgS2V5UHJlc3MpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19LZXlVcCwgS2V5VXApO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19DaGFyUHJlc3MsIENoYXJQcmVzcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gQXR0cmlidXRlQ29udHJvbCB0aGF0IGRlYWxzIHdpdGggYmluZGluZyB0byBhIHNwZWNpZmllZCBwcm9wZXJ0eSBvbiBpdHMgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU2V0QXR0cmlidXRlQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhTZXRBdHRyaWJ1dGVDb250cm9sLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTZXRBdHRyaWJ1dGVDb250cm9sKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzZXQgb24gdGhlIGFzc29jaWF0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIHRoZSBkZWxheWVkIGF0dHJpYnV0ZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTZXR0ZXIgPSBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSB7cHJvcGVydHl9IHZhbHVlIGFuZFxyXG4gICAgICAgICAgICAgKiBvYnNlcnZlcyB0aGUgYXR0cmlidXRlIGZvciBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2V0QXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLmVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBjYW1lbENhc2UodGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLmF0dHJpYnV0ZXMub2JzZXJ2ZSh0aGlzLnNldHRlciwgdGhpcy5hdHRyaWJ1dGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVzZXRzIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSBwcm9wZXJ0eSB2YWx1ZSB1cG9uXHJcbiAgICAgICAgICAgICAqIGEgY2hhbmdlIG9mIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTZXRBdHRyaWJ1dGVDb250cm9sLnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5lbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGVyKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTdG9wcyBsaXN0ZW5pbmcgdG8gYXR0cmlidXRlIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTZXRBdHRyaWJ1dGVDb250cm9sLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFNldHRlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpcy5fX3JlbW92ZUxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZW1vdmVMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19yZW1vdmVMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gZm9yIHNldHRpbmcgdGhlIGNvcnJlc3BvbmRpbmdcclxuICAgICAgICAgICAgICogYXR0cmlidXRlIHByb3BlcnR5IHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU2V0QXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuc2V0dGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTZXR0ZXIoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BTZXR0ZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVHbG9iYWwoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZWxlbWVudCwgcHJvcGVydHkgPSBfdGhpcy5wcm9wZXJ0eTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX3RoaXMuYXR0cmlidXRlc1tfdGhpcy5hdHRyaWJ1dGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZhbHNlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcGVydHksICcnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbcHJvcGVydHldID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCBwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W3Byb3BlcnR5XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFNldEF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICAgICAgfShBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU2V0QXR0cmlidXRlQ29udHJvbCA9IFNldEF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTZXRBdHRyaWJ1dGVDb250cm9sIGZvciB0aGUgJ2NoZWNrZWQnIGF0dHJpYnV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgQ2hlY2tlZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhDaGVja2VkLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBDaGVja2VkKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzZXQgb24gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGUgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICdjaGVja2VkJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gQ2hlY2tlZDtcclxuICAgICAgICB9KFNldEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5DaGVja2VkID0gQ2hlY2tlZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNldEF0dHJpYnV0ZUNvbnRyb2wgZm9yIHRoZSAnZGlzYWJsZWQnIGF0dHJpYnV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgRGlzYWJsZWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoRGlzYWJsZWQsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIERpc2FibGVkKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzZXQgb24gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGUgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICdkaXNhYmxlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIERpc2FibGVkO1xyXG4gICAgICAgIH0oU2V0QXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLkRpc2FibGVkID0gRGlzYWJsZWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBTZXRBdHRyaWJ1dGVDb250cm9sIGZvciB0aGUgJ3NlbGVjdGVkJyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFNlbGVjdGVkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKFNlbGVjdGVkLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTZWxlY3RlZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnc2VsZWN0ZWQnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBTZWxlY3RlZDtcclxuICAgICAgICB9KFNldEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5TZWxlY3RlZCA9IFNlbGVjdGVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgU2V0QXR0cmlidXRlQ29udHJvbCBmb3IgdGhlICdyZWFkb25seScgYXR0cmlidXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBSZWFkT25seSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhSZWFkT25seSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gUmVhZE9ubHkoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIHNldCBvbiB0aGUgYXNzb2NpYXRlZCB0ZW1wbGF0ZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gJ3JlYWRvbmx5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gUmVhZE9ubHk7XHJcbiAgICAgICAgfShTZXRBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuUmVhZE9ubHkgPSBSZWFkT25seTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNldEF0dHJpYnV0ZUNvbnRyb2wgZm9yIHRoZSAncGxhdC1oaWRlJyBhdHRyaWJ1dGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIFZpc2libGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoVmlzaWJsZSwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gVmlzaWJsZSgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnZGlzcGxheSc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSB2YWx1ZSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBpbXBvcnRhbmNlIHRvIHNldCBvbiB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuaW1wb3J0YW5jZSA9ICdpbXBvcnRhbnQnO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGlkZXMgdGhlIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaXNpYmxlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5lbGVtZW50LnN0eWxlIHx8IHsgZ2V0UHJvcGVydHlWYWx1ZTogbm9vcCB9LCBpbml0aWFsVmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMucHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUodGhpcy52YWx1ZSwgdGhpcy5pbXBvcnRhbmNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGluaXRpYWxWYWx1ZSkgfHwgaW5pdGlhbFZhbHVlID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIaWRlcyBvciBzaG93cyB0aGUgZWxlbWVudCBkZXBlbmRpbmcgdXBvbiB0aGUgYXR0cmlidXRlIHZhbHVlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBWaXNpYmxlLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFNldHRlcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFNldHRlciA9IHJlcXVlc3RBbmltYXRpb25GcmFtZUdsb2JhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoX3RoaXMuZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF90aGlzLmF0dHJpYnV0ZXNbX3RoaXMuYXR0cmlidXRlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWxzZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRWYWx1ZShfdGhpcy52YWx1ZSwgX3RoaXMuaW1wb3J0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRWYWx1ZShfdGhpcy5faW5pdGlhbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGVsZW1lbnQgd2l0aCB0aGUgZ2l2ZW4gaW1wb3J0YW5jZS4gSWYgdGhlXHJcbiAgICAgICAgICAgICAqIHZhbHVlIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nLCB0aGUgcHJvcGVydHkgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGltcG9ydGFuY2U/IFRoZSBwcmlvcml0eSBvciBpbXBvcnRhbmNlIGxldmVsIHRvIHNldC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFZpc2libGUucHJvdG90eXBlLl9zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW1wb3J0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eSwgc3R5bGUgPSB0aGlzLmVsZW1lbnQuc3R5bGUgfHwge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFByb3BlcnR5OiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVByb3BlcnR5OiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgIGdldFByb3BlcnR5VmFsdWU6IG5vb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0UHJvcGVydHlQcmlvcml0eTogbm9vcFxyXG4gICAgICAgICAgICAgICAgfSwgY3VycmVudFZhbCA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpLCBjdXJyZW50UHJpb3JpdHkgPSBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudFZhbCAmJiBpbXBvcnRhbmNlID09PSBjdXJyZW50UHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0VtcHR5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIGltcG9ydGFuY2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gVmlzaWJsZTtcclxuICAgICAgICB9KFNldEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5WaXNpYmxlID0gVmlzaWJsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIFNldEF0dHJpYnV0ZUNvbnRyb2wgZm9yIHRoZSAnc3R5bGUnIGF0dHJpYnV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgU3R5bGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3R5bGUsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFN0eWxlKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBwcm9wZXJ0eSB0byBzZXQgb24gdGhlIGFzc29jaWF0ZWQgdGVtcGxhdGUgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICdzdHlsZSc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEEgcmVndWxhciBleHByZXNzaW9uIGZvciBzZXBhcmF0aW5nIHN0eWxlIHByb3BlcnRpZXMgZnJvbSBzdHlsZSB2YWx1ZXMgaW5cclxuICAgICAgICAgICAgICAgICAqIGluZGl2aWR1YWwgc3R5bGUgZGVjbGFyYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdHlsZVJlZ2V4ID0gLyguKj8pOiguKikvO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGVtcG9yYXJpbHkgZmluZGluZyBhbmQgcmVtb3ZpbmcgdXJsIGRlY2xhcmF0aW9ucyBpbiB0aGUgc3R5bGUgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cmxSZWdleCA9IC91cmxcXChbXlxcKV0qXFwpL2dpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdGVtcG9yYXJ5IHJlcGxhY2UgdmFsdWUgb2YgdXJscyBmb3VuZCBpbiB0aGUgc3R5bGUgYXR0cmlidXRlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cmxSZXBsYWNlID0gJ1tQTEFULVNUWUxFLVVSTF0nO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBbiBvYmplY3Qgc3RvcmluZyBhbGwgdGhlIGFkZGVkIHN0eWxlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2FkZGVkU3R5bGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFuIG9iamVjdCBzdG9yaW5nIGFsbCB0aGUgb2xkIHN0eWxlIHZhbHVlcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX29sZFN0eWxlcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBldmFsdWF0ZWQgc3R5bGVzIG9uIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgU3R5bGUucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU2V0dGVyKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgZXhwcmVzc2lvbiA9IHRoaXMuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShleHByZXNzaW9uKSB8fCBpc051bGwoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wU2V0dGVyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lR2xvYmFsKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXJscyA9IFtdLCB1cmxSZXBsYWNlID0gX3RoaXMuX3VybFJlcGxhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZShfdGhpcy5fdXJsUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxzLnB1c2gobWF0Y2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsUmVwbGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlLCBhZGRlZFN0eWxlcyA9IF90aGlzLl9fYWRkZWRTdHlsZXMsIG9sZFN0eWxlcyA9IF90aGlzLl9fb2xkU3R5bGVzLCBuZXdTdHlsZXMgPSBbXSwgcHJvcHMgPSBleHByZXNzaW9uLnNwbGl0KCc7JyksIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgcHJvcCwgdmFsLCBzdHlsZVJlZ2V4ID0gX3RoaXMuX3N0eWxlUmVnZXgsIGV4ZWMsIHN0eWxlQ2hhbmdlcyA9IHt9LCBpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjID0gc3R5bGVSZWdleC5leGVjKHByb3BzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVsbChleGVjKSB8fCBleGVjLmxlbmd0aCA8IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AgPSBleGVjWzFdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AubGVuZ3RoID09PSAwIHx8IGlzVW5kZWZpbmVkKHN0eWxlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWRkZWRTdHlsZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFN0eWxlc1twcm9wXSA9IHN0eWxlW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0eWxlcy5wdXNoKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBleGVjWzJdLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVybHMubGVuZ3RoID4gMCAmJiB2YWwuaW5kZXhPZih1cmxSZXBsYWNlKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKHVybFJlcGxhY2UsIHVybHMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVDaGFuZ2VzW3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBhZGRlZFN0eWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGxlbmd0aC0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gYWRkZWRTdHlsZXNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1N0eWxlcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVDaGFuZ2VzW3Byb3BdID0gb2xkU3R5bGVzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRTdHlsZXMuc3BsaWNlKGxlbmd0aCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZUNoYW5nZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcCA9IGtleXNbbGVuZ3RoXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVbcHJvcF0gPSBzdHlsZUNoYW5nZXNbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fYWRkZWRTdHlsZXMgPSBhZGRlZFN0eWxlcy5jb25jYXQobmV3U3R5bGVzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU3R5bGU7XHJcbiAgICAgICAgfShTZXRBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuU3R5bGUgPSBTdHlsZTtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQ2hlY2tlZCwgQ2hlY2tlZCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX0Rpc2FibGVkLCBEaXNhYmxlZCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1NlbGVjdGVkLCBTZWxlY3RlZCk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1JlYWRPbmx5LCBSZWFkT25seSk7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1Zpc2libGUsIFZpc2libGUpO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19TdHlsZSwgU3R5bGUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhc2UgY2xhc3MgdXNlZCBmb3Igc2V0dGluZyB0aGUgcHJvcGVydHkgb2YgYW4gZWxlbWVudCAoZS5nLiBocmVmIGZvciBhbmNob3IgZWxlbWVudHMpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBFbGVtZW50UHJvcGVydHlDb250cm9sID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICAgICAgX19leHRlbmRzKEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2wsIF9zdXBlcik7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2woKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgICAgICAgICAqIGF0dHJpYnV0ZSBwcm9wZXJ0eSB2YWx1ZSB0byB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBFbGVtZW50UHJvcGVydHlDb250cm9sLnByb3RvdHlwZS5zZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgZWxlbWVudFByb3BlcnR5ID0gdGhpcy5wcm9wZXJ0eSwgZXhwcmVzc2lvbiA9IHRoaXMuYXR0cmlidXRlc1t0aGlzLmF0dHJpYnV0ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShleHByZXNzaW9uKSB8fCBpc051bGwoZWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGVsZW1lbnRbZWxlbWVudFByb3BlcnR5XSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50W2VsZW1lbnRQcm9wZXJ0eV0gPSBleHByZXNzaW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFByb3BlcnR5Q29udHJvbDtcclxuICAgICAgICB9KFNldEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5FbGVtZW50UHJvcGVydHlDb250cm9sID0gRWxlbWVudFByb3BlcnR5Q29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHR5cGUgb2YgRWxlbWVudFByb3BlcnR5Q29udHJvbCB1c2VkIHRvIHNldCAnaHJlZicgb24gYW4gYW5jaG9yIHRhZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgSHJlZiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhIcmVmLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBIcmVmKCkge1xyXG4gICAgICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gc2V0IHRoZSBlbGVtZW50J3MgaHJlZiBwcm9wZXJ0eS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9ICdocmVmJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gSHJlZjtcclxuICAgICAgICB9KEVsZW1lbnRQcm9wZXJ0eUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5IcmVmID0gSHJlZjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHR5cGUgb2YgRWxlbWVudFByb3BlcnR5Q29udHJvbCB1c2VkIHRvIHNldCAnc3JjJyBvbiBhbiBhbmNob3IgdGFnLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBTcmMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoU3JjLCBfc3VwZXIpO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBTcmMoKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXNlZCB0byBzZXQgdGhlIGVsZW1lbnQncyBzcmMgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnc3JjJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBjb3JyZXNwb25kaW5nXHJcbiAgICAgICAgICAgICAqIGF0dHJpYnV0ZSBwcm9wZXJ0eSB2YWx1ZSB0byB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBTcmMucHJvdG90eXBlLnNldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBlbGVtZW50UHJvcGVydHkgPSB0aGlzLnByb3BlcnR5LCBleHByZXNzaW9uID0gdGhpcy5hdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGV4cHJlc3Npb24pIHx8IGlzTnVsbChlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoZWxlbWVudFtlbGVtZW50UHJvcGVydHldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbZWxlbWVudFByb3BlcnR5XSA9IHRoaXMuX2Jyb3dzZXIudXJsVXRpbHMoZXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFNyYy5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX2Jyb3dzZXI6IF9fQnJvd3NlclxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gU3JjO1xyXG4gICAgICAgIH0oRWxlbWVudFByb3BlcnR5Q29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLlNyYyA9IFNyYztcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fSHJlZiwgSHJlZik7XHJcbiAgICAgICAgcmVnaXN0ZXIuY29udHJvbChfX1NyYywgU3JjKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWNpbGl0YXRlcyB0d28td2F5IGRhdGFiaW5kaW5nIGZvciBIVE1MSW5wdXRFbGVtZW50cywgSFRNTFNlbGVjdEVsZW1lbnRzLCBhbmQgSFRNTFRleHRBcmVhRWxlbWVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIEJpbmQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoQmluZCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gQmluZCgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJpb3JpdHkgb2YgQmluZCBpcyBzZXQgaGlnaCB0byBwcmVjZWRlXHJcbiAgICAgICAgICAgICAgICAgKiBvdGhlciBjb250cm9scyB0aGF0IG1heSBiZSBsaXN0ZW5pbmcgdG8gdGhlIHNhbWVcclxuICAgICAgICAgICAgICAgICAqIGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByaW9yaXR5ID0gMTAwO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBCaW5kIGlzIGJlaW5nIHVzZWQgaW4gY29uanVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAqIHdpdGggYSBUZW1wbGF0ZUNvbnRyb2wgdGhhdCBpbXBsZW1lbnRzIHRoZVxyXG4gICAgICAgICAgICAgICAgICogaW50ZXJmYWNlIElTdXBwb3J0VHdvV2F5QmluZGluZy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNUd29XYXlCaW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBGaWxlIEFQSSBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX19maWxlU3VwcG9ydGVkID0gYWNxdWlyZShfX0NvbXBhdCkuZmlsZVN1cHBvcnRlZDtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXNlZCB0byBncmFiIGEgZmlsZW5hbWUgZnJvbSBpbnB1dFt0eXBlPVwiZmlsZVwiXS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2ZpbGVOYW1lUmVnZXggPSBhY3F1aXJlKF9fUmVnZXgpLmZpbGVOYW1lUmVnZXg7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVzZWQgdG8gZGVub3RlIHRoYXQgYSBwcm9wZXJ0eSBjaGFuZ2UgaGFwcGVuZWQgZnJvbSB3aXRoaW4gdGhpcyBjb250cm9sLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9faXNTZWxmID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgdGhlIHR5cGUgb2YgRWxlbWVudCBiZWluZyBib3VuZCB0b1xyXG4gICAgICAgICAgICAgKiBhbmQgc2V0cyB0aGUgbmVjZXNzYXJ5IGhhbmRsZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZVR5cGUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFBhcnNlcyBhbmQgd2F0Y2hlcyB0aGUgZXhwcmVzc2lvbiBiZWluZyBib3VuZCB0by5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwocGFyZW50KSB8fCBpc051bGwodGhpcy5lbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhdHRyID0gY2FtZWxDYXNlKHRoaXMudHlwZSksIF9wYXJzZXIgPSB0aGlzLl9wYXJzZXIsIGV4cHJlc3Npb24gPSB0aGlzLl9leHByZXNzaW9uID0gX3BhcnNlci5wYXJzZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlkZW50aWZpZXJzID0gZXhwcmVzc2lvbi5pZGVudGlmaWVycztcclxuICAgICAgICAgICAgICAgIGlmIChpZGVudGlmaWVycy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2FybignT25seSAxIGlkZW50aWZpZXIgYWxsb3dlZCBpbiBhICcgKyB0aGlzLnR5cGUgKyAnIGV4cHJlc3Npb24uJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dEV4cHJlc3Npb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGlkZW50aWZpZXJzWzBdLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eSA9IHNwbGl0LnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uYWxpYXNlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gZXhwcmVzc2lvbi5hbGlhc2VzWzBdLCByZXNvdXJjZU9ial8xID0gcGFyZW50LmZpbmRSZXNvdXJjZShhbGlhcyksIHR5cGUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHJlc291cmNlT2JqXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSByZXNvdXJjZU9ial8xLnJlc291cmNlLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSBfX09CU0VSVkFCTEVfUkVTT1VSQ0UgJiYgdHlwZSAhPT0gX19MSVRFUkFMX1JFU09VUkNFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc291cmNlT2JqXzEgPSB7IHJlc291cmNlOiB7fSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXMgPT09IF9fQ09OVEVYVF9SRVNPVVJDRSB8fCBhbGlhcyA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dEV4cHJlc3Npb24gPSBfcGFyc2VyLnBhcnNlKHNwbGl0LmpvaW4oJy4nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eSA9ICd2YWx1ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRFeHByZXNzaW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VPYmpfMS5yZXNvdXJjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlhc2VzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXJzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3BsaXQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHRFeHByZXNzaW9uID0gX3BhcnNlci5wYXJzZShzcGxpdC5qb2luKCcuJykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dEV4cHJlc3Npb24gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmNvbnRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWFzZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyczogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246ICcnXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdXBwb3J0c1R3b1dheUJpbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlQ29udHJvbC5vYnNlcnZlUHJvcGVydGllcyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3dhdGNoRXhwcmVzc2lvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLl9hZGRFdmVudFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZS1vYnNlcnZlcyB0aGUgZXhwcmVzc2lvbiB3aXRoIHRoZSBuZXcgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd2F0Y2hFeHByZXNzaW9uKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGFsbCBvZiB0aGUgZWxlbWVudCdzIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgYm91bmQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5fZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChleHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBpZGVudGlmaWVyLCBhdXRvY2FzdCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVQcm9wZXJ0eShsaXN0ZW5lciwgaWRlbnRpZmllciwgYXV0b2Nhc3QpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5vYnNlcnZlQXJyYXlDaGFuZ2UgPSBmdW5jdGlvbiAobGlzdGVuZXIsIGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vYnNlcnZlUHJvcGVydHkobGlzdGVuZXIsIGlkZW50aWZpZXIsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSB0ZXh0IGV2ZW50IGFzIHRoZSBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgICAgICogVXNlZCBmb3IgdGV4dGFyZWEgYW5kIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2FkZFRleHRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBfY29tcGF0ID0gdGhpcy5fY29tcGF0LCBjb21wb3NpbmcgPSBmYWxzZSwgaW5wdXQgPSAnaW5wdXQnLCB0aW1lb3V0LCBldmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wb3NpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJvcGVydHlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBwb3N0cG9uZWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRpbWVvdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX2NvbXBhdC5BTkRST0lEKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY29tcG9zaXRpb25zdGFydCcsIGZ1bmN0aW9uICgpIHsgY29tcG9zaW5nID0gdHJ1ZTsgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY29tcG9zaXRpb25lbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKF9jb21wYXQuaGFzRXZlbnQoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGlucHV0LCBldmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGV2LmtleUNvZGUgfHwgZXYud2hpY2gsIGNvZGVzID0gY29udHJvbHMuS2V5Q29kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IGNvZGVzLmx3ayB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID09PSBjb2Rlcy5yd2sgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChrZXkgPj0gY29kZXMuc2hpZnQgJiYga2V5IDw9IGNvZGVzLmVzY2FwZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChrZXkgPiBjb2Rlcy5zcGFjZSAmJiBrZXkgPD0gY29kZXMuZG93bikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0cG9uZWRFdmVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAnY3V0JywgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCAncGFzdGUnLCBwb3N0cG9uZWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgJ2NoYW5nZScsIGV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBjaGFuZ2UgZXZlbnQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKiBVc2VkIGZvciBzZWxlY3QsIGlucHV0W3R5cGU9XCJyYWRpb1wiXSwgYW5kIGlucHV0W3R5cGU9XCJyYW5nZVwiXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9hZGRDaGFuZ2VFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgJ2NoYW5nZScsIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhICR0YXAgZXZlbnQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKiBVc2VkIGZvciBpbnB1dFt0eXBlPVwiYnV0dG9uXCJdIGFuZCBidXR0b24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fYWRkQnV0dG9uRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIF9fdGFwLCB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFkZHMgYSBjaGFuZ2UgZXZlbnQgYXMgdGhlIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKiBVc2VkIGZvciBzZWxlY3QsIGlucHV0W3R5cGU9XCJyYWRpb1wiXSwgYW5kIGlucHV0W3R5cGU9XCJyYW5nZVwiXS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9hZGRSYW5nZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgaW5wdXQgPSAnaW5wdXQnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhdC5oYXNFdmVudChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgaW5wdXQsIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsICdjaGFuZ2UnLCB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHRlciBmb3IgaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdIGFuZCBpbnB1dFt0eXBlPVwicmFkaW9cIl0uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fZ2V0Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2hlY2tlZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHRlciBmb3IgaW5wdXRbdHlwZT1cInRleHRcIl0sIGlucHV0W3R5cGU9XCJyYW5nZVwiXSxcclxuICAgICAgICAgICAgICogdGV4dGFyZWEsIGFuZCBzZWxlY3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0dGVyIGZvciBidXR0b24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0dGVyIGZvciBpbnB1dFt0eXBlPVwiZmlsZVwiXS4gQ3JlYXRlcyBhIHBhcnRpYWwgSUZpbGVcclxuICAgICAgICAgICAgICogZWxlbWVudCBpZiBmaWxlIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fZ2V0RmlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2ZpbGVTdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5maWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmZpbGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdmFsdWUucmVwbGFjZSh0aGlzLl9fZmlsZU5hbWVSZWdleCwgJycpLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb2RpZmllZERhdGU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgIG1zRGV0YWNoU3RyZWFtOiBub29wLFxyXG4gICAgICAgICAgICAgICAgICAgIG1zQ2xvc2U6IG5vb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgc2xpY2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9OyB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0dGVyIGZvciBpbnB1dFt0eXBlPVwiZmlsZVwiXS1tdWx0aXBsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9nZXRGaWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19maWxlU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuZmlsZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjYXNlIHNob3VsZCBuZXZlciBiZSBoaXQgc2luY2UgaWU5IGRvZXMgbm90IHN1cHBvcnQgbXVsdGktZmlsZSB1cGxvYWRzLCBcclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBrZXB0IGluIGhlcmUgZm9yIG5vdyBmb3IgY29uc2lzdGVuY3kncyBzYWtlIFxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVsaXN0ID0gZWxlbWVudC52YWx1ZS5zcGxpdCgvLHw7L2cpLCBsZW5ndGggPSBmaWxlbGlzdC5sZW5ndGgsIGZpbGVzID0gW10sIGZpbGVWYWx1ZSwgYmxvYlNsaWNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge307IH07XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVZhbHVlID0gZmlsZWxpc3RbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZpbGVWYWx1ZS5yZXBsYWNlKHRoaXMuX19maWxlTmFtZVJlZ2V4LCAnJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGZpbGVWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkRGF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXNEZXRhY2hTdHJlYW06IG5vb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zQ2xvc2U6IG5vb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlOiBibG9iU2xpY2VcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEdldHRlciBmb3Igc2VsZWN0LW11bHRpcGxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2dldFNlbGVjdGVkVmFsdWVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQub3B0aW9ucywgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGgsIG9wdGlvbiwgc2VsZWN0ZWRWYWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMucHVzaChvcHRpb24udmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZFZhbHVlcztcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHRlciBmb3IgdGV4dGFyZWEsIGlucHV0W3R5cGU9XCJ0ZXh0XCJdLFxyXG4gICAgICAgICAgICAgKiBhbmQgaW5wdXRbdHlwZT1cImJ1dHRvblwiXSwgYW5kIHNlbGVjdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgcHJldmlvdXNseSBib3VuZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gVGhlIGNvbnRleHQgaXMgYmVpbmcgZXZhbHVhdGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcclxuICAgICAgICAgICAgICogc2hvdWxkIHRodXMgY2hhbmdlIHRoZSBwcm9wZXJ0eSBpZiBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fc2V0VGV4dCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc1NlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuZWxlbWVudC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHRlciBmb3IgaW5wdXRbdHlwZT1cInJhbmdlXCJdLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXRcclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBwcmV2aW91c2x5IGJvdW5kIHZhbHVlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBUaGUgY29udGV4dCBpcyBiZWluZyBldmFsdWF0ZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZFxyXG4gICAgICAgICAgICAgKiBzaG91bGQgdGh1cyBjaGFuZ2UgdGhlIHByb3BlcnR5IGlmIG51bGxcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9zZXRSYW5nZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc1NlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSAnJyA/ICcwJyA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLmVsZW1lbnQudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTZXR0ZXIgZm9yIGlucHV0W3R5cGU9XCJoaWRkZW5cIl0uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIHByZXZpb3VzbHkgYm91bmQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFRoZSBjb250ZXh0IGlzIGJlaW5nIGV2YWx1YXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXHJcbiAgICAgICAgICAgICAqIHNob3VsZCB0aHVzIGNoYW5nZSB0aGUgcHJvcGVydHkgaWYgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldEhpZGRlbiA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc1NlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5lbGVtZW50LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb24gYW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fc2V0VmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdudW1iZXInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbihuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlUeXBlID0gJ2Jvb2xlYW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgPT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0dGVyIGZvciBpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl1cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgdG8gc2V0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZSBUaGUgcHJldmlvdXNseSBib3VuZCB2YWx1ZVxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gVGhlIGNvbnRleHQgaXMgYmVpbmcgZXZhbHVhdGVkIGZvciB0aGUgZmlyc3QgdGltZSBhbmRcclxuICAgICAgICAgICAgICogc2hvdWxkIHRodXMgY2hhbmdlIHRoZSBwcm9wZXJ0eSBpZiBudWxsXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fc2V0Q2hlY2tlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc1NlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNCb29sZWFuKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gISFuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jaGVja2VkID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNoZWNrZWQgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHRlciBmb3IgaW5wdXRbdHlwZT1cInJhZGlvXCJdXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldFJhZGlvID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOdWxsKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlDaGFuZ2VkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFpc1N0cmluZyhuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdudW1iZXInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbihuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlUeXBlID0gJ2Jvb2xlYW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jaGVja2VkID0gKGVsZW1lbnQudmFsdWUgPT09IG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHRlciBmb3Igc2VsZWN0XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIHByZXZpb3VzbHkgYm91bmQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFRoZSBjb250ZXh0IGlzIGJlaW5nIGV2YWx1YXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXHJcbiAgICAgICAgICAgICAqIHNob3VsZCB0aHVzIGNoYW5nZSB0aGUgcHJvcGVydHkgaWYgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldFNlbGVjdGVkSW5kZXggPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9faXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHZhbHVlID0gZWxlbWVudC52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSB8fCAhdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhlbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNTdHJpbmcobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4obmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdib29sZWFuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1RyeWluZyB0byBiaW5kIGFuIGludmFsaWQgdmFsdWUgdG8gYSA8c2VsZWN0PiBlbGVtZW50IHVzaW5nIGEgJyArIHRoaXMudHlwZSArICcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnZhbHVlICE9PSBuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgdGhlIHVzZXIgY2hhbmdlZCB0byBhIHZhbGlkIHZhbHVlIFxyXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kIGJvb2xlYW4gYXJndW1lbnQgaXMgYW4gaWUgZml4IGZvciBpbmNvbnNpc3RlbmN5IFxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQudmFsdWUgIT09IG5ld1ZhbHVlIHx8IGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHRlciBmb3Igc2VsZWN0LW11bHRpcGxlXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldFxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIHByZXZpb3VzbHkgYm91bmQgdmFsdWVcclxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFRoZSBjb250ZXh0IGlzIGJlaW5nIGV2YWx1YXRlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXHJcbiAgICAgICAgICAgICAqIHNob3VsZCB0aHVzIGNoYW5nZSB0aGUgcHJvcGVydHkgaWYgbnVsbFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX3NldFNlbGVjdGVkSW5kaWNlcyA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19pc1NlbGYpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLCBsZW5ndGggPSBpc051bGwob3B0aW9ucykgPyAwIDogb3B0aW9ucy5sZW5ndGgsIG9wdGlvbiwgbnVsbFZhbHVlID0gaXNOdWxsKG5ld1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChudWxsVmFsdWUgfHwgIWlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zZWxlY3RzIHRoZSBvcHRpb25zIHVubGVzcyBhIG1hdGNoIGlzIGZvdW5kIFxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uc1tsZW5ndGhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW51bGxWYWx1ZSAmJiBvcHRpb24udmFsdWUgPT09ICcnICsgbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSwgbnVtYmVyVmFsdWUsIGluZGV4LCBoaWdoZXN0SW5kZXggPSBJbmZpbml0eTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChsZW5ndGgtLSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2xlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvcHRpb24udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihudW1iZXJWYWx1ZSkgJiYgKGluZGV4ID0gbmV3VmFsdWUuaW5kZXhPZihudW1iZXJWYWx1ZSkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBoaWdoZXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdudW1iZXInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGVzdEluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2YWx1ZSA9PT0gJ3RydWUnICYmIChpbmRleCA9IG5ld1ZhbHVlLmluZGV4T2YodHJ1ZSkpICE9PSAtMSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPT09ICdmYWxzZScgJiYgKGluZGV4ID0gbmV3VmFsdWUuaW5kZXhPZihmYWxzZSkpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBoaWdoZXN0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9ICdib29sZWFuJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hlc3RJbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIERldGVybWluZXMgdGhlIHR5cGUgb2YgRWxlbWVudCBiZWluZyBib3VuZCB0b1xyXG4gICAgICAgICAgICAgKiBhbmQgc2V0cyB0aGUgbmVjZXNzYXJ5IGhhbmRsZXJzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2RldGVybWluZVR5cGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb2JzZXJ2aW5nQmluZGFibGVQcm9wZXJ0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnB1dCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3VibWl0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Jlc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRCdXR0b25FdmVudExpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50VHlwZSA9IHRoaXMuX2FkZENoYW5nZUV2ZW50TGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0Q2hlY2tlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0ZXIgPSB0aGlzLl9zZXRDaGVja2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVSYWRpbygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmFuZ2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50VHlwZSA9IHRoaXMuX2FkZFJhbmdlRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSB0aGlzLl9nZXRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0ZXIgPSB0aGlzLl9zZXRSYW5nZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aSA9IGVsZW1lbnQubXVsdGlwbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gdGhpcy5fYWRkQ2hhbmdlRXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSBtdWx0aSA/IHRoaXMuX2dldEZpbGVzIDogdGhpcy5fZ2V0RmlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0SGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRUZXh0RXZlbnRMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXR0ZXIgPSB0aGlzLl9nZXRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0ZXIgPSB0aGlzLl9zZXRUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkRXZlbnRUeXBlID0gdGhpcy5fYWRkVGV4dEV2ZW50TGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXR0ZXIgPSB0aGlzLl9zZXRUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplU2VsZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2J1dHRvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50VHlwZSA9IHRoaXMuX2FkZEJ1dHRvbkV2ZW50TGlzdGVuZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldHRlciA9IHRoaXMuX2dldFRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9ic2VydmVzIHRoZSBleHByZXNzaW9uIHRvIGJpbmQgdG8uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5fd2F0Y2hFeHByZXNzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0RXhwcmVzc2lvbiA9IHRoaXMuX2NvbnRleHRFeHByZXNzaW9uLCBjb250ZXh0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24oY29udGV4dEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udGV4dCkgJiYgY29udGV4dEV4cHJlc3Npb24uaWRlbnRpZmllcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5fY3JlYXRlQ29udGV4dChjb250ZXh0RXhwcmVzc2lvbi5pZGVudGlmaWVyc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLnR5cGUgKyAnIGlzIHRyeWluZyB0byBpbmRleCBpbnRvIGEgcHJpbWl0aXZlIHR5cGUuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dEV4cHJlc3Npb24uZXhwcmVzc2lvbiArICcgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCBub3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYW4gb2JqZWN0IHdoZW4gdHJ5aW5nIHRvIGV2YWx1YXRlICcgKyB0aGlzLnR5cGUgKyAnPVwiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leHByZXNzaW9uLmV4cHJlc3Npb24gKyAnXCInKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNGdW5jdGlvbih0aGlzLl9zZXR0ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc2V0dGVyID09PSB0aGlzLl9zZXRTZWxlY3RlZEluZGljZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuX3Byb3BlcnR5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc051bGwoY29udGV4dFtwcm9wZXJ0eV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRbcHJvcGVydHldID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KGZ1bmN0aW9uIChhcnJheUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldHRlcihhcnJheUluZm9bMF0ub2JqZWN0LCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBjb250ZXh0RXhwcmVzc2lvbiArICcuJyArIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5fZXhwcmVzc2lvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUV4cHJlc3Npb24oZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXR0ZXIobmV3VmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0sIGV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyKHRoaXMuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24pLCB1bmRlZmluZWQsIHRydWUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogSGFuZGxlcyBjcmVhdGluZyBjb250ZXh0IHdpdGggYW4gaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgdG8gYmFzZSB0aGUgY3JlYXRlZCBjb250ZXh0IG9mZiBvZi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IGlkZW50aWZpZXIuc3BsaXQoJy4nKSwgc3RhcnQgPSBzcGxpdC5zaGlmdCgpLnNsaWNlKDEpLCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydCA9PT0gX19ST09UX0NPTlRFWFRfUkVTT1VSQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZGVudGlmaWVyID0gc3BsaXQuam9pbignLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50LnJvb3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydCA9PT0gX19DT05URVhUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IHNwbGl0LmpvaW4oJy4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Db250ZXh0TWFuYWdlci5jcmVhdGVDb250ZXh0KHBhcmVudCwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBIYW5kbGVzIGNhc3RpbmcgdGhlIGJvdW5kIHByb3BlcnR5IGJhY2sgdG8gaXRzIGluaXRpYWwgdHlwZSBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FzdC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHR5cGU/IFRoZSBvcHRpb25hbCB0eXBlIHRvIGNhc3QgdGhlIHZhbHVlIHRvLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX2Nhc3RQcm9wZXJ0eSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhc3RWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IHRoaXMuX3Byb3BlcnR5VHlwZTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xMiA9IHZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzEyOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZS5wdXNoKHRoaXMuX2Nhc3RQcm9wZXJ0eSh2YWx1ZVtpXSwgdHlwZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0ZSh2YWx1ZSkgfHwgaXNGaWxlKHZhbHVlKSB8fCBpc1Byb21pc2UodmFsdWUpIHx8IGlzV2luZG93KHZhbHVlKSB8fCBpc05vZGUodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSksIGtleSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWVba2V5XSA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUudG9TdHJpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IGlzRW1wdHkodmFsdWUpID8gdW5kZWZpbmVkIDogTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd0cnVlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFsc2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc3RWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXN0VmFsdWUgPSAhIXZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzdFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FzdFZhbHVlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU2V0cyB0aGUgY29udGV4dCBwcm9wZXJ0eSBiZWluZyBib3VuZCB0byB3aGVuIHRoZVxyXG4gICAgICAgICAgICAgKiBlbGVtZW50J3MgcHJvcGVydHkgaXMgY2hhbmdlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9wcm9wZXJ0eUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuX2NvbnRleHRFeHByZXNzaW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24odGhpcy5fY29udGV4dEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuX3Byb3BlcnR5LCBuZXdWYWx1ZSA9IHRoaXMuX2Nhc3RQcm9wZXJ0eSh0aGlzLl9nZXR0ZXIoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dFtwcm9wZXJ0eV0gPT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc2V0IGZsYWcgdG8gbGV0IHNldHRlciBmdW5jdGlvbnMga25vdyB3ZSBjaGFuZ2VkIHRoZSBwcm9wZXJ0eSBcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pc1NlbGYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dFtwcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pc1NlbGYgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vcm1hbGl6ZXMgaW5wdXRbdHlwZT1cInJhZGlvXCJdIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5faW5pdGlhbGl6ZVJhZGlvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRDaGFuZ2VFdmVudExpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXR0ZXIgPSB0aGlzLl9zZXRSYWRpbztcclxuICAgICAgICAgICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gY2FtZWxDYXNlKHRoaXMudHlwZSksIGV4cHJlc3Npb24gPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCBleHByZXNzaW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE5vcm1hbGl6ZXMgSFRNTFNlbGVjdEVsZW1lbnRzIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBCaW5kLnByb3RvdHlwZS5faW5pdGlhbGl6ZVNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBtdWx0aXBsZSA9IGVsZW1lbnQubXVsdGlwbGUsIG9wdGlvbnMgPSBlbGVtZW50Lm9wdGlvbnMsIGxlbmd0aCA9IG9wdGlvbnMubGVuZ3RoLCBvcHRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudFR5cGUgPSB0aGlzLl9hZGRDaGFuZ2VFdmVudExpc3RlbmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0U2VsZWN0ZWRWYWx1ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0U2VsZWN0ZWRJbmRpY2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0dGVyID0gdGhpcy5fZ2V0VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dGVyID0gdGhpcy5fc2V0U2VsZWN0ZWRJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb24gPSBvcHRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9uLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCd2YWx1ZScsIG9wdGlvbi50ZXh0Q29udGVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBhc3NvY2lhdGVkIFRlbXBsYXRlQ29udHJvbCBpcyBpbXBsZW1lbnRpbmdcclxuICAgICAgICAgICAgICogSVN1cHBvcnRUd29XYXlCaW5kaW5nIGFuZCBpbml0aWFsaXplcyBhbGwgbGlzdGVuZXJzIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX29ic2VydmluZ0JpbmRhYmxlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ29udHJvbCA9IHRoaXMudGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHRlbXBsYXRlQ29udHJvbCkgJiYgaXNGdW5jdGlvbih0ZW1wbGF0ZUNvbnRyb2wub25JbnB1dCkgJiYgaXNGdW5jdGlvbih0ZW1wbGF0ZUNvbnRyb2wub2JzZXJ2ZVByb3BlcnRpZXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVDb250cm9sLm9uSW5wdXQoZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXdWYWx1ZTsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb3BlcnR5Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5fc3VwcG9ydHNUd29XYXlCaW5kaW5nID0gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGEgSVN1cHBvcnRUd29XYXlCaW5kaW5nIHRvIG9ic2VydmUgZWl0aGVyIHRoZVxyXG4gICAgICAgICAgICAgKiBib3VuZCBwcm9wZXJ0eSBzcGVjaWZpZWQgYnkgdGhlIGlkZW50aWZpZXIgKGFzIHdlbGwgYXMgcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0KSBvclxyXG4gICAgICAgICAgICAgKiBBcnJheSBtdXRhdGlvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IGlkZW50aWZpZXI/IFRoZSBpbmRleCBvZmYgb2YgdGhlIGJvdW5kIG9iamVjdCB0byBsaXN0ZW4gdG8gZm9yIGNoYW5nZXMgaWYgdGhlIGJvdW5kIG9iamVjdCBpcyBhbiBBcnJheS5cclxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkIG9yIGVtcHR5IHRoZSBsaXN0ZW5lciB3aWxsIGxpc3RlbiBmb3IgY2hhbmdlcyB0byB0aGUgYm91bmQgQXJyYXkgaXRzZWxmLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9jYXN0PyBXaWxsIGNhc3QgYSBwcmltaXRpdmUgdmFsdWUgdG8gd2hhdGV2ZXIgaXQgd2FzIHNldCB0byBpbiBjb2RlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFycmF5TXV0YXRpb25zPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGZvciBBcnJheSBtdXRhdGlvbiBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgQmluZC5wcm90b3R5cGUuX29ic2VydmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgaWRlbnRpZmllciwgYXV0b2Nhc3QsIGFycmF5TXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZElkZW50aWZpZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShpZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElkZW50aWZpZXIgPSB0aGlzLl9leHByZXNzaW9uLmV4cHJlc3Npb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bWJlcihpZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElkZW50aWZpZXIgPSB0aGlzLl9leHByZXNzaW9uLmV4cHJlc3Npb24gKyAnLicgKyBpZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9wYXJzZXIgPSB0aGlzLl9wYXJzZXIsIGlkZW50aWZpZXJFeHByZXNzaW9uID0gX3BhcnNlci5wYXJzZShpZGVudGlmaWVyKSwgaWRlbnRpZmllcnMgPSBpZGVudGlmaWVyRXhwcmVzc2lvbi5pZGVudGlmaWVycztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaWRlbnRpZmllcnMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdPbmx5IDEgaWRlbnRpZmllciBwYXRoIGFsbG93ZWQgd2hlbiBvYnNlcnZpbmcgY2hhbmdlcyB0byBhIGJvdW5kIHByb3BlcnR5XFwncyBjaGlsZCB3aXRoIGEgY29udHJvbCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbXBsZW1lbnRpbmcgb2JzZXJ2YWJsZS5JU3VwcG9ydFR3b1dheUJpbmRpbmcgYW5kIHdvcmtpbmcgd2l0aCAnICsgdGhpcy50eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IF9wYXJzZXIucGFyc2UodGhpcy5fZXhwcmVzc2lvbi5leHByZXNzaW9uICsgJy4nICsgaWRlbnRpZmllcnNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElkZW50aWZpZXIgPSBleHByZXNzaW9uLmlkZW50aWZpZXJzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdCA9IHBhcnNlZElkZW50aWZpZXIuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICBzcGxpdC5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dEV4cHJlc3Npb24gPSBzcGxpdC5qb2luKCcuJyksIGNvbnRleHQgPSB0aGlzLmV2YWx1YXRlRXhwcmVzc2lvbihjb250ZXh0RXhwcmVzc2lvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09iamVjdChjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5fQ29udGV4dE1hbmFnZXIuY3JlYXRlQ29udGV4dCh0aGlzLnBhcmVudCwgY29udGV4dEV4cHJlc3Npb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oJ0EgY29udHJvbCBpbXBsZW1lbnRpbmcgb2JzZXJ2YWJsZS5JU3VwcG9ydFR3b1dheUJpbmRpbmcgaXMgdHJ5aW5nIHRvIGluZGV4IGludG8gYSBwcmltaXRpdmUgdHlwZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2hlbiB0cnlpbmcgdG8gZXZhbHVhdGUgJyArIHRoaXMudHlwZSArICc9XCInICsgdGhpcy5fZXhwcmVzc2lvbi5leHByZXNzaW9uICsgJ1wiJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmJpbmQodGhpcy50ZW1wbGF0ZUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgYXV0b2Nhc3QgPSBhdXRvY2FzdCA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcjtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJheU11dGF0aW9ucyA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVyID0gdGhpcy5vYnNlcnZlQXJyYXkoZnVuY3Rpb24gKGNoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoY2hhbmdlcywgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFyc2VkSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lciA9IHRoaXMub2JzZXJ2ZShmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fX2lzU2VsZiB8fCBuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhdXRvY2FzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Byb3BlcnR5VHlwZSA9IF90aGlzLl9nZXRQcm9wZXJ0eVR5cGUobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcGFyc2VkSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24ocGFyc2VkSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9jYXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5VHlwZSA9IHRoaXMuX2dldFByb3BlcnR5VHlwZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHZhbHVlLCB1bmRlZmluZWQsIGlkZW50aWZpZXIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogR2V0cyB0aGUgcHJvcGVydHkgdHlwZSBvZiB0aGUgcGFzc2VkIGluIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIGdyYWIgdGhlIHByb3BlcnR5IHR5cGUgZnJvbS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEJpbmQucHJvdG90eXBlLl9nZXRQcm9wZXJ0eVR5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3N0cmluZyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bWJlcic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdib29sZWFuJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgQmluZC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgX3BhcnNlcjogX19QYXJzZXIsXHJcbiAgICAgICAgICAgICAgICBfQ29udGV4dE1hbmFnZXI6IF9fQ29udGV4dE1hbmFnZXJTdGF0aWMsXHJcbiAgICAgICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gQmluZDtcclxuICAgICAgICB9KEF0dHJpYnV0ZUNvbnRyb2wpKTtcclxuICAgICAgICBjb250cm9scy5CaW5kID0gQmluZDtcclxuICAgICAgICByZWdpc3Rlci5jb250cm9sKF9fQmluZCwgQmluZCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gQXR0cmlidXRlQ29udHJvbCB0aGF0IGRlYWxzIHdpdGggb2JzZXJ2aW5nIGNoYW5nZXMgZm9yIGEgc3BlY2lmaWVkIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbCwgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2woKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHByb3BlcnR5IHRvIHNldCBvbiB0aGUgYXNzb2NpYXRlZCB0ZW1wbGF0ZSBjb250cm9sLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoaXMgY29udHJvbCBuZWVkcyB0byBsb2FkIGJlZm9yZSBpdHMgdGVtcGxhdGVDb250cm9sXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHkgPSAyMDA7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBzZXQgb2YgZnVuY3Rpb25zIGFkZGVkIGJ5IHRoZSBUZW1wbGF0ZSBDb250cm9sIHRoYXQgbGlzdGVuc1xyXG4gICAgICAgICAgICAgICAgICogZm9yIHByb3BlcnR5IGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgX2FkZExpc3RlbmVyIGZ1bmN0aW9uIGJvdW5kIHRvIHRoaXMgY29udHJvbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRBZGRMaXN0ZW5lciA9IHRoaXMuX2FkZExpc3RlbmVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIHByb3BlcnR5IG9uXHJcbiAgICAgICAgICAgICAqIHRoZSBUZW1wbGF0ZSBDb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZSA9IGNhbWVsQ2FzZSh0aGlzLnR5cGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkodGhpcy5fZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyB0aGUgcHJvcGVydHkgYW5kIHJlc2V0cyB0aGUgdmFsdWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZVByb3BlcnR5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eSh0aGlzLl9nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN0b3BzIGxpc3RlbmluZyBmb3IgY2hhbmdlcyB0byB0aGUgZXZhbHVhdGVkXHJcbiAgICAgICAgICAgICAqIGV4cHJlc3Npb24gYW5kIHJlbW92ZXMgcmVmZXJlbmNlcyB0byB0aGUgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAqIGRlZmluZWQgYnkgdGhlIFRlbXBsYXRlIENvbnRyb2wuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX3JlbW92ZUxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldHMgdGhlIHByb3BlcnR5IG9uIHRoZSBUZW1wbGF0ZSBDb250cm9sLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZT8gVGhlIG9sZCB2YWx1ZSBvZiB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuX3NldFByb3BlcnR5ID0gZnVuY3Rpb24gKHZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlQ29udHJvbCA9IHRoaXMudGVtcGxhdGVDb250cm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0ZW1wbGF0ZUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fQ29udGV4dE1hbmFnZXIuZGVmaW5lR2V0dGVyKHRlbXBsYXRlQ29udHJvbCwgdGhpcy5wcm9wZXJ0eSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlOiB0aGlzLl9ib3VuZEFkZExpc3RlbmVyXHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxMaXN0ZW5lcnModmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGxzIHRoZSBsaXN0ZW5lcnMgZGVmaW5lZCBieSB0aGUgVGVtcGxhdGUgQ29udHJvbC5cclxuICAgICAgICAgICAgICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGV2YWx1YXRlZCBleHByZXNzaW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgZXZhbHVhdGVkIGV4cHJlc3Npb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuX2NhbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQWRkcyBhIGxpc3RlbmVyIGFzIGRlZmluZWQgYnkgdGhlIFRlbXBsYXRlIENvbnRyb2wuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7cGxhdC5JUHJvcGVydHlDaGFuZ2VkTGlzdGVuZXJ9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBhZGRlZCBieSB0aGUgVGVtcGxhdGUgQ29udHJvbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE9ic2VydmFibGVBdHRyaWJ1dGVDb250cm9sLnByb3RvdHlwZS5fYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmJpbmQodGhpcy50ZW1wbGF0ZUNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEV2YWx1YXRlcyB0aGUgYXR0cmlidXRlJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuX2dldFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbCh0aGlzLnRlbXBsYXRlQ29udHJvbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0ZUV4cHJlc3Npb24odGhpcy5hdHRyaWJ1dGVzW3RoaXMuYXR0cmlidXRlXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBPYnNlcnZlcyB0aGUgYXR0cmlidXRlJ3MgdmFsdWUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbC5wcm90b3R5cGUuX29ic2VydmVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy50ZW1wbGF0ZUNvbnRyb2wpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLm9ic2VydmVFeHByZXNzaW9uKHRoaXMuX3NldFByb3BlcnR5LCB0aGlzLmF0dHJpYnV0ZXNbdGhpcy5hdHRyaWJ1dGVdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgICAgIF9Db250ZXh0TWFuYWdlcjogX19Db250ZXh0TWFuYWdlclN0YXRpY1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2w7XHJcbiAgICAgICAgfShBdHRyaWJ1dGVDb250cm9sKSk7XHJcbiAgICAgICAgY29udHJvbHMuT2JzZXJ2YWJsZUF0dHJpYnV0ZUNvbnRyb2wgPSBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbCB0aGF0IHNldHMgJ29wdGlvbnMnIGFzIHRoZVxyXG4gICAgICAgICAqIGFzc29jaWF0ZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdmFyIE9wdGlvbnMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICBfX2V4dGVuZHMoT3B0aW9ucywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gT3B0aW9ucygpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgcHJvcGVydHkgdG8gc2V0IG9uIHRoZSBhc3NvY2lhdGVkIHRlbXBsYXRlIGNvbnRyb2wuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHRoaXMucHJvcGVydHkgPSAnb3B0aW9ucyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9wdGlvbnM7XHJcbiAgICAgICAgfShPYnNlcnZhYmxlQXR0cmlidXRlQ29udHJvbCkpO1xyXG4gICAgICAgIGNvbnRyb2xzLk9wdGlvbnMgPSBPcHRpb25zO1xyXG4gICAgICAgIHJlZ2lzdGVyLmNvbnRyb2woX19PcHRpb25zLCBPcHRpb25zKTtcclxuICAgIH0pKGNvbnRyb2xzID0gcGxhdF8xLmNvbnRyb2xzIHx8IChwbGF0XzEuY29udHJvbHMgPSB7fSkpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGFzcyBmb3IgZXZlcnkgYXBwLiBUaGlzIGNsYXNzIGNvbnRhaW5zIGhvb2tzIGZvciBBcHBsaWNhdGlvbiBMaWZlY3ljbGUgRXZlbnRzXHJcbiAgICAgKiBhcyB3ZWxsIGFzIGVycm9yIGhhbmRsaW5nLlxyXG4gICAgICovXHJcbiAgICB2YXIgQXBwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDbGFzcyBmb3IgZXZlcnkgYXBwLiBUaGlzIGNsYXNzIGNvbnRhaW5zIGhvb2tzIGZvciBBcHBsaWNhdGlvbiBMaWZlY3ljbGUgTWFuYWdlbWVudCAoQUxNKVxyXG4gICAgICAgICAqIGFzIHdlbGwgYXMgZXJyb3IgaGFuZGxpbmcgYW5kIG5hdmlnYXRpb24gZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEFwcCgpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgdW5pcXVlIGlkLCBjcmVhdGVkIGR1cmluZyBpbnN0YW50aWF0aW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy51aWQgPSB1bmlxdWVJZChfX1BsYXQpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBMb2cgaW5qZWN0YWJsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZyA9IEFwcC5fbG9nO1xyXG4gICAgICAgICAgICB2YXIgbmF2aWdhdG9yID0gdGhpcy5uYXZpZ2F0b3IgPSBhY3F1aXJlKF9fTmF2aWdhdG9ySW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBuYXZpZ2F0b3IuaW5pdGlhbGl6ZShhY3F1aXJlKF9fUm91dGVyU3RhdGljKS5jdXJyZW50Um91dGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHN0YXRpYyBtZXRob2QgZm9yIGluaXRpYXRpbmcgdGhlIGFwcCBzdGFydHVwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5zdGFydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFBcHAuX2NvbXBhdC5pc0NvbXBhdGlibGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBcHAuX2xvZy5lcnJvcihuZXcgRXJyb3IoJ1BsYXR5cHVzVFMgb25seSBzdXBwb3J0cyBtb2Rlcm4gYnJvd3NlcnMgd2hlcmUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ09iamVjdC5kZWZpbmVQcm9wZXJ0eSBpcyBkZWZpbmVkJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEFwcC5fX2FkZFBsYXRDc3MoKTtcclxuICAgICAgICAgICAgdmFyIF9FdmVudE1hbmFnZXIgPSBBcHAuX0V2ZW50TWFuYWdlcjtcclxuICAgICAgICAgICAgX0V2ZW50TWFuYWdlci5kaXNwb3NlKF9fQVBQKTtcclxuICAgICAgICAgICAgX0V2ZW50TWFuYWdlci5vbihfX0FQUCwgX19yZWFkeSwgQXBwLl9fcmVhZHkpO1xyXG4gICAgICAgICAgICBfRXZlbnRNYW5hZ2VyLm9uKF9fQVBQLCBfX3NodXRkb3duLCBBcHAuX19zaHV0ZG93bik7XHJcbiAgICAgICAgICAgIF9FdmVudE1hbmFnZXIuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzdGF0aWMgbWV0aG9kIGNhbGxlZCB1cG9uIGFwcCByZWdpc3RyYXRpb24uIFByaW1hcmlseSB1c2VkXHJcbiAgICAgICAgICogdG8gaW5pdGlhdGUgYSByZWFkeSBzdGF0ZSBpbiB0aGUgY2FzZSB0aGF0IGFtZCBpcyBiZWluZyB1c2VkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5kZXBlbmRlbmN5LkluamVjdG9yPHBsYXQuQXBwPn0gYXBwSW5qZWN0b3IgVGhlIGluamVjdG9yIGZvclxyXG4gICAgICAgICAqIGluamVjdGluZyB0aGUgYXBwIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5yZWdpc3RlckFwcCA9IGZ1bmN0aW9uIChhcHBJbmplY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChBcHAuYXBwKSAmJiBpc1N0cmluZyhBcHAuYXBwLnVpZCkpIHtcclxuICAgICAgICAgICAgICAgIEFwcC5fRXZlbnRNYW5hZ2VyLmRpc3Bvc2UoQXBwLmFwcC51aWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEFwcC5fX2luamVjdG9yID0gYXBwSW5qZWN0b3I7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLaWNrcyBvZmYgY29tcGlsYXRpb24gb2YgdGhlIERPTSBmcm9tIHRoZSBzcGVjaWZpZWQgbm9kZS4gSWYgbm8gbm9kZSBpcyBzcGVjaWZpZWQsXHJcbiAgICAgICAgICogdGhlIGRlZmF1bHQgc3RhcnQgbm9kZSBpcyBkb2N1bWVudC5ib2R5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSBhdCB3aGljaCBET00gY29tcGlsYXRpb24gYmVnaW5zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5sb2FkID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIF9MaWZlY3ljbGVFdmVudCA9IEFwcC5fTGlmZWN5Y2xlRXZlbnQsIF9jb21waWxlciA9IEFwcC5fY29tcGlsZXIsIGJvZHkgPSBBcHAuX2RvY3VtZW50LmJvZHksIGhlYWQgPSBBcHAuX2RvY3VtZW50LmhlYWQ7XHJcbiAgICAgICAgICAgIF9MaWZlY3ljbGVFdmVudC5kaXNwYXRjaChfX2JlZm9yZUxvYWQsIEFwcCk7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwobm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIGJvZHkuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgcG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb21waWxlci5jb21waWxlKFtoZWFkXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbXBpbGVyLmNvbXBpbGUoW2JvZHldKTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5LnJlbW92ZUF0dHJpYnV0ZShfX0hpZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obm9kZS5zZXRBdHRyaWJ1dGUpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgIHBvc3Rwb25lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY29tcGlsZXIuY29tcGlsZShbbm9kZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3N0cG9uZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfY29tcGlsZXIuY29tcGlsZShbbm9kZV0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgc3RhdGljIG1ldGhvZCBjYWxsZWQgd2hlbiB0aGUgYXBwbGljYXRpb24gaXMgcmVhZHkuIEl0IGNhbGxzIHRoZSBhcHAgaW5zdGFuY2Unc1xyXG4gICAgICAgICAqIHJlYWR5IGZ1bmN0aW9uIGFzIHdlbGwgYXMgY2hlY2tzIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBtb2R1bGUgbG9hZGVyLiBJZiBvbmUgZXhpc3RzLFxyXG4gICAgICAgICAqIGxvYWRpbmcgdGhlIERPTSBmYWxscyBiYWNrIHRvIHRoZSBhcHAgZGV2ZWxvcGVyLiBJZiBpdCBkb2Vzbid0LCB0aGUgRE9NIGlzIGxvYWRlZCBmcm9tXHJcbiAgICAgICAgICogZG9jdW1lbnQuYm9keS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkxpZmVjeWNsZUV2ZW50fSBldiBUaGUgTGlmZWN5Y2xlRXZlbnQgZm9yIHRoZSBhcHAgcmVhZHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLl9fcmVhZHkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgZGVwZW5kZW5jeS5JbmplY3Rvci5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIEFwcC5fX3JlZ2lzdGVyQXBwRXZlbnRzKGV2KTtcclxuICAgICAgICAgICAgaWYgKCFldi5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgICAgICAgICBBcHAubG9hZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHN0YXRpYyBtZXRob2QgY2FsbGVkIHdoZW4gdGhlIGFwcGxpY2F0aW9uIHdhbnRzIHRvIHByb2dyYW1tYXRpY2FsbHkgc2h1dGRvd24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLl9fc2h1dGRvd24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcHAgPSBuYXZpZ2F0b3IuYXBwLCBfTGlmZWN5Y2xlRXZlbnQgPSBBcHAuX0xpZmVjeWNsZUV2ZW50LCBldjtcclxuICAgICAgICAgICAgaWYgKCFpc051bGwoYXBwKSAmJiBpc0Z1bmN0aW9uKGFwcC5leGl0QXBwKSkge1xyXG4gICAgICAgICAgICAgICAgZXYgPSBfTGlmZWN5Y2xlRXZlbnQuZGlzcGF0Y2goX19leGl0aW5nLCBBcHApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhcHAuZXhpdEFwcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHN0YXRpYyBtZXRob2QgY2FsbGVkIHRvIHJlZ2lzdGVyIGFsbCB0aGUgTGlmZWN5Y2xlRXZlbnRzIGZvciBhbiBhcHAgaW5zdGFuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLl9fcmVnaXN0ZXJBcHBFdmVudHMgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGFwcEluamVjdG9yID0gQXBwLl9faW5qZWN0b3I7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoYXBwSW5qZWN0b3IpIHx8ICFpc0Z1bmN0aW9uKGFwcEluamVjdG9yLmluamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXBwID0gQXBwLmFwcCA9IGFwcEluamVjdG9yLmluamVjdCgpO1xyXG4gICAgICAgICAgICBhcHAub24oX19zdXNwZW5kLCBhcHAuc3VzcGVuZCk7XHJcbiAgICAgICAgICAgIGFwcC5vbihfX3Jlc3VtZSwgYXBwLnJlc3VtZSk7XHJcbiAgICAgICAgICAgIGFwcC5vbihfX29ubGluZSwgYXBwLm9ubGluZSk7XHJcbiAgICAgICAgICAgIGFwcC5vbihfX29mZmxpbmUsIGFwcC5vZmZsaW5lKTtcclxuICAgICAgICAgICAgYXBwLm9uKF9fZXJyb3IsIGFwcC5lcnJvcik7XHJcbiAgICAgICAgICAgIGFwcC5vbihfX2V4aXRpbmcsIGFwcC5leGl0aW5nKTtcclxuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXBwLnJlYWR5KSkge1xyXG4gICAgICAgICAgICAgICAgYXBwLnJlYWR5KGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2UgbmVlZCB0byBhZGQgW3BsYXQtaGlkZV0gYXMgYSBjc3MgcHJvcGVydHkgaWYgcGxhdHlwdXMuY3NzIGRvZXNuJ3QgZXhpc3Qgc28gd2UgY2FuIHVzZSBpdCB0byB0ZW1wb3JhcmlseVxyXG4gICAgICAgICAqIGhpZGUgZWxlbWVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLl9fYWRkUGxhdENzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IEFwcC5fZG9jdW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChBcHAuX2NvbXBhdC5wbGF0Q3NzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbChfZG9jdW1lbnQuc3R5bGVTaGVldHMpICYmIF9kb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBfZG9jdW1lbnQuc3R5bGVTaGVldHNbMF0uaW5zZXJ0UnVsZSgnW3BsYXQtaGlkZV0geyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IH0nLCAwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdbcGxhdC1oaWRlXSB7IGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgfSc7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgYXBwIGlzIHN1c3BlbmRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkxpZmVjeWNsZUV2ZW50fSBldiBUaGUgTGlmZWN5Y2xlRXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUuc3VzcGVuZCA9IGZ1bmN0aW9uIChldikgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGFwcCByZXN1bWVzIGZyb20gdGhlIHN1c3BlbmRlZCBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkxpZmVjeWNsZUV2ZW50fSBldiBUaGUgTGlmZWN5Y2xlRXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKGV2KSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgZmlyZWQgd2hlbiBhbiBpbnRlcm5hbCBlcnJvciBvY2N1cmVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuRXJyb3JFdmVudDxFcnJvcj59IGV2IFRoZSBFcnJvckV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGV2KSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgYXBwIGlzIHJlYWR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5ldmVudHMuTGlmZWN5Y2xlRXZlbnR9IGV2IFRoZSBMaWZlY3ljbGVFdmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChldikgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGFwcCBoYXMgYmVlbiBwcm9ncmFtYXRpY2FsbHkgc2h1dGRvd24uIFRoaXMgZXZlbnQgaXMgY2FuY2VsYWJsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkxpZmVjeWNsZUV2ZW50fSBldiBUaGUgTGlmZWN5Y2xlRXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUuZXhpdGluZyA9IGZ1bmN0aW9uIChldikgeyB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGFwcCByZWdhaW5zIGNvbm5lY3Rpdml0eSBhbmQgaXMgbm93IGluIGFuIG9ubGluZSBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuZXZlbnRzLkxpZmVjeWNsZUV2ZW50fSBldiBUaGUgTGlmZWN5Y2xlRXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUub25saW5lID0gZnVuY3Rpb24gKGV2KSB7IH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgYXBwIGxvc2VzIGNvbm5lY3Rpdml0eSBhbmQgaXMgbm93IGluIGFuIG9mZmxpbmUgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LmV2ZW50cy5MaWZlY3ljbGVFdmVudH0gZXYgVGhlIExpZmVjeWNsZUV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBBcHAucHJvdG90eXBlLm9mZmxpbmUgPSBmdW5jdGlvbiAoZXYpIHsgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IERpc3BhdGNoRXZlbnQgYW5kIHByb3BhZ2F0ZXMgaXQgdG8gYWxsXHJcbiAgICAgICAgICogbGlzdGVuZXJzIGJhc2VkIG9uIHRoZSBESVJFQ1QgbWV0aG9kLiBQcm9wYWdhdGlvblxyXG4gICAgICAgICAqIHdpbGwgYWx3YXlzIHN0YXJ0IHdpdGggdGhlIHNlbmRlciwgc28gdGhlIHNlbmRlciBjYW4gYm90aCBwcm9kdWNlIGFuZCBjb25zdW1lIHRoZSBzYW1lIGV2ZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kLCBjb29pbmNpZGVzIHdpdGggdGhlIG5hbWUgdXNlZCBpbiB0aGVcclxuICAgICAgICAgKiBhcHAub24oKSBtZXRob2QuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxhbnk+fSAuLi5hcmdzIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHNlbmQgdG8gYWxsIHRoZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIF9FdmVudE1hbmFnZXIgPSBBcHAuX0V2ZW50TWFuYWdlciB8fCBhY3F1aXJlKF9fRXZlbnRNYW5hZ2VyU3RhdGljKTtcclxuICAgICAgICAgICAgX0V2ZW50TWFuYWdlci5kaXNwYXRjaChuYW1lLCB0aGlzLCBfRXZlbnRNYW5hZ2VyLkRJUkVDVCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgYSBEaXNwYXRjaEV2ZW50LiBUaGUgbGlzdGVuZXIgd2lsbCBiZSBjYWxsZWQgd2hlblxyXG4gICAgICAgICAqIGEgRGlzcGF0Y2hFdmVudCBpcyBwcm9wYWdhdGluZyBvdmVyIHRoZSBhcHAuIEFueSBudW1iZXIgb2YgbGlzdGVuZXJzIGNhbiBleGlzdCBmb3IgYSBzaW5nbGUgZXZlbnQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQsIGNvb2luY2lkaW5nIHdpdGggdGhlIERpc3BhdGNoRXZlbnQgbmFtZS5cclxuICAgICAgICAgKiBAcGFyYW0geyhldjogcGxhdC5ldmVudHMuRGlzcGF0Y2hFdmVudCwgLi4uYXJnczogQXJyYXk8YW55PikgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIG1ldGhvZCBjYWxsZWQgd2hlblxyXG4gICAgICAgICAqIHRoZSBEaXNwYXRjaEV2ZW50IGlzIGZpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAobmFtZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdmFyIF9FdmVudE1hbmFnZXIgPSBBcHAuX0V2ZW50TWFuYWdlciB8fCBhY3F1aXJlKF9fRXZlbnRNYW5hZ2VyU3RhdGljKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9FdmVudE1hbmFnZXIub24odGhpcy51aWQsIG5hbWUsIGxpc3RlbmVyLCB0aGlzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtpY2tzIG9mZiBjb21waWxhdGlvbiBvZiB0aGUgRE9NIGZyb20gdGhlIHNwZWNpZmllZCBub2RlLiBJZiBubyBub2RlIGlzIHNwZWNpZmllZCxcclxuICAgICAgICAgKiB0aGUgZGVmYXVsdCBzdGFydCBub2RlIGlzIGRvY3VtZW50LmJvZHkuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgZnJvbSB0aGUgYXBwIHdoZW5cclxuICAgICAgICAgKiB1c2luZyBtb2R1bGUgbG9hZGVycy4gSWYgYSBtb2R1bGUgbG9hZGVyIGlzIGluIHVzZSwgdGhlIGFwcCB3aWxsIGRlbGF5IGxvYWRpbmcgdW50aWxcclxuICAgICAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHdoZXJlIGF0IHdoaWNoIERPTSBjb21waWxhdGlvbiBiZWdpbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICAgICAgQXBwLmxvYWQobm9kZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxscyB0byBleGl0IHRoZSBhcHBsaWNhdGlvbi4gTWFrZXMgdGhlIG5lY2Vzc2FyeSBjYWxscyB0byB0aGUgZGV2aWNlIGlzIHBvc3NpYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEFwcC5wcm90b3R5cGUuZXhpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KF9fc2h1dGRvd24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSByZWdpc3RlcmVkIElBcHAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQXBwLmFwcCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIEFwcDtcclxuICAgIH0oKSk7XHJcbiAgICBwbGF0XzEuQXBwID0gQXBwO1xyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIElBcHBTdGF0aWMoX2NvbXBhdCwgX0V2ZW50TWFuYWdlciwgX2RvY3VtZW50LCBfY29tcGlsZXIsIF9MaWZlY3ljbGVFdmVudCwgX2xvZykge1xyXG4gICAgICAgIEFwcC5fY29tcGF0ID0gX2NvbXBhdDtcclxuICAgICAgICBBcHAuX0V2ZW50TWFuYWdlciA9IF9FdmVudE1hbmFnZXI7XHJcbiAgICAgICAgQXBwLl9kb2N1bWVudCA9IF9kb2N1bWVudDtcclxuICAgICAgICBBcHAuX2NvbXBpbGVyID0gX2NvbXBpbGVyO1xyXG4gICAgICAgIEFwcC5fTGlmZWN5Y2xlRXZlbnQgPSBfTGlmZWN5Y2xlRXZlbnQ7XHJcbiAgICAgICAgQXBwLl9sb2cgPSBfbG9nO1xyXG4gICAgICAgIHJldHVybiBBcHA7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuSUFwcFN0YXRpYyA9IElBcHBTdGF0aWM7XHJcbiAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQXBwU3RhdGljLCBJQXBwU3RhdGljLCBbXHJcbiAgICAgICAgX19Db21wYXQsXHJcbiAgICAgICAgX19FdmVudE1hbmFnZXJTdGF0aWMsXHJcbiAgICAgICAgX19Eb2N1bWVudCxcclxuICAgICAgICBfX0NvbXBpbGVyLFxyXG4gICAgICAgIF9fTGlmZWN5Y2xlRXZlbnRTdGF0aWMsXHJcbiAgICAgICAgX19Mb2dcclxuICAgIF0sIF9fU1RBVElDKTtcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBJQXBwKF9BcHBTdGF0aWMpIHtcclxuICAgICAgICByZXR1cm4gX0FwcFN0YXRpYy5hcHA7XHJcbiAgICB9XHJcbiAgICBwbGF0XzEuSUFwcCA9IElBcHA7XHJcbiAgICByZWdpc3Rlci5pbmplY3RhYmxlKF9fQXBwLCBJQXBwLCBbX19BcHBTdGF0aWNdLCBfX0lOU1RBTkNFKTtcclxufSkocGxhdCB8fCAocGxhdCA9IHt9KSk7XHJcbm1vZHVsZS5leHBvcnRzID0gcGxhdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcbi8qIHRzbGludDpkaXNhYmxlICovXHJcbi8qKlxyXG4gKiBQbGF0eXB1c1VJIHYwLjE0LjcgKGh0dHBzOi8vcGxhdHlwaS5pbylcclxuICogQ29weXJpZ2h0IDIwMTUgUGxhdHlwaSwgTExDLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKlxyXG4gKiBQbGF0eXB1c1VJIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBhdFxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vUGxhdHlwaS9wbGF0eXB1c3VpL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICpcclxuICovXHJcbi8qKlxyXG4gKiBUaGUgZW50cnkgcG9pbnQgaW50byB0aGUgcGxhdHlwdXMgVUkgY29udHJvbHMgbGlicmFyeS5cclxuICovXHJcbnZhciBwbGF0dWk7XHJcbihmdW5jdGlvbiAocGxhdHVpKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIC8qXHJcbiAgICAgKi9cclxuICAgIHZhciBfX3ByZWZpeCA9ICckJywgX19Qcm9taXNlID0gX19wcmVmaXggKyBcIlByb21pc2VcIiwgX19Db21wYXQgPSBfX3ByZWZpeCArIFwiQ29tcGF0XCIsIF9fUmVnZXggPSBfX3ByZWZpeCArIFwiUmVnZXhcIiwgX19XaW5kb3cgPSBfX3ByZWZpeCArIFwiV2luZG93XCIsIF9fRG9jdW1lbnQgPSBfX3ByZWZpeCArIFwiRG9jdW1lbnRcIiwgX19VdGlscyA9IF9fcHJlZml4ICsgXCJVdGlsc1wiLCBfX0FuaW1hdG9yID0gX19wcmVmaXggKyBcIkFuaW1hdG9yXCIsIF9fRG9tRXZlbnRJbnN0YW5jZSA9IF9fcHJlZml4ICsgXCJEb21FdmVudEluc3RhbmNlXCIsIF9fVGVtcGxhdGVDb250cm9sRmFjdG9yeSA9IF9fcHJlZml4ICsgXCJUZW1wbGF0ZUNvbnRyb2xGYWN0b3J5XCIsIF9fTm9kZU1hbmFnZXJTdGF0aWMgPSBfX3ByZWZpeCArIFwiTm9kZU1hbmFnZXJTdGF0aWNcIiwgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19DT05URVhUID0gJ2NvbnRleHQnLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfX1BsYXRQcmVmaXggPSAncGxhdCcsIF9fUGxhdCA9IF9fUGxhdFByZWZpeCArIFwiLVwiLCBfX0J1dHRvbiA9IF9fUGxhdCArIFwiYnV0dG9uXCIsIF9fQ2hlY2tib3ggPSBfX1BsYXQgKyBcImNoZWNrYm94XCIsIF9fRHJhd2VyID0gX19QbGF0ICsgXCJkcmF3ZXJcIiwgX19EcmF3ZXJDb250cm9sbGVyID0gX19EcmF3ZXIgKyBcIi1jb250cm9sbGVyXCIsIF9fTW9kYWwgPSBfX1BsYXQgKyBcIm1vZGFsXCIsIF9fUHJvZ3Jlc3NCYXIgPSBfX1BsYXQgKyBcInByb2dyZXNzXCIsIF9fUHJvZ3Jlc3NSaW5nID0gX19QbGF0ICsgXCJyaW5nXCIsIF9fUmFkaW8gPSBfX1BsYXQgKyBcInJhZGlvXCIsIF9fVG9nZ2xlID0gX19QbGF0ICsgXCJ0b2dnbGVcIiwgX19TbGlkZXIgPSBfX1BsYXQgKyBcInNsaWRlclwiLCBfX1JhbmdlID0gX19QbGF0ICsgXCJyYW5nZVwiLCBfX1NlbGVjdCA9IF9fUGxhdCArIFwic2VsZWN0XCIsIF9fSW5wdXQgPSBfX1BsYXQgKyBcImlucHV0XCIsIF9fRmlsZSA9IF9fUGxhdCArIFwiZmlsZVwiLCBfX0Nhcm91c2VsID0gX19QbGF0ICsgXCJjYXJvdXNlbFwiLCBfX0xpc3R2aWV3ID0gX19QbGF0ICsgXCJsaXN0dmlld1wiLCBfX05hdmJhciA9IF9fUGxhdCArIFwibmF2YmFyXCIsIF9fSW1hZ2UgPSBfX1BsYXQgKyBcImltYWdlXCIsIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fSGlkZSA9IF9fUGxhdCArIFwiaGlkZVwiLCBfX0hpZGRlbiA9IF9fUGxhdCArIFwiaGlkZGVuXCIsIF9fQ29udGV4dCA9IF9fUGxhdCArIF9fQ09OVEVYVCwgX19Gb3JFYWNoID0gX19QbGF0ICsgXCJmb3JlYWNoXCIsIF9fSHRtbCA9IF9fUGxhdCArIFwiaHRtbFwiLCBfX0Rpc2FibGVkID0gX19QbGF0ICsgXCJkaXNhYmxlZFwiLCBfX1JlYWRvbmx5ID0gX19QbGF0ICsgXCJyZWFkb25seVwiLCBfX0NhbWVsQ29udGV4dCA9IF9fUGxhdFByZWZpeCArIFwiQ29udGV4dFwiLCBfX0NhbWVsQ2hlY2tlZCA9IF9fUGxhdFByZWZpeCArIFwiQ2hlY2tlZFwiLCBfX0NhbWVsQmluZCA9IF9fUGxhdFByZWZpeCArIFwiQmluZFwiLCBfX0NhbWVsU3JjID0gX19QbGF0UHJlZml4ICsgXCJTcmNcIiwgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19saXN0dmlld0FsaWFzT3B0aW9ucyA9IHtcclxuICAgICAgICBpbmRleDogJ2luZGV4JyxcclxuICAgICAgICBldmVuOiAnZXZlbicsXHJcbiAgICAgICAgb2RkOiAnb2RkJyxcclxuICAgICAgICBmaXJzdDogJ2ZpcnN0JyxcclxuICAgICAgICBsYXN0OiAnbGFzdCcsXHJcbiAgICAgICAgZ3JvdXA6ICdncm91cCdcclxuICAgIH0sIFxyXG4gICAgLyoqXHJcbiAgICAgKi9cclxuICAgIF9fVHJhbnNpdGlvbiA9IF9fUGxhdCArIFwidHJhbnNpdGlvblwiLCBfX0VudGVyID0gX19QbGF0ICsgXCJlbnRlclwiLCBfX0xlYXZlID0gX19QbGF0ICsgXCJsZWF2ZVwiLCBcclxuICAgIC8qKlxyXG4gICAgICovXHJcbiAgICBfXyR0YXAgPSAnJHRhcCcsIF9fJHRvdWNoc3RhcnQgPSAnJHRvdWNoc3RhcnQnLCBfXyR0b3VjaGVuZCA9ICckdG91Y2hlbmQnLCBfXyR0b3VjaGNhbmNlbCA9ICckdG91Y2hjYW5jZWwnLCBfXyRzd2lwZSA9ICckc3dpcGUnLCBfXyR0cmFjayA9ICckdHJhY2snLCBfXyR0cmFja2VuZCA9ICckdHJhY2tlbmQnLCBfX0J1dHRvblByZWZpeCA9ICdfX3BsYXQtYnV0dG9uLScsIF9fUmFkaW9QcmVmaXggPSAnX19wbGF0LXJhZGlvLScsIF9fRHJhd2VyQ29udHJvbGxlckluaXRFdmVudCA9ICdfX3BsYXREcmF3ZXJDb250cm9sbGVySW5pdCcsIF9fRHJhd2VyQ29udHJvbGxlckZldGNoRXZlbnQgPSAnX19wbGF0RHJhd2VyQ29udHJvbGxlckZldGNoJywgX19EcmF3ZXJGb3VuZEV2ZW50ID0gJ19fcGxhdERyYXdlckZvdW5kJywgXHJcbiAgICAvKipcclxuICAgICAqL1xyXG4gICAgX19SZXZlcnNlZCA9ICctcmV2ZXJzZWQnLCBfX0xJVEVSQUxfUkVTT1VSQ0UgPSAnbGl0ZXJhbCcsIF9fdHJhbnNpdGlvbk5lZ2F0ZSA9IHtcclxuICAgICAgICByaWdodDogJ2xlZnQnLFxyXG4gICAgICAgIGxlZnQ6ICdyaWdodCcsXHJcbiAgICAgICAgdXA6ICdkb3duJyxcclxuICAgICAgICBkb3duOiAndXAnXHJcbiAgICB9LCBfX3NyYyA9ICdzcmMnLCBfX3ByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LCBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LnBsYXR1aSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgd2luZG93LnBsYXR1aSA9IHBsYXR1aTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cubW9kdWxlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB3aW5kb3cubW9kdWxlID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBCaW5kQ29udHJvbCB0aGF0IHN0YW5kYXJkaXplcyBhbiBIVE1MNSBidXR0b24uXHJcbiAgICAgKi9cclxuICAgIHZhciBCdXR0b24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhCdXR0b24sIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gQnV0dG9uKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIHRoZSA8cGxhdC1idXR0b24+IG5vZGUgd2l0aFxyXG4gICAgICAgICAgICAgKiBhIDxidXR0b24+IG5vZGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoID0gJ2J1dHRvbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGJvb2xlYW4gdmFsdWUgc2hvd2luZyB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgdGhpcyBCdXR0b24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19CdXR0b24gKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgZGVmYXVsdCBjbGFzc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXcmFwIGFsbCBpbm5lciB0ZXh0IG5vZGVzIGluIHNwYW5zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnQuY2hpbGROb2RlcyksIGNoaWxkTm9kZSwgc3BhbiwgaXNFbXB0eSA9IHRoaXMudXRpbHMuaXNFbXB0eTtcclxuICAgICAgICAgICAgd2hpbGUgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkoY2hpbGROb2RlLnRleHRDb250ZW50LnRyaW0oKS5tYXRjaCgvW15cXHJcXG5dL2cpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoc3BhbiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUoY2hpbGROb2RlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBidXR0b24gc3R5bGUgYW5kIGFwcGx5IHRoZSBwcm9wZXIgY2xhc3Nlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLCBpc1N0cmluZyA9IHRoaXMudXRpbHMuaXNTdHJpbmc7XHJcbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcoZ3JvdXApKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cCA9IHRoaXMuYXR0cmlidXRlc1tfX0NhbWVsQmluZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcoZ3JvdXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXAgPSBncm91cDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb20uaGFzQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgXCJzZWxlY3RlZFwiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblRhcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwID0gZ3JvdXA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRvbS5oYXNDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyBcInNlbGVjdGVkXCIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblRhcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCdXR0b24ucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGJpbmRlcikge1xyXG4gICAgICAgICAgICBiaW5kZXIub2JzZXJ2ZVByb3BlcnR5KHRoaXMuX3NldEJvdW5kUHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eSBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYmluZGFibGUgcHJvcGVydHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGl0cyBiZWluZyBzZXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQnV0dG9uLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNTdHJpbmcobmV3VmFsdWUpIHx8IG5ld1ZhbHVlICE9PSB0aGlzLmVsZW1lbnQudGV4dENvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vblRhcCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkIGV2ZW50IGxpc3RlbmVycyBmb3Igc2VsZWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCBfXyR0YXAsIHRoaXMuX29uVGFwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMub24oX19CdXR0b25QcmVmaXggKyB0aGlzLl9ncm91cCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc1NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9tLnJlbW92ZUNsYXNzKF90aGlzLmVsZW1lbnQsIF9fUGxhdCArIFwic2VsZWN0ZWRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzU2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbGFjZSB0aGUgcHVzaGVkIGJ1dHRvbiBpbiBhIHNlbGVjdGVkIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEJ1dHRvbi5wcm90b3R5cGUuX29uVGFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNTZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyBcInNlbGVjdGVkXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoX19CdXR0b25QcmVmaXggKyB0aGlzLl9ncm91cCwgcGxhdC5ldmVudHMuRXZlbnRNYW5hZ2VyLkRJUkVDVCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzU2VsZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChlbGVtZW50LnRleHRDb250ZW50KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEJ1dHRvbi5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBCdXR0b247XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5CdXR0b24gPSBCdXR0b247XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19CdXR0b24sIEJ1dHRvbik7XHJcbiAgICAvKipcclxuICAgICAqIEFuIEJpbmRDb250cm9sIHRoYXQgc2ltdWxhdGVzIGEgdG9nZ2xlIHN3aXRjaC5cclxuICAgICAqL1xyXG4gICAgdmFyIFRvZ2dsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFRvZ2dsZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBUb2dnbGUoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LXRvZ2dsZS1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQta25vYlwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIGFjdGl2ZWx5IHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIGNvbnRyb2wncyBhY3RpdmF0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFR5cGUgPSAnc2xpZGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fVG9nZ2xlICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSBsaXN0ZW5lciBmb3IgdGhlIHRhcCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2dnbGUucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kdGFwLCB0aGlzLl9vblRhcCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRDaGVja2VkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZSh0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHByb3BlcnR5IGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgcHJvcGVydHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2V0UHJvcGVydHk/IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgd2Ugc2hvdWxkIHNldFxyXG4gICAgICAgICAqIHRoZSBwcm9wZXJ0eSBpZiB3ZSBuZWVkIHRvIHRvZ2dsZSB0aGUgc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIHNldFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzZXRQcm9wZXJ0eSA9PT0gdHJ1ZSAmJiB0aGlzLnV0aWxzLmlzTnVsbChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKHRoaXMuaXNBY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc0FjdGl2ZSA9ICEhbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZSA9PT0gdGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZShzZXRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBjaGVja2luZyBcImNoZWNrZWRcIiBhdHRyaWJ1dGVzIGFuZCBoYW5kbGluZyB0aGVtIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3VmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZT8gVGhlIG9sZFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY29udmVydC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2dnbGUucHJvdG90eXBlLl9jb252ZXJ0Q2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc051bGwodGhpcy5hdHRyaWJ1dGVzW19fQ2FtZWxDaGVja2VkXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRBdHRyaWJ1dGUodGhpcy5hdHRyaWJ1dGVzW19fQ2FtZWxDaGVja2VkXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMub2JzZXJ2ZSh0aGlzLl9jb252ZXJ0QXR0cmlidXRlLCBfX0NhbWVsQ2hlY2tlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29udmVydEF0dHJpYnV0ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBjb252ZXJzaW9uIGZvciB1cGRhdGluZyB0aGVcclxuICAgICAgICAgKiBib3VuZCBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ld1ZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY29udmVydC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWU/IFRoZSBvbGRWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHRvIGNvbnZlcnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVG9nZ2xlLnByb3RvdHlwZS5fY29udmVydEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzQm9vbGVhbihuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRCb3VuZFByb3BlcnR5KG5ld1ZhbHVlLCBvbGRWYWx1ZSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXV0aWxzLmlzU3RyaW5nKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEJvdW5kUHJvcGVydHkobmV3VmFsdWUgPT09ICd0cnVlJywgb2xkVmFsdWUgPT09ICd0cnVlJywgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY2FsbGJhY2sgZm9yIGEgdGFwIGV2ZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgdGFwIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUb2dnbGUucHJvdG90eXBlLl9vblRhcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGUodHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJpZ2dlcnMgYW4gZXZlbnQgc3RhcnRpbmcgZnJvbSB0aGlzIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZSB0byB0cmlnZ2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuX3RyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9tRXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGRvbUV2ZW50LmluaXRpYWxpemUodGhpcy5lbGVtZW50LCBldmVudCk7XHJcbiAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGhlIG1hcmsgYW5kIHVwZGF0ZXMgdGhlIGJpbmRhYmxlIHByb3BlcnR5IGlmIG5lZWRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNldFByb3BlcnR5PyBBIGJvb2xlYW4gdmFsdWUgc3RhdGluZyB3aGV0aGVyIHRoZSBiaW5kYWJsZVxyXG4gICAgICAgICAqIHByb3BlcnR5IHNob3VsZCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuX3RvZ2dsZSA9IGZ1bmN0aW9uIChzZXRQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZSwgaXNBY3RpdmUgPSAhd2FzQWN0aXZlLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0aGlzLl90YXJnZXRFbGVtZW50IHx8ICh0aGlzLl90YXJnZXRFbGVtZW50ID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkpO1xyXG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gZWxlbWVudC5jaGVja2VkID0gaXNBY3RpdmU7XHJcbiAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnY2hlY2tlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2V0UHJvcGVydHkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKGlzQWN0aXZlLCB3YXNBY3RpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHRoZSBnaXZlbiBlbGVtZW50IGJ5IHRvZ2dsaW5nIHRoZVxyXG4gICAgICAgICAqIGNsYXNzIHNwZWNpZmllZCBhcyB0aGUgdGFyZ2V0IHR5cGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFjdGl2YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRvZ2dsZS5wcm90b3R5cGUuX2FjdGl2YXRlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20udG9nZ2xlQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgdGhpcy5fdGFyZ2V0VHlwZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gVG9nZ2xlO1xyXG4gICAgfShwbGF0LnVpLkJpbmRDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuVG9nZ2xlID0gVG9nZ2xlO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fVG9nZ2xlLCBUb2dnbGUpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJQmluZGFibGVQcm9wZXJ0eUNvbnRyb2wgdGhhdCBzdGFuZGFyZGl6ZXMgdGhlIEhUTUw1IGNoZWNrYm94LlxyXG4gICAgICovXHJcbiAgICB2YXIgQ2hlY2tib3ggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDaGVja2JveCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBDaGVja2JveCgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTCB0ZW1wbGF0ZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSAnPGRpdiBjbGFzcz1cInBsYXQtY2hlY2tib3gtY29udGFpbmVyXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxzcGFuIGNsYXNzPVwicGxhdC1tYXJrXCI+PC9zcGFuPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSB0YXJnZXQgdHlwZSBoYXMgYmVlbiBzZXQgYWxyZWFkeSBvciBub3QuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRUeXBlU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2hlY2tib3gucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0NoZWNrYm94ICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHRoZSBpbm5lciB0ZW1wbGF0ZSB0byB0aGUgRE9NIG1ha2luZyBzdXJlIHRvIHdyYXAgdGV4dCBub2RlcyBpbiBzcGFucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDaGVja2JveC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc051bGwgPSB0aGlzLnV0aWxzLmlzTnVsbCwgaW5uZXJUZW1wbGF0ZSA9IHRoaXMuaW5uZXJUZW1wbGF0ZTtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbChpbm5lclRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGlubmVyVGVtcGxhdGUuY2hpbGROb2RlcyksIGNoaWxkTm9kZSwgc3BhbiwgbWF0Y2g7XHJcbiAgICAgICAgICAgIHdoaWxlIChjaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBjaGlsZE5vZGUudGV4dENvbnRlbnQudHJpbSgpLm1hdGNoKC9bXlxcclxcbl0vZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNwYW4sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBmb3IgY2hlY2tlZCBhdHRyaWJ1dGVzIGFuZCBoYW5kbGVzIHRoZW0gYWNjb3JkaW5nbHkuIEFsc28sXHJcbiAgICAgICAgICogaW5pdGlhbGl6ZXMgdGhlIG1hcmsgYW5kIGFkZHMgYSBsaXN0ZW5lciBmb3IgdGhlIHRhcCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDaGVja2JveC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmxvYWRlZC5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uT2JqID0gdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zID0gb3B0aW9uT2JqLnZhbHVlIHx8IHt9LCBwcmV2aW91c1R5cGUgPSB0aGlzLl90YXJnZXRUeXBlLCBtYXJrID0gdGhpcy5fdGFyZ2V0VHlwZSA9IG9wdGlvbnMubWFyayB8fCAnY2hlY2snO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1hcmsudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2snOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkludmFsaWQgbWFyayBvcHRpb24gc3BlY2lmaWVkIGZvciBcIiArIHRoaXMudHlwZSArIFwiLiBEZWZhdWx0aW5nIHRvIGNoZWNrbWFyay5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VHlwZSA9ICdjaGVjayc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldFR5cGVTZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl90YXJnZXRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2xhc3ModGFyZ2V0LCBwcmV2aW91c1R5cGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRUeXBlU2V0ID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdGhlIGdpdmVuIGVsZW1lbnQgYnkgdG9nZ2xpbmcgdGhlXHJcbiAgICAgICAgICogY2xhc3Mgc3BlY2lmaWVkIGFzIHRoZSB0YXJnZXQgdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWN0aXZhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2hlY2tib3gucHJvdG90eXBlLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRUeXBlU2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS50b2dnbGVDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyB0aGlzLl90YXJnZXRUeXBlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRUeXBlU2V0ID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIENoZWNrYm94Ll9pbmplY3QgPSB7XHJcbiAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENoZWNrYm94O1xyXG4gICAgfShUb2dnbGUpKTtcclxuICAgIHBsYXR1aS5DaGVja2JveCA9IENoZWNrYm94O1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fQ2hlY2tib3gsIENoZWNrYm94KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gSUJpbmRhYmxlUHJvcGVydHlDb250cm9sIHRoYXQgc3RhbmRhcmRpemVzIHRoZSBIVE1MNSByYWRpbyBidXR0b24uXHJcbiAgICAgKi9cclxuICAgIHZhciBSYWRpbyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFJhZGlvLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFJhZGlvKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1yYWRpby1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtbWFya1wiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcmFkaW8gZ3JvdXBzIG5hbWUgaWYgYSByYWRpbyBncm91cCBpcyBwcmVzZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5ncm91cE5hbWUgPSAnJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjaGVjayB0eXBlIHRvIGJlIHBsYWNlZCBpbiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFR5cGUgPSAnYnVsbGV0JztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIHRhcmdldCB0eXBlIGhhcyBiZWVuIHNldCBhbHJlYWR5IG9yIG5vdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFR5cGVTZXQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19SYWRpbyArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGZvciBhIHJhZGlvIGdyb3VwIGFuZCBjb252ZXJ0cyBcImNoZWNrZWRcIiBhdHRyaWJ1dGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXRFbGVtZW50ID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHRhcCwgdGhpcy5fb25UYXApO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cE5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbmFtZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnV0aWxzLmlzTnVsbCh0aGlzLmF0dHJpYnV0ZXNbX19DYW1lbEJpbmRdKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cE5hbWUgPSB0aGlzLmF0dHJpYnV0ZXNbX19DYW1lbEJpbmRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRDaGVja2VkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIHJhZGlvIGhhcyBiZWVuIHNlbGVjdGVkIGFuZCBvbmx5IG5vdGlmaWVzIG9mIGEgYmluZGFibGVcclxuICAgICAgICAgKiBwcm9wZXJ0eSBjaGFuZ2VkIGlmIGl0IGhhcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWU/IFRoZSBuZXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGFmdGVyIHRoZSBjaGFuZ2UuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlPyBUaGUgb2xkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBwcmlvciB0byB0aGUgY2hhbmdlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5pbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmlucHV0Q2hhbmdlZC5jYWxsKHRoaXMsIHRoaXMuX2dldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHByb3BlcnR5IGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgcHJvcGVydHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2V0UHJvcGVydHk/IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgd2Ugc2hvdWxkIHNldFxyXG4gICAgICAgICAqIHRoZSBwcm9wZXJ0eSBpZiB3ZSBuZWVkIHRvIHRvZ2dsZSB0aGUgbWFyay5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYWRpby5wcm90b3R5cGUuX3NldEJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBzZXRQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0UHJvcGVydHkgPT09IHRydWUgJiYgdGhpcy51dGlscy5pc051bGwobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc0NoZWNrZWQgPSBuZXdWYWx1ZSA9PT0gdGhpcy5fZ2V0VmFsdWUoKSwgd2FzQ2hlY2tlZCA9IHRoaXMuaXNBY3RpdmU7XHJcbiAgICAgICAgICAgIGlmIChpc0NoZWNrZWQgPT09IHdhc0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoc2V0UHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIGZvciBhIHRhcCBldmVudC4gT25seSBmaXJlcyB0aGUgZXZlbnQgaWYgdGhlIFJhZGlvXHJcbiAgICAgICAgICogaGFzIGJlZW4gc2VsZWN0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0YXAgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5fb25UYXAgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9vblRhcC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRvZ2dsZXMgdGhlIG1hcmsgYW5kIHVwZGF0ZXMgdGhlIGJpbmRhYmxlIHByb3BlcnR5IGlmIG5lZWRlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNldFByb3BlcnR5PyBBIGJvb2xlYW4gdmFsdWUgc3RhdGluZyB3aGV0aGVyIHRoZSBiaW5kYWJsZVxyXG4gICAgICAgICAqIHByb3BlcnR5IHNob3VsZCBiZSB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhZGlvLnByb3RvdHlwZS5fdG9nZ2xlID0gZnVuY3Rpb24gKHNldFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3RvZ2dsZS5jYWxsKHRoaXMsIHNldFByb3BlcnR5KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNGdW5jdGlvbih0aGlzLl9yZW1vdmVMaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSB0aGlzLmdyb3VwTmFtZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChfX1JhZGlvUHJlZml4ICsgbmFtZV8xLCBwbGF0LmV2ZW50cy5FdmVudE1hbmFnZXIuRElSRUNUKTtcclxuICAgICAgICAgICAgICAgIHZhciByZW1vdmVyXzEgPSB0aGlzLl9yZW1vdmVMaXN0ZW5lciA9IHRoaXMub24oX19SYWRpb1ByZWZpeCArIG5hbWVfMSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVyXzEoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIGZvciBoYW5kbGluZyB0aGUgYXR0cmlidXRlIHZhbHVlIGNvbnZlcnNpb24gZm9yIHVwZGF0aW5nIHRoZVxyXG4gICAgICAgICAqIGJvdW5kIHByb3BlcnR5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBuZXdWYWx1ZSBUaGUgbmV3VmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBjb252ZXJ0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBvbGRWYWx1ZT8gVGhlIG9sZFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgdG8gY29udmVydC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYWRpby5wcm90b3R5cGUuX2NvbnZlcnRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0Jvb2xlYW4obmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRCb3VuZFByb3BlcnR5KHRoaXMuX2dldFZhbHVlKCksIG51bGwsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlscy5pc1N0cmluZyhuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSh0aGlzLl9nZXRWYWx1ZSgpLCBudWxsLCBudWxsLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR3JhYnMgdGhlIHZhbHVlIG9mIHRoaXMgUmFkaW8ncyBiaW5kYWJsZSBwcm9wZXJ0eS4gSXQgZmlyc3QgY2hlY2tzIGZvclxyXG4gICAgICAgICAqIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlLCBhbmQgZGVmYXVsdHMgdG8gdGhlIGVsZW1lbnRzIHRleHRDb250ZW50IGlmIGl0J3MgdW5hdmFpbGFibGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFkaW8ucHJvdG90eXBlLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKSA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2YWx1ZScpLnRyaW0oKSA6IGVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJhZGlvO1xyXG4gICAgfShDaGVja2JveCkpO1xyXG4gICAgcGxhdHVpLlJhZGlvID0gUmFkaW87XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19SYWRpbywgUmFkaW8pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJVGVtcGxhdGVDb250cm9sIGZvciBzaG93aW5nIGluZGV0ZXJtaW5hdGUgcHJvZ3Jlc3MuXHJcbiAgICAgKi9cclxuICAgIHZhciBQcm9ncmVzc1JpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcm9ncmVzc1JpbmcsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gUHJvZ3Jlc3NSaW5nKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1hbmltYXRlZC1yaW5nXCI+PC9kaXY+JztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9ncmVzc1JpbmcucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX1Byb2dyZXNzUmluZyArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzUmluZy5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9ncmVzc1JpbmcucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIHV0aWxzID0gdGhpcy51dGlscywgaXNPYmplY3QgPSB1dGlscy5pc09iamVjdCwgc3R5bGUgPSAwO1xyXG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgaXNPYmplY3Qob3B0aW9ucy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlID0gb3B0aW9ucy52YWx1ZS5zdHlsZTtcclxuICAgICAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdW1iZXIoc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgX19Qcm9ncmVzc1JpbmcgKyBcIi1cIiArIHN0eWxlKTtcclxuICAgICAgICAgICAgaWYgKHN0eWxlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYWRkQW5pbWF0ZWRFbGVtZW50cyhzdHlsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFueSBuZWVkZWQgRE9NIGZvciB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzUmluZy5wcm90b3R5cGUuX2FkZEFuaW1hdGVkRWxlbWVudHMgPSBmdW5jdGlvbiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHBsYXQuYWNxdWlyZShfX0RvY3VtZW50KSwgZnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBjb3VudCA9IHN0eWxlID09PSAyID8gMTIgOiA0LCBkaXYgPSAnZGl2JywgY2xhc3NQcmVmaXggPSBfX1BsYXQgKyBcImFuaW1hdGVkLWNoaWxkIFwiICsgX19QbGF0ICsgXCJhbmltYXRlZC1jaGlsZC1cIiwgY2hpbGQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudChkaXYpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuY2xhc3NOYW1lID0gY2xhc3NQcmVmaXggKyBpO1xyXG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQcm9ncmVzc1Jpbmc7XHJcbiAgICB9KHBsYXQudWkuVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuUHJvZ3Jlc3NSaW5nID0gUHJvZ3Jlc3NSaW5nO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fUHJvZ3Jlc3NSaW5nLCBQcm9ncmVzc1JpbmcpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBJVGVtcGxhdGVDb250cm9sIGZvciBzaG93aW5nIGluY3JlbWVudGFsIHByb2dyZXNzLlxyXG4gICAgICovXHJcbiAgICB2YXIgUHJvZ3Jlc3NCYXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhQcm9ncmVzc0JhciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBQcm9ncmVzc0JhcigpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTCB0ZW1wbGF0ZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSAnPGRpdiBjbGFzcz1cInBsYXQtcHJvZ3Jlc3MtY29udGFpbmVyXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJwbGF0LWFuaW1hdGVkLWJhclwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2Plxcbic7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBzdG9wIGxpc3RlbmluZyBmb3IgdmlzaWJpbGl0eSBpZiBhcHBsaWNhYmxlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUxpc3RlbmVyID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fUHJvZ3Jlc3NCYXIgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgY2xhc3MgbmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmFicyB0aGUgYmFyIGVsZW1lbnQgdGhlbiBzZXRzIGFueSBpbml0aWFsIHByb2dyZXNzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzQmFyLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhckVsZW1lbnQgPSB0aGlzLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl93aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRQcm9ncmVzcyhfdGhpcy5jb250ZXh0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvZ3Jlc3ModGhpcy5jb250ZXh0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIHZpc2liaWxpdHkgbGlzdGVuZXIgaWYgYXBwbGljYWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQcm9ncmVzc0Jhci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUxpc3RlbmVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmltYXRlcyB0aGUgYmFyIG9uIGEgY29udGV4dCBjaGFuZ2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzQmFyLnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRQcm9ncmVzcyh0aGlzLmNvbnRleHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgcHJvZ3Jlc3MgYmFyIHZhbHVlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgZGVjaW1hbCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxIHRvIHNldCBhcyB0aGVcclxuICAgICAgICAgKiBiYXIgcGVyY2VudGFnZSAoZS5nLiAtIDAuNSB3b3VsZCBiZSA1MCUgY29tcGxldGUpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFByb2dyZXNzQmFyLnByb3RvdHlwZS5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51dGlscy5pc051bWJlcih2YWx1ZSkgfHwgdmFsdWUgPiAxIHx8IHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIlRoZSB2YWx1ZSBvZiBhIFxcXCJcIiArIF90aGlzLnR5cGUgKyBcIlxcXCIgY29udHJvbCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS5cIjtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGJhckVsZW1lbnQgPSBfdGhpcy5fYmFyRWxlbWVudCwgYmFyTWF4ID0gYmFyRWxlbWVudC5wYXJlbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFiYXJNYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZVZpc2liaWxpdHlMaXN0ZW5lciA9IF90aGlzLmRvbS53aGVuVmlzaWJsZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFByb2dyZXNzKHZhbHVlKS50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIF90aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRvci5hbmltYXRlKGJhckVsZW1lbnQsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IE1hdGguY2VpbChiYXJNYXggKiB2YWx1ZSkgKyBcInB4XCJcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBQcm9ncmVzc0Jhci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUHJvZ3Jlc3NCYXI7XHJcbiAgICB9KHBsYXQudWkuVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuUHJvZ3Jlc3NCYXIgPSBQcm9ncmVzc0JhcjtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX1Byb2dyZXNzQmFyLCBQcm9ncmVzc0Jhcik7XHJcbiAgICAvKipcclxuICAgICAqIEFuIEJpbmRDb250cm9sIHRoYXQgYWN0cyBhcyBhIGdsb2JhbCBkcmF3ZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciBEcmF3ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhEcmF3ZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gRHJhd2VyKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgcHJvbWlzZSB0aGF0IHNpZ25pZmllcyB0aGUgRHJhd2VyIGlzIHJlYWR5IGZvciBhIHBhaXJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWZlcmVuY2VzIHRvIGFsbCB0aGUgRHJhd2VyQ29udHJvbGxlcnMgdXNlZCB0byBjb250cm9sIHRoaXMgRHJhd2VyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0aGlzIGNvbnRyb2wgaGFzIGJlZW4gcGFpcmVkIHdpdGggYSBjb3JyZXNwb25kaW5nIERyYXdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgYm91bmQgdmFsdWUgdGhhdCBtYXkgaGF2ZSBjb21lIHRocm91Z2ggcHJpb3IgdG8gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVJbml0aWFsaXplZFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHByaXZhdGUgdmFyaWFibGUgdGhhdCB0ZWxscyB0aGUgRHJhd2VyIGl0cyBsYXN0IG9wZW4gb3IgY2xvc2VkIHN0YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fX3N0YXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHByaXZhdGUgdmFyaWFibGUgdGhhdCB0ZWxscyB0aGUgRHJhd2VyIGl0cyBuZXh0IG9wZW4gb3IgY2xvc2VkIHN0YXRlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fX25leHRTdGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fRHJhd2VyICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUgYW5kIGhpZGVzIHRoZSBlbGVtZW50IGFuZFxyXG4gICAgICAgICAqIHJlbW92ZXMgdGhlIGlubmVySFRNTCBmcm9tIHRoZSBET00gYW5kIHNhdmVzIGl0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbm5lckhUTUwgZnJvbSB0aGUgRE9NIGFuZCBzYXZlcyBpdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyVGVtcGxhdGUgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZHJlbih0aGlzLmVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayBmb3IgYSBwb3NpdGlvbiBhbmQgaW5pdGlhbGl6ZSBldmVudCBoYW5kbGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHV0aWxzID0gdGhpcy51dGlscywgb3B0aW9uT2JqID0gdGhpcy5vcHRpb25zIHx8IHt9LCBvcHRpb25zID0gb3B0aW9uT2JqLnZhbHVlIHx8IHt9LCBwb3NpdGlvbiA9IHRoaXMuX2N1cnJlbnRQb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb24gfHwgJ2xlZnQnLCBpZCA9IG9wdGlvbnMuaWQgfHwgJycsIHRlbXBsYXRlVXJsID0gb3B0aW9ucy50ZW1wbGF0ZVVybCwgaXNFbGFzdGljID0gb3B0aW9ucy5lbGFzdGljID09PSB0cnVlO1xyXG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgcG9zaXRpb24pO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcodGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICBwbGF0LnVpLlRlbXBsYXRlQ29udHJvbC5kZXRlcm1pbmVUZW1wbGF0ZSh0aGlzLCB0ZW1wbGF0ZVVybCkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbm5lclRlbXBsYXRlID0gdGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemVFdmVudHMoaWQsIHBvc2l0aW9uLCBpc0VsYXN0aWMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUV2ZW50cyhpZCwgcG9zaXRpb24sIGlzRWxhc3RpYyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcGVucyB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJObyBjb250cm9sbGVyLCBzdWNoIGFzIGEgXCIgKyBfX0RyYXdlckNvbnRyb2xsZXIgKyBcIiwgZm91bmQgZm9yIHRoZSBcIiArIHRoaXMudHlwZSArIFwiIGF0dGVtcHRpbmcgdG8gb3Blbi5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIub3BlbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xvc2VzIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJObyBjb250cm9sbGVyLCBzdWNoIGFzIGEgXCIgKyBfX0RyYXdlckNvbnRyb2xsZXIgKyBcIiwgZm91bmQgZm9yIHRoZSBcIiArIHRoaXMudHlwZSArIFwiIGF0dGVtcHRpbmcgdG8gY2xvc2UuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRoZSBEcmF3ZXIncyBvcGVuL2Nsb3NlZCBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGNvbnRyb2xsZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJObyBjb250cm9sbGVyLCBzdWNoIGFzIGEgXCIgKyBfX0RyYXdlckNvbnRyb2xsZXIgKyBcIiwgZm91bmQgZm9yIHRoZSBcIiArIHRoaXMudHlwZSArIFwiIGF0dGVtcHRpbmcgdG8gdG9nZ2xlLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci50b2dnbGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBEcmF3ZXIgaXMgY3VycmVudGx5IG9wZW4uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcnNbMF07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzTnVsbChjb250cm9sbGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiTm8gY29udHJvbGxlciwgc3VjaCBhcyBhIFwiICsgX19EcmF3ZXJDb250cm9sbGVyICsgXCIsIGZvdW5kIGZvciB0aGUgXCIgKyB0aGlzLnR5cGUgKyBcIiBhdHRlbXB0aW5nIHRvIGNoZWNrIGlmIG9wZW4uXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLmlzT3BlbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbmQgYmluZHMgdGhlIGFkZGVkIEhUTUwgdGVtcGxhdGUgdG8gdGhpcyBjb250cm9sJ3MgaW5oZXJpdGVkIGNvbnRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHRlbXBsYXRlIG5hbWUgdG8gYm90aCBhZGQgYW5kIGJpbmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkZCBhcyBhIGJpbmRhYmxlIHRlbXBsYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuYmluZFRlbXBsYXRlID0gZnVuY3Rpb24gKG5hbWUsIG5vZGUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGJpbmRhYmxlVGVtcGxhdGVzID0gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcztcclxuICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMuYWRkKG5hbWUsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZGFibGVUZW1wbGF0ZXMuYmluZChuYW1lKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBfdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZG9tLmNsZWFyTm9kZShlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoXCJFcnJvciBiaW5kaW5nIHRlbXBsYXRlIGZvciBcIiArIF90aGlzLnR5cGUgKyBcIjogXCIgKyBlcnJvcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIERyYXdlckNvbnRyb2xsZXJzIGxpbmtlZCB0byB0aGlzXHJcbiAgICAgICAgICogRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuY29udHJvbGxlckNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udHJvbGxlcnMubGVuZ3RoO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhIHNwZWNpZmllZCBEcmF3ZXJDb250cm9sbGVyIGZyb20gdGhpcyBjb250cm9sJ3MgQXJyYXkgb2ZcclxuICAgICAgICAgKiBsaW5rZWQgRHJhd2VyQ29udHJvbGxlcnMuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuRHJhd2VyQ29udHJvbGxlcn0gY29udHJvbGxlciBUaGUgRHJhd2VyQ29udHJvbGxlclxyXG4gICAgICAgICAqIHRvIHNwbGljZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLnNwbGljZUNvbnRyb2xsZXIgPSBmdW5jdGlvbiAoY29udHJvbGxlcikge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbGxlcnMgPSB0aGlzLl9jb250cm9sbGVycywgaW5kZXggPSBjb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fX3N0YXRlID0gdGhpcy5fX25leHRTdGF0ZSA9IGNvbnRyb2xsZXJzW2luZGV4XS5pc09wZW4oKTtcclxuICAgICAgICAgICAgY29udHJvbGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHByb3BlcnR5IGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY29udHJvbCBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGNvbnRyb2wgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHt2b2lkfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLl9zZXRCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyc1swXTtcclxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSAmJiB1dGlscy5pc051bGwobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCh1dGlscy5pc051bGwoY29udHJvbGxlcikgPyBmYWxzZSA6IGNvbnRyb2xsZXIuaXNPcGVuKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkcmF3ZXJTdGF0ZSA9ICEhbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChkcmF3ZXJTdGF0ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKGRyYXdlclN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUgPSBkcmF3ZXJTdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1dGlscy5pc051bGwoY29udHJvbGxlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19uZXh0U3RhdGUgPSBkcmF3ZXJTdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkcmF3ZXJTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXNPcGVuKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLm9wZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb250cm9sbGVyLmlzT3BlbigpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgdGhlIHBsYWNlbWVudCBhbmQgaW1wbGllZCBwb3NpdGlvbiBvZiB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiBUaGUgbmV3IHBvc2l0aW9uIHRvIGNoYW5nZSB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXIucHJvdG90eXBlLl9jaGFuZ2VEaXJlY3Rpb24gPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKHBvc2l0aW9uKSB8fCBwb3NpdGlvbiA9PT0gdGhpcy5fY3VycmVudFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xyXG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgdGhpcy5fY3VycmVudFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKGVsZW1lbnQsIF9fUGxhdCArIHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBhbmQgZGlzcGF0Y2hlcyBwdWIgc3ViIGV2ZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoaXMgRHJhd2VyIGlmIHVzZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRWxhc3RpYyBXaGV0aGVyIG9yIG5vdCB0aGUgRHJhd2VyIGhhcyBhblxyXG4gICAgICAgICAqIGVsYXN0aWMgdHJhbnNpdGlvbiBlZmZlY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyLnByb3RvdHlwZS5faW5pdGlhbGl6ZUV2ZW50cyA9IGZ1bmN0aW9uIChpZCwgcG9zaXRpb24sIGlzRWxhc3RpYykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBpbm5lclRlbXBsYXRlID0gdGhpcy5pbm5lclRlbXBsYXRlO1xyXG4gICAgICAgICAgICB0aGlzLm9uKF9fRHJhd2VyQ29udHJvbGxlckZldGNoRXZlbnQgKyBcIl9cIiArIGlkLCBmdW5jdGlvbiAoZXZlbnQsIGNvbnRyb2xsZXJBcmcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sID0gY29udHJvbGxlckFyZy5jb250cm9sO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChjb250cm9sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhjb250cm9sbGVyQXJnLnBvc2l0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gY29udHJvbGxlckFyZy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hhbmdlRGlyZWN0aW9uKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb250cm9sbGVycy51bnNoaWZ0KGNvbnRyb2wpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb250cm9sbGVyQXJnLnJlY2VpdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhZHkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc3BhdGNoRXZlbnQoX19EcmF3ZXJGb3VuZEV2ZW50ICsgXCJfXCIgKyBpZCwgcGxhdC5ldmVudHMuRXZlbnRNYW5hZ2VyLkRJUkVDVCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbDogX3RoaXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB1dGlscy5pc05vZGUoaW5uZXJUZW1wbGF0ZSkgPyBpbm5lclRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGFzdGljOiBpc0VsYXN0aWMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogX3RoaXMuX19zdGF0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZTogX3RoaXMuX19uZXh0U3RhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXJBcmcudXNlQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmJpbmRUZW1wbGF0ZSgnZHJhd2VyJywgaW5uZXJUZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2hlY2tQcmVJbml0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrUHJlSW5pdCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KF9fRHJhd2VyRm91bmRFdmVudCArIFwiX1wiICsgaWQsIHBsYXQuZXZlbnRzLkV2ZW50TWFuYWdlci5ESVJFQ1QsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRyb2w6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdXRpbHMuaXNOb2RlKGlubmVyVGVtcGxhdGUpID8gaW5uZXJUZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZWxhc3RpYzogaXNFbGFzdGljLFxyXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuX19zdGF0ZSxcclxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZTogdGhpcy5fX25leHRTdGF0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgcHJlLWluaXRpYWxpemVkIHZhbHVlIGFuZCBoYW5kbGVzIGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlci5wcm90b3R5cGUuX2NoZWNrUHJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB1dGlsc18xID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgICAgIHV0aWxzXzEucG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyID0gX3RoaXMuX2NvbnRyb2xsZXJzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXRpbHNfMS5pc051bGwoY29udHJvbGxlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5vcGVuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIERyYXdlci5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gRHJhd2VyO1xyXG4gICAgfShwbGF0LnVpLkJpbmRDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuRHJhd2VyID0gRHJhd2VyO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fRHJhd2VyLCBEcmF3ZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBCaW5kQ29udHJvbCB0aGF0IG1hbmlwdWxhdGVzIGFuZCBjb250cm9scyBhIGdsb2JhbCBkcmF3ZXIuXHJcbiAgICAgKi9cclxuICAgIHZhciBEcmF3ZXJDb250cm9sbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoRHJhd2VyQ29udHJvbGxlciwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBEcmF3ZXJDb250cm9sbGVyKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGhhcyBzd2lwZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNTd2lwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGhhcyB0YXBwZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNUYXBwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBEcmF3ZXIgaXMgb3Blbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gZW51bSBkZW5vdGluZyB0aGUgY3VycmVudCB0b3VjaCBzdGF0ZSBvZiB0aGUgdXNlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgY29ycmVzcG9uZGluZyBEcmF3ZXIgaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gZm9yIHJlbW92aW5nIHRoZSBjbGljayBlYXRlciBzY3JvbGwgbGlzdGVuaW5nIGV2ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tFYXRlckxpc3RlbmVyID0gbm9vcDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoZSB0b2dnbGUgZGVsYXkgaWYgcHJlc2VudC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURlbGF5ID0gbm9vcDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0aGlzIGNvbnRyb2wgaGFzIGJlZW4gcGFpcmVkIHdpdGggYSBjb3JyZXNwb25kaW5nIERyYXdlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19EcmF3ZXJDb250cm9sbGVyICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzcyBuYW1lIG9uIHRoZSBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgX19EcmF3ZXJDb250cm9sbGVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIHRyYWNrIGV2ZW50cyBvbiB0aGUgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbiwgaWQgPSBvcHRpb25zLmlkIHx8ICcnO1xyXG4gICAgICAgICAgICB0aGlzLl90eXBlID0gb3B0aW9ucy50eXBlIHx8ICd0YXAgdHJhY2snO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0VsYXN0aWMgPSBvcHRpb25zLmVsYXN0aWM7XHJcbiAgICAgICAgICAgIHRoaXMuX3VzZUNvbnRleHQgPSBvcHRpb25zLnVzZUNvbnRleHQgPT09IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlVXJsID0gb3B0aW9ucy50ZW1wbGF0ZVVybDtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUV2ZW50cyhpZCwgcG9zaXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlIHRoZSB0cmFuc2l0aW9uIGNsYXNzZXMgb2ZmIHRoZSByb290IGVsZW1lbnQgYW5kIHJlc2V0IHRoZSBwb3NpdGlvbiBhbmRcclxuICAgICAgICAgKiB6SW5kZXggcHJvcGVydGllcyBpZiBtb2RpZmllZCBhbmQgb25seSBpZiB0aGlzIGlzIHRoZSBsYXN0IERyYXdlckNvbnRyb2xsZXJcclxuICAgICAgICAgKiByZWZlcmVuY2luZyB0aGlzIERyYXdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuX2RyYXdlcjtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGRyYXdlcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZHJhd2VyLmNvbnRyb2xsZXJDb3VudCgpID4gMSkge1xyXG4gICAgICAgICAgICAgICAgZHJhd2VyLnNwbGljZUNvbnRyb2xsZXIodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICBkcmF3ZXIucmVhZHkgPSB0aGlzLmNsb3NlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyLnNwbGljZUNvbnRyb2xsZXIoX3RoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmF3ZXIuY29udHJvbGxlckNvdW50KCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NsZWFuUm9vdEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRyYXdlci5yZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRyYXdlci5zcGxpY2VDb250cm9sbGVyKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChkcmF3ZXIuY29udHJvbGxlckNvdW50KCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2NsZWFuUm9vdEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPcGVucyB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB3YXNDbG9zZWQgPSAhdGhpcy5faXNPcGVuLCB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURlbGF5KCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b2dnbGVEZWxheSA9IHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29wZW4oKS50aGVuKHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAod2FzQ2xvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5fZHJhd2VyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVsbChkcmF3ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyLmlucHV0Q2hhbmdlZCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb3NlcyB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgd2FzT3BlbiA9IHRoaXMuX2lzT3BlbiwgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICB0aGlzLl90b2dnbGVEZWxheSgpO1xyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlRGVsYXkgPSB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jbG9zZSgpLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICh3YXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHJhd2VyID0gdGhpcy5fZHJhd2VyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF1dGlscy5pc051bGwoZHJhd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYXdlci5yZWFkeSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyLmlucHV0Q2hhbmdlZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRoZSBEcmF3ZXIncyBvcGVuL2Nsb3NlZCBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc09wZW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERyYXdlciBpcyBjdXJyZW50bHkgb3Blbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc09wZW47XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCaW5kcyB0aGUgYWRkZWQgSFRNTCB0ZW1wbGF0ZSB0byB0aGlzIGNvbnRyb2wncyBpbmhlcml0ZWQgY29udGV4dCBhbmRcclxuICAgICAgICAgKiBwbGFjZXMgdGhlIG5vZGUgaW50byB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSB0ZW1wbGF0ZSBuYW1lIHRvIGJpbmQuXHJcbiAgICAgICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFkZCBhcyBhIGJpbmRhYmxlIHRlbXBsYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLmJpbmRUZW1wbGF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBiaW5kYWJsZVRlbXBsYXRlcyA9IHRoaXMuYmluZGFibGVUZW1wbGF0ZXM7XHJcbiAgICAgICAgICAgIGJpbmRhYmxlVGVtcGxhdGVzLmFkZChuYW1lLCBub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJpbmRhYmxlVGVtcGxhdGVzLmJpbmQobmFtZSkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuX2RyYXdlckVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kb20uY2xlYXJOb2RlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0ZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcIkVycm9yIGJpbmRpbmcgdGVtcGxhdGUgZm9yIFwiICsgX3RoaXMudHlwZSArIFwiOiBcIiArIGVycm9yKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRCb3VuZFByb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgcHJvcGVydHkgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjb250cm9sJ3Mgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBjb250cm9sIHN0YXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7dm9pZH0gaWRlbnRpZmllciBUaGUgY2hpbGQgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gYmluZCB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3NldEJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSAmJiB1dGlscy5pc051bGwobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCh0aGlzLl9pc09wZW4pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkcmF3ZXJTdGF0ZSA9ICEhbmV3VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChkcmF3ZXJTdGF0ZSAhPT0gbmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKGRyYXdlclN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUgPSBkcmF3ZXJTdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkcmF3ZXJTdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURlbGF5KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b2dnbGVEZWxheSA9IHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29wZW4oKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGVsYXkoKTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlRGVsYXkgPSB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLl9jbG9zZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pLCBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVsbChkcmF3ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd2VyLnJlYWR5ID0gcHJvbWlzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3BlbnMgdGhlIERyYXdlci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0PyBXaGV0aGVyIHRoZSBvcGVuIGlzIGJlaW5nIGNhbGxlZCB0byByZXNldCB0aGUgb3BlbiBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uIChyZXNldCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCwgaXNOb2RlID0gdGhpcy51dGlscy5pc05vZGUsIGlzT3BlbiA9IHRoaXMuX2lzT3Blbiwgb2Zmc2V0ID0gdGhpcy5fZ2V0T2Zmc2V0KCk7XHJcbiAgICAgICAgICAgIGlmICgoaXNPcGVuICYmICFyZXNldCkgfHwgIShvZmZzZXQgJiYgaXNOb2RlKHJvb3RFbGVtZW50KSAmJiBpc05vZGUodGhpcy5fZHJhd2VyRWxlbWVudCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IFwidHJhbnNsYXRlM2QoXCIgKyBvZmZzZXQgKyBcInB4LDAsMClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiA9IFwidHJhbnNsYXRlM2QoXCIgKyAoLW9mZnNldCkgKyBcInB4LDAsMClcIjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBcInRyYW5zbGF0ZTNkKDAsXCIgKyBvZmZzZXQgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUzZCgwLFwiICsgKC1vZmZzZXQpICsgXCJweCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faXNPcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3Mocm9vdEVsZW1lbnQsIHRoaXMuX2RpcmVjdGlvbmFsVHJhbnNpdGlvblByZXApO1xyXG4gICAgICAgICAgICBpZiAoIWlzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkQ2xpY2tFYXRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbdGhpcy5fdHJhbnNmb3JtXSA9IHRyYW5zbGF0aW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uVGhlbmFibGUgPSB0aGlzLl9hbmltYXRvci5hbmltYXRlKHJvb3RFbGVtZW50LCBfX1RyYW5zaXRpb24sIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uVGhlbmFibGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RyYXdlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBfX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xvc2VzIHRoZSBEcmF3ZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZXNldD8gV2hldGhlciB0aGUgb3BlbiBpcyBiZWluZyBjYWxsZWQgdG8gcmVzZXQgdGhlIG9wZW4gc3RhdGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24gKHJlc2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50LCBpc05vZGUgPSB0aGlzLnV0aWxzLmlzTm9kZSwgaXNDbG9zZWQgPSAhdGhpcy5faXNPcGVuO1xyXG4gICAgICAgICAgICBpZiAoKGlzQ2xvc2VkICYmICFyZXNldCkgfHwgIShpc05vZGUocm9vdEVsZW1lbnQpICYmIGlzTm9kZSh0aGlzLl9kcmF3ZXJFbGVtZW50KSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1t0aGlzLl90cmFuc2Zvcm1dID0gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uVGhlbmFibGUgPSB0aGlzLl9hbmltYXRvci5hbmltYXRlKHJvb3RFbGVtZW50LCBfX1RyYW5zaXRpb24sIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0aW9uVGhlbmFibGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2RyYXdlckVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBfX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2lzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl90b3VjaFN0YXRlIDwgMikge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDbGlja0VhdGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzZXRzIHRoZSBEcmF3ZXIgdG8gaXQncyBjdXJyZW50IG9wZW4vY2xvc2VkIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZW4odHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9jbG9zZSh0cnVlKSwgZHJhd2VyID0gdGhpcy5fZHJhd2VyO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOdWxsKGRyYXdlcikpIHtcclxuICAgICAgICAgICAgICAgIGRyYXdlci5yZWFkeSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgY2xpY2sgZWF0ZXIgd2hlbiB0cmFja2luZyBhbmQgY2xvc2luZyBhbiBvcGVuIERyYXdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fYWRkQ2xpY2tFYXRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGNsaWNrRWF0ZXIgPSB0aGlzLl9jbGlja0VhdGVyLCBzdHlsZSA9IGNsaWNrRWF0ZXIuc3R5bGUsIHJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIGlmIChyb290RWxlbWVudC5jb250YWlucyhjbGlja0VhdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsaWduIGNsaWNrRWF0ZXIgdG8gZmlsbCB0aGUgcm9vdEVsZW1lbnQgXHJcbiAgICAgICAgICAgIHN0eWxlLnRvcCA9IHJvb3RFbGVtZW50LnNjcm9sbFRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgc3R5bGUubGVmdCA9IHJvb3RFbGVtZW50LnNjcm9sbExlZnQgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHJvb3RFbGVtZW50Lmluc2VydEJlZm9yZShjbGlja0VhdGVyLCBudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5fcm9vdEVsZW1lbnQsIHRoaXMuX2RpcmVjdGlvbmFsVHJhbnNpdGlvblByZXApO1xyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlU2Nyb2xsLCByZW1vdmVSZXF1ZXN0ID0gbm9vcCwgcmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICByZW1vdmVTY3JvbGwgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIocm9vdEVsZW1lbnQsICdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVhZHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVJlcXVlc3QgPSBfdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IGNsaWNrRWF0ZXIuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsaWduIGNsaWNrRWF0ZXIgdG8gZmlsbCB0aGUgcm9vdEVsZW1lbnQgXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUudG9wID0gcm9vdEVsZW1lbnQuc2Nyb2xsVG9wICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmxlZnQgPSByb290RWxlbWVudC5zY3JvbGxMZWZ0ICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0VhdGVyTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVTY3JvbGwoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGNsaWNrIGVhdGVyIGFmdGVyIGNsb3NpbmcgYW4gb3BlbiBEcmF3ZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3JlbW92ZUNsaWNrRWF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50LCBjbGlja0VhdGVyID0gdGhpcy5fY2xpY2tFYXRlcjtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tFYXRlckxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChyb290RWxlbWVudC5jb250YWlucyhjbGlja0VhdGVyKSkge1xyXG4gICAgICAgICAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2xpY2tFYXRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2xhc3Mocm9vdEVsZW1lbnQsIHRoaXMuX2RpcmVjdGlvbmFsVHJhbnNpdGlvblByZXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBzd2lwZSBldmVudHMgdG8gdGhlIGNvbnRyb2xsZXIgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fYWRkU3dpcGVUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCByZW1vdmVTd2lwZU9wZW4gPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kc3dpcGUgKyBfX3RyYW5zaXRpb25OZWdhdGVbdGhpcy5fcG9zaXRpb25dLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFzU3dpcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpLCByZW1vdmVTd2lwZUNsb3NlID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHN3aXBlICsgdGhpcy5fcG9zaXRpb24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9oYXNTd2lwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTd2lwZVRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZVN3aXBlT3BlbigpO1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlU3dpcGVDbG9zZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBzd2lwZSBjbG9zZSBldmVudCB0byB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9hZGRTd2lwZUNsb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuU3dpcGVSZW1vdmVyID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuX2NsaWNrRWF0ZXIsIF9fJHN3aXBlICsgdGhpcy5fcG9zaXRpb24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9oYXNTd2lwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyB0YXAgdG9nZ2xlIGV2ZW50IHRvIHRoZSBjb250cm9sbGVyIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2FkZFRhcFRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGFwID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuZWxlbWVudCwgX18kdGFwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFzVGFwcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIHRhcCBjbG9zZSBldmVudCB0byB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9hZGRUYXBDbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fb3BlblRhcFJlbW92ZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fY2xpY2tFYXRlciwgX18kdGFwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFzVGFwcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgcHJpbWFyeSBhbmQgc2Vjb25kYXJ5IHRyYWNraW5nIGV2ZW50cyB0byB0aGUgRHJhd2VyQ29udHJvbGxlciBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGlzTnVsbCA9IHRoaXMudXRpbHMuaXNOdWxsLCB0eXBlcyA9IHRoaXMuX3R5cGUuc3BsaXQoJyAnKSwgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBoZXJlIGZpcnN0IGlmIHdlIHdhbnQgdG8gbGF0ZXIgYmUgYWJsZSB0byBkeW5hbWljYWxseSBjaGFuZ2UgcG9zaXRpb24gb2YgZHJhd2VyLiBcclxuICAgICAgICAgICAgLy8gdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTsgXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1RhcCA9ICh0eXBlcy5pbmRleE9mKCd0YXAnKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUYXBUb2dnbGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRhcENsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3dpcGUgPSAodHlwZXMuaW5kZXhPZignc3dpcGUnKSAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRTd2lwZVRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkU3dpcGVDbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1RyYWNrID0gKHR5cGVzLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrRm4gPSB0aGlzLl90cmFjaywgdHJhY2tEaXJlY3Rpb24gPSB2b2lkIDAsIGNsaWNrRWF0ZXIgPSB0aGlzLl9jbGlja0VhdGVyO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tEaXJlY3Rpb24gPSBwb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tEaXJlY3Rpb24gPSAndXAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja0RpcmVjdGlvbiA9ICdkb3duJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHByaW1hcnlUcmFjayA9IF9fJHRyYWNrICsgX190cmFuc2l0aW9uTmVnYXRlW3RyYWNrRGlyZWN0aW9uXSwgc2Vjb25kYXJ5VHJhY2sgPSBfXyR0cmFjayArIHRyYWNrRGlyZWN0aW9uLCByZW1vdmVQcmltYXJ5VHJhY2tfMSA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBwcmltYXJ5VHJhY2ssIHRyYWNrRm4sIGZhbHNlKSwgcmVtb3ZlU2Vjb25kYXJ5VHJhY2tfMSA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBzZWNvbmRhcnlUcmFjaywgdHJhY2tGbiwgZmFsc2UpLCBvcGVuVHJhY2tQcmltYXJ5UmVtb3Zlcl8xID0gdGhpcy5hZGRFdmVudExpc3RlbmVyKGNsaWNrRWF0ZXIsIHByaW1hcnlUcmFjaywgdHJhY2tGbiwgZmFsc2UpLCBvcGVuVHJhY2tTZWNvbmRhcnlSZW1vdmVyXzEgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tFYXRlciwgc2Vjb25kYXJ5VHJhY2ssIHRyYWNrRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRyYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVByaW1hcnlUcmFja18xKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2Vjb25kYXJ5VHJhY2tfMSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFja1JlbW92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BlblRyYWNrUHJpbWFyeVJlbW92ZXJfMSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5UcmFja1NlY29uZGFyeVJlbW92ZXJfMSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwodGhpcy5fbGFzdFRvdWNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaFN0YXJ0ID0gdGhpcy5fdG91Y2hTdGFydCwgdG91Y2hFbmQgPSB0aGlzLl90b3VjaEVuZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2ggPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kdG91Y2hzdGFydCwgdG91Y2hTdGFydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfXyR0b3VjaGVuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGNsaWNrRWF0ZXIsIF9fJHRvdWNoc3RhcnQsIHRvdWNoU3RhcnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoY2xpY2tFYXRlciwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGNsaWNrRWF0ZXIsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl93aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVSZXNpemUsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgYSBXaW5kb3cgcmVzaXplIGV2ZW50IGJ5IGNsb3NpbmcgdGhlIERyYXdlciBpbW1lZGlhdGVseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5faGFuZGxlUmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzT3Blbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpc051bGwgPSB0aGlzLnV0aWxzLmlzTnVsbCwgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCwgZHJhd2VyID0gdGhpcy5fZHJhd2VyO1xyXG4gICAgICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTnVsbChyb290RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50LnN0eWxlW3RoaXMuX3RyYW5zZm9ybV0gPSB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGwoZHJhd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhd2VyLmlucHV0Q2hhbmdlZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3ZXJFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgX19wcmV2ZW50RGVmYXVsdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlIDwgMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tFYXRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGFsbCBldmVudCBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IHRoaXMudXRpbHMuaXNGdW5jdGlvbjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGFwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9yZW1vdmVUYXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVGFwID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX29wZW5UYXBSZW1vdmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UYXBSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRhcFJlbW92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1RyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9yZW1vdmVUcmFjaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUcmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRyYWNrID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX29wZW5UcmFja1JlbW92ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblRyYWNrUmVtb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5UcmFja1JlbW92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1N3aXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzLl9yZW1vdmVTd2lwZVRvZ2dsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTd2lwZVRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN3aXBlVG9nZ2xlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX29wZW5Td2lwZVJlbW92ZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3BlblN3aXBlUmVtb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5Td2lwZVJlbW92ZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb2cgd2hlbiB0aGUgdXNlciB0b3VjaGVzIHRoZSBEcmF3ZXJDb250cm9sbGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgdG91Y2ggZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3RvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoU3RhdGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoID0ge1xyXG4gICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgIHk6IGV2LmNsaWVudFlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSAkdG91Y2hlbmQgYW5kICR0cmFja2VuZCBldmVudCBoYW5kbGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgdG91Y2ggZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3RvdWNoRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBub1RvdWNoID0gdGhpcy5fdG91Y2hTdGF0ZSA9PT0gMCwgaGFzU3dpcGVkID0gdGhpcy5faGFzU3dpcGVkLCBoYXNUYXBwZWQgPSB0aGlzLl9oYXNUYXBwZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1N3aXBlZCA9IHRoaXMuX2hhc1RhcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgaWYgKGhhc1RhcHBlZCB8fCBub1RvdWNoIHx8IGhhc1N3aXBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZU1vdmVkID0gdGhpcy5faXNWZXJ0aWNhbCA/IGV2LmNsaWVudFkgLSB0aGlzLl9sYXN0VG91Y2gueSA6IGV2LmNsaWVudFggLSB0aGlzLl9sYXN0VG91Y2gueDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUmlnaHREaXJlY3Rpb24oZGlzdGFuY2VNb3ZlZCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9nZXRPZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgIGlmICghb2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoZGlzdGFuY2VNb3ZlZCkgPiBNYXRoLmNlaWwob2Zmc2V0IC8gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNFbGFzdGljKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VNb3ZlZCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faXNPcGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDbGlja0VhdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSAkdHJhY2sgZXZlbnQgaGFuZGxlci4gVXNlZCBmb3IgdHJhY2tpbmcgb25seSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHRyYWNraW5nIG1vdGlvbnNcclxuICAgICAgICAgKiBkZXBlbmRpbmcgb24gdGhlIGRlZmluZWQgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tpbmcgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3RyYWNrID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB0b3VjaFN0YXRlID0gdGhpcy5fdG91Y2hTdGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRvdWNoU3RhdGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0b3VjaFN0YXRlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOdWxsKHRoaXMuX2FuaW1hdGlvblRoZW5hYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvblRoZW5hYmxlLmNhbmNlbCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWRkQ2xpY2tFYXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMudXRpbHMuaXNOb2RlKF90aGlzLl9kcmF3ZXJFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RyYXdlckVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBfX3ByZXZlbnREZWZhdWx0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZENsaWNrRWF0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc05vZGUodGhpcy5fZHJhd2VyRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd2VyRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIF9fcHJldmVudERlZmF1bHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcm9vdEVsZW1lbnQuc3R5bGVbX3RoaXMuX3RyYW5zZm9ybV0gPSBfdGhpcy5fY2FsY3VsYXRlVHJhbnNsYXRpb24oZXYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0byBtYWtlIHN1cmUgdGhlIHVzZXIgaGFzIGJlZW4gdHJhY2tpbmcgaW4gdGhlIHJpZ2h0IGRpcmVjdGlvbiB0b1xyXG4gICAgICAgICAqIHRvZ2dsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VNb3ZlZCBUaGUgZGlzdGFuY2UgdGhlIHVzZXIncyBwb2ludGVyIGhhcyBtb3ZlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5faXNSaWdodERpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaXN0YW5jZU1vdmVkKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuID8gZGlzdGFuY2VNb3ZlZCA8IDAgOiBkaXN0YW5jZU1vdmVkID4gMDtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbiA/IGRpc3RhbmNlTW92ZWQgPiAwIDogZGlzdGFuY2VNb3ZlZCA8IDA7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgdHJhbnNsYXRpb24gdmFsdWUgZm9yIHNldHRpbmcgdGhlIHRyYW5zZm9ybSB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFja2luZyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX2dldE9mZnNldCgpLCBkaXN0YW5jZU1vdmVkO1xyXG4gICAgICAgICAgICBpZiAoIW9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZU1vdmVkID0gdGhpcy5fY2hlY2tFbGFzdGljaXR5KG9mZnNldCwgZXYuY2xpZW50WCAtIHRoaXMuX2xhc3RUb3VjaC54KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VNb3ZlZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArIGRpc3RhbmNlTW92ZWQgKyBcInB4LDAsMClcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZU1vdmVkID0gdGhpcy5fY2hlY2tFbGFzdGljaXR5KG9mZnNldCwgdGhpcy5fbGFzdFRvdWNoLnggLSBldi5jbGllbnRYKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VNb3ZlZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArICgtZGlzdGFuY2VNb3ZlZCkgKyBcInB4LDAsMClcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VNb3ZlZCA9IHRoaXMuX2NoZWNrRWxhc3RpY2l0eShvZmZzZXQsIGV2LmNsaWVudFkgLSB0aGlzLl9sYXN0VG91Y2gueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlTW92ZWQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidHJhbnNsYXRlM2QoMCxcIiArIGRpc3RhbmNlTW92ZWQgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlTW92ZWQgPSB0aGlzLl9jaGVja0VsYXN0aWNpdHkob2Zmc2V0LCB0aGlzLl9sYXN0VG91Y2gueSAtIGV2LmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZU1vdmVkID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKDAsXCIgKyAoLWRpc3RhbmNlTW92ZWQpICsgXCJweCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgZm9yIGVsYXN0aWNpdHkgYW5kIHBvdGVudGlhbGx5IHJlYWRqdXN0cyB0aGUgdXNlcidzXHJcbiAgICAgICAgICogZGlzdGFuY2UgbW92ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG1heE9mZnNldCBUaGUgbWF4aW11bSBkaXN0YW5jZSB0aGUgY29ycmVzcG9uZGluZyBEcmF3ZXIgY2FuIHRyYW5zbGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGEgVGhlIGRpc3RhbmNlIHRoZSB1c2VyJ3MgZmluZ2VyIG1vdmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9jaGVja0VsYXN0aWNpdHkgPSBmdW5jdGlvbiAobWF4T2Zmc2V0LCBkZWx0YSkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VNb3ZlZCA9IHRoaXMuX2lzT3BlbiA/IG1heE9mZnNldCArIGRlbHRhIDogZGVsdGE7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0VsYXN0aWMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkaXN0YW5jZU1vdmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZU1vdmVkIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VNb3ZlZCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2VNb3ZlZCA+IG1heE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VNb3ZlZCA9IG1heE9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2VNb3ZlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIGFuZCBkaXNwYXRjaGVzIHB1YiBzdWIgZXZlbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhpcyBEcmF3ZXJDb250cm9sbGVyIGlmIHVzZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiBvZiB0aGUgRHJhd2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9pbml0aWFsaXplRXZlbnRzID0gZnVuY3Rpb24gKGlkLCBwb3NpdGlvbikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXNlQ29udGV4dCA9IHRoaXMuX3VzZUNvbnRleHQsIGV2ZW50UmVtb3ZlciA9IHRoaXMub24oX19EcmF3ZXJGb3VuZEV2ZW50ICsgXCJfXCIgKyBpZCwgZnVuY3Rpb24gKGV2ZW50LCBkcmF3ZXJBcmcpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50UmVtb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHV0aWxzID0gX3RoaXMudXRpbHMsIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsIGlzVW5kZWZpbmVkID0gdXRpbHMuaXNVbmRlZmluZWQsIGRyYXdlciA9IChfdGhpcy5fZHJhd2VyID0gZHJhd2VyQXJnLmNvbnRyb2wpIHx8IHt9LCBkcmF3ZXJFbGVtZW50ID0gX3RoaXMuX2RyYXdlckVsZW1lbnQgPSBkcmF3ZXIuZWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNTdHJpbmcocG9zaXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGRyYXdlckFyZy5wb3NpdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBkcmF3ZXJBcmcucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKChcIlxcXCJwb3NpdGlvblxcXCIgaXMgaW5jb3JyZWN0bHkgZGVmaW5lZCBmb3IgYSBjb250cm9sIHN1Y2ggYXMgXFxcIlwiICsgX19EcmF3ZXIgKyBcIlxcXCIgXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcIm9yIFxcXCJcIiArIF90aGlzLnR5cGUgKyBcIi5cXFwiIFBsZWFzZSBlbnN1cmUgaXQgaXMgYSBzdHJpbmcuXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRyYXdlckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9jb250cm9sbGVySXNWYWxpZChwb3NpdGlvbi50b0xvd2VyQ2FzZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKF90aGlzLl9pc0VsYXN0aWMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzRWxhc3RpYyA9IGRyYXdlckFyZy5lbGFzdGljID09PSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFkcmF3ZXJBcmcucmVjZWl2ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaEV2ZW50KF9fRHJhd2VyQ29udHJvbGxlckZldGNoRXZlbnQgKyBcIl9cIiArIGlkLCBwbGF0LmV2ZW50cy5FdmVudE1hbmFnZXIuRElSRUNULCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2w6IF90aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VDb250ZXh0OiB1c2VDb250ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZHJhd2VyQXJnLnN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2lzT3BlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZHJhd2VyQXJnLm5leHRTdGF0ZSAmJiB1dGlscy5pc051bGwoX3RoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9wcmVJbml0aWFsaXplZFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHJhd2VyQXJnLm5leHRTdGF0ZSAmJiB1dGlscy5pc051bGwoX3RoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3ByZUluaXRpYWxpemVkVmFsdWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NoZWNrUHJlSW5pdCgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGlmICghdXNlQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9kZXRlcm1pbmVUZW1wbGF0ZShkcmF3ZXJBcmcudGVtcGxhdGUpLnRoZW4oZmluaXNoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChfX0RyYXdlckNvbnRyb2xsZXJGZXRjaEV2ZW50ICsgXCJfXCIgKyBpZCwgcGxhdC5ldmVudHMuRXZlbnRNYW5hZ2VyLkRJUkVDVCwge1xyXG4gICAgICAgICAgICAgICAgY29udHJvbDogdGhpcyxcclxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIHVzZUNvbnRleHQ6IHVzZUNvbnRleHRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdGhlIHByZS1pbml0aWFsaXplZCB2YWx1ZSBhbmQgaGFuZGxlcyBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fY2hlY2tQcmVJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9wcmVJbml0aWFsaXplZFZhbHVlLCB1dGlscyA9IHRoaXMudXRpbHMsIGlzTnVsbCA9IHV0aWxzLmlzTnVsbDtcclxuICAgICAgICAgICAgaWYgKGlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNPcGVuID0gdGhpcy5faXNPcGVuO1xyXG4gICAgICAgICAgICBpZiAoaXNPcGVuICYmIHZhbHVlIHx8ICEoaXNPcGVuIHx8IHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RvZ2dsZURlbGF5KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG9nZ2xlRGVsYXkgPSB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fb3Blbi5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG9nZ2xlRGVsYXkgPSB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMuX2Nsb3NlKCkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pLCBkcmF3ZXIgPSB0aGlzLl9kcmF3ZXI7XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKGRyYXdlcikpIHtcclxuICAgICAgICAgICAgICAgIGRyYXdlci5yZWFkeSA9IHByb21pc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHByb3BlciBIVE1MIHRlbXBsYXRlLCBiaW5kcyBpdCwgYW5kIGluc2VydHMgaXQgaWYgbmVlZGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Tm9kZX0gZnJhZ21lbnQ/IEEgTm9kZSB0byBpbnNlcnQgYXMgdGhlIERyYXdlcidzIEhUTUwgdGVtcGxhdGVcclxuICAgICAgICAgKiBpZiBubyB0ZW1wbGF0ZVVybCBpcyBwcmVzZW50IG9uIHRoaXMgRHJhd2VyQ29udHJvbGxlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fZGV0ZXJtaW5lVGVtcGxhdGUgPSBmdW5jdGlvbiAoZnJhZ21lbnQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHRoaXMuX3RlbXBsYXRlVXJsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYXQudWkuVGVtcGxhdGVDb250cm9sLmRldGVybWluZVRlbXBsYXRlKHRoaXMsIHRoaXMuX3RlbXBsYXRlVXJsKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iaW5kVGVtcGxhdGUoJ2RyYXdlcicsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxzLmlzTm9kZShmcmFnbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmRUZW1wbGF0ZSgnZHJhd2VyJywgZnJhZ21lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9idGFpbnMgdGhlIGN1cnJlbnQgYnJvd3NlcidzIHRyYW5zZm9ybSBwcm9wZXJ0eSB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9yb290RWxlbWVudC5zdHlsZSwgaXNVbmRlZmluZWQgPSB0aGlzLnV0aWxzLmlzVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YXIgdmVuZG9yUHJlZml4ID0gdGhpcy5fY29tcGF0LnZlbmRvclByZWZpeDtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9wcmVUcmFuc2Zvcm0gPSBzdHlsZVsodmVuZG9yUHJlZml4Lmxvd2VyQ2FzZSArIFwiVHJhbnNmb3JtXCIpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHZlbmRvclByZWZpeC5sb3dlckNhc2UgKyBcIlRyYW5zZm9ybVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9wcmVUcmFuc2Zvcm0gPSBzdHlsZVsodmVuZG9yUHJlZml4LnVwcGVyQ2FzZSArIFwiVHJhbnNmb3JtXCIpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHZlbmRvclByZWZpeC51cHBlckNhc2UgKyBcIlRyYW5zZm9ybVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gJ3RyYW5zZm9ybSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyBpZiB0aGlzIGNvbnRyb2wgaGFzIGFsbCB2YWxpZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gb2YgdGhlIERyYXdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fY29udHJvbGxlcklzVmFsaWQgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgaXNOdWxsID0gdXRpbHMuaXNOdWxsO1xyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuX2RyYXdlckVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJDb3VsZCBub3QgZmluZCBhIGNvcnJlc3BvbmRpbmcgY29udHJvbCBzdWNoIGFzIFxcXCJcIiArIF9fRHJhd2VyICsgXCJcXFwiIGZvciB0aGlzIFxcXCJcIiArIHRoaXMudHlwZSArIFwiLlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJJbmNvcnJlY3QgcG9zaXRpb246IFxcXCJcIiArIHBvc2l0aW9uICsgXCJcXFwiIGRlZmluZWQgZm9yIHRoZSBhIGNvbnRyb2wgc3VjaCBhcyBhIFxcXCJcIiArIF9fRHJhd2VyICsgXCJcXFwiLCBvciBcXFwiXCIgKyB0aGlzLnR5cGUgKyBcIi5cXFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCA9IHRoaXMuX2dldFJvb3RFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwocm9vdEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJDYW5ub3QgaGF2ZSBhIFxcXCJcIiArIHRoaXMudHlwZSArIFwiXFxcIiBpbiBhIGhpZXJhcmNoeSBhYm92ZSB0aGUgY29ycmVzcG9uZGluZyBjb250cm9sIHN1Y2ggYXMgXFxcIlwiICsgX19EcmF3ZXIgKyBcIi5cXFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbTtcclxuICAgICAgICAgICAgZG9tLmFkZENsYXNzKHJvb3RFbGVtZW50LCBfX0RyYXdlciArIFwiLXJvb3RcIik7XHJcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsICh0aGlzLl9pc1ZlcnRpY2FsID8gX19QbGF0ICsgXCJ2ZXJ0aWNhbFwiIDogX19QbGF0ICsgXCJob3Jpem9udGFsXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uYWxUcmFuc2l0aW9uUHJlcCA9IF9fRHJhd2VyICsgXCItdHJhbnNpdGlvbi1cIiArIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9jbGlja0VhdGVyID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsaWNrRWF0ZXIuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJjbGlja2VhdGVyXCI7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlUm9vdEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnRhaW5zIHRoZSByb290IGVsZW1lbnQgdG8gdHJhbnNsYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIucHJvdG90eXBlLl9nZXRSb290RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRyYXdlciA9IHRoaXMuX2RyYXdlciwgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVsbChkcmF3ZXIuc3RvcmVkUHJvcGVydGllcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkcmF3ZXIuc3RvcmVkUHJvcGVydGllcy5yb290RWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXNOb2RlID0gdXRpbHMuaXNOb2RlLCByb290ID0gdGhpcy5yb290LCBlbGVtZW50ID0gdXRpbHMuaXNPYmplY3Qocm9vdCkgJiYgaXNOb2RlKHJvb3QuZWxlbWVudCkgPyByb290LmVsZW1lbnQgOiB0aGlzLmVsZW1lbnQsIGRyYXdlckVsID0gdGhpcy5fZHJhd2VyRWxlbWVudCwgcGFyZW50O1xyXG4gICAgICAgICAgICB3aGlsZSAoaXNOb2RlKHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCkgJiYgIXBhcmVudC5jb250YWlucyhkcmF3ZXJFbCkpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIHJvb3QgZWxlbWVudCBzdHlsaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX3N0eWxlUm9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfd2luZG93ID0gdGhpcy5fd2luZG93LCB1dGlscyA9IHRoaXMudXRpbHMsIGRyYXdlciA9IHRoaXMuX2RyYXdlciwgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCwgcGFyZW50ID0gcm9vdEVsZW1lbnQucGFyZW50RWxlbWVudCwgY29tcHV0ZWRTdHlsZSA9IF93aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyb290RWxlbWVudCksIHN0eWxlID0gcm9vdEVsZW1lbnQuc3R5bGUsIHBvc2l0aW9uID0gY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiwgekluZGV4ID0gTnVtYmVyKGNvbXB1dGVkU3R5bGUuekluZGV4KSwgcm9vdEVsZW1lbnRTdHlsZSA9IHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50OiByb290RWxlbWVudFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XHJcbiAgICAgICAgICAgICAgICByb290RWxlbWVudFN0eWxlLnBvc2l0aW9uID0gc3R5bGUucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc051bWJlcih6SW5kZXgpIHx8IHpJbmRleCA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHJvb3RFbGVtZW50U3R5bGUuekluZGV4ID0gc3R5bGUuekluZGV4O1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuekluZGV4ID0gJzEnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc05vZGUocGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkUGFyZW50U3R5bGUgPSBfd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KSwgb3ZlcmZsb3cgPSBjb21wdXRlZFBhcmVudFN0eWxlLm92ZXJmbG93O1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJmbG93ICE9PSAnaGlkZGVuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZERpcmVjdGlvbmFsT3ZlcmZsb3cgPSB2b2lkIDAsIGtleSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnb3ZlcmZsb3dZJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREaXJlY3Rpb25hbE92ZXJmbG93ID0gY29tcHV0ZWRQYXJlbnRTdHlsZS5vdmVyZmxvd1k7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSAnb3ZlcmZsb3dYJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWREaXJlY3Rpb25hbE92ZXJmbG93ID0gY29tcHV0ZWRQYXJlbnRTdHlsZS5vdmVyZmxvd1g7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wdXRlZERpcmVjdGlvbmFsT3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdHlsZSA9IHBhcmVudC5zdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVsZW1lbnRTdHlsZS5wYXJlbnRPdmVyZmxvdyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcmVudFN0eWxlW2tleV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50U3R5bGVba2V5XSA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkcmF3ZXIuc3RvcmVkUHJvcGVydGllcyA9IHJvb3RFbGVtZW50U3R5bGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbmluaXRpYWxpemVzIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRHJhd2VyQ29udHJvbGxlci5wcm90b3R5cGUuX2NsZWFuUm9vdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGlzT2JqZWN0ID0gdXRpbHMuaXNPYmplY3QsIGlzTm9kZSA9IHV0aWxzLmlzTm9kZSwgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudCwgZHJhd2VyID0gdGhpcy5fZHJhd2VyO1xyXG4gICAgICAgICAgICBpZiAoIWlzTm9kZShyb290RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRvbS5yZW1vdmVDbGFzcyhyb290RWxlbWVudCwgX19EcmF3ZXIgKyBcIi1yb290IFwiICsgdGhpcy5fZGlyZWN0aW9uYWxUcmFuc2l0aW9uUHJlcCk7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc051bGwoZHJhd2VyKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzdG9yZWRTdHlsZSA9IGRyYXdlci5zdG9yZWRQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICBpZiAoIWlzT2JqZWN0KHN0b3JlZFN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb290RWxlbWVudFN0eWxlID0gcm9vdEVsZW1lbnQuc3R5bGUsIHBhcmVudCA9IHJvb3RFbGVtZW50LnBhcmVudEVsZW1lbnQsIG92ZXJmbG93ID0gc3RvcmVkU3R5bGUucGFyZW50T3ZlcmZsb3c7XHJcbiAgICAgICAgICAgIHJvb3RFbGVtZW50U3R5bGUucG9zaXRpb24gPSBzdG9yZWRTdHlsZS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgcm9vdEVsZW1lbnRTdHlsZS56SW5kZXggPSBzdG9yZWRTdHlsZS56SW5kZXg7XHJcbiAgICAgICAgICAgIGlmIChpc09iamVjdChvdmVyZmxvdykgJiYgaXNOb2RlKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5zdHlsZVtvdmVyZmxvdy5rZXldID0gb3ZlcmZsb3cudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsZXRlIGRyYXdlci5zdG9yZWRQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3ZXJFbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIG1heCBvZmZzZXQgdG8gdHJhbnNsYXRlIHRoZSBjb3JyZXNwb25kaW5nIERyYXdlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBEcmF3ZXJDb250cm9sbGVyLnByb3RvdHlwZS5fZ2V0T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNWZXJ0aWNhbCA/IHRoaXMuX2RyYXdlckVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogdGhpcy5fZHJhd2VyRWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIERyYXdlckNvbnRyb2xsZXIuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgIF9hbmltYXRvcjogX19BbmltYXRvcixcclxuICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIERyYXdlckNvbnRyb2xsZXI7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5EcmF3ZXJDb250cm9sbGVyID0gRHJhd2VyQ29udHJvbGxlcjtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX0RyYXdlckNvbnRyb2xsZXIsIERyYXdlckNvbnRyb2xsZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBCaW5kQ29udHJvbCBmb3Igc2hvd2luZyBhIHRlbXBsYXRlZCBhbmQgYW5pbWF0ZWQgb3ZlcmxheS5cclxuICAgICAqL1xyXG4gICAgdmFyIE1vZGFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgICAgICBfX2V4dGVuZHMoTW9kYWwsIF9zdXBlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbnN0cnVjdG9yIGZvciBhIE1vZGFsLiBDcmVhdGVzIHRoZSBtb2RhbExvYWRlZCBQcm9taXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIE1vZGFsKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9IHRoaXMuX190ZW1wbGF0ZVN0cmluZztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb2RhbCBpcyBjdXJyZW50bHkgdmlzaWJsZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiB0byBzdG9wIGxpc3RlbmluZyB0byBzY3JvbGwgZXZlbnRzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUmVtb3ZlciA9IG5vb3A7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIHN0b3AgbGlzdGVuaW5nIGZvciBET00gcHJlc2VuY2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVzZW5jZVJlbW92ZXIgPSBub29wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBtb2RhbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGhhc2ggZm9yIHZhbGlkYXRpbmcgYXZhaWxhYmxlIHRyYW5zaXRpb25zLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkhhc2ggPSB7XHJcbiAgICAgICAgICAgICAgICB1cDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRvd246IHRydWUsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmYWRlOiB0cnVlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgcHJpdmF0ZSB0ZW1wbGF0ZSBzdHJpbmcgdXNlZCB0byBjaGVjayBmb3IgYSB0ZW1wbGF0ZSBvdmVyd3JpdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9fdGVtcGxhdGVTdHJpbmcgPSAnPGRpdiBjbGFzcz1cInBsYXQtbW9kYWwtY29udGFpbmVyXCI+PC9kaXY+XFxuJztcclxuICAgICAgICAgICAgdGhpcy5tb2RhbExvYWRlZCA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9fcmVqZWN0Rm4gPSByZWplY3Q7XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19Nb2RhbCArIFwiIFwiICsgX19IaWRlICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayBmb3IgdGVtcGxhdGVVcmwgYW5kIHNldCBpZiBuZWVkZWQgdGhlbiBoaWRlIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uT2JqID0gdGhpcy5vcHRpb25zIHx8ICh0aGlzLm9wdGlvbnMgPSB7fSksIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwgKG9wdGlvbk9iai52YWx1ZSA9IHt9KTtcclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVVybCA9IG9wdGlvbnMudGVtcGxhdGVVcmwgfHwgdGhpcy50ZW1wbGF0ZVVybDtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGQgdGhlIGlubmVyVGVtcGxhdGUgdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcGxhdGVTdHJpbmcgIT09IHRoaXMuX190ZW1wbGF0ZVN0cmluZyB8fCB0aGlzLnV0aWxzLmlzU3RyaW5nKHRoaXMudGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9tID0gdGhpcy5kb20sIGZyYWdtZW50ID0gZG9tLnNlcmlhbGl6ZUh0bWwodGhpcy5fX3RlbXBsYXRlU3RyaW5nKSwgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgbW9kYWxDb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBmcmFnbWVudC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lclRlbXBsYXRlID0gZG9tLmFwcGVuZENoaWxkcmVuKGVsZW1lbnQuY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgZm9yIGEgdHJhbnNpdGlvbiBhbmQgaW5pdGlhbGl6ZSBpdCBpZiBuZWNlc3NhcnkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLmxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudmFsdWUsIHRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb24sIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIC8vIGluIGNhc2Ugb2YgY2xvbmluZyBcclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyIHx8IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXNlbmNlUmVtb3ZlciA9IHRoaXMuZG9tLndoZW5QcmVzZW50KHRoaXMuX2luamVjdEVsZW1lbnQuYmluZCh0aGlzKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc1N0cmluZyh0cmFuc2l0aW9uKSB8fCB0cmFuc2l0aW9uID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgX19QbGF0ICsgXCJuby10cmFuc2l0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLl90cmFuc2l0aW9uSGFzaFt0cmFuc2l0aW9uXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiQ3VzdG9tIHRyYW5zaXRpb246IFxcXCJcIiArIHRyYW5zaXRpb24gKyBcIlxcXCIgZGVmaW5lZCBmb3IgXFxcIlwiICsgdGhpcy50eXBlICsgXCIuXFxcIiBQbGVhc2UgZW5zdXJlIHRoZSB0cmFuc2l0aW9uIGlzIGRlZmluZWQgdG8gYXZvaWQgZXJyb3JzLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uRXZlbnRzID0gdGhpcy5fY29tcGF0LmFuaW1hdGlvbkV2ZW50cztcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGFuaW1hdGlvbkV2ZW50cykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZygnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgQ1NTMyBhbmltYXRpb25zLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCBfX1BsYXQgKyBcIm5vLXRyYW5zaXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbkVuZCA9IGFuaW1hdGlvbkV2ZW50cy4kdHJhbnNpdGlvbkVuZDtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAoX19QbGF0ICsgdHJhbnNpdGlvbikgKyBcIiBcIiArIF9fUGxhdCArIFwibW9kYWwtdHJhbnNpdGlvblwiKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFuIHVwIHRoZSBhdXRvIHNjcm9sbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFJlbW92ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJlc2VuY2VSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzRnVuY3Rpb24odGhpcy5fX3JlamVjdEZuKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3JlamVjdEZuKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fcmVqZWN0Rm4gPSB0aGlzLl9fcmVzb2x2ZUZuID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvd3MgdGhlIE1vZGFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gIXRoaXMuX2lzVmlzaWJsZSwgcHJvbWlzZSA9IHRoaXMuX3Nob3coKTtcclxuICAgICAgICAgICAgaWYgKHdhc0hpZGRlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIaWRlcyB0aGUgTW9kYWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB3YXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGUsIHByb21pc2UgPSB0aGlzLl9oaWRlKCk7XHJcbiAgICAgICAgICAgIGlmICh3YXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBNb2RhbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvdygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIE1vZGFsIGlzIGN1cnJlbnRseSB2aXNpYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5pc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1Zpc2libGU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHByb3BlcnR5IGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbW9kYWxTdGF0ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBjb250cm9sIHN0YXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgY29udHJvbCBzdGF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3ZvaWR9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChtb2RhbFN0YXRlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUgJiYgdXRpbHMuaXNOdWxsKG1vZGFsU3RhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCh0aGlzLl9pc1Zpc2libGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0Jvb2xlYW4obW9kYWxTdGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtb2RhbFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Nob3coKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkF0dGVtcHRpbmcgdG8gc2hvdyBvciBoaWRlIGEgXCIgKyB0aGlzLnR5cGUgKyBcIiB3aXRoIGEgYm91bmQgdmFsdWUgdGhhdCBpcyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGJvb2xlYW4uXCIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvd3MgdGhlIE1vZGFsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5fc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tLCB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdWxsKHRoaXMuaW5uZXJUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9iaW5kSW5uZXJUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYWxpZ25Nb2RhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5lbGVtZW50LCBfX0hpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLmRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhfdGhpcy5fY29udGFpbmVyLCBfX1BsYXQgKyBcImFjdGl2YXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9LCAyMCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGlnbnMgdGhlIGNvbnRyb2wgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZXY/IFRoZSBzY3JvbGwgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5fYWxpZ25Nb2RhbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc051bGwgPSB1dGlscy5pc051bGwsIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBkb2N1bWVudEVsID0gX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgc2Nyb2xsRWwgPSBpc051bGwoZG9jdW1lbnRFbCkgfHwgIWRvY3VtZW50RWwuc2Nyb2xsVG9wID8gX2RvY3VtZW50LmJvZHkgOiBkb2N1bWVudEVsLCBzY3JvbGxUb3AgPSBzY3JvbGxFbC5zY3JvbGxUb3A7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9zY3JvbGxUb3AgPT09IHNjcm9sbFRvcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOdWxsKGV2KSkge1xyXG4gICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IHNjcm9sbFRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IHNjcm9sbFRvcCArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFJlbW92ZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fd2luZG93LCAnc2Nyb2xsJywgdGhpcy5fYWxpZ25Nb2RhbCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRvcCA9IHNjcm9sbFRvcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhpZGVzIHRoZSBNb2RhbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUuX2hpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBkb20gPSB0aGlzLmRvbSwgdXRpbHMgPSB0aGlzLnV0aWxzLCBwcm9taXNlO1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxSZW1vdmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFJlbW92ZXIgPSBub29wO1xyXG4gICAgICAgICAgICB0aGlzLl9pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHRoaXMuX3RyYW5zaXRpb25FbmQpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gdGhpcy5fYWRkSGlkZU9uVHJhbnNpdGlvbkVuZCgpO1xyXG4gICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoX3RoaXMuX2NvbnRhaW5lciwgX19QbGF0ICsgXCJhY3RpdmF0ZVwiKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKF90aGlzLmVsZW1lbnQsIF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhfdGhpcy5fY29udGFpbmVyLCBfX1BsYXQgKyBcImFjdGl2YXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgdGhlIGlubmVyVGVtcGxhdGUgdG8gQmluZGFibGVUZW1wbGF0ZXMsIGJpbmRzIGl0LFxyXG4gICAgICAgICAqIGFuZCBhZGRzIGl0IHRvIHRoZSBET00uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTW9kYWwucHJvdG90eXBlLl9iaW5kSW5uZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIGlubmVyVGVtcGxhdGUgPSB0aGlzLmlubmVyVGVtcGxhdGUsIGJpbmRhYmxlVGVtcGxhdGVzID0gdGhpcy5iaW5kYWJsZVRlbXBsYXRlcywgbW9kYWwgPSAnbW9kYWwnO1xyXG4gICAgICAgICAgICBiaW5kYWJsZVRlbXBsYXRlcy5hZGQobW9kYWwsIGlubmVyVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyVGVtcGxhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gYmluZGFibGVUZW1wbGF0ZXMuYmluZChtb2RhbCkudGhlbihmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRlbXBsYXRlLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51dGlscy5pc0Z1bmN0aW9uKF90aGlzLl9fcmVzb2x2ZUZuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4gPSBfdGhpcy5fX3JlamVjdEZuID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hvdygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgaXRzZWxmIGZyb20gdGhlIERPTSBhbmQgaW5zZXJ0cyBpdHNlbGYgaW50byB0aGUgYm9keSB0byB3b3JrIHdpdGhcclxuICAgICAgICAgKiBhYnNvbHV0ZSBwb3NpdGlvbmluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNb2RhbC5wcm90b3R5cGUuX2luamVjdEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBwYXJlbnRFbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50LCBib2R5ID0gdGhpcy5fZG9jdW1lbnQuYm9keTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzTm9kZShwYXJlbnRFbGVtZW50KSB8fCBwYXJlbnRFbGVtZW50ID09PSBib2R5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgbnVsbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0ZW5zIGZvciB0aGUgdHJhbnNpdGlvbiB0byBlbmQgYW5kIGhpZGVzIHRoZSBlbGVtZW50IGFmdGVyIGl0IGlzIGZpbmlzaGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE1vZGFsLnByb3RvdHlwZS5fYWRkSGlkZU9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IF90aGlzLmVsZW1lbnQsIHJlbW92ZSA9IF90aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgX3RoaXMuX3RyYW5zaXRpb25FbmQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCwgX19IaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTW9kYWwuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX3dpbmRvdzogX19XaW5kb3csXHJcbiAgICAgICAgICAgIF9kb2N1bWVudDogX19Eb2N1bWVudCxcclxuICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgIF9Qcm9taXNlOiBfX1Byb21pc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBNb2RhbDtcclxuICAgIH0ocGxhdC51aS5CaW5kQ29udHJvbCkpO1xyXG4gICAgcGxhdHVpLk1vZGFsID0gTW9kYWw7XHJcbiAgICBwbGF0LnJlZ2lzdGVyLmNvbnRyb2woX19Nb2RhbCwgTW9kYWwpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBCaW5kQ29udHJvbCB0aGF0IHN0YW5kYXJkaXplcyBhbiBIVE1MNSBpbnB1dFt0eXBlPVwicmFuZ2VcIl0uXHJcbiAgICAgKi9cclxuICAgIHZhciBTbGlkZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhTbGlkZXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU2xpZGVyKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1zbGlkZXItY29udGFpbmVyXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJwbGF0LXNsaWRlci10cmFja1wiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICAgICAgPGRpdiBjbGFzcz1cInBsYXQta25vYlwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgY29udHJvbCBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQga25vYiBvZmZzZXQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9rbm9iT2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGVudW0gZGVub3RpbmcgdGhlIGN1cnJlbnQgdG91Y2ggc3RhdGUgb2YgdGhlIHVzZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHN0b3AgbGlzdGVuaW5nIGZvciB2aXNpYmlsaXR5IGlmIGFwcGxpY2FibGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fU2xpZGVyICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHByb3BlciBjbGFzc2VzIGZvciB0aGUgY29udHJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBidXR0b24gdHlwZSBhbmQgYXBwbHkgdGhlIHByb3BlciBjbGFzc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgc2xpZGVyID0gdGhpcy5fc2xpZGVyID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZCwgaXNOdW1iZXIgPSB0aGlzLnV0aWxzLmlzTnVtYmVyLCBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIG9wdGlvblZhbHVlID0gTnVtYmVyKG9wdGlvbnMudmFsdWUpLCBvcHRpb25NaW4gPSBvcHRpb25zLm1pbiwgb3B0aW9uTWF4ID0gb3B0aW9ucy5tYXgsIHN0ZXAgPSBvcHRpb25zLnN0ZXAsIHJldmVyc2VkID0gdGhpcy5fcmV2ZXJzZWQgPSAob3B0aW9ucy5yZXZlcnNlID09PSB0cnVlKSwgbWluID0gdGhpcy5taW4gPSBpc051bWJlcihvcHRpb25NaW4pID8gTWF0aC5mbG9vcihvcHRpb25NaW4pIDogMCwgbWF4ID0gdGhpcy5tYXggPSBpc051bWJlcihvcHRpb25NYXgpID8gTWF0aC5jZWlsKG9wdGlvbk1heCkgOiAxMDAsIHZhbHVlID0gaXNOdW1iZXIob3B0aW9uVmFsdWUpID8gTWF0aC5yb3VuZChvcHRpb25WYWx1ZSkgOiBtaW4sIGNsYXNzTmFtZSA9IF9fUGxhdCArIHRoaXMuX3ZhbGlkYXRlT3JpZW50YXRpb24ob3B0aW9ucy5vcmllbnRhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2tub2IgPSBzbGlkZXIuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lICs9IF9fUmV2ZXJzZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgLy8gcmVzZXQgdmFsdWUgdG8gbWluaW11bSBpbiBjYXNlIEJpbmQgc2V0IGl0IHRvIGEgdmFsdWUgXHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBtaW47XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSBpc051bWJlcihzdGVwKSA/IChzdGVwID4gMCA/IE1hdGgucm91bmQoc3RlcCkgOiAxKSA6IDE7XHJcbiAgICAgICAgICAgIGlmIChtaW4gPj0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcXFwiXCIgKyB0aGlzLnR5cGUgKyBcIidzXFxcIiBtaW4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGl0cyBtYXguIFNldHRpbmcgbWF4IHRvIG1pbiArIDEuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXggPSBtaW4gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldExlbmd0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplRXZlbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgdmlzaWJpbGl0eSBsaXN0ZW5lciBpZiBhcHBsaWNhYmxlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9zbGlkZXJWaXNpYmxlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIFNsaWRlci4gSWYgYW4gaW52YWxpZCB2YWx1ZSBpcyBwYXNzZWQgaW5cclxuICAgICAgICAgKiBub3RoaW5nIHdpbGwgaGFwcGVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBTbGlkZXIgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZSh2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLm9ic2VydmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGJpbmRlcikge1xyXG4gICAgICAgICAgICBiaW5kZXIub2JzZXJ2ZVByb3BlcnR5KHRoaXMuX3NldEJvdW5kUHJvcGVydHkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSB2YWx1ZSBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgYmluZGFibGUgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSB7dm9pZH0gaWRlbnRpZmllciBUaGUgY2hpbGQgaWRlbnRpZmllciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gYmluZCB0aGUgcHJvcGVydHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRWYWx1ZShuZXdWYWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFNsaWRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3BlcnR5Q2hhbmdlZCBXaGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGZpcmUgYSBwcm9wZXJ0eUNoYW5nZWQgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIHByb3BlcnR5Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiQ2Fubm90IHNldCB0aGUgdmFsdWUgb2YgXCIgKyB0aGlzLnR5cGUgKyBcIiB3aGlsZSB0aGUgdXNlciBpcyBtYW5pcHVsYXRpbmcgaXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxzLmlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNOdW1iZXIodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyVmFsID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihudW1iZXJWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudW1iZXJWYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMudHlwZSArIFwiIGhhcyBpdHMgdmFsdWUgYm91bmQgdG8gYSBwcm9wZXJ0eSB0aGF0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhIE51bWJlci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUHJvcGVydHkodmFsdWUsIHRydWUsIHByb3BlcnR5Q2hhbmdlZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBwcm9wZXIgdHJhY2tpbmcgZXZlbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX2luaXRpYWxpemVFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB0cmFja0ZuID0gdGhpcy5fdHJhY2ssIHRvdWNoRW5kID0gdGhpcy5fdG91Y2hFbmQsIHRyYWNrLCByZXZlcnNlVHJhY2s7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayA9IF9fJHRyYWNrICsgXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwidXBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gX18kdHJhY2sgKyBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfXyR0b3VjaHN0YXJ0LCB0aGlzLl90b3VjaFN0YXJ0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0cmFjaywgdHJhY2tGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgcmV2ZXJzZVRyYWNrLCB0cmFja0ZuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBfXyR0b3VjaGVuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGVsZW1lbnQsIF9fJHRyYWNrZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fd2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51dGlscy5pc051bGwoX3RoaXMuX3NsaWRlclZpc2libGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldEtub2IoKTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTG9nIHRoZSBmaXJzdCB0b3VjaC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlIHRvdWNoIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl90b3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaCA9IHtcclxuICAgICAgICAgICAgICAgIHg6IGV2LmNsaWVudFgsXHJcbiAgICAgICAgICAgICAgICB5OiBldi5jbGllbnRZLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdGhpcy5fa25vYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9yZXZlcnNlZCA/IGV2Lm9mZnNldFkgLSB0aGlzLl9zbGlkZXJPZmZzZXQgOiB0aGlzLl9tYXhPZmZzZXQgLSAoZXYub2Zmc2V0WSAtIHRoaXMuX3NsaWRlck9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IHRoaXMuX3NsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3JldmVyc2VkID8gZXYub2Zmc2V0WSA6IHRoaXMuX2tub2JPZmZzZXQgLSBldi5vZmZzZXRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZWQgPyBldi5vZmZzZXRZIDogdGhpcy5fbWF4T2Zmc2V0IC0gZXYub2Zmc2V0WTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3JldmVyc2VkID8gdGhpcy5fbWF4T2Zmc2V0IC0gKGV2Lm9mZnNldFggLSB0aGlzLl9zbGlkZXJPZmZzZXQpIDogZXYub2Zmc2V0WCAtIHRoaXMuX3NsaWRlck9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldCA9PT0gdGhpcy5fc2xpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fcmV2ZXJzZWQgPyB0aGlzLl9rbm9iT2Zmc2V0IC0gZXYub2Zmc2V0WCA6IGV2Lm9mZnNldFg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLl9yZXZlcnNlZCA/IHRoaXMuX21heE9mZnNldCAtIGV2Lm9mZnNldFggOiBldi5vZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rbm9iT2Zmc2V0ID0gX3RoaXMuX3NldFNsaWRlclByb3BlcnRpZXMob2Zmc2V0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIG5ldyBzbGlkZXIgb2Zmc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl90b3VjaEVuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDI7XHJcbiAgICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSB0aGlzLl9jYWxjdWxhdGVPZmZzZXQoZXYpLCBtYXhPZmZzZXQgPSB0aGlzLl9tYXhPZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fbGFzdFRvdWNoLnZhbHVlICE9PSBfdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2tub2JPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld09mZnNldCA+IG1heE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9rbm9iT2Zmc2V0ID0gbWF4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9rbm9iT2Zmc2V0ID0gbmV3T2Zmc2V0O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrIHRoZSBrbm9iIG1vdmVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl90cmFjayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRTbGlkZXJQcm9wZXJ0aWVzKF90aGlzLl9jYWxjdWxhdGVPZmZzZXQoZXYpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIFNsaWRlcidzIGtub2IgcG9zaXRpb24gYW5kIGNvcnJlc3BvbmRpbmcgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB2YWx1ZSB0byBzZXQgdGhlIGtub2IgdG8gcHJpb3IgdG9cclxuICAgICAgICAgKiBub3JtYWxpemF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3NldFNsaWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIG1heE9mZnNldCA9IHRoaXMuX21heE9mZnNldCwgdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWluO1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0gdGhpcy52YWx1ZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBvc2l0aW9uID49IG1heE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1heDtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gbWF4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0gdGhpcy52YWx1ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLl9jYWxjdWxhdGVWYWx1ZShwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQcm9wZXJ0eSh2YWx1ZSwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9zbGlkZXIuc3R5bGVbdGhpcy5fbGVuZ3RoUHJvcGVydHldID0gcG9zaXRpb24gKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgdmFsdWUgYmFzZWQgb24ga25vYiBwb3NpdGlvbiBhbmQgc2xpZGVyIHdpZHRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgc2xpZGVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZVZhbHVlID0gZnVuY3Rpb24gKHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdGVwID0gdGhpcy5fc3RlcDtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1pbiArIE1hdGgucm91bmQod2lkdGggLyB0aGlzLl9pbmNyZW1lbnQgLyBzdGVwKSAqIHN0ZXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlcyBrbm9iIHBvc2l0aW9uIGJhc2VkIG9uIGN1cnJlbnQgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSB7bGluayBwbGF0dWkuU2xpZGVyfFNsaWRlcn0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fY2FsY3VsYXRlS25vYlBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiB0aGlzLl9pbmNyZW1lbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBuZXcgb2Zmc2V0IG9mIHRoZSBzbGlkZXIgYmFzZWQgb24gdGhlIG9sZCBvZmZzZXQgYW5kIHRoZSBkaXN0YW5jZSBtb3ZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFjayBvciAkdHJhY2tlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX2NhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VkID9cclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fa25vYk9mZnNldCArIGV2LmNsaWVudFkgLSB0aGlzLl9sYXN0VG91Y2gueSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLl9rbm9iT2Zmc2V0ICsgdGhpcy5fbGFzdFRvdWNoLnkgLSBldi5jbGllbnRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXZlcnNlZCA/XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX2tub2JPZmZzZXQgKyB0aGlzLl9sYXN0VG91Y2gueCAtIGV2LmNsaWVudFgpIDpcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fa25vYk9mZnNldCArIGV2LmNsaWVudFggLSB0aGlzLl9sYXN0VG91Y2gueCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHByb3BlcnR5IHRvIHVzZSBmb3IgbGVuZ3RoIGFuZCBzZXRzIHRoZSBtYXggbGVuZ3RoIG9mIHRoZSBzbGlkZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aFByb3BlcnR5ID0gJ2hlaWdodCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhPZmZzZXQgPSBlbC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zbGlkZXJPZmZzZXQgPSBlbC5vZmZzZXRUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZW5ndGhQcm9wZXJ0eSA9ICd3aWR0aCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhPZmZzZXQgPSBlbC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWRlck9mZnNldCA9IGVsLm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tYXhPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWRlclZpc2libGUgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIgPSBfdGhpcy5kb20ud2hlblZpc2libGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2xpZGVyVmlzaWJsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGVsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEluY3JlbWVudCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgaW5jcmVtZW50IGZvciBzbGlkaW5nIHRoZSB7bGluayBwbGF0dWkuU2xpZGVyfFNsaWRlcn0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0SW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2luY3JlbWVudCA9IHRoaXMuX21heE9mZnNldCAvICh0aGlzLm1heCAtIHRoaXMubWluKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgU2xpZGVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIHRvIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNldEtub2IgV2hldGhlciBvciBub3Qgd2UgbmVlZCB0byBzZXQgdGhlIGtub2IgcG9zaXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBwcm9wZXJ0eUNoYW5nZWQgV2hldGhlciBvciBub3Qgd2UgbmVlZCB0byBmaXJlIGEgcHJvcGVydHlDaGFuZ2VkIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3NldFZhbHVlUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIHNldEtub2IsIHByb3BlcnR5Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPj0gdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPD0gdGhpcy5taW4pIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMobmV3VmFsdWUgLSB2YWx1ZSkgPCB0aGlzLl9zdGVwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoc2V0S25vYikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0S25vYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKG5ld1ZhbHVlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignaW5wdXQnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuaW1hdGVzIGFuZCBzZXRzIHRoZSBrbm9iIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZT8gVGhlIHZhbHVlIHRvIHVzZSB0byBjYWxjdWxhdGUgdGhlIGtub2IgcG9zaXRpb24uIElmIG5vIHZhbHVlIGlzXHJcbiAgICAgICAgICogc3BlY2lmaWVkLCB0aGUgY3VycmVudCBTbGlkZXIncyB2YWx1ZSB3aWxsIGJlIHVzZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2xpZGVyLnByb3RvdHlwZS5fc2V0S25vYiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9Qcm9taXNlLnJlc29sdmUodGhpcy5fc2xpZGVyVmlzaWJsZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9LCBsZW5ndGggPSBfdGhpcy5fY2FsY3VsYXRlS25vYlBvc2l0aW9uKCh2YWx1ZSB8fCBfdGhpcy52YWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gX3RoaXMuX2tub2JPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zW190aGlzLl9sZW5ndGhQcm9wZXJ0eV0gPSBsZW5ndGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0b3IuYW5pbWF0ZShfdGhpcy5fc2xpZGVyLCBfX1RyYW5zaXRpb24sIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBhbmltYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9rbm9iT2Zmc2V0ID0gbGVuZ3RoO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWdnZXJzIGFuIGV2ZW50IHN0YXJ0aW5nIGZyb20gdGhpcyBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBTbGlkZXIucHJvdG90eXBlLl90cmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBkb21FdmVudCA9IHBsYXQuYWNxdWlyZShfX0RvbUV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICBkb21FdmVudC5pbml0aWFsaXplKHRoaXMuZWxlbWVudCwgZXZlbnQpO1xyXG4gICAgICAgICAgICBkb21FdmVudC50cmlnZ2VyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjb250cm9sIGFuZCBlbnN1cmVzIGl0IGlzIHZhbGlkLlxyXG4gICAgICAgICAqIFdpbGwgZGVmYXVsdCB0byBcImhvcml6b250YWxcIiBpZiBpbnZhbGlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiBUaGUgZWxlbWVudCB0byBiYXNlIHRoZSBsZW5ndGggb2ZmIG9mLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNsaWRlci5wcm90b3R5cGUuX3ZhbGlkYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNVbmRlZmluZWQob3JpZW50YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hvcml6b250YWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWxpZE9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1ZlcnRpY2FsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkludmFsaWQgb3JpZW50YXRpb24gXFxcIlwiICsgb3JpZW50YXRpb24gKyBcIlxcXCIgZm9yIFwiICsgdGhpcy50eXBlICsgXCIuIERlZmF1bHRpbmcgdG8gXFxcImhvcml6b250YWwuXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSAnaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkT3JpZW50YXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICBTbGlkZXIuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2xpZGVyO1xyXG4gICAgfShwbGF0LnVpLkJpbmRDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuU2xpZGVyID0gU2xpZGVyO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fU2xpZGVyLCBTbGlkZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIEJpbmRDb250cm9sIHRoYXQgYWxsb3dzIGZvciBhIGxvd2VyIGFuZCB1cHBlciB2YWx1ZSxcclxuICAgICAqIHRodXMgY3JlYXRpbmcgYSB2YXJpYWJsZSByYW5nZSBvZiBpbmNsdWRlZCB2YWx1ZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBSYW5nZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFJhbmdlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIFJhbmdlKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1yYW5nZS1jb250YWluZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtcmFuZ2UtdHJhY2tcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF0LWxvd2VyLWtub2JcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF0LXVwcGVyLWtub2JcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGVudW0gZGVub3RpbmcgdGhlIGN1cnJlbnQgdG91Y2ggc3RhdGUgb2YgdGhlIHVzZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCB3aWxsIHN0b3AgbGlzdGVuaW5nIGZvciB2aXNpYmlsaXR5IGlmIGFwcGxpY2FibGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIgPSBub29wO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBib29sZWFuIHZhbHVlIHRoYXQgZm9yY2VzIGEgb25lLXRpbWUgdHJpZ2dlciB1cG9uIHRoZSBmaXJzdCBib3VuZCB2YWx1ZSBjaGFuZ2UuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JjZUZpcnN0VGltZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19SYW5nZSArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBwcm9wZXIgY2xhc3NlcyBmb3IgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NlcygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBidXR0b24gdHlwZSBhbmQgYXBwbHkgdGhlIHByb3BlciBjbGFzc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCBzbGlkZXIgPSB0aGlzLl9zbGlkZXIgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLCBpc051bWJlciA9IHRoaXMudXRpbHMuaXNOdW1iZXIsIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgb3B0aW9uTG93ZXIgPSBOdW1iZXIob3B0aW9ucy5sb3dlciksIG9wdGlvblVwcGVyID0gTnVtYmVyKG9wdGlvbnMudXBwZXIpLCBpZGVudGlmaWVycyA9IG9wdGlvbnMuaWRlbnRpZmllcnMgfHwge30sIG9wdGlvbk1pbiA9IG9wdGlvbnMubWluLCBvcHRpb25NYXggPSBvcHRpb25zLm1heCwgc3RlcCA9IG9wdGlvbnMuc3RlcCwgcmV2ZXJzZWQgPSB0aGlzLl9yZXZlcnNlZCA9IChvcHRpb25zLnJldmVyc2UgPT09IHRydWUpLCBtaW4gPSB0aGlzLm1pbiA9IGlzTnVtYmVyKG9wdGlvbk1pbikgPyBNYXRoLmZsb29yKG9wdGlvbk1pbikgOiAwLCBtYXggPSB0aGlzLm1heCA9IGlzTnVtYmVyKG9wdGlvbk1heCkgPyBNYXRoLmNlaWwob3B0aW9uTWF4KSA6IDEwMCwgbG93ZXIgPSBpc051bWJlcihvcHRpb25Mb3dlcikgPyBNYXRoLnJvdW5kKG9wdGlvbkxvd2VyKSA6IG1pbiwgdXBwZXIgPSBpc051bWJlcihvcHRpb25VcHBlcikgPyBNYXRoLnJvdW5kKG9wdGlvblVwcGVyKSA6IG1heCwgY2xhc3NOYW1lID0gX19QbGF0ICsgdGhpcy5fdmFsaWRhdGVPcmllbnRhdGlvbihvcHRpb25zLm9yaWVudGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fbG93ZXJLbm9iID0gc2xpZGVyLmZpcnN0RWxlbWVudENoaWxkO1xyXG4gICAgICAgICAgICB0aGlzLl91cHBlcktub2IgPSBzbGlkZXIubGFzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fbG93ZXJJZGVudGlmaWVyID0gaWRlbnRpZmllcnMubG93ZXIgfHwgJ2xvd2VyJztcclxuICAgICAgICAgICAgdGhpcy5fdXBwZXJJZGVudGlmaWVyID0gaWRlbnRpZmllcnMudXBwZXIgfHwgJ3VwcGVyJztcclxuICAgICAgICAgICAgLy8gaWYgaXQncyBhIHJldmVyc2VkIGRpcmVjdGlvbiwgc3dhcCBrbm9icy4gXHJcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvd2VyS25vYiA9IHRoaXMuX2xvd2VyS25vYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvd2VyS25vYiA9IHRoaXMuX3VwcGVyS25vYjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwcGVyS25vYiA9IGxvd2VyS25vYjtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSArPSBfX1JldmVyc2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIC8vIHJlc2V0IHZhbHVlIHRvIG1pbmltdW0gaW4gY2FzZSBjb250ZXh0IGlzIGFscmVhZHkgc2V0IHRvIGEgdmFsdWUgXHJcbiAgICAgICAgICAgIHRoaXMubG93ZXIgPSBtaW47XHJcbiAgICAgICAgICAgIHRoaXMudXBwZXIgPSBtYXg7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSBpc051bWJlcihzdGVwKSA/IChzdGVwID4gMCA/IE1hdGgucm91bmQoc3RlcCkgOiAxKSA6IDE7XHJcbiAgICAgICAgICAgIGlmIChtaW4gPj0gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJcXFwiXCIgKyB0aGlzLnR5cGUgKyBcIidzXFxcIiBtaW4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGl0cyBtYXguIFNldHRpbmcgbWF4IHRvIG1pbiArIDEuXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXggPSBtaW4gKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uQW5kTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIC8vIG11c3Qgc2V0IHRoaXMgaW4gY2FzZSB0aGUgdmFsdWUgaXMgbm90IHNldCBhbmQgbG93ZXIga25vYiBpcyBuZXZlciBwb3NpdGlvbmVkIGR1ZSB0byBzZXRMb3dlciBmdW5jdGlvbi4gXHJcbiAgICAgICAgICAgIHRoaXMuX3NldExvd2VyS25vYlBvc2l0aW9uKG1pbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVFdmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRMb3dlcihsb3dlcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VXBwZXIodXBwZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIFJhbmdlLiBJZiBhbiBpbnZhbGlkIHZhbHVlIGlzIHBhc3NlZCBpblxyXG4gICAgICAgICAqIG5vdGhpbmcgd2lsbCBoYXBwZW4uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIFJhbmdlIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5zZXRMb3dlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRMb3dlcih2YWx1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB1cHBlciB2YWx1ZSBvZiB0aGUgUmFuZ2UuIElmIGFuIGludmFsaWQgdmFsdWUgaXMgcGFzc2VkIGluXHJcbiAgICAgICAgICogbm90aGluZyB3aWxsIGhhcHBlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgUmFuZ2UgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLnNldFVwcGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFVwcGVyKHZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhpcyBjb250cm9sIHRvIG9ic2VydmUgYm90aCB0aGUgYm91bmQgcHJvcGVydHkgaXRzZWxmIGFzIHdlbGwgYXNcclxuICAgICAgICAgKiBwb3RlbnRpYWwgY2hpbGQgcHJvcGVydGllcyBpZiBiZWluZyBib3VuZCB0byBhbiBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0Lm9ic2VydmFibGUuSUltcGxlbWVudFR3b1dheUJpbmRpbmd9IGJpbmRlciBUaGUgY29udHJvbCB0aGF0IGZhY2lsaXRhdGVzIHRoZVxyXG4gICAgICAgICAqIGRhdGFiaW5kaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5vYnNlcnZlUHJvcGVydGllcyA9IGZ1bmN0aW9uIChiaW5kZXIpIHtcclxuICAgICAgICAgICAgYmluZGVyLm9ic2VydmVQcm9wZXJ0eSh0aGlzLl9zZXRMb3dlckJvdW5kUHJvcGVydHksIHRoaXMuX2xvd2VySWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0VXBwZXJCb3VuZFByb3BlcnR5LCB0aGlzLl91cHBlcklkZW50aWZpZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSBsb3dlciB2YWx1ZSBpcyBzZXQgZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgVGhlIG5ldyBsb3dlciB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkZW50aWZpZXIgVGhlIGNoaWxkIGlkZW50aWZpZXIgb2YgdGhlIHByb3BlcnR5IGJlaW5nIG9ic2VydmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIGJpbmQgdGhlIHByb3BlcnR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fc2V0TG93ZXJCb3VuZFByb3BlcnR5ID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSwgaWRlbnRpZmllciwgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldExvd2VyKG5ld1ZhbHVlLCBmYWxzZSwgZmlyc3RUaW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgYmluZGFibGUgdXBwZXIgdmFsdWUgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlIFRoZSBuZXcgdXBwZXIgdmFsdWUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldFVwcGVyQm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRVcHBlcihuZXdWYWx1ZSwgZmFsc2UsIGZpcnN0VGltZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgUmFuZ2UuIElmIGFuIGludmFsaWQgdmFsdWUgaXMgcGFzc2VkIGluXHJcbiAgICAgICAgICogbm90aGluZyB3aWxsIGhhcHBlbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgUmFuZ2UgdG8uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBwcm9wZXJ0eUNoYW5nZWQgV2hldGhlciBvciBub3QgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkIGJ5IHRoZSB1c2VyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RUaW1lPyBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsIHRvIHNldCB0aGUgbG93ZXIgdmFsdWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9zZXRMb3dlciA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJvcGVydHlDaGFuZ2VkLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoU3RhdGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhcIkNhbm5vdCBzZXQgdGhlIHZhbHVlIG9mIHRoZSBcIiArIHRoaXMudHlwZSArIFwiJ3MgbG93ZXIga25vYiB3aGlsZSB0aGUgdXNlciBpcyBtYW5pcHVsYXRpbmcgaXQuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWxzLmlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RUaW1lID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yY2VGaXJzdFRpbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVtYmVyKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bWJlclZhbCA9IE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIobnVtYmVyVmFsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVtYmVyVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yY2VGaXJzdFRpbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cud2Fybih0aGlzLnR5cGUgKyBcIiBoYXMgaXRzIGxvd2VyIHZhbHVlIGJvdW5kIHRvIGEgcHJvcGVydHkgdGhhdCBjYW5ub3QgYmUgaW50ZXJwcmV0ZWQgYXMgYSBOdW1iZXIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRMb3dlclZhbHVlKHZhbHVlLCB0cnVlLCBwcm9wZXJ0eUNoYW5nZWQsIHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgdXBwcGVyIHZhbHVlIG9mIHRoZSBSYW5nZS4gSWYgYW4gaW52YWxpZCB2YWx1ZSBpcyBwYXNzZWQgaW5cclxuICAgICAgICAgKiBub3RoaW5nIHdpbGwgaGFwcGVuLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBSYW5nZSB0by5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByb3BlcnR5Q2hhbmdlZCBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvcGVydHkgd2FzIGNoYW5nZWQgYnkgdGhlIHVzZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmaXJzdFRpbWU/IFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwgdG8gc2V0IHRoZSB1cHBlciB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldFVwcGVyID0gZnVuY3Rpb24gKHZhbHVlLCBwcm9wZXJ0eUNoYW5nZWQsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdG91Y2hTdGF0ZSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiQ2Fubm90IHNldCB0aGUgdmFsdWUgb2YgdGhlIFwiICsgdGhpcy50eXBlICsgXCIncyB1cHBlciBrbm9iIHdoaWxlIHRoZSB1c2VyIGlzIG1hbmlwdWxhdGluZyBpdC5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXRpbHMuaXNOdWxsKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1heDtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5Q2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc051bWJlcih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBudW1iZXJWYWwgPSBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKG51bWJlclZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bWJlclZhbDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4odGhpcy50eXBlICsgXCIgaGFzIGl0cyB1cHBlciB2YWx1ZSBib3VuZCB0byBhIHByb3BlcnR5IHRoYXQgY2Fubm90IGJlIGludGVycHJldGVkIGFzIGEgTnVtYmVyLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0VXBwZXJWYWx1ZSh2YWx1ZSwgdHJ1ZSwgcHJvcGVydHlDaGFuZ2VkIHx8IChmaXJzdFRpbWUgPT09IHRydWUgJiYgdGhpcy5fZm9yY2VGaXJzdFRpbWUpLCB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIHByb3BlciB0cmFja2luZyBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9pbml0aWFsaXplRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbG93ZXJLbm9iID0gdGhpcy5fbG93ZXJLbm9iLCB1cHBlcktub2IgPSB0aGlzLl91cHBlcktub2IsIHRvdWNoc3RhcnQgPSB0aGlzLl90b3VjaFN0YXJ0LCB0b3VjaEVuZCA9IHRoaXMuX3RvdWNoRW5kLCB0cmFja0xvd2VyID0gdGhpcy5fdHJhY2tMb3dlciwgdHJhY2tVcHBlciA9IHRoaXMuX3RyYWNrVXBwZXIsIHRyYWNrLCByZXZlcnNlVHJhY2s7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayA9IF9fJHRyYWNrICsgXCJkb3duXCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwidXBcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gX18kdHJhY2sgKyBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwibGVmdFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihsb3dlcktub2IsIF9fJHRvdWNoc3RhcnQsIHRvdWNoc3RhcnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHVwcGVyS25vYiwgX18kdG91Y2hzdGFydCwgdG91Y2hzdGFydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobG93ZXJLbm9iLCB0cmFjaywgdHJhY2tMb3dlciwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobG93ZXJLbm9iLCByZXZlcnNlVHJhY2ssIHRyYWNrTG93ZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHVwcGVyS25vYiwgdHJhY2ssIHRyYWNrVXBwZXIsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHVwcGVyS25vYiwgcmV2ZXJzZVRyYWNrLCB0cmFja1VwcGVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihsb3dlcktub2IsIF9fJHRvdWNoZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodXBwZXJLbm9iLCBfXyR0b3VjaGVuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGxvd2VyS25vYiwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih1cHBlcktub2IsIF9fJHRyYWNrZW5kLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fd2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51dGlscy5pc051bGwoX3RoaXMuX3JhbmdlVmlzaWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fc2V0UG9zaXRpb25BbmRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zZXRMb3dlcktub2JQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFVwcGVyS25vYlBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZyB0aGUgZmlyc3QgdG91Y2guXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0b3VjaCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl90b3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciB0b3VjaFN0YXRlID0gdGhpcy5fdG91Y2hTdGF0ZTtcclxuICAgICAgICAgICAgaWYgKHRvdWNoU3RhdGUgPT09IDEgfHwgdG91Y2hTdGF0ZSA9PT0gMiB8fCB0b3VjaFN0YXRlID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDE7XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldi5jdXJyZW50VGFyZ2V0LCBsYXN0VG91Y2ggPSB0aGlzLl9sYXN0VG91Y2g7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzTnVsbChsYXN0VG91Y2gpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0YXJnZXQsIF9fUGxhdCArIFwidG9wXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3RUb3VjaC50YXJnZXQgIT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xyXG4gICAgICAgICAgICAgICAgZG9tLmFkZENsYXNzKHRhcmdldCwgX19QbGF0ICsgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MobGFzdFRvdWNoLnRhcmdldCwgX19QbGF0ICsgXCJ0b3BcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoID0ge1xyXG4gICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgIHk6IGV2LmNsaWVudFksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGFyZ2V0ID09PSB0aGlzLl9sb3dlcktub2IgPyB0aGlzLmxvd2VyIDogdGhpcy51cHBlcixcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIG5ldyBzbGlkZXIgZWxlbWVudCBvZmZzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fdG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHRvdWNoU3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSA9PT0gMCB8fCB0b3VjaFN0YXRlID09PSA0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gNDtcclxuICAgICAgICAgICAgdmFyIGxhc3RUb3VjaCA9IHRoaXMuX2xhc3RUb3VjaCwgdGFyZ2V0ID0gZXYuY3VycmVudFRhcmdldDtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGxhc3RUb3VjaCkgfHwgKGxhc3RUb3VjaC50YXJnZXQgIT09IHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNMb3dlciA9IHRhcmdldCA9PT0gX3RoaXMuX2xvd2VyS25vYiwgbmV3T2Zmc2V0ID0gX3RoaXMuX2NhbGN1bGF0ZU9mZnNldChldiwgaXNMb3dlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNMb3dlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VG91Y2gudmFsdWUgIT09IF90aGlzLmxvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl90cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsYXN0VG91Y2gudmFsdWUgIT09IF90aGlzLnVwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldE9mZnNldChuZXdPZmZzZXQsIGlzTG93ZXIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGRlc2lnbmF0ZWQga25vYiBlbGVtZW50J3Mgb2Zmc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBuZXcgb2Zmc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlciBXaGV0aGVyIHdlJ3JlIHNldHRpbmcgdGhlIGxvd2VyIG9yIHVwcGVyIGtub2IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9zZXRPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0LCBpc0xvd2VyKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXhPZmZzZXQgPSB0aGlzLl9tYXhPZmZzZXQ7XHJcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICh0aGlzLl9sb3dlcktub2JPZmZzZXQgPSAwKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3VwcGVyS25vYk9mZnNldCA9IDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAodGhpcy5fbG93ZXJLbm9iT2Zmc2V0ID0gbWF4T2Zmc2V0KSA6XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3VwcGVyS25vYk9mZnNldCA9IG1heE9mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAodGhpcy5fbG93ZXJLbm9iT2Zmc2V0ID0gb2Zmc2V0KSA6XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fdXBwZXJLbm9iT2Zmc2V0ID0gb2Zmc2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrIHRoZSBsb3dlciBrbm9iIG1vdmVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3RyYWNrTG93ZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIHRvdWNoU3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoU3RhdGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoU3RhdGUgPT09IDAgfHwgdG91Y2hTdGF0ZSA9PT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gdGhpcy5fbWF4T2Zmc2V0LCBwb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZU9mZnNldChldiwgdHJ1ZSksIHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAtIHRoaXMubG93ZXIgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwb3NpdGlvbiA+PSBtYXhPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5tYXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSB0aGlzLmxvd2VyIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG1heE9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fY2FsY3VsYXRlVmFsdWUocG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0gdGhpcy5sb3dlciA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLl91cHBlcktub2JPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uVG9nZXRoZXIocG9zaXRpb24sIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NldE9mZnNldChwb3NpdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uTG93ZXIocG9zaXRpb24sIHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrIHRoZSB1cHBlciBrbm9iIG1vdmVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3RyYWNrVXBwZXIgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIHRvdWNoU3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlO1xyXG4gICAgICAgICAgICBpZiAodG91Y2hTdGF0ZSAhPT0gMykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoU3RhdGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvdWNoU3RhdGUgPT09IDAgfHwgdG91Y2hTdGF0ZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWF4T2Zmc2V0ID0gdGhpcy5fbWF4T2Zmc2V0LCBwb3NpdGlvbiA9IHRoaXMuX2NhbGN1bGF0ZU9mZnNldChldiwgZmFsc2UpLCB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgLSB0aGlzLnVwcGVyID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocG9zaXRpb24gPj0gbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIC0gdGhpcy51cHBlciA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBtYXhPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhbGN1bGF0ZVZhbHVlKHBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAtIHRoaXMudXBwZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIDwgdGhpcy5fbG93ZXJLbm9iT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblRvZ2V0aGVyKHBvc2l0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRPZmZzZXQocG9zaXRpb24sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uVXBwZXIocG9zaXRpb24sIHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvc2l0aW9ucyB0aGUgc2xpZGVyIGVsZW1lbnQgYW5kIGFkanVzdHMgaXQncyBsZW5ndGggdG8gYWNjb3VudFxyXG4gICAgICAgICAqIGZvciBsb3dlciBrbm9iIG1vdmVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiBUaGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBsb3dlciBrbm9iLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZT8gVGhlIG5ldyB2YWx1ZSB0byBzZXQgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fcG9zaXRpb25Mb3dlciA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gX3RoaXMuX3NsaWRlci5zdHlsZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlW190aGlzLl9wb3NpdGlvblByb3BlcnR5XSA9IHBvc2l0aW9uICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbX3RoaXMuX2xlbmd0aFByb3BlcnR5XSA9IChfdGhpcy5fdXBwZXJLbm9iT2Zmc2V0IC0gcG9zaXRpb24pICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldExvd2VyVmFsdWUodmFsdWUsIGZhbHNlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb3NpdGlvbnMgdGhlIHNsaWRlciBlbGVtZW50IGFuZCBhZGp1c3RzIGl0J3MgbGVuZ3RoIHRvIGFjY291bnRcclxuICAgICAgICAgKiBmb3IgdXBwZXIga25vYiBtb3ZlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgdXBwZXIga25vYi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWU/IFRoZSBuZXcgdmFsdWUgdG8gc2V0IGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3Bvc2l0aW9uVXBwZXIgPSBmdW5jdGlvbiAocG9zaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMudXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zbGlkZXIuc3R5bGVbX3RoaXMuX2xlbmd0aFByb3BlcnR5XSA9IChwb3NpdGlvbiAtIF90aGlzLl9sb3dlcktub2JPZmZzZXQpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFVwcGVyVmFsdWUodmFsdWUsIGZhbHNlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb3NpdGlvbnMgdGhlIHNsaWRlciBlbGVtZW50IGFuZCBhZGp1c3RzIGl0J3MgbGVuZ3RoIHRvIGFjY291bnRcclxuICAgICAgICAgKiBmb3Igc3luY2hyb25pemVkIGtub2IgbW92ZW1lbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIFRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGtub2JzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZT8gVGhlIG5ldyB2YWx1ZSB0byBzZXQgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFJhbmdlLnByb3RvdHlwZS5fcG9zaXRpb25Ub2dldGhlciA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gX3RoaXMuX3NsaWRlci5zdHlsZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlW190aGlzLl9wb3NpdGlvblByb3BlcnR5XSA9IHBvc2l0aW9uICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgc3R5bGVbX3RoaXMuX2xlbmd0aFByb3BlcnR5XSA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldExvd2VyVmFsdWUodmFsdWUsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3NldFVwcGVyVmFsdWUodmFsdWUsIGZhbHNlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZhbHVlIGJhc2VkIG9uIGtub2IgcG9zaXRpb24gYW5kIHNsaWRlciBlbGVtZW50IHdpZHRoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBUaGUgY3VycmVudCB3aWR0aCBvZiB0aGUgc2xpZGVyIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9jYWxjdWxhdGVWYWx1ZSA9IGZ1bmN0aW9uICh3aWR0aCkge1xyXG4gICAgICAgICAgICB2YXIgc3RlcCA9IHRoaXMuX3N0ZXA7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5taW4gKyBNYXRoLnJvdW5kKHdpZHRoIC8gdGhpcy5faW5jcmVtZW50IC8gc3RlcCkgKiBzdGVwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBvZmZzZXQgb2YgdGhlIHNsaWRlciBlbGVtZW50IGJhc2VkIG9uIHRoZSBvbGQgb2Zmc2V0IGFuZCB0aGUgZGlzdGFuY2UgbW92ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2sgb3IgJHRyYWNrZW5kIGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXIgV2hldGhlciB0aGUgY3VycmVudCBrbm9iIGlzIHRoZSBsb3dlciBvciB0aGUgdXBwZXIga25vYi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX2NhbGN1bGF0ZU9mZnNldCA9IGZ1bmN0aW9uIChldiwgaXNMb3dlcikge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudE9mZnNldCA9IGlzTG93ZXIgPyB0aGlzLl9sb3dlcktub2JPZmZzZXQgOiB0aGlzLl91cHBlcktub2JPZmZzZXQsIGRpc3BsYWNlbWVudDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHRoaXMuX3JldmVyc2VkID8gZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55IDogdGhpcy5fbGFzdFRvdWNoLnkgLSBldi5jbGllbnRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gdGhpcy5fcmV2ZXJzZWQgPyB0aGlzLl9sYXN0VG91Y2gueCAtIGV2LmNsaWVudFggOiBldi5jbGllbnRYIC0gdGhpcy5fbGFzdFRvdWNoLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQgKyBkaXNwbGFjZW1lbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIGtub2IgcG9zaXRpb24gYmFzZWQgb24gY3VycmVudCB2YWx1ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHtsaW5rIHBsYXR1aS5SYW5nZXxSYW5nZX0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl9jYWxjdWxhdGVLbm9iUG9zaXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHRoaXMuX2luY3JlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBSYW5nZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBzZXRLbm9iIFdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gc2V0IHRoZSBrbm9iIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcGVydHlDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZCBieSB0aGUgdXNlci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXIgV2hldGhlciBvciBub3QgdG8gdHJpZ2dlciB0aGUgJ2lucHV0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldExvd2VyVmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUsIHNldEtub2IsIHByb3BlcnR5Q2hhbmdlZCwgdHJpZ2dlcikge1xyXG4gICAgICAgICAgICB2YXIgbG93ZXIgPSB0aGlzLmxvd2VyO1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IGxvd2VyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPj0gdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPD0gdGhpcy5taW4pIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMobmV3VmFsdWUgLSBsb3dlcikgPCB0aGlzLl9zdGVwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sb3dlciA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoc2V0S25vYikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0TG93ZXJLbm9iUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvcGVydHlDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBSYW5nZS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBzZXRLbm9iIFdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gc2V0IHRoZSBrbm9iIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcGVydHlDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9wZXJ0eSB3YXMgY2hhbmdlZCBieSB0aGUgdXNlci5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXIgV2hldGhlciBvciBub3QgdG8gdHJpZ2dlciB0aGUgJ2lucHV0JyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldFVwcGVyVmFsdWUgPSBmdW5jdGlvbiAobmV3VmFsdWUsIHNldEtub2IsIHByb3BlcnR5Q2hhbmdlZCwgdHJpZ2dlcikge1xyXG4gICAgICAgICAgICB2YXIgdXBwZXIgPSB0aGlzLnVwcGVyO1xyXG4gICAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPj0gdGhpcy5tYXgpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPD0gdGhpcy5taW4pIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMobmV3VmFsdWUgLSB1cHBlcikgPCB0aGlzLl9zdGVwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cHBlciA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoc2V0S25vYikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VXBwZXJLbm9iUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvcGVydHlDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9maXJlQ2hhbmdlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGluY3JlbWVudCBmb3Igc2xpZGluZyB0aGUge2xpbmsgcGxhdHVpLlJhbmdlfFJhbmdlfS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldEluY3JlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9pbmNyZW1lbnQgPSB0aGlzLl9tYXhPZmZzZXQgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgcHJvcGVydGllcyB0byB1c2UgZm9yIGxlbmd0aCBhbmQgcG9zaXRpb24gYW5kIHNldHMgdGhlIG1heCBsZW5ndGggb2YgdGhlIHNsaWRpbmcgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldFBvc2l0aW9uQW5kTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLl9zbGlkZXIucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlbmd0aFByb3BlcnR5ID0gJ2hlaWdodCc7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblByb3BlcnR5ID0gdGhpcy5fcmV2ZXJzZWQgPyAndG9wJyA6ICdib3R0b20nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4T2Zmc2V0ID0gZWwuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoUHJvcGVydHkgPSAnd2lkdGgnO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25Qcm9wZXJ0eSA9IHRoaXMuX3JldmVyc2VkID8gJ3JpZ2h0JyA6ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heE9mZnNldCA9IGVsLmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZVZpc2libGUgPSBuZXcgdGhpcy5fUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZW1vdmVWaXNpYmlsaXR5TGlzdGVuZXIgPSBfdGhpcy5kb20ud2hlblZpc2libGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmFuZ2VWaXNpYmxlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldFBvc2l0aW9uQW5kTGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9LCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbmNyZW1lbnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuaW1hdGVzIGFuZCBzZXRzIHRoZSBrbm9iIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZT8gVGhlIHZhbHVlIHRvIHVzZSB0byBjYWxjdWxhdGUgdGhlIGtub2IgcG9zaXRpb24uIElmIG5vIHZhbHVlIGlzXHJcbiAgICAgICAgICogc3BlY2lmaWVkLCB0aGUgY3VycmVudCBSYW5nZSdzIHZhbHVlIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldExvd2VyS25vYlBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX1Byb21pc2UucmVzb2x2ZSh0aGlzLl9yYW5nZVZpc2libGUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7fSwgdXBwZXJLbm9iT2Zmc2V0ID0gX3RoaXMuX3VwcGVyS25vYk9mZnNldCwgdXBwZXJPZmZzZXQgPSBfdGhpcy51dGlscy5pc051bWJlcih1cHBlcktub2JPZmZzZXQpID9cclxuICAgICAgICAgICAgICAgICAgICB1cHBlcktub2JPZmZzZXQgOlxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXRPZmZzZXQoX3RoaXMuX2NhbGN1bGF0ZUtub2JQb3NpdGlvbihfdGhpcy51cHBlciksIGZhbHNlKSwgcG9zaXRpb24gPSBfdGhpcy5fY2FsY3VsYXRlS25vYlBvc2l0aW9uKCh2YWx1ZSB8fCBfdGhpcy5sb3dlcikpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBfdGhpcy5fbG93ZXJLbm9iT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1tfdGhpcy5fcG9zaXRpb25Qcm9wZXJ0eV0gPSBwb3NpdGlvbiArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbX3RoaXMuX2xlbmd0aFByb3BlcnR5XSA9ICh1cHBlck9mZnNldCAtIHBvc2l0aW9uKSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRvci5hbmltYXRlKF90aGlzLl9zbGlkZXIsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvd2VyS25vYk9mZnNldCA9IHBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuaW1hdGVzIGFuZCBzZXRzIHRoZSBrbm9iIHBvc2l0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZT8gVGhlIHZhbHVlIHRvIHVzZSB0byBjYWxjdWxhdGUgdGhlIGtub2IgcG9zaXRpb24uIElmIG5vIHZhbHVlIGlzXHJcbiAgICAgICAgICogc3BlY2lmaWVkLCB0aGUgY3VycmVudCBSYW5nZSdzIHZhbHVlIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3NldFVwcGVyS25vYlBvc2l0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX1Byb21pc2UucmVzb2x2ZSh0aGlzLl9yYW5nZVZpc2libGUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7fSwgbGVuZ3RoID0gX3RoaXMuX2NhbGN1bGF0ZUtub2JQb3NpdGlvbigodmFsdWUgfHwgX3RoaXMudXBwZXIpKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IF90aGlzLl91cHBlcktub2JPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zW190aGlzLl9sZW5ndGhQcm9wZXJ0eV0gPSAobGVuZ3RoIC0gX3RoaXMuX2xvd2VyS25vYk9mZnNldCkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fYW5pbWF0b3IuYW5pbWF0ZShfdGhpcy5fc2xpZGVyLCBfX1RyYW5zaXRpb24sIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBhbmltYXRpb25PcHRpb25zXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl91cHBlcktub2JPZmZzZXQgPSBsZW5ndGg7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZXMgYW4gaW5wdXRDaGFuZ2VkIGV2ZW50IHdpdGggdGhlIG5ldyBib3VuZCB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX2ZpcmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdQcm9wZXJ0eSA9IHt9O1xyXG4gICAgICAgICAgICBuZXdQcm9wZXJ0eVt0aGlzLl9sb3dlcklkZW50aWZpZXJdID0gdGhpcy5sb3dlcjtcclxuICAgICAgICAgICAgbmV3UHJvcGVydHlbdGhpcy5fdXBwZXJJZGVudGlmaWVyXSA9IHRoaXMudXBwZXI7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKG5ld1Byb3BlcnR5KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWdnZXJzIGFuIGV2ZW50IHN0YXJ0aW5nIGZyb20gdGhpcyBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBSYW5nZS5wcm90b3R5cGUuX3RyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGRvbUV2ZW50ID0gcGxhdC5hY3F1aXJlKF9fRG9tRXZlbnRJbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIGRvbUV2ZW50LmluaXRpYWxpemUodGhpcy5lbGVtZW50LCBldmVudCk7XHJcbiAgICAgICAgICAgIGRvbUV2ZW50LnRyaWdnZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrcyB0aGUgb3JpZW50YXRpb24gb2YgdGhlIGNvbnRyb2wgYW5kIGVuc3VyZXMgaXQgaXMgdmFsaWQuXHJcbiAgICAgICAgICogV2lsbCBkZWZhdWx0IHRvIFwiaG9yaXpvbnRhbFwiIGlmIGludmFsaWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWVudGF0aW9uIFRoZSBlbGVtZW50IHRvIGJhc2UgdGhlIGxlbmd0aCBvZmYgb2YuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUmFuZ2UucHJvdG90eXBlLl92YWxpZGF0ZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzVW5kZWZpbmVkKG9yaWVudGF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdob3Jpem9udGFsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsaWRPcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJJbnZhbGlkIG9yaWVudGF0aW9uIFxcXCJcIiArIG9yaWVudGF0aW9uICsgXCJcXFwiIGZvciBcIiArIHRoaXMudHlwZSArIFwiLiBEZWZhdWx0aW5nIHRvIFxcXCJob3Jpem9udGFsLlxcXCJcIik7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxpZE9yaWVudGF0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgUmFuZ2UuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICBfd2luZG93OiBfX1dpbmRvdyxcclxuICAgICAgICAgICAgX1Byb21pc2U6IF9fUHJvbWlzZSxcclxuICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gUmFuZ2U7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5SYW5nZSA9IFJhbmdlO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fUmFuZ2UsIFJhbmdlKTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gSVRlbXBsYXRlQ29udHJvbCB0aGF0IGFsbG93cyBmb3IgZGF0YWJpbmRpbmcgYSBzZWxlY3QgYm94IGFuZCBhZGRzXHJcbiAgICAgKiBjdXN0b20gc3R5bGluZyB0byBtYWtlIGl0IGxvb2sgY29uc2lzdGVudCBhY3Jvc3MgYWxsIHBsYXRmb3Jtcy5cclxuICAgICAqL1xyXG4gICAgdmFyIFNlbGVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKFNlbGVjdCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBTZWxlY3QoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFNlbGVjdC5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCB8fCB0aGlzLmVsZW1lbnQsIF9fU2VsZWN0ICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIGNsYXNzIG5hbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgU2VsZWN0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gU2VsZWN0O1xyXG4gICAgfShwbGF0LnVpLmNvbnRyb2xzLlNlbGVjdCkpO1xyXG4gICAgcGxhdHVpLlNlbGVjdCA9IFNlbGVjdDtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX1NlbGVjdCwgU2VsZWN0KTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gQmluZENvbnRyb2wgdGhhdCBzdGFuZGFyZGl6ZXMgYW5kIHN0eWxlc1xyXG4gICAgICogYW4gSFRNTCBpbnB1dCBlbGVtZW50IG9mIHZhcmlvdXMgdHlwZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBJbnB1dCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKElucHV0LCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIElucHV0KCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIHRoZSBjb250cm9sJ3MgZWxlbWVudCB3aXRoIGFuIEhUTUxJbnB1dEVsZW1lbnQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VXaXRoID0gJ2lucHV0JztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IHZhbHVlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19JbnB1dCArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBhbGwgSFRNTEVsZW1lbnQgcmVmZXJlbmNlcyBhbmQgcG90ZW50aWFsIGF0dHJpYnV0ZSBjb250cm9scy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmNsZWFyTm9kZSh0aGlzLmVsZW1lbnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBzdHlsZSBhbmQgaW5pdGlhbGl6ZSB0aGUgYWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIHBhdHRlcm4gPSBvcHRpb25zLnBhdHRlcm4sIHZhbGlkYXRpb24gPSBvcHRpb25zLnZhbGlkYXRpb24sIGlzU3RyaW5nID0gdGhpcy51dGlscy5pc1N0cmluZztcclxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9IHRoaXMuYXR0cmlidXRlc1sndHlwZSddIHx8IG9wdGlvbnMudHlwZSB8fCAndGV4dCc7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhwYXR0ZXJuKSAmJiBwYXR0ZXJuICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm5bMF0gPT09ICcvJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWxpZGF0aW9uKSAmJiB2YWxpZGF0aW9uICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25bMF0gPT09ICcvJyAmJiB2YWxpZGF0aW9uW3ZhbGlkYXRpb24ubGVuZ3RoIC0gMV0gPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb24gPSB2YWxpZGF0aW9uLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSBuZXcgUmVnRXhwKHZhbGlkYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVUeXBlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRvIHZhbGlkYXRlIHRoZSB1c2VyJ3MgaW5wdXQuIEZvciBhY3Rpb249XCJlbWFpbFwiIGl0IHJldHVybnNcclxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBlbWFpbCBjYW4gYmUgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLiBGb3IgYWxsIG90aGVyXHJcbiAgICAgICAgICogYWN0aW9ucyBpdCByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGlzIG5vdCBlbXB0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0aW9uLnRlc3QodGhpcy5lbGVtZW50LnZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyB0aGUgdXNlcidzIGlucHV0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHZhbHVlID0gZWxlbWVudC52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSB0aGlzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKHRoaXMudmFsdWUsIHZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvY3VzZXMgdGhlIGlucHV0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCbHVycyB0aGUgaW5wdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5ibHVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHRleHQgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIHRleHQuXHJcbiAgICAgICAgICogQHBhcmFtIHt2b2lkfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuX3NldEJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5lbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc051bGwobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0VGltZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzTnVsbCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25JbnB1dENoYW5nZWQobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobmV3VmFsdWUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb25JbnB1dENoYW5nZWQobmV3VmFsdWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIHR5cGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLl9pbml0aWFsaXplVHlwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGlucHV0VHlwZSA9IHRoaXMuX3R5cGU7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXR0ZXJuID0gdGhpcy5fcGF0dGVybiB8fCAvW1xcU1xcc10qLztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0aW9uID0gdGhpcy5fdmFsaWRhdGlvbiB8fCB0aGlzLl9wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZW1haWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuIHx8IC9bXFxTXFxzXSovO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSB0aGlzLl92YWxpZGF0aW9uIHx8IHRoaXMuX3JlZ2V4LnZhbGlkYXRlRW1haWw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwYXNzd29yZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGF0dGVybiA9IHRoaXMuX3BhdHRlcm4gfHwgL1tcXFNcXHNdKi87XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGlvbiA9IHRoaXMuX3ZhbGlkYXRpb24gfHwgdGhpcy5fcGF0dGVybjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3RlbGVwaG9uZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRUeXBlID0gJ3RlbCc7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd0ZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuIHx8IHRoaXMuX3JlZ2V4LnZhbGlkYXRlVGVsZXBob25lO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSB0aGlzLl92YWxpZGF0aW9uIHx8IHRoaXMuX3BhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhdHRlcm4gPSB0aGlzLl9wYXR0ZXJuIHx8IC9eWzAtOVxcLixdKiQvO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb24gPSB0aGlzLl92YWxpZGF0aW9uIHx8IHRoaXMuX3BhdHRlcm47XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRUeXBlID0gJ3RlbCc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdoaWRkZW4nOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncmFkaW8nOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhpbnB1dFR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IFwiICsgdGhpcy50eXBlICsgXCIuIFBsZWFzZSB1c2UgYSBcIiArIF9fUmFkaW8gKyBcIiBpbnN0ZWFkLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKGlucHV0VHlwZSArIFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgXCIgKyB0aGlzLnR5cGUgKyBcIi4gUGxlYXNlIHVzZSBhIFwiICsgX19DaGVja2JveCArIFwiIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JhbmdlJzpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoaW5wdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSBcIiArIHRoaXMudHlwZSArIFwiLiBQbGVhc2UgdXNlIGEgXCIgKyBfX1NsaWRlciArIFwiIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhpbnB1dFR5cGUgKyBcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IFwiICsgdGhpcy50eXBlICsgXCIuIFBsZWFzZSB1c2UgYSBcIiArIF9fRmlsZSArIFwiIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKGlucHV0VHlwZSArIFwiIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkIGJ5IFwiICsgdGhpcy50eXBlICsgXCIuIERlZmF1bHRpbmcgdG8gdHlwZT1cXFwidGV4dFxcXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9ICd0ZXh0JztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXR0ZXJuID0gdGhpcy5fcGF0dGVybiB8fCAvW1xcU1xcc10qLztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0aW9uID0gdGhpcy5fdmFsaWRhdGlvbiB8fCB0aGlzLl9wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFRleHRFdmVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGEgdGV4dCBldmVudCBsaXN0ZW5lciB0byB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbnB1dC5wcm90b3R5cGUuX2FkZFRleHRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmVsZW1lbnQsIGNvbXBhdCA9IHRoaXMuX2NvbXBhdCwgdXRpbHMgPSB0aGlzLnV0aWxzLCBjb21wb3NpbmcgPSBmYWxzZSwgdGltZW91dCwgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fb25JbnB1dCgpO1xyXG4gICAgICAgICAgICB9LCBwb3N0cG9uZWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24odGltZW91dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gdXRpbHMucG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQoY29tcGF0LkFORFJPSUQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdjb21wb3NpdGlvbnN0YXJ0JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNvbXBvc2luZyA9IHRydWUpOyB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdjb21wb3NpdGlvbmVuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudExpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXBhdC5oYXNFdmVudCgnaW5wdXQnKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAnaW5wdXQnLCBldmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoaW5wdXQsICdrZXlkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGV2LmtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gOTEgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID09PSA5MiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ID4gMTUgJiYga2V5IDwgMjgpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXkgPiAzMiAmJiBrZXkgPCA0MSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IF90aGlzLl9wYXR0ZXJuLCBjaGFyID0gZXYuY2hhcjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShwYXR0ZXJuLnRlc3QoY2hhcikgJiYgcGF0dGVybi50ZXN0KGlucHV0LnZhbHVlICsgY2hhcikpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAnY3V0JywgcG9zdHBvbmVkRXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAncGFzdGUnLCBwb3N0cG9uZWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGlucHV0LCAnY2hhbmdlJywgZXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGV2ZW50IGhhbmRsZXIgdXBvbiB1c2VyIHRleHQgaW5wdXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLl9vbklucHV0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgdmFsdWUgPSBlbGVtZW50LnZhbHVlLCBzdHJpcHBlZFZhbHVlID0gdGhpcy5fc3RyaXBJbnB1dChlbGVtZW50LnZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBzdHJpcHBlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnQudmFsdWUgPSBzdHJpcHBlZFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBlbGVtZW50LnZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCh0aGlzLnZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBldmVudCBoYW5kbGVyIHVwb24gYm91bmQgdGV4dCBiZWluZyBjaGFuZ2VkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBib3VuZCB0ZXh0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIElucHV0LnByb3RvdHlwZS5fb25JbnB1dENoYW5nZWQgPSBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5fc3RyaXBJbnB1dChuZXdWYWx1ZSk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXJzZXMgdGhlIGlucHV0IGFuZCBzdHJpcHMgaXQgb2YgY2hhcmFjdGVycyB0aGF0IGRvbid0IGZpdCBpdHMgcGF0dGVybi5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIGN1cnJlbnQgdmFsdWUgdG8gcGFyc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgSW5wdXQucHJvdG90eXBlLl9zdHJpcElucHV0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9ICcnLCByZXZlcnQgPSBuZXdWYWx1ZSwgY2hhciwgcGF0dGVybiA9IHRoaXMuX3BhdHRlcm4sIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY2hhciA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlICs9IGNoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0ID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IHJldmVydDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgSW5wdXQuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2NvbXBhdDogX19Db21wYXQsXHJcbiAgICAgICAgICAgIF9yZWdleDogX19SZWdleFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIElucHV0O1xyXG4gICAgfShwbGF0LnVpLkJpbmRDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuSW5wdXQgPSBJbnB1dDtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX0lucHV0LCBJbnB1dCk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIEJpbmRDb250cm9sIHRoYXQgc3RhbmRhcmRpemVzIGFuZCBzdHlsZXNcclxuICAgICAqIGFuIEhUTUwgaW5wdXRbdHlwZT1cImZpbGVcIl0gZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgdmFyIEZpbGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhGaWxlLCBfc3VwZXIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIEZpbGUoKSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIEhUTUwgdGVtcGxhdGUgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlU3RyaW5nID0gJzxkaXYgY2xhc3M9XCJwbGF0LWZpbGUtY29udGFpbmVyXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiIGNsYXNzPVwicGxhdC1maWxlLWhpZGRlblwiIC8+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwicGxhdC1maWxlLWlucHV0XCIgcGxhdC1rZXlkb3duPVwiX29uS2V5RG93blwiIC8+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxidXR0b24gY2xhc3M9XCJwbGF0LWZpbGUtYnV0dG9uXCIgcGxhdC10YXA9XCJfc2VsZWN0RmlsZXNcIj48L2J1dHRvbj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgdGhlICdjaGFuZ2UnIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0ZpbGUgKyBcIiBcIiArIChjbGFzc05hbWUgfHwgJycpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgY2xhc3MgbmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCBhbGwgSFRNTEVsZW1lbnQgcmVmZXJlbmNlcyBhbmQgcG90ZW50aWFsIGF0dHJpYnV0ZSBjb250cm9scy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGhpZGRlbklucHV0ID0gdGhpcy5faGlkZGVuSW5wdXQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmZpcnN0RWxlbWVudENoaWxkLCB2aXNpYmxlSW5wdXQgPSB0aGlzLl92aXNpYmxlSW5wdXQgPSBoaWRkZW5JbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcsIGJ1dHRvbklucHV0ID0gdmlzaWJsZUlucHV0Lm5leHRFbGVtZW50U2libGluZywgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcywga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgY29udHJvbEluamVjdG9ycyA9IHBsYXQuZGVwZW5kZW5jeS5pbmplY3RvcnMuY29udHJvbCwgYXR0clJlZ2V4ID0gL3BsYXQtKD86Y29udHJvbHxoaWRlfGNvbnRleHQpfGNsYXNzfHN0eWxlLywgaGFzTXVsdGlwbGUgPSBmYWxzZSwgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc051bGwgPSB1dGlscy5pc051bGwsIGRlbGltaXQgPSB1dGlscy5kZWxpbWl0LCBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nLCBrZXksIG5hbWUsIHZhbHVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IGRlbGltaXQoa2V5LCAnLScpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhdHRyaWJ1dGVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3RyaW5nKHZhbHVlKSB8fCBhdHRyUmVnZXgudGVzdChuYW1lKSB8fCAhaXNOdWxsKGNvbnRyb2xJbmplY3RvcnNbbmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IF9fRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUlucHV0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbklucHV0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2lkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbklucHV0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnbXVsdGlwbGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzTXVsdGlwbGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbklucHV0LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZGlzYWJsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBidXR0b25JbnB1dC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuSW5wdXQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNOdWxsKHRoaXMuaW5uZXJUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbklucHV0LnRleHRDb250ZW50ID0gaGFzTXVsdGlwbGUgPyAnU2VsZWN0IGZpbGVzJyA6ICdTZWxlY3QgYSBmaWxlJztcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYnV0dG9uVGV4dCA9IHRoaXMuaW5uZXJUZW1wbGF0ZS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXHJ8XFxuL2csICcnKTtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRW1wdHkoYnV0dG9uVGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbklucHV0LnRleHRDb250ZW50ID0gaGFzTXVsdGlwbGUgPyAnU2VsZWN0IGZpbGVzJyA6ICdTZWxlY3QgYSBmaWxlJztcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidXR0b25JbnB1dC50ZXh0Q29udGVudCA9IGJ1dHRvblRleHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXQgdGhlIHN0eWxlIGFuZCBpbml0aWFsaXplIHRoZSBhY3Rpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGlkZGVuSW5wdXQgPSB0aGlzLl9oaWRkZW5JbnB1dCA9IHRoaXMuX2hpZGRlbklucHV0IHx8IHRoaXMuZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZUlucHV0ID0gdGhpcy5fdmlzaWJsZUlucHV0IHx8IGhpZGRlbklucHV0Lm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgICAgICAgdGhpcy5fYWRkQ2hhbmdlTGlzdGVuZXIoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdG8gdmFsaWRhdGUgdGhlIHVzZXIncyBpbnB1dC4gUmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBpcyBub3QgZW1wdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy51dGlscy5pc0VtcHR5KHRoaXMuX2hpZGRlbklucHV0LnZhbHVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyB0aGUgdXNlcidzIGlucHV0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGlkZGVuSW5wdXQgPSB0aGlzLl9oaWRkZW5JbnB1dDtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNFbXB0eShoaWRkZW5JbnB1dC52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoaWRkZW5JbnB1dC52YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IHRoaXMuX2hpZGRlbklucHV0ID0gaGlkZGVuSW5wdXQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQucmVwbGFjZUNoaWxkKGNsb25lLCBoaWRkZW5JbnB1dCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZENoYW5nZUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVJbnB1dC52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcignY2hhbmdlJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3RzIGFzIGEgcHJvZ3JhbW1hdGljIGNsaWNrIGZvciBmaWxlIHNlbGVjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5jbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0RmlsZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgRmlsZSBjb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGlkZGVuSW5wdXQgPSB0aGlzLl9oaWRkZW5JbnB1dCwgZmlsZXMgPSBoaWRkZW5JbnB1dC5maWxlcztcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKGZpbGVzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFoaWRkZW5JbnB1dC5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVzWzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmaWxlcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNhYmxlcyB0aGUgY29udHJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSAnZGlzYWJsZWQnLCB2aXNpYmxlSW5wdXQgPSB0aGlzLl92aXNpYmxlSW5wdXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbklucHV0LnNldEF0dHJpYnV0ZShkaXNhYmxlZCwgZGlzYWJsZWQpO1xyXG4gICAgICAgICAgICB2aXNpYmxlSW5wdXQuc2V0QXR0cmlidXRlKGRpc2FibGVkLCBkaXNhYmxlZCk7XHJcbiAgICAgICAgICAgIHZpc2libGVJbnB1dC5uZXh0RWxlbWVudFNpYmxpbmcuc2V0QXR0cmlidXRlKGRpc2FibGVkLCBkaXNhYmxlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoZGlzYWJsZWQsIGRpc2FibGVkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2wuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSAnZGlzYWJsZWQnLCB2aXNpYmxlSW5wdXQgPSB0aGlzLl92aXNpYmxlSW5wdXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2hpZGRlbklucHV0LnJlbW92ZUF0dHJpYnV0ZShkaXNhYmxlZCk7XHJcbiAgICAgICAgICAgIHZpc2libGVJbnB1dC5yZW1vdmVBdHRyaWJ1dGUoZGlzYWJsZWQpO1xyXG4gICAgICAgICAgICB2aXNpYmxlSW5wdXQubmV4dEVsZW1lbnRTaWJsaW5nLnJlbW92ZUF0dHJpYnV0ZShkaXNhYmxlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoZGlzYWJsZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGFsbG93cyB0aGlzIGNvbnRyb2wgdG8gb2JzZXJ2ZSBib3RoIHRoZSBib3VuZCBwcm9wZXJ0eSBpdHNlbGYgYXMgd2VsbCBhc1xyXG4gICAgICAgICAqIHBvdGVudGlhbCBjaGlsZCBwcm9wZXJ0aWVzIGlmIGJlaW5nIGJvdW5kIHRvIGFuIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQub2JzZXJ2YWJsZS5JSW1wbGVtZW50VHdvV2F5QmluZGluZ30gYmluZGVyIFRoZSBjb250cm9sIHRoYXQgZmFjaWxpdGF0ZXMgdGhlXHJcbiAgICAgICAgICogZGF0YWJpbmRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIHRleHQgaXMgc2V0IGV4dGVybmFsbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlIFRoZSBuZXcgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGZpbGUocykuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgb2YgdGhlIGJpbmRhYmxlIGZpbGUocykuXHJcbiAgICAgICAgICogQHBhcmFtIHt2b2lkfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5fc2V0Qm91bmRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUsIGlkZW50aWZpZXIsIGZpcnN0VGltZSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzO1xyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzRmlsZShuZXdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGlkZGVuSW5wdXQgPSB0aGlzLl9oaWRkZW5JbnB1dCwgZmlsZXMgPSBoaWRkZW5JbnB1dC5maWxlcztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChmaWxlcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWhpZGRlbklucHV0Lm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3VmFsdWUgIT09IGZpbGVzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoZmlsZXNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZpbGVzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoJ2NoYW5nZScpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyB0aGUgJ2NoYW5nZScgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGhpZGRlbiBpbnB1dFt0eXBlPWZpbGVdLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEZpbGUucHJvdG90eXBlLl9hZGRDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5faGlkZGVuSW5wdXQsICdjaGFuZ2UnLCB0aGlzLl9maWxlc1NlbGVjdGVkLCBmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBldmVudCBsaXN0ZW5lciB0byBoYW5kbGUgYSBcImtleWRvd25cIiBldmVudCBvbiB0aGUgdmlzaWJsZSBpbnB1dC5cclxuICAgICAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGV2IFRoZSBcImtleWRvd25cIiBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5fb25LZXlEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBldi5rZXlDb2RlLCBrZXlDb2RlcyA9IHBsYXQuY29udHJvbHMuS2V5Q29kZXM7XHJcbiAgICAgICAgICAgIGlmIChrZXkgPT09IGtleUNvZGVzLnRhYikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBrZXlDb2Rlcy5iYWNrc3BhY2UgfHwga2V5ID09PSBrZXlDb2Rlcy5kZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBLaWNrcyBvZmYgdGhlIGZpbGUgc2VsZWN0aW9uIHByb2Nlc3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRmlsZS5wcm90b3R5cGUuX3NlbGVjdEZpbGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oaWRkZW5JbnB1dC5jbGljaygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gZXZlbnQgaW5kaWNhdGluZyB0aGF0IGZpbGVzIGhhdmUgYmVlbiBzZWxlY3RlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5fZmlsZXNTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGhpZGRlbklucHV0ID0gdGhpcy5faGlkZGVuSW5wdXQsIHZpc2libGVJbnB1dCA9IHRoaXMuX3Zpc2libGVJbnB1dCwgZmlsZXMgPSBoaWRkZW5JbnB1dC5maWxlcztcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNFbXB0eShmaWxlcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaGlkZGVuSW5wdXQubXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlID0gZmlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlSW5wdXQudmFsdWUgPSBmaWxlLm5hbWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZChmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaWxlTmFtZXMgPSBbXSwgbGVuZ3RoXzEgPSBmaWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8xOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZXMucHVzaChmaWxlc1tpXS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZpc2libGVJbnB1dC52YWx1ZSA9IGZpbGVOYW1lcy5qb2luKCcsICcpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmlsZXMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyKCdjaGFuZ2UnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyaWdnZXJzIGFuIGV2ZW50IHN0YXJ0aW5nIGZyb20gdGhpcyBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBGaWxlLnByb3RvdHlwZS5fdHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBwbGF0LmFjcXVpcmUoX19Eb21FdmVudEluc3RhbmNlKTtcclxuICAgICAgICAgICAgZG9tRXZlbnQuaW5pdGlhbGl6ZSh0aGlzLmVsZW1lbnQsIGV2ZW50KTtcclxuICAgICAgICAgICAgZG9tRXZlbnQudHJpZ2dlcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgRmlsZS5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEZpbGU7XHJcbiAgICB9KHBsYXQudWkuQmluZENvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5GaWxlID0gRmlsZTtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX0ZpbGUsIEZpbGUpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBleHRlbnNpb24gb2YgdGhlIEZvckVhY2ggdGhhdCBhY3RzIGFzIGEgSFRNTCB0ZW1wbGF0ZSBjYXJvdXNlbFxyXG4gICAgICogYW5kIGNhbiBiaW5kIHRoZSBzZWxlY3RlZCBpbmRleCB0byBhIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICB2YXIgQ2Fyb3VzZWwgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhDYXJvdXNlbCwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBDYXJvdXNlbCgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTCB0ZW1wbGF0ZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSAnPGRpdiBjbGFzcz1cInBsYXQtY2Fyb3VzZWwtdmlld3BvcnRcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtY2Fyb3VzZWwtY29udGFpbmVyXCI+PC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBzZXQgb2YgZnVuY3Rpb25zIGFkZGVkIGV4dGVybmFsbHkgdGhhdCBsaXN0ZW5zXHJcbiAgICAgICAgICAgICAqIGZvciBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb250cm9sIGlzIHZlcnRpY2FsIG9yIGhvcml6b250YWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc1ZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBoYXMgc3dpcGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faGFzU3dpcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdXNlciBpcyBjdXJyZW50bHkgdG91Y2hpbmcgdGhlIHNjcmVlbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2luVG91Y2ggPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIGN1cnJlbnRseSB0b3VjaGluZyB0aGUgc2NyZWVuIGFuZCBoYXMgbW92ZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGxhc3QgdG91Y2ggc3RhcnQgcmVjb3JkZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2ggPSB7IHg6IDAsIHk6IDAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBjb250cm9sIGhhcyBiZWVuIGxvYWRlZCBiYXNlZCBvbiBpdHMgY29udGV4dCBiZWluZyBhbiBBcnJheS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgaW5kZXggc2VlbiBpbiB0aGUgQ2Fyb3VzZWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIHByZXZpb3VzIGluZGV4IG9mIHRoZSBDYXJvdXNlbCBpbiByZWxhdGlvbiB0byB0aGUgaXRlbSBub2Rlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBuZXh0IGluZGV4IG9mIHRoZSBDYXJvdXNlbCBpbiByZWxhdGlvbiB0byB0aGUgaXRlbSBub2Rlcy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX25leHRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgb2Zmc2V0IG9mIHRoZSB0cmFuc2xhdGVkIENhcm91c2VsJ3Mgc2xpZGluZyBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjbGVhciB0aGUgYXV0byBzY3JvbGwgaW50ZXJ2YWwuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJbnRlcnZhbCA9IG5vb3A7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gdXNlZCB0byBjbGVhciB0aGUgc3VzcGVuZGVkIGF1dG8gc2Nyb2xsIGludGVydmFsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3VzcGVuZCA9IG5vb3A7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBhdXRvbWF0aWMgc2Nyb2xsaW5nIGlzIGVuYWJsZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc0F1dG8gPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGF1dG9tYXRpYyBzY3JvbGxpbmcgaXMgY3VycmVudGx5IHBhdXNlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgY29udHJvbCBpcyByZXNwb25zaWJsZSBmb3IgcGF1c2luZyBpdHNlbGYuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxmUGF1c2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIEFycmF5IG9mIGFsbCB0aGUgY3VycmVudCBub2RlcyBpbiB0aGUgY29udHJvbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1Ob2RlcyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSBjb2xsZWN0aW9uIG9mIHJlbW92ZSBsaXN0ZW5lcnMgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yIGV2ZW50cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHN0YXJ0IG91dGVyIGl0ZW0gbm9kZSBoYXMgYmVlbiBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX291dGVyU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBlbmQgb3V0ZXIgaXRlbSBub2RlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fb3V0ZXJFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGludGVydmFsIGNvbnN0YW50IHVzZWQgdG8gcmVndWxhdGUgdGhlIHNwZWVkIG9mIHRoZSBhdXRvIHNjcm9sbFxyXG4gICAgICAgICAgICAgKiB3aGVuIHRoZSBnb1RvSW5kZXggZnVuY3Rpb24gaXMgY2FsbGVkIGFuZCBpcyBub3QgZGlyZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fZ29Ub0ludGVydmFsQ29uc3RhbnQgPSAxMjU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDYXJvdXNlbC5wcm90b3R5cGUsIFwiaW5kZXhcIiwge1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIENhcm91c2VsLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5kZXg7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0Nhcm91c2VsICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGNvbnRyb2wgaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIG90aGVyd2lzZSBpdCBkb2VzIHNvLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbmV3VmFsdWUgVGhlIG5ldyBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gb2xkVmFsdWUgVGhlIG9sZCBhcnJheSBjb250ZXh0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5jb250ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24odGhpcy5fb25Mb2FkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzQXJyYXkobmV3VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1Zyh0aGlzLnR5cGUgKyBcIiBjb250ZXh0IHNldCB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBBcnJheS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVFdmVudChbe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3BsaWNlJ1xyXG4gICAgICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbmRleCgwKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRlZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluc2VydHMgdGhlIGlubmVySFRNTCBvZiB0aGlzIGNvbnRyb2wgaW50byBhIGNoaWxkIEZvckVhY2ggY29udHJvbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtQ29udGFpbmVyID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXIuY2xhc3NOYW1lID0gX19DYXJvdXNlbCArIFwiLWl0ZW1cIjtcclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmlubmVyVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZCgnaXRlbScsIGl0ZW1Db250YWluZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGNvbnRleHQgYW5kIHdhcm5zIGlmIG5vdCBhbiBBcnJheSwgdGhlbiBpbml0aWFsaXplcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkoY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiVGhlIGNvbnRleHQgb2YgYSBcIiArIHRoaXMudHlwZSArIFwiIG11c3QgYmUgYW4gQXJyYXkuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4dGVuZGluZyB0aGUgRm9yRWFjaCwgd2UgbXVzdCBzZXQgdGhpcyBhbmltYXRlIHRvIGZhbHNlIGFzIGl0IHJlZmVycyB0byBpdGVtIG1hbmlwdWxhdGlvbi4gXHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbk9iaiA9IHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCB7fSwgaW5kZXggPSBvcHRpb25zLmluZGV4LCBpc051bWJlciA9IHV0aWxzLmlzTnVtYmVyLCBvcmllbnRhdGlvbiA9IHRoaXMuX3ZhbGlkYXRlT3JpZW50YXRpb24ob3B0aW9ucy5vcmllbnRhdGlvbiksIGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbCwgaW50ZXJ2YWxOdW0gPSB0aGlzLl9pbnRlcnZhbCA9IGlzTnVtYmVyKGludGVydmFsKSA/IE1hdGguYWJzKGludGVydmFsKSA6IDMwMDAsIHN1c3BlbmQgPSBvcHRpb25zLnN1c3BlbmQsIGRvbSA9IHRoaXMuZG9tLCBlbGVtZW50ID0gdGhpcy5lbGVtZW50LCB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0ID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdmlld3BvcnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSBvcHRpb25zLnR5cGUgfHwgJ3RyYWNrIHN3aXBlJztcclxuICAgICAgICAgICAgdGhpcy5faXNJbmZpbml0ZSA9IG9wdGlvbnMuaW5maW5pdGUgPT09IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1c3BlbmQgPSBNYXRoLmFicyhpc051bWJlcihzdXNwZW5kKSA/IGludGVydmFsTnVtIC0gc3VzcGVuZCA6IGludGVydmFsTnVtIC0gMzAwMCk7XHJcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyBvcmllbnRhdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX29uTG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXRJbmRleCA9IF90aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gaXNOdW1iZXIoaW5kZXgpICYmIGluZGV4ID49IDAgPyBpbmRleCA8IGNvbnRleHQubGVuZ3RoID8gaW5kZXggOiAoY29udGV4dC5sZW5ndGggLSAxKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgZG9tLndoZW5WaXNpYmxlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZUluZGV4KGluZGV4ID09PSBudWxsID8gc2V0SW5kZXggOiBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9LCBlbGVtZW50KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWR2YW5jZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBDYXJvdXNlbCB0byB0aGUgbmV4dCBzdGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuZ29Ub05leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nb1RvTmV4dChmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiB0aGUgQ2Fyb3VzZWwgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5nb1RvUHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nb1RvUHJldmlvdXMoZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIHRoZSBzdGF0ZVxyXG4gICAgICAgICAqIHNwZWNpZmllZCBieSB0aGUgaW5wdXQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBuZXcgaW5kZXggb2YgdGhlIENhcm91c2VsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlyZWN0PyBJZiB0cnVlLCB3aWxsIGdvIHN0cmFpZ2h0IHRvIHRoZSBzcGVjaWZpZWQgaW5kZXggd2l0aG91dCB0cmFuc2l0aW9uaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5nb1RvSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGRpcmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ29Ub0luZGV4KGluZGV4LCBmYWxzZSwgZGlyZWN0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0b3BzIGF1dG8gc2Nyb2xsaW5nIGlmIGF1dG8gc2Nyb2xsaW5nIGlzIGVuYWJsZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxmUGF1c2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG8gfHwgdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN1c3BlbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU3VzcGVuZCA9IG5vb3A7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsID0gbm9vcDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc3VtZXMgYXV0byBzY3JvbGxpbmcgaWYgYXV0byBzY3JvbGxpbmcgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoISh0aGlzLl9pc0F1dG8gJiYgdGhpcy5faXNQYXVzZWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0aGlzLl9zZWxmUGF1c2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhdGVJbnRlcnZhbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xlYW4gdXAgdGhlIGF1dG8gc2Nyb2xsIGludGVydmFsIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVycygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBiaW5kYWJsZSBwcm9wZXJ0eSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5JUHJvcGVydHlDaGFuZ2VkTGlzdGVuZXI8YW55Pn0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRoYXQgYWN0cyBhcyBhIGxpc3RlbmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5vbklucHV0ID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gdGhhdCBzaWduaWZpZXMgd2hlbiB0aGlzIGNvbnRyb2wncyBiaW5kYWJsZSBwcm9wZXJ0eSBoYXMgY2hhbmdlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgYWZ0ZXIgdGhlIGNoYW5nZS5cclxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb2xkVmFsdWU/IFRoZSBvbGQgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHByaW9yIHRvIHRoZSBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLmlucHV0Q2hhbmdlZCA9IGZ1bmN0aW9uIChuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMsIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHRoaXMgY29udHJvbCB0byBvYnNlcnZlIGJvdGggdGhlIGJvdW5kIHByb3BlcnR5IGl0c2VsZiBhcyB3ZWxsIGFzXHJcbiAgICAgICAgICogcG90ZW50aWFsIGNoaWxkIHByb3BlcnRpZXMgaWYgYmVpbmcgYm91bmQgdG8gYW4gb2JqZWN0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC5vYnNlcnZhYmxlLklJbXBsZW1lbnRUd29XYXlCaW5kaW5nfSBiaW5kZXIgVGhlIGNvbnRyb2wgdGhhdCBmYWNpbGl0YXRlcyB0aGVcclxuICAgICAgICAgKiBkYXRhYmluZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUub2JzZXJ2ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoYmluZGVyKSB7XHJcbiAgICAgICAgICAgIGJpbmRlci5vYnNlcnZlUHJvcGVydHkodGhpcy5fc2V0Qm91bmRQcm9wZXJ0eSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGJpbmRhYmxlIGluZGV4IGlzIHNldCBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgbmV3IHZhbHVlIG9mIHRoZSBiaW5kYWJsZSBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSBvZiB0aGUgYmluZGFibGUgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHt2b2lkfSBpZGVudGlmaWVyIFRoZSBjaGlsZCBpZGVudGlmaWVyIG9mIHRoZSBwcm9wZXJ0eSBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0VGltZT8gV2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCB0byBiaW5kIHRoZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldEJvdW5kUHJvcGVydHkgPSBmdW5jdGlvbiAoaW5kZXgsIG9sZFZhbHVlLCBpZGVudGlmaWVyLCBmaXJzdFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscztcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaXJzdFRpbWUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdXRpbHMuaXNOdW1iZXIoaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IE51bWJlcihpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVtYmVyKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKHRoaXMudHlwZSArIFwiIGhhcyBpdHMgaW5kZXggYm91bmQgdG8gYSBwcm9wZXJ0eSB0aGF0IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhIE51bWJlci5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZWQoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluZGV4KDApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dvVG9JbmRleChpbmRleCwgdHJ1ZSwgZmlyc3RUaW1lID09PSB0cnVlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIGl0cyBjdXJyZW50IHN0YXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25PcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKDApO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWF0ZUFuaW1hdGlvbih7IHByb3BlcnRpZXM6IGFuaW1hdGlvbk9wdGlvbnMgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgY29udGV4dCBhbGlnbnMgd2l0aCB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fdmVyaWZ5TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dCwgaW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzQXJyYXkoY29udGV4dCkgfHwgY29udGV4dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc1VuZGVmaW5lZChpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlZCgodGhpcy5faW5kZXggPSB1bmRlZmluZWQpLCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKC10aGlzLl9jdXJyZW50T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0Fycm93cygpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IGNvbnRleHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ29Ub0luZGV4KG1heEluZGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jaGVja0Fycm93cygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgcHJldmlvdXMgYW5kIG5leHQgaW5kaWNlcyBpbiByZWxhdGlvbiB0byBpdGVtIG5vZGVzIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBpbmRleC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3NldEluZGV4V2luZG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleCwgbGFzdEluZGV4ID0gdGhpcy5faXRlbU5vZGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gdGhpcy5fbmV4dEluZGV4ID0gbGFzdEluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID49IGxhc3RJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9pbmRleCA9IGxhc3RJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSBpbmRleCAtIDE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0SW5kZXggPSB0aGlzLl9pc0luZmluaXRlID8gMCA6IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzSW5kZXggPSB0aGlzLl9pc0luZmluaXRlID8gbGFzdEluZGV4IDogLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXh0SW5kZXggPSBpbmRleCArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0luZGV4ID0gaW5kZXggLSAxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmV4dEluZGV4ID0gaW5kZXggKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZHZhbmNlcyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIHRoZSBuZXh0IHN0YXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXRDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHRoaXMgd2FzIHRoZSByZXN1bHQgb2YgYSBib3VuZCBpbnB1dCBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9nb1RvTmV4dCA9IGZ1bmN0aW9uIChpbnB1dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UuYWxsKHRoaXMuX2FkZFF1ZXVlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9pbmRleCwgcmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICgoaW5kZXggPj0gX3RoaXMuX2l0ZW1Ob2Rlcy5sZW5ndGggLSAxKSAmJiAhKHJlc2V0ID0gX3RoaXMuX2lzSW5maW5pdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc0F1dG8gJiYgIV90aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VsZlBhdXNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9Qcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IF90aGlzLl9nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdvVG9JbmRleChfdGhpcy5fbmV4dEluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9vdXRlckVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZU91dGVyTm9kZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zW190aGlzLl90cmFuc2Zvcm1dID0gX3RoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKC1sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBfdGhpcy5faW5pdGlhdGVBbmltYXRpb24oeyBwcm9wZXJ0aWVzOiBhbmltYXRpb25PcHRpb25zIH0pLCBuZXh0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbmRleCA9IG5leHRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSArK190aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKF90aGlzLl9pbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlTmV4dChuZXh0SW5kZXgsIGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja0Fycm93cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBDYXJvdXNlbCB0byB0aGUgcHJldmlvdXMgc3RhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dENoYW5nZWQgV2hldGhlciBvciBub3QgdGhpcyB3YXMgdGhlIHJlc3VsdCBvZiBhIGJvdW5kIGlucHV0IGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2dvVG9QcmV2aW91cyA9IGZ1bmN0aW9uIChpbnB1dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UuYWxsKHRoaXMuX2FkZFF1ZXVlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLl9pbmRleCwgcmVzZXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8PSAwICYmICEocmVzZXQgPSBfdGhpcy5faXNJbmZpbml0ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX1Byb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5fc2VsZlBhdXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gX3RoaXMuX2dldExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ29Ub0luZGV4KF90aGlzLl9wcmV2aW91c0luZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9vdXRlclN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWFsaXplT3V0ZXJOb2RlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbX3RoaXMuX3RyYW5zZm9ybV0gPSBfdGhpcy5fY2FsY3VsYXRlU3RhdGljVHJhbnNsYXRpb24obGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gX3RoaXMuX2luaXRpYXRlQW5pbWF0aW9uKHsgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9ucyB9KSwgcHJldmlvdXNJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luZGV4ID0gcHJldmlvdXNJbmRleCA9IF90aGlzLl9pdGVtTm9kZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXggPSAtLV90aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbnB1dENoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKF90aGlzLl9pbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlUHJldmlvdXMocHJldmlvdXNJbmRleCwgLWxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jaGVja0Fycm93cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBDYXJvdXNlbCB0byB0aGUgc3RhdGVcclxuICAgICAgICAgKiBzcGVjaWZpZWQgYnkgdGhlIGlucHV0IGluZGV4LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgbmV3IGluZGV4IG9mIHRoZSBDYXJvdXNlbC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlucHV0Q2hhbmdlZCBXaGV0aGVyIG9yIG5vdCB0aGlzIHdhcyB0aGUgcmVzdWx0IG9mIGEgYm91bmQgaW5wdXQgY2hhbmdlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlyZWN0PyBJZiB0cnVlLCB3aWxsIGdvIHN0cmFpZ2h0IHRvIHRoZSBzcGVjaWZpZWQgaW5kZXggd2l0aG91dCB0cmFuc2l0aW9uaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ29Ub0luZGV4ID0gZnVuY3Rpb24gKGluZGV4LCBpbnB1dENoYW5nZWQsIGRpcmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwodGhpcy5fYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4ID0gX3RoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnV0aWxzLmlzVW5kZWZpbmVkKG9sZEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWFsaXplSW5kZXgoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKF90aGlzLl9pbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2lzSW5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgX3RoaXMuY29udGV4dC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGZQYXVzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9pc0F1dG8gJiYgIV90aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxmUGF1c2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IG9sZEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9Qcm9taXNlLnJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlyZWN0ID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemVJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5wdXRDaGFuZ2VkKF90aGlzLl9pbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2lzSW5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgX3RoaXMuY29udGV4dC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX3NlbGZQYXVzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLl9pc0F1dG8gJiYgIV90aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZWxmUGF1c2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggLSBvbGRJbmRleCA+IDAgJiYgaW5kZXggPT09IF90aGlzLl9uZXh0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dvVG9OZXh0KGlucHV0Q2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gX3RoaXMuX3ByZXZpb3VzSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX2dvVG9QcmV2aW91cyhpbnB1dENoYW5nZWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9oYW5kbGVHb1RvSW5kZXgoaW5kZXgsIGlucHV0Q2hhbmdlZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIENhcm91c2VsIHRvIHRoZSBzdGF0ZVxyXG4gICAgICAgICAqIHNwZWNpZmllZCBieSB0aGUgaW5wdXQgaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBuZXcgaW5kZXggb2YgdGhlIENhcm91c2VsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXRDaGFuZ2VkIFdoZXRoZXIgb3Igbm90IHRoaXMgd2FzIHRoZSByZXN1bHQgb2YgYSBib3VuZCBpbnB1dCBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVHb1RvSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGlucHV0Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICB2YXIgb2xkSW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBvbGRJbmRleCB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jb250ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc2VsZlBhdXNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZ2V0TGVuZ3RoKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbmRleChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfUHJvbWlzZSA9IHRoaXMuX1Byb21pc2UsIGRlZmVyID0gdGhpcy51dGlscy5kZWZlciwgbW92ZSwgZGlmZiwgcmV2ZXJzZURpZmY7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IG9sZEluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlID0gdGhpcy5fZ29Ub05leHQ7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gaW5kZXggLSBvbGRJbmRleDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luZmluaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZURpZmYgPSB0aGlzLl9pdGVtTm9kZXMubGVuZ3RoIC0gaW5kZXggKyBvbGRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmV2ZXJzZURpZmYgPCBkaWZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdmUgPSB0aGlzLl9nb1RvUHJldmlvdXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSByZXZlcnNlRGlmZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb3ZlID0gdGhpcy5fZ29Ub1ByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IG9sZEluZGV4IC0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNJbmZpbml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldmVyc2VEaWZmID0gdGhpcy5faXRlbU5vZGVzLmxlbmd0aCAtIG9sZEluZGV4ICsgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVyc2VEaWZmIDwgZGlmZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3ZlID0gdGhpcy5fZ29Ub05leHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmYgPSByZXZlcnNlRGlmZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbW92ZSA9IG1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW10sIHJlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3JlbW92ZUxpc3RlbmVycywgY29uc3RhbnQgPSB0aGlzLl9nb1RvSW50ZXJ2YWxDb25zdGFudCwgaW50ZXJ2YWwgPSAwLCBtb3ZlciA9IGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlID0gZGVmZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVJbmRleCA9IHJlbW92ZUxpc3RlbmVycy5pbmRleE9mKHJlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMuc3BsaWNlKHJlbW92ZUluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtb3ZlKGlucHV0Q2hhbmdlZCkpO1xyXG4gICAgICAgICAgICAgICAgfSwgaW50ZXJ2YWwgKz0gTWF0aC5yb3VuZChjb25zdGFudCAvIGRpZmYpKTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHJlbW92ZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdoaWxlICgtLWRpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKG5ldyBfUHJvbWlzZShtb3ZlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gobW92ZShpbnB1dENoYW5nZWQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIF9Qcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCByZXN1bHRzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIHN3YXBwaW5nIGFuZCB0cmFuc2xhdGluZyBub2RlcyBmb3IgYSBcIm5leHRcIiBvcGVyYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBuZXcgaW5kZXggYXQgdGhlIHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggdG8gc3RhdGljYWxseSB0cmFuc2l0aW9uIGJhY2sgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9oYW5kbGVOZXh0ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGlzSW5maW5pdGUgPSB0aGlzLl9pc0luZmluaXRlLCBpdGVtTm9kZXMgPSB0aGlzLl9pdGVtTm9kZXMsIG5vZGVMZW5ndGggPSBpdGVtTm9kZXMubGVuZ3RoLCBpc05vZGUgPSB0aGlzLnV0aWxzLmlzTm9kZTtcclxuICAgICAgICAgICAgaWYgKGlzSW5maW5pdGUgJiYgKG5vZGVMZW5ndGggPCAzIHx8IGlzTm9kZSh0aGlzLl9wcmVDbG9uZWROb2RlKSB8fCBpc05vZGUodGhpcy5fcG9zdENsb25lZE5vZGUpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluZGV4KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3V0ZXJTdGFydCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5maW5pdGUgfHwgaW5kZXggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1t0aGlzLl9wcmV2aW91c0luZGV4XSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMsIDAsIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGVbdGhpcy5fdHJhbnNmb3JtXSA9IHRoaXMuX2NhbGN1bGF0ZVN0YXRpY1RyYW5zbGF0aW9uKGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9yY2VSZXBhaW50KGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRlclN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbmRleFdpbmRvdygpO1xyXG4gICAgICAgICAgICBpZiAoIShpc0luZmluaXRlIHx8IGluZGV4IDwgbm9kZUxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShpdGVtTm9kZXNbdGhpcy5fbmV4dEluZGV4XSwgbnVsbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIHN3YXBwaW5nIGFuZCB0cmFuc2xhdGluZyBub2RlcyBmb3IgYSBcInByZXZpb3VzXCIgb3BlcmF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgbmV3IGluZGV4IGF0IHRoZSB0aW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbGVuZ3RoIHRvIHN0YXRpY2FsbHkgdHJhbnNpdGlvbiBiYWNrIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faGFuZGxlUHJldmlvdXMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgaXNJbmZpbml0ZSA9IHRoaXMuX2lzSW5maW5pdGUsIGl0ZW1Ob2RlcyA9IHRoaXMuX2l0ZW1Ob2Rlcywgbm9kZUxlbmd0aCA9IGl0ZW1Ob2Rlcy5sZW5ndGgsIGlzTm9kZSA9IHRoaXMudXRpbHMuaXNOb2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNJbmZpbml0ZSAmJiAobm9kZUxlbmd0aCA8IDMgfHwgaXNOb2RlKHRoaXMuX3ByZUNsb25lZE5vZGUpIHx8IGlzTm9kZSh0aGlzLl9wb3N0Q2xvbmVkTm9kZSkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRlckVuZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5maW5pdGUgfHwgaW5kZXggPCBub2RlTGVuZ3RoIC0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmluc2VydEJlZm9yZShpdGVtTm9kZXNbdGhpcy5fbmV4dEluZGV4XSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMsIC0zKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRlckVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0SW5kZXhXaW5kb3coKTtcclxuICAgICAgICAgICAgaWYgKCEoaXNJbmZpbml0ZSB8fCBpbmRleCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShpdGVtTm9kZXNbdGhpcy5fcHJldmlvdXNJbmRleF0sIGNvbnRhaW5lci5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlW3RoaXMuX3RyYW5zZm9ybV0gPSB0aGlzLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbihsZW5ndGgpO1xyXG4gICAgICAgICAgICB0aGlzLl9mb3JjZVJlcGFpbnQoY29udGFpbmVyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsZWFycyBhbGwgdGhlIGlubmVyIG5vZGVzIG9mIHRoZSBjb250cm9sLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fY2xlYXJJbm5lck5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVDbG9uZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0ZXJTdGFydCA9IHRoaXMuX291dGVyRW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBpdGVtTm9kZXMgPSB0aGlzLl9pdGVtTm9kZXM7XHJcbiAgICAgICAgICAgIGlmIChpdGVtTm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9jb250YWluZXIuY2hpbGROb2RlcyksIGluc2VydEJlZm9yZSA9IHRoaXMuZG9tLmluc2VydEJlZm9yZTtcclxuICAgICAgICAgICAgc3dpdGNoIChjaGlsZE5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5OlxyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZShpdGVtTm9kZXNbdGhpcy5fcHJldmlvdXNJbmRleF0sIGNoaWxkTm9kZXMuc3BsaWNlKDAsIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoaXRlbU5vZGVzW3RoaXMuX25leHRJbmRleF0sIGNoaWxkTm9kZXMuc3BsaWNlKC0zLCAzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1t0aGlzLl9pbmRleF0sIGNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5fbmV4dEluZGV4LCBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0IDwgMCB8fCBuZXh0ID09PSBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoaXRlbU5vZGVzW2luZGV4XSwgY2hpbGROb2Rlcy5zcGxpY2UoLTMsIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKGl0ZW1Ob2Rlc1tpbmRleCA9PT0gMCA/IHRoaXMuX3ByZXZpb3VzSW5kZXggKyAxIDogaW5kZXggLSAxXSwgY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoaXRlbU5vZGVzW25leHRdLCBjaGlsZE5vZGVzLnNwbGljZSgtMywgMykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZShpdGVtTm9kZXNbaW5kZXhdLCBjaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUoaXRlbU5vZGVzW3RoaXMuX2luZGV4XSwgY2hpbGROb2Rlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbml0aWFsaXplcyBpdGVtIG5vZGVzIGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG5ldyBpbmRleCBhdCB0aGUgdGltZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhbGl6ZUluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBpbm5lck5vZGVzQ2xlYXJlZCA9IHRoaXMuX2NsZWFySW5uZXJOb2RlcygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXRlbU5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRJbmRleFdpbmRvdygpO1xyXG4gICAgICAgICAgICBpZiAoIWlubmVyTm9kZXNDbGVhcmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh0aGlzLl9pdGVtTm9kZXNbaW5kZXhdLCBudWxsKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlW3RoaXMuX3RyYW5zZm9ybV0gPSB0aGlzLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbigtdGhpcy5fY3VycmVudE9mZnNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvcmNlUmVwYWludChjb250YWluZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplT3V0ZXJOb2RlcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja0Fycm93cygpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHByZSBhbmQgcG9zdCBpdGVtIG5vZGVzIGZvciB0aGUgY3VycmVudCBpbmRleC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXRpYWxpemVPdXRlck5vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRlclN0YXJ0ID0gdGhpcy5fb3V0ZXJFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaXRlbU5vZGVzID0gdGhpcy5faXRlbU5vZGVzLCBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsIG5vZGVMZW5ndGggPSBpdGVtTm9kZXMubGVuZ3RoLCBub2RlVG9JbnNlcnQ7XHJcbiAgICAgICAgICAgIGlmIChub2RlTGVuZ3RoIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0luZmluaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvbmVGb3JJbmZpbml0ZSgtbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNOb2RlID0gdGhpcy51dGlscy5pc05vZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX291dGVyRW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZVRvSW5zZXJ0ID0gaXRlbU5vZGVzW3RoaXMuX25leHRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZShub2RlVG9JbnNlcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0ZXJFbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChub2RlTGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3V0ZXJTdGFydCAmJiAodGhpcy5faXNJbmZpbml0ZSB8fCB0aGlzLl9pbmRleCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVUb0luc2VydCA9IGl0ZW1Ob2Rlc1t0aGlzLl9wcmV2aW91c0luZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZShub2RlVG9JbnNlcnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlW3RoaXMuX3RyYW5zZm9ybV0gPSB0aGlzLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbigtbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvcmNlUmVwYWludChjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0ZXJTdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9pc0luZmluaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xvbmVGb3JJbmZpbml0ZSgtbGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5pbWF0ZXMgdGhlIGNhcm91c2VsIHdpdGggYSBzZXQgb2YgY2hhcmFjdGVyaXN0aWNzIHBhc3NlZCBpbiBhcyBhbiBhcmd1bWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQuSU9iamVjdDxzdHJpbmc+fSBhbmltYXRpb25PcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nIGtleS12YWx1ZSBwYWlyc1xyXG4gICAgICAgICAqIG9mIHByb3BlcnRpZXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXRpYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1hdGlvbk9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvblRoZW5hYmxlID1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdG9yLmFuaW1hdGUodGhpcy5fY29udGFpbmVyLCBfX1RyYW5zaXRpb24sIGFuaW1hdGlvbk9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbnRyb2wgYW5kIGFkZHMgYWxsIGV2ZW50IGxpc3RlbmVycy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBhZGRRdWV1ZSA9IHRoaXMuX2FkZFF1ZXVlLCBpdGVtQ291bnQgPSB0aGlzLmNvbnRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRBbGlhc2VzKCk7XHJcbiAgICAgICAgICAgIHZhciBhZGRQcm9taXNlID0gdGhpcy5fYWRkSXRlbXMoMCwgaXRlbUNvdW50LCAwKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFkZFF1ZXVlLmluZGV4T2YoYWRkUHJvbWlzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9vbkxvYWQoKTtcclxuICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhcIkFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHByb2Nlc3NpbmcgdGhlIFwiICsgX3RoaXMudHlwZSArIFwiLiBQbGVhc2UgZW5zdXJlIHlvdSdyZSBjb250ZXh0IGlzIGNvcnJlY3QuXCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhpcyBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdHlwZXMgPSB0aGlzLl90eXBlLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKCd0YXAnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVUYXAoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZXMuaW5kZXhPZignc3dpcGUnKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVTd2lwZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlcy5pbmRleE9mKCd0cmFjaycpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVRyYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YoJ2F1dG8nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVBdXRvKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl93aW5kb3csICdyZXNpemUnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRMZW5ndGggPSBfdGhpcy5fbGVuZ3RoLCBsZW5ndGggPSBfdGhpcy5fZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZW5ndGggfHwgY3VycmVudExlbmd0aCA9PT0gbGVuZ3RoIHx8ICghX3RoaXMuX2lzSW5maW5pdGUgJiYgX3RoaXMuX2luZGV4ID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jb250YWluZXIuc3R5bGVbX3RoaXMuX3RyYW5zZm9ybV0gPSBfdGhpcy5fY2FsY3VsYXRlU3RhdGljVHJhbnNsYXRpb24oY3VycmVudExlbmd0aCAtIGxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzIG9uIHRoaXMgY29udHJvbCdzIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3JlbW92ZUxpc3RlbmVycztcclxuICAgICAgICAgICAgd2hpbGUgKHJlbW92ZUxpc3RlbmVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucG9wKCkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdXNwZW5kKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luZmluaXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDbG9uZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vbkxvYWQgPSBub29wO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlIHRoZSBjbG9uZXMgY2FzZSB3aGVyZSBpdGVtIGxlbmd0aCBpcyBsZXNzIHRoYW4gMy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBsZW5ndGggdG8gdHJhbnNsYXRlIHRoZSBvZmZzZXQgY2xvbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9jbG9uZUZvckluZmluaXRlID0gZnVuY3Rpb24gKGxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVDbG9uZXMoKTtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy51dGlscy5pc0FycmF5KGNvbnRleHQpIHx8IGNvbnRleHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG91dGVyU3RhcnQgPSB0aGlzLl9vdXRlclN0YXJ0LCBvdXRlckVuZCA9IHRoaXMuX291dGVyRW5kO1xyXG4gICAgICAgICAgICBpZiAob3V0ZXJTdGFydCAmJiBvdXRlckVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcbiAgICAgICAgICAgIGlmICghb3V0ZXJFbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwb3N0Q2xvbmUgPSB0aGlzLl9wb3N0Q2xvbmVkTm9kZSA9IGNvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZC5jbG9uZU5vZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHBvc3RDbG9uZSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRlckVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvdXRlclN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJlQ2xvbmUgPSB0aGlzLl9wcmVDbG9uZWROb2RlID0gY29udGFpbmVyLmxhc3RFbGVtZW50Q2hpbGQuY2xvbmVOb2RlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShwcmVDbG9uZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlW3RoaXMuX3RyYW5zZm9ybV0gPSB0aGlzLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbihsZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9yY2VSZXBhaW50KGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRlclN0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyB0aGUgY2xvbmVzIGZvciBpbmZpbml0ZSBzY3JvbGxpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZW1vdmVDbG9uZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIsIHByZUNsb25lID0gdGhpcy5fcHJlQ2xvbmVkTm9kZSwgcG9zdENsb25lID0gdGhpcy5fcG9zdENsb25lZE5vZGUsIGlzTm9kZSA9IHRoaXMudXRpbHMuaXNOb2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlKHByZUNsb25lKSAmJiBjb250YWluZXIuY29udGFpbnMocHJlQ2xvbmUpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocHJlQ2xvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05vZGUocG9zdENsb25lKSAmJiBjb250YWluZXIuY29udGFpbnMocG9zdENsb25lKSkge1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHBvc3RDbG9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcHJlQ2xvbmVkTm9kZSA9IHRoaXMuX3Bvc3RDbG9uZWROb2RlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYWxsIG5lY2Vzc2FyeSBlbGVtZW50cyBhbmQgZXZlbnQgbGlzdGVuZXJzIHRvIHNldHVwIGF1dG8gc2Nyb2xsLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faW5pdGlhbGl6ZUF1dG8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0byA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYXRlSW50ZXJ2YWwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJlZ2lucyBhdXRvIHNjcm9sbGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXRpYXRlSW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsID0gdGhpcy51dGlscy5zZXRJbnRlcnZhbCh0aGlzLmdvVG9OZXh0LCB0aGlzLl9pbnRlcnZhbCwgbnVsbCwgdGhpcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgZm9yIGF1dG9tYXRpYyBzY3JvbGxpbmcgYW5kIHN1c3BlbmRzIGlmIG5lY2Vzc2FyeS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3N1c3BlbmRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG8gfHwgdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVTdXNwZW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVydmFsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN1c3BlbmQgPSB0aGlzLnV0aWxzLmRlZmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9pbml0aWF0ZUludGVydmFsKCk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlU3VzcGVuZCA9IG5vb3A7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX3N1c3BlbmQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbGwgbmVjZXNzYXJ5IGVsZW1lbnRzIGFuZCBldmVudCBsaXN0ZW5lcnMgdG8gaGFuZGxlIHRhcCBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9pbml0aWFsaXplVGFwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNOb2RlKHRoaXMuX2ZvcndhcmRBcnJvdykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUFycm93RWxlbWVudHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5fcmVtb3ZlTGlzdGVuZXJzO1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucHVzaCh0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fYmFja0Fycm93LCBfXyR0YXAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zdXNwZW5kSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmdvVG9QcmV2aW91cygpO1xyXG4gICAgICAgICAgICB9LCBmYWxzZSkpO1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucHVzaCh0aGlzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZm9yd2FyZEFycm93LCBfXyR0YXAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zdXNwZW5kSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmdvVG9OZXh0KCk7XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrQXJyb3dzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIHRoZSBhcnJvdyBlbGVtZW50cyBmb3IgdHlwZSBgdGFwYCBhbmQgcGxhY2VzIHRoZW0gaW4gdGhlIERPTS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2NyZWF0ZUFycm93RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCwgYmFja0Fycm93Q29udGFpbmVyID0gdGhpcy5fYmFja0Fycm93ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBmb3J3YXJkQXJyb3dDb250YWluZXIgPSB0aGlzLl9mb3J3YXJkQXJyb3cgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGJhY2tBcnJvdyA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksIGZvcndhcmRBcnJvdyA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBiYWNrQXJyb3cuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJpY29uLWFycm93LXVwXCI7XHJcbiAgICAgICAgICAgICAgICBmb3J3YXJkQXJyb3cuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJpY29uLWFycm93LWRvd25cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJhY2tBcnJvdy5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImljb24tYXJyb3ctbGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgZm9yd2FyZEFycm93LmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiaWNvbi1hcnJvdy1yaWdodFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhY2tBcnJvd0NvbnRhaW5lci5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImJhY2stYXJyb3dcIjtcclxuICAgICAgICAgICAgZm9yd2FyZEFycm93Q29udGFpbmVyLmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiZm9yd2FyZC1hcnJvd1wiO1xyXG4gICAgICAgICAgICBiYWNrQXJyb3dDb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja0Fycm93KTtcclxuICAgICAgICAgICAgZm9yd2FyZEFycm93Q29udGFpbmVyLmFwcGVuZENoaWxkKGZvcndhcmRBcnJvdyk7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGJhY2tBcnJvd0NvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGZvcndhcmRBcnJvd0NvbnRhaW5lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdGhlIHZhbGlkaXR5IG9mIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmb3J3YXJkIGFuZCBiYWNrIGFycm93cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2NoZWNrQXJyb3dzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc05vZGUgPSB1dGlscy5pc05vZGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0luZmluaXRlIHx8ICEoaXNOb2RlKHRoaXMuX2ZvcndhcmRBcnJvdykgJiYgaXNOb2RlKHRoaXMuX2JhY2tBcnJvdykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRleHRMZW5ndGggPSB0aGlzLmNvbnRleHQubGVuZ3RoLCBpbmRleCA9IHRoaXMuX2luZGV4O1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdWxsKGluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmFja0Fycm93LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvcndhcmRBcnJvdy5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGluZGV4IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tBcnJvdy5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrQXJyb3cucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGluZGV4ID49IGNvbnRleHRMZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mb3J3YXJkQXJyb3cuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9yd2FyZEFycm93LnJlbW92ZUF0dHJpYnV0ZShfX0hpZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFsbCBldmVudCBsaXN0ZW5lcnMgdG8gaGFuZGxlIHN3aXBlIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXRpYWxpemVTd2lwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ZpZXdwb3J0LCBzd2lwZUZuID0gdGhpcy5faGFuZGxlU3dpcGUsIHN3aXBlLCByZXZlcnNlU3dpcGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBzd2lwZSA9IF9fJHN3aXBlICsgXCJ1cFwiO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVN3aXBlID0gX18kc3dpcGUgKyBcImRvd25cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3aXBlID0gX18kc3dpcGUgKyBcImxlZnRcIjtcclxuICAgICAgICAgICAgICAgIHJldmVyc2VTd2lwZSA9IF9fJHN3aXBlICsgXCJyaWdodFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9yZW1vdmVMaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihjb250YWluZXIsIHN3aXBlLCBzd2lwZUZuLCBmYWxzZSkpO1xyXG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcnMucHVzaCh0aGlzLmFkZEV2ZW50TGlzdGVuZXIoY29udGFpbmVyLCByZXZlcnNlU3dpcGUsIHN3aXBlRm4sIGZhbHNlKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFsbCBldmVudCBsaXN0ZW5lcnMgdG8gaGFuZGxlIHRyYWNraW5nIGV2ZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2luaXRpYWxpemVUcmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQsIHRyYWNrRm4gPSB0aGlzLl90cmFjaywgdG91Y2hFbmQgPSB0aGlzLl90b3VjaEVuZCwgdHJhY2ssIHJldmVyc2VUcmFjaztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNrID0gX18kdHJhY2sgKyBcInVwXCI7XHJcbiAgICAgICAgICAgICAgICByZXZlcnNlVHJhY2sgPSBfXyR0cmFjayArIFwiZG93blwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJhY2sgPSBfXyR0cmFjayArIFwibGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVRyYWNrID0gX18kdHJhY2sgKyBcInJpZ2h0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3JlbW92ZUxpc3RlbmVycztcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCB0cmFjaywgdHJhY2tGbiwgZmFsc2UpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCByZXZlcnNlVHJhY2ssIHRyYWNrRm4sIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdG91Y2hzdGFydCwgdGhpcy5fdG91Y2hTdGFydCwgZmFsc2UpKTtcclxuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzLnB1c2godGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0cmFja2VuZCwgdG91Y2hFbmQsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIHJlbW92ZUxpc3RlbmVycy5wdXNoKHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdG91Y2hlbmQsIHRvdWNoRW5kLCBmYWxzZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBhIHN3aXBlIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5faGFuZGxlU3dpcGUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGV2LmRpcmVjdGlvbi5wcmltYXJ5LCBoYXNTd2lwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNWZXJ0aWNhbCAmJiAodGhpcy5faXNJbmZpbml0ZSB8fCB0aGlzLl9pbmRleCA8IHRoaXMuY29udGV4dC5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdXNwZW5kSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzU3dpcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzVmVydGljYWwgJiYgKHRoaXMuX2lzSW5maW5pdGUgfHwgdGhpcy5faW5kZXggPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdXNwZW5kSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzU3dpcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nb1RvUHJldmlvdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwgJiYgKHRoaXMuX2lzSW5maW5pdGUgfHwgdGhpcy5faW5kZXggPCB0aGlzLmNvbnRleHQubGVuZ3RoIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3VzcGVuZEludGVydmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N3aXBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ29Ub05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdkb3duJzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCAmJiAodGhpcy5faXNJbmZpbml0ZSB8fCB0aGlzLl9pbmRleCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1c3BlbmRJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNTd2lwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9QcmV2aW91cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1N3aXBlZCA9IGhhc1N3aXBlZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExvZyB3aGVuIHRoZSB1c2VyIHRvdWNoZXMgdGhlIENhcm91c2VsLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgdG91Y2ggZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl90b3VjaFN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pblRvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVJbnRlcnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJ2YWwgPSBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2luVG91Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2ggPSB7XHJcbiAgICAgICAgICAgICAgICB4OiBldi5jbGllbnRYLFxyXG4gICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlICR0b3VjaGVuZCBhbmQgJHRyYWNrZW5kIGV2ZW50IGhhbmRsZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSB0b3VjaCBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX3RvdWNoRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpblRvdWNoID0gdGhpcy5faW5Ub3VjaCwgaGFzTW92ZWQgPSB0aGlzLl9oYXNNb3ZlZCwgaGFzU3dpcGVkID0gdGhpcy5faGFzU3dpcGVkO1xyXG4gICAgICAgICAgICB0aGlzLl9pblRvdWNoID0gdGhpcy5faGFzU3dpcGVkID0gdGhpcy5faGFzTW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFpblRvdWNoIHx8IGhhc1N3aXBlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2lzQXV0byAmJiAhdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYXRlSW50ZXJ2YWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWhhc01vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRpc3RhbmNlTW92ZWQgPSB0aGlzLl9pc1ZlcnRpY2FsID8gKGV2LmNsaWVudFkgLSB0aGlzLl9sYXN0VG91Y2gueSkgOiAoZXYuY2xpZW50WCAtIHRoaXMuX2xhc3RUb3VjaC54KSwgbGVuZ3RoID0gdGhpcy5fZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKE1hdGguYWJzKGRpc3RhbmNlTW92ZWQpID4gTWF0aC5jZWlsKGxlbmd0aCAvIDIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VNb3ZlZCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdvVG9OZXh0KCkudGhlbihmdW5jdGlvbiAoc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvUHJldmlvdXMoKS50aGVuKGZ1bmN0aW9uIChzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgJHRyYWNrIGV2ZW50IGhhbmRsZXIuIFVzZWQgZm9yIHRyYWNraW5nIG9ubHkgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCB0cmFja2luZyBtb3Rpb25zXHJcbiAgICAgICAgICogZGVwZW5kaW5nIG9uIHRoZSBkZWZpbmVkIG9yaWVudGF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNraW5nIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fdHJhY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pblRvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hhc01vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucygpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKF90aGlzLl9vdXRlclN0YXJ0ICYmIF90aGlzLl9vdXRlckVuZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2luaXRpYWxpemVPdXRlck5vZGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGFzTW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSBfdGhpcy5fY2FsY3VsYXRlRHluYW1pY1RyYW5zbGF0aW9uKGV2KTtcclxuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLl9jb250YWluZXIuc3R5bGVbX3RoaXMuX3RyYW5zZm9ybV0gPSB0cmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB0cmFuc2xhdGlvbiB2YWx1ZSBmb3Igc2V0dGluZyB0aGUgdHJhbnNmb3JtIHZhbHVlIGR1cmluZyBhIHN0YXRpYyBpbmRleCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVydmFsIFRoZSBpbnRlcnZhbCBjaGFuZ2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9jYWxjdWxhdGVTdGF0aWNUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChpbnRlcnZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNWZXJ0aWNhbCA/IFwidHJhbnNsYXRlM2QoMCxcIiArICh0aGlzLl9jdXJyZW50T2Zmc2V0ICs9IGludGVydmFsKSArIFwicHgsMClcIiA6XHJcbiAgICAgICAgICAgICAgICBcInRyYW5zbGF0ZTNkKFwiICsgKHRoaXMuX2N1cnJlbnRPZmZzZXQgKz0gaW50ZXJ2YWwpICsgXCJweCwwLDApXCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB0cmFuc2xhdGlvbiB2YWx1ZSBmb3Igc2V0dGluZyB0aGUgdHJhbnNmb3JtIHZhbHVlIGR1cmluZyB0cmFja2luZy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFja2luZyBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2NhbGN1bGF0ZUR5bmFtaWNUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZXYuY2xpZW50WSAtIHRoaXMuX2xhc3RUb3VjaC55O1xyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG9mZnNldCkgPiB0aGlzLl9nZXRMZW5ndGgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoRW5kKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKDAsXCIgKyAodGhpcy5fY3VycmVudE9mZnNldCArIG9mZnNldCkgKyBcInB4LDApXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2Zmc2V0ID0gZXYuY2xpZW50WCAtIHRoaXMuX2xhc3RUb3VjaC54O1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMob2Zmc2V0KSA+IHRoaXMuX2dldExlbmd0aCgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaEVuZChldik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArICh0aGlzLl9jdXJyZW50T2Zmc2V0ICsgb2Zmc2V0KSArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyB0aGUgY3VycmVudCBicm93c2VyJ3MgdHJhbnNmb3JtIHByb3BlcnR5IHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9jb250YWluZXIuc3R5bGUsIGlzVW5kZWZpbmVkID0gdGhpcy51dGlscy5pc1VuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIHZlbmRvclByZWZpeCA9IHRoaXMuX2NvbXBhdC52ZW5kb3JQcmVmaXg7XHJcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoc3R5bGVbKHZlbmRvclByZWZpeC5sb3dlckNhc2UgKyBcIlRyYW5zZm9ybVwiKV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB2ZW5kb3JQcmVmaXgubG93ZXJDYXNlICsgXCJUcmFuc2Zvcm1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNVbmRlZmluZWQoc3R5bGVbKHZlbmRvclByZWZpeC51cHBlckNhc2UgKyBcIlRyYW5zZm9ybVwiKV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB2ZW5kb3JQcmVmaXgudXBwZXJDYXNlICsgXCJUcmFuc2Zvcm1cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9ICd0cmFuc2Zvcm0nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIHRoZSBpbnRlcnZhbCBsZW5ndGggb2YgdGhlIHNsaWRpbmcgY29udGFpbmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoID0gKHRoaXMuX2lzVmVydGljYWwgPyB0aGlzLl92aWV3cG9ydC5vZmZzZXRIZWlnaHQgOiB0aGlzLl92aWV3cG9ydC5vZmZzZXRXaWR0aCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVja3MgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBjb250cm9sIGFuZCBlbnN1cmVzIGl0IGlzIHZhbGlkLlxyXG4gICAgICAgICAqIFdpbGwgZGVmYXVsdCB0byBcImhvcml6b250YWxcIiBpZiBpbnZhbGlkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcmllbnRhdGlvbiBUaGUgZWxlbWVudCB0byBiYXNlIHRoZSBsZW5ndGggb2ZmIG9mLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIENhcm91c2VsLnByb3RvdHlwZS5fdmFsaWRhdGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uIChvcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc1VuZGVmaW5lZChvcmllbnRhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbGlkT3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzVmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiSW52YWxpZCBvcmllbnRhdGlvbiBcXFwiXCIgKyBvcmllbnRhdGlvbiArIFwiXFxcIiBmb3IgXCIgKyB0aGlzLnR5cGUgKyBcIi4gRGVmYXVsdGluZyB0byBcXFwiaG9yaXpvbnRhbC5cXFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRPcmllbnRhdGlvbjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYW4gQXJyYXkgb2YgaXRlbXMgdG8gdGhlIGVsZW1lbnQgd2l0aG91dCBhbmltYXRpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxOb2RlPn0gaXRlbXMgVGhlIEFycmF5IG9mIGl0ZW1zIHRvIGFkZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2FwcGVuZEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1Ob2RlcyA9IHRoaXMuX2l0ZW1Ob2Rlcy5jb25jYXQoaXRlbXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleDtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG5vIHJlbW92ZSBsaXN0ZW5lcnMgZXhpc3Qgd2Uga25vdyB0aGF0IHdlIGhhZCBwcmV2aW91c2x5IHJlbW92ZWQgdGhlbS4gXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluZGV4KDApO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2VkKDAsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5faXRlbU5vZGVzLmxlbmd0aCAtIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplSW5kZXgoaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW1vdmVzIGl0ZW1zIGZyb20gdGhlIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gc3RhcnQgZGlzcG9zaW5nIGZyb20uXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9yZW1vdmVJdGVtcyA9IGZ1bmN0aW9uIChpbmRleCwgbnVtYmVyT2ZJdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgZGlzcG9zZSA9IHRoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZGlzcG9zZSwgY29udHJvbHMgPSB0aGlzLmNvbnRyb2xzLCBpdGVtTm9kZXMgPSB0aGlzLl9pdGVtTm9kZXMsIGxhc3QgPSBpbmRleCArIG51bWJlck9mSXRlbXM7XHJcbiAgICAgICAgICAgIHdoaWxlIChsYXN0LS0gPiBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zZShjb250cm9sc1tsYXN0XSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtTm9kZXMucG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVzb3VyY2UoY29udHJvbHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZlcmlmeUxlbmd0aCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQ2Fyb3VzZWwucHJvdG90eXBlLl9jYW5jZWxDdXJyZW50QW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNOdWxsKHRoaXMuX2FuaW1hdGlvblRoZW5hYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbmltYXRpb25UaGVuYWJsZS5jYW5jZWwoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZvcmNlcyBhIHJlcGFpbnQgLyByZWZsb3cuXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBmb3JjZSB0aGUgcmVwYWludCAvIHJlZmxvdyBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBDYXJvdXNlbC5wcm90b3R5cGUuX2ZvcmNlUmVwYWludCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsIGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5LCBub25lID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUuZGlzcGxheSA9PT0gbm9uZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdHlsZS5kaXNwbGF5ID0gbm9uZTtcclxuICAgICAgICAgICAgZWxlbWVudC5vZmZzZXRXaWR0aDtcclxuICAgICAgICAgICAgc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBDYXJvdXNlbC5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX1RlbXBsYXRlQ29udHJvbEZhY3Rvcnk6IF9fVGVtcGxhdGVDb250cm9sRmFjdG9yeVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIENhcm91c2VsO1xyXG4gICAgfShwbGF0LnVpLmNvbnRyb2xzLkZvckVhY2gpKTtcclxuICAgIHBsYXR1aS5DYXJvdXNlbCA9IENhcm91c2VsO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fQ2Fyb3VzZWwsIENhcm91c2VsKTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gSVRlbXBsYXRlQ29udHJvbCBmb3IgY3JlYXRpbmcgYSBjb21wbGV4IGxpc3Qgb2YgaXRlbXMgd2l0aFxyXG4gICAgICogZXh0ZW5zaXZlIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgKi9cclxuICAgIHZhciBMaXN0dmlldyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgX19leHRlbmRzKExpc3R2aWV3LCBfc3VwZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYSBMaXN0dmlldy4gQ3JlYXRlcyB0aGUgaXRlbXNMb2FkZWQgUHJvbWlzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBMaXN0dmlldygpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTCB0ZW1wbGF0ZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSB0aGlzLl9fdGVtcGxhdGVTdHJpbmc7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBVc2VkIHRvIGhvbGQgdGhlIGFsaWFzIHRva2VucyBmb3IgdGhlIGJ1aWx0LWluIGFsaWFzZXMuIFlvdVxyXG4gICAgICAgICAgICAgKiBjYW4gb3ZlcndyaXRlIHRoZXNlIHdpdGggdGhlIG9wdGlvbnMgZm9yXHJcbiAgICAgICAgICAgICAqIHRoZSBMaXN0dmlldyBjb250cm9sLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fYWxpYXNlcyA9IHtcclxuICAgICAgICAgICAgICAgIGluZGV4OiBfX2xpc3R2aWV3QWxpYXNPcHRpb25zLmluZGV4LFxyXG4gICAgICAgICAgICAgICAgZXZlbjogX19saXN0dmlld0FsaWFzT3B0aW9ucy5ldmVuLFxyXG4gICAgICAgICAgICAgICAgb2RkOiBfX2xpc3R2aWV3QWxpYXNPcHRpb25zLm9kZCxcclxuICAgICAgICAgICAgICAgIGZpcnN0OiBfX2xpc3R2aWV3QWxpYXNPcHRpb25zLmZpcnN0LFxyXG4gICAgICAgICAgICAgICAgbGFzdDogX19saXN0dmlld0FsaWFzT3B0aW9ucy5sYXN0LFxyXG4gICAgICAgICAgICAgICAgZ3JvdXA6IF9fbGlzdHZpZXdBbGlhc09wdGlvbnMuZ3JvdXBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBub2RlIG5hbWVzIG9mIHRoZSBMaXN0dmlldydzIGRlZmluZWQgdGVtcGxhdGVzIGFuZFxyXG4gICAgICAgICAgICAgKiB0aGVpciBjb3JyZXNwb25kaW5nIHRlbXBsYXRlIG5vZGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZXMgPSB7fTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzVmVydGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHNjcm9sbCBmdW5jdGlvbiBpcyByZWFkeSB0byBiZSBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHVzZXIgaXMgY3VycmVudGx5IHBlcmZvcm1pbmcgYSBsb2FkIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBjb250YWluZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU2Nyb2xsID0gbm9vcDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGlzIGN1cnJlbnRseSBwZXJmb3JtaW5nIGEgcmVmcmVzaCBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9pc1JlZnJlc2hpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFuIGVudW1lcmF0aW9uIHZhbHVlIHNpZ25pZnlpbmcgdGhlIGN1cnJlbnQgdG91Y2ggc3RhdGUuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIHVzZXIgaXMgdHJhY2tpbmcgaW4gYSBmYXNoaW9uIHRoYXQgYXR0ZW1wdHMgdG8gcmVmcmVzaCB0aGUgbGlzdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2hhc01vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbGFzdCB0b3VjaCBzdGFydCByZWNvcmRlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RUb3VjaCA9IHsgeDogMCwgeTogMCB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG5vcm1hbGl6aW5nIGEgbm9kZSBuYW1lIGJ5IHJlbW92aW5nIHBvdGVudGlhbCBzcGVjaWFsIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9ub2RlTm9ybWFsaXplUmVnZXggPSAvLXxcXC58Xy9nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHNlbGVjdCBpcyBncm91cGVkLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNHcm91cGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIHNldCBvZiBmdW5jdGlvbnMgdG8gcmVtb3ZlIGFsbCB2aXNpYmlsaXR5IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2liaWxpdHlSZW1vdmVMaXN0ZW5lcnMgPSBbXTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBwcml2YXRlIHRlbXBsYXRlIHN0cmluZyB1c2VkIHRvIGNoZWNrIGZvciBhIHRlbXBsYXRlIG92ZXJ3cml0ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1saXN0dmlldy12aWV3cG9ydFwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwicGxhdC1zY3JvbGwtY29udGFpbmVyXCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgICAgICA8ZGl2IGNsYXNzPVwicGxhdC1saXN0dmlldy1jb250YWluZXJcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJztcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtYWluIEFycmF5IGxpc3RlbmVyIGhhcyBiZWVuIHNldC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX19saXN0ZW5lclNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zTG9hZGVkID0gbmV3IHRoaXMuX1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX19yZXNvbHZlRm4gPSByZXNvbHZlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX19yZWplY3RGbiA9IHJlamVjdDtcclxuICAgICAgICAgICAgfSkuY2F0Y2gobm9vcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGNsYXNzZXMgb24gdGhlIHByb3BlciBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lPyBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBjbGFzcyBuYW1lIG9yIGNsYXNzIG5hbWVzIHRvIHNldCBvbiB0aGUgY29udHJvbFxyXG4gICAgICAgICAqIGluIGFkZGl0aW9uIHRvIGl0cyBzdGFuZGFyZCBzZXQuXHJcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50PyBUaGUgZWxlbWVudCB0byBzZXQgdGhlIGNsYXNzIG5hbWUgb24uIFNob3VsZCBkZWZhdWx0IHRvXHJcbiAgICAgICAgICogdGhlIGNvbnRyb2wncyBlbGVtZW50IGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX0xpc3R2aWV3ICsgXCIgXCIgKyAoY2xhc3NOYW1lIHx8ICcnKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGVjayBmb3IgdGVtcGxhdGVVcmwgYW5kIHNldCBpZiBuZWVkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwgKHRoaXMub3B0aW9ucyA9IHt9KSwgb3B0aW9ucyA9IG9wdGlvbk9iai52YWx1ZSB8fCAob3B0aW9uT2JqLnZhbHVlID0ge30pO1xyXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlVXJsID0gb3B0aW9ucy50ZW1wbGF0ZVVybCB8fCB0aGlzLnRlbXBsYXRlVXJsO1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBhcnNlIHRoZSBpbm5lclRlbXBsYXRlIGFuZCBhZGQgaXQgdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5zZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGVtcGxhdGVTdHJpbmcgIT09IHRoaXMuX190ZW1wbGF0ZVN0cmluZyB8fCB0aGlzLnV0aWxzLmlzU3RyaW5nKHRoaXMudGVtcGxhdGVVcmwpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmRvbS5zZXJpYWxpemVIdG1sKHRoaXMuX190ZW1wbGF0ZVN0cmluZyksIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyVGVtcGxhdGUgPSB0aGlzLmRvbS5hcHBlbmRDaGlsZHJlbihlbGVtZW50LmNoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlLXN5bmNzIHRoZSBMaXN0dmlldyBjaGlsZCBjb250cm9scyBhbmQgRE9NIHdpdGggdGhlIG5ld1xyXG4gICAgICAgICAqIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gbmV3VmFsdWU/IFRoZSBuZXcgQXJyYXlcclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PGFueT59IG9sZFZhbHVlPyBUaGUgb2xkIEFycmF5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLmNvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0FycmF5KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1Zyh0aGlzLnR5cGUgKyBcIiBjb250ZXh0IHNldCB0byBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBBcnJheS5cIik7XHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVFdmVudChbe1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdDogbmV3VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3NwbGljZSdcclxuICAgICAgICAgICAgICAgIH1dKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZSBpdGVtIHRlbXBsYXRlcyBhbmQga2ljayBvZmYgcmVuZGVyaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLnZhbHVlLCB1dGlscyA9IHRoaXMudXRpbHMsIGlzU3RyaW5nID0gdXRpbHMuaXNTdHJpbmcsIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLCBzY3JvbGxDb250YWluZXIgPSB0aGlzLl9zY3JvbGxDb250YWluZXIgPSB2aWV3cG9ydC5maXJzdEVsZW1lbnRDaGlsZCwgbG9hZGluZyA9IHRoaXMuX2xvYWRpbmcgPSBvcHRpb25zLmxvYWRpbmcsIGFuaW1hdGUgPSB0aGlzLl9hbmltYXRlID0gb3B0aW9ucy5hbmltYXRlID09PSB0cnVlLCByZXF1ZXN0SXRlbXMgPSBvcHRpb25zLm9uSXRlbXNSZXF1ZXN0ZWQsIHJlZnJlc2ggPSBvcHRpb25zLm9uUmVmcmVzaCwgaXRlbVRlbXBsYXRlID0gb3B0aW9ucy5pdGVtVGVtcGxhdGUsIHNjcm9sbEVsZW1lbnQgPSBvcHRpb25zLnNjcm9sbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3MoZWxlbWVudCwgX19QbGF0ICsgdGhpcy5fdmFsaWRhdGVPcmllbnRhdGlvbihvcHRpb25zLm9yaWVudGF0aW9uKSArXHJcbiAgICAgICAgICAgICAgICAoYW5pbWF0ZSA/IChcIiBcIiArIF9fUGxhdCArIFwiYW5pbWF0ZWRcIikgOiAnJykpO1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoc2Nyb2xsRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbEVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNjcm9sbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc05vZGUoc2Nyb2xsRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbENvbnRhaW5lciA9IHNjcm9sbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyBcIm5vLXNjcm9sbGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNTdHJpbmcoaXRlbVRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiTm8gaXRlbSB0ZW1wbGF0ZSBvciBpdGVtIHRlbXBsYXRlIHNlbGVjdG9yIHNwZWNpZmllZCBmb3IgXCIgKyB0aGlzLnR5cGUgKyBcIi5cIik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJdGVtVGVtcGxhdGUgPSB0aGlzLl9ub3JtYWxpemVUZW1wbGF0ZU5hbWUoaXRlbVRlbXBsYXRlKSwgaGVhZGVyVGVtcGxhdGUgPSBvcHRpb25zLmhlYWRlclRlbXBsYXRlLCBub3JtYWxpemVkR3JvdXBUZW1wbGF0ZSA9IGlzU3RyaW5nKGhlYWRlclRlbXBsYXRlKSA/IHRoaXMuX25vcm1hbGl6ZVRlbXBsYXRlTmFtZShoZWFkZXJUZW1wbGF0ZSkgOiBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJzZUlubmVyVGVtcGxhdGUobm9ybWFsaXplZEl0ZW1UZW1wbGF0ZSwgbm9ybWFsaXplZEdyb3VwVGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVUZW1wbGF0ZXMoaXRlbVRlbXBsYXRlLCBub3JtYWxpemVkSXRlbVRlbXBsYXRlLCBub3JtYWxpemVkR3JvdXBUZW1wbGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRHcm91cCA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBjb250cm9sOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgaXRlbUNvbnRhaW5lcjogdGhpcy5fY29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIGluZGV4OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaXRlbUNvdW50OiAwLFxyXG4gICAgICAgICAgICAgICAgYWRkUXVldWU6IFtdLFxyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWU6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBpc1JlZnJlc2hpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGxvYWRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcocmVxdWVzdEl0ZW1zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxvYWRpbmcocmVxdWVzdEl0ZW1zLCBvcHRpb25zLmluZmluaXRlUHJvZ3Jlc3MgIT09IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1Zyh0aGlzLnR5cGUgKyBcIiBsb2FkaW5nIHR5cGUgc3BlY2lmaWVkIGFzIFxcXCJcIiArIGxvYWRpbmcgKyBcIlxcXCIgYnV0IG5vIG9wdGlvbiBzcGVjaWZ5aW5nIGFuIG9uSXRlbXNSZXF1ZXN0ZWQgaGFuZGxlci5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHJlZnJlc2gpKSB7XHJcbiAgICAgICAgICAgICAgICBpc1JlZnJlc2hpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVJlZnJlc2gocmVmcmVzaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVRyYWNraW5nKGxvYWRpbmcgPT09ICdpbmNyZW1lbnRhbCcsIGlzUmVmcmVzaGluZyk7XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNBcnJheSh0aGlzLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzTnVsbCh0aGlzLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKHRoaXMudHlwZSArIFwiJ3MgY29udGV4dCBtdXN0IGJlIGFuIEFycmF5LlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zZXRBbGlhc2VzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENvbnRhaW5lckhlaWdodCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcigpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBhbnkgcG90ZW50aWFsbHkgaGVsZCBtZW1vcnkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aXNpYmlsaXR5UmVtb3ZlcnMgPSB0aGlzLl92aXNpYmlsaXR5UmVtb3ZlTGlzdGVuZXJzO1xyXG4gICAgICAgICAgICB3aGlsZSAodmlzaWJpbGl0eVJlbW92ZXJzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHlSZW1vdmVycy5wb3AoKSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjcm9sbCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy51dGlscy5pc0Z1bmN0aW9uKHRoaXMuX19yZWplY3RGbikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZWplY3RGbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX3Jlc29sdmVGbiA9IHRoaXMuX19yZWplY3RGbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJsb3cgb3V0IHRoZSBET00gc3RhcnRpbmcgYXQgdGhlIGluZGV4LCBkZXRlcm1pbmUgaG93IHRvIHJlbmRlciwgYW5kIHJlbmRlciB0aGUgY291bnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4PyBUaGUgc3RhcnRpbmcgaW5kZXggdG8gcmVuZGVyLiBJZiBub3Qgc3BlY2lmaWVkLCBpdCB3aWxsIHN0YXJ0IGF0IGN1cnJlbnRDb3VudC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQ/IFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gcmVuZGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgd2hvbGUgY29udGV4dFxyXG4gICAgICAgICAqIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleCB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgd2UncmUgcmVuZGVyaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoaW5kZXgsIGNvdW50LCBncm91cCkge1xyXG4gICAgICAgICAgICB2YXIgaXNOdW1iZXIgPSB0aGlzLnV0aWxzLmlzTnVtYmVyLCBvcEdyb3VwID0gZ3JvdXAgfHwgdGhpcy5fZGVmYXVsdEdyb3VwLCBjb250cm9sID0gb3BHcm91cC5jb250cm9sLCBjb250ZXh0ID0gdGhpcyA9PT0gY29udHJvbCA/IHRoaXMuY29udGV4dCA6IGNvbnRyb2wuY29udGV4dC5pdGVtcztcclxuICAgICAgICAgICAgaWYgKCFpc051bWJlcihpbmRleCkpIHtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbWF4Q291bnQgPSBjb250ZXh0Lmxlbmd0aCAtIGluZGV4LCBpdGVtQ291bnQgPSBpc051bWJlcihjb3VudCkgJiYgbWF4Q291bnQgPj0gY291bnQgPyBjb3VudCA6IG1heENvdW50O1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtcyhpbmRleCwgaXRlbUNvdW50LCBvcEdyb3VwLCAwKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJsb3cgb3V0IGFsbCB0aGUgRE9NLCBkZXRlcm1pbmUgaG93IHRvIHJlbmRlciwgYW5kIHJlbmRlciBhY2NvcmRpbmdseS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cD8gVGhlIGdyb3VwIHdlJ3JlIHJlcmVuZGVyaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5yZXJlbmRlciA9IGZ1bmN0aW9uIChncm91cCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcigwLCBudWxsLCBncm91cCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZS1zeW5jcyB0aGUgTGlzdHZpZXcgY2hpbGQgaXRlbXMgYW5kIERPTSB3aXRoIHRoZSBuZXcgaXRlbXNcclxuICAgICAgICAgKiBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lIFRoZSBncm91cCBuYW1lIG9mIHRoZSBjdXJyZW50bHkgY2hhbmdpbmcgQXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlPyBUaGUgbmV3IGNoaWxkIGFycmF5IG9mIGl0ZW1zXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IG9sZFZhbHVlPyBUaGUgb2xkIGNoaWxkIGFycmF5IG9mIGl0ZW1zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9jaGlsZENvbnRleHRDaGFuZ2VkID0gZnVuY3Rpb24gKGdyb3VwTmFtZSwgbmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVDaGlsZEV2ZW50KGdyb3VwTmFtZSwgW3tcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Q6IG5ld1ZhbHVlIHx8IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzcGxpY2UnXHJcbiAgICAgICAgICAgICAgICB9XSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGEgbGlzdGVuZXIgZm9yIHRoZSBjaGFuZ2VzIHRvIHRoZSBhcnJheS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3NldExpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX19saXN0ZW5lclNldCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlQXJyYXkodGhpcy5fZXhlY3V0ZUV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19saXN0ZW5lclNldCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGFsaWFzIHRva2VucyB0byB1c2UgZm9yIGFsbCB0aGUgaXRlbXMgaW4gdGhlIExpc3R2aWV3IGNvbnRleHQgYXJyYXkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zZXRBbGlhc2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYWxpYXNlcyA9IHRoaXMub3B0aW9ucy52YWx1ZS5hbGlhc2VzLCB1dGlscyA9IHRoaXMudXRpbHM7XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNPYmplY3QoYWxpYXNlcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX2FsaWFzZXMgPSB0aGlzLl9hbGlhc2VzLCBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nLCBrZXlzID0gT2JqZWN0LmtleXMoX2FsaWFzZXMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gYWxpYXNlc1trZXlzW2ldXTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBfYWxpYXNlc1trZXlzW2ldXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlcm1pbmUgdGhlIHByb3BlciBpdGVtIHRlbXBsYXRlIG9yIG1ldGhvZCBvZiBpdGVtIHRlbXBsYXRlIHNlbGVjdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVRlbXBsYXRlIFRoZSBwcmUtbm9ybWFsaXplZCBwcm9wZXJ0eSBmb3IgaW5kaWNhdGluZyBlaXRoZXIgdGhlIGl0ZW0gdGVtcGxhdGUgb3IgdGhlXHJcbiAgICAgICAgICogaXRlbSB0ZW1wbGF0ZSBzZWxlY3Rvci5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVRlbXBsYXRlS2V5IFRoZSBub3JtYWxpemVkIHByb3BlcnR5IGZvciBpbmRpY2F0aW5nIHRoZSBpdGVtIHRlbXBsYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJUZW1wbGF0ZSBUaGUgcHJvcGVydHkgZm9yIGluZGljYXRpbmcgdGhlIGdyb3VwIGhlYWRlciB0ZW1wbGF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2RldGVybWluZVRlbXBsYXRlcyA9IGZ1bmN0aW9uIChpdGVtVGVtcGxhdGUsIGl0ZW1UZW1wbGF0ZUtleSwgaGVhZGVyVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgYmluZGFibGVUZW1wbGF0ZXMgPSB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLCB0ZW1wbGF0ZXMgPSB0aGlzLl90ZW1wbGF0ZXMsIHRlbXBsYXRlO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoaGVhZGVyVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0dyb3VwZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20uYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCBfX1BsYXQgKyBcImdyb3VwZWRcIik7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlc1toZWFkZXJUZW1wbGF0ZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNOb2RlKHRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlID0gaGVhZGVyVGVtcGxhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kYWJsZVRlbXBsYXRlcy5hZGQoaGVhZGVyVGVtcGxhdGUsIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcGxhdGVzW2hlYWRlclRlbXBsYXRlXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhfX0xpc3R2aWV3ICsgXCIgZ3JvdXAgaGVhZGVyIHRlbXBsYXRlIFxcXCJcIiArIGhlYWRlclRlbXBsYXRlICsgXCJcXFwiIHdhcyBub3QgYSB0ZW1wbGF0ZSBkZWZpbmVkIGluIHRoZSBET00uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVyVGVtcGxhdGVQcm9taXNlID0gdGhpcy5fY3JlYXRlR3JvdXBUZW1wbGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVzW2l0ZW1UZW1wbGF0ZUtleV07XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc05vZGUodGVtcGxhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtVGVtcGxhdGUgPSBpdGVtVGVtcGxhdGVLZXk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLmFkZChpdGVtVGVtcGxhdGVLZXksIHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZW1wbGF0ZXNbaXRlbVRlbXBsYXRlS2V5XTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udHJvbFByb3BlcnR5ID0gdGhpcy5maW5kUHJvcGVydHkoaXRlbVRlbXBsYXRlKSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCF1dGlscy5pc0Z1bmN0aW9uKGNvbnRyb2xQcm9wZXJ0eS52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhfX0xpc3R2aWV3ICsgXCIgaXRlbSB0ZW1wbGF0ZSBcXFwiXCIgKyBpdGVtVGVtcGxhdGUgKyBcIlxcXCIgd2FzIG5laXRoZXIgYSB0ZW1wbGF0ZSBkZWZpbmVkIGluIHRoZSBET00gbm9yIGEgdGVtcGxhdGUgc2VsZWN0b3IgZnVuY3Rpb24gaW4gaXRzIGNvbnRyb2wgaGllYXJjaHkuXCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlU2VsZWN0b3IgPSBjb250cm9sUHJvcGVydHkudmFsdWUuYmluZChjb250cm9sUHJvcGVydHkuY29udHJvbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlU2VsZWN0b3JLZXlzID0ge307XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcGxhdGVzKSwga2V5O1xyXG4gICAgICAgICAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYmluZGFibGVUZW1wbGF0ZXMuYWRkKGtleSwgdGVtcGxhdGVzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRlbXBsYXRlc1trZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3QgdGhlIGdyb3VwIHRlbXBsYXRlIGFuZCBhZGQgaXQgdG8gYmluZGFibGUgdGVtcGxhdGVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fY3JlYXRlR3JvdXBUZW1wbGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBiaW5kYWJsZVRlbXBsYXRlcyA9IHRoaXMuYmluZGFibGVUZW1wbGF0ZXMsIGhlYWRlclRlbXBsYXRlID0gdGhpcy5faGVhZGVyVGVtcGxhdGUsIGxpc3R2aWV3R3JvdXAgPSBfX0xpc3R2aWV3ICsgXCItZ3JvdXBcIiwgZ3JvdXAgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGl0ZW1Db250YWluZXIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGhlYWRlclByb21pc2U7XHJcbiAgICAgICAgICAgIGdyb3VwLmNsYXNzTmFtZSA9IGxpc3R2aWV3R3JvdXA7XHJcbiAgICAgICAgICAgIGl0ZW1Db250YWluZXIuY2xhc3NOYW1lID0gX19MaXN0dmlldyArIFwiLWl0ZW1zXCI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnV0aWxzLmlzU3RyaW5nKGhlYWRlclRlbXBsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgaGVhZGVyUHJvbWlzZSA9IGJpbmRhYmxlVGVtcGxhdGVzLnRlbXBsYXRlc1toZWFkZXJUZW1wbGF0ZV0udGhlbihmdW5jdGlvbiAoaGVhZGVyVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBncm91cC5pbnNlcnRCZWZvcmUoaGVhZGVyVGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoaGVhZGVyUHJvbWlzZSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cC5pbnNlcnRCZWZvcmUoaXRlbUNvbnRhaW5lciwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBiaW5kYWJsZVRlbXBsYXRlcy5hZGQobGlzdHZpZXdHcm91cCwgZ3JvdXApO1xyXG4gICAgICAgICAgICB9KS50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhfdGhpcy50eXBlICsgXCIgZXJyb3I6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgbmV3IGdyb3VwcyB0byB0aGUgY29udHJvbCdzIGVsZW1lbnQgd2hlbiBpdGVtcyBhcmUgYWRkZWQgdG9cclxuICAgICAgICAgKiB0aGUgY29udGV4dC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZHcm91cHMgVGhlIG51bWJlciBvZiBncm91cHMgdG8gYWRkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9pbnQgaW4gdGhlIGFycmF5IHRvIHN0YXJ0IGFkZGluZyBncm91cHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGFuaW1hdGVJdGVtcyBUaGUgbnVtYmVyIG9mIGdyb3VwcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fYWRkR3JvdXBzID0gZnVuY3Rpb24gKG51bWJlck9mR3JvdXBzLCBpbmRleCwgYW5pbWF0ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsSW5kZXggPSBpbmRleCwgbWF4ID0gKyhpbmRleCArIG51bWJlck9mR3JvdXBzKSwgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2JpbmRHcm91cChpbmRleCsrKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChmcmFnbWVudHMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBmcmFnbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hZGRHcm91cChpICsgaW5pdGlhbEluZGV4LCBmcmFnbWVudHNbaV0sIGkgPCBhbmltYXRlSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgbmV3IGdyb3VwIHRvIHRoZSBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBncm91cC5cclxuICAgICAgICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IGZyYWdtZW50IFRoZSBncm91cCBmcmFnbWVudCB0byBhZGQgdG8gdGhlIERPTS5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGUgV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgZ3JvdXAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9hZGRHcm91cCA9IGZ1bmN0aW9uIChpbmRleCwgZnJhZ21lbnQsIGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgY29udGV4dCA9IHRoaXMuY29udGV4dCwgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzIHx8ICh0aGlzLl9ncm91cHMgPSB7fSksIGdyb3VwID0gY29udGV4dFtpbmRleF0sIG5hbWUgPSBncm91cC5ncm91cCwgZ3JvdXBDb250YWluZXIgPSBmcmFnbWVudC5jaGlsZE5vZGVzWzFdLCBpdGVtQ29udGFpbmVyID0gZ3JvdXBDb250YWluZXIubGFzdEVsZW1lbnRDaGlsZCwgY29udHJvbCA9IHRoaXMuY29udHJvbHNbaW5kZXhdLCBncm91cEhhc2ggPSBncm91cHNbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxyXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZ3JvdXBDb250YWluZXIsXHJcbiAgICAgICAgICAgICAgICBpdGVtQ29udGFpbmVyOiBpdGVtQ29udGFpbmVyLFxyXG4gICAgICAgICAgICAgICAgY29udHJvbDogY29udHJvbCxcclxuICAgICAgICAgICAgICAgIGl0ZW1Db3VudDogMCxcclxuICAgICAgICAgICAgICAgIGFkZFF1ZXVlOiBbXSxcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlOiBbXVxyXG4gICAgICAgICAgICB9LCBpdGVtcyA9ICdpdGVtcycsIHJlbW92ZUFycmF5TGlzdGVuZXIsIHJlbW92ZU11dGF0aW9uTGlzdGVuZXI7XHJcbiAgICAgICAgICAgIGNvbnRyb2wuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKF90aGlzKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBncm91cHNbbmFtZV07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnRyb2wub2JzZXJ2ZShmdW5jdGlvbiAobmV3VmFsdWUsIG9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3TmFtZSA9IG5ld1ZhbHVlLmdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld05hbWUgPT09IG5hbWUgfHwgIXV0aWxzLmlzT2JqZWN0KG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gZ3JvdXBzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGdyb3Vwc1tuYW1lXTtcclxuICAgICAgICAgICAgICAgIHRlbXAubmFtZSA9IG5ld05hbWU7XHJcbiAgICAgICAgICAgICAgICBncm91cHNbbmV3TmFtZV0gPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5ld05hbWU7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVBcnJheUxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVNdXRhdGlvbkxpc3RlbmVyKCk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVBcnJheUxpc3RlbmVyID0gY29udHJvbC5vYnNlcnZlKF90aGlzLl9jaGlsZENvbnRleHRDaGFuZ2VkLmJpbmQoX3RoaXMsIG5hbWUpLCBpdGVtcyk7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVNdXRhdGlvbkxpc3RlbmVyID0gY29udHJvbC5vYnNlcnZlQXJyYXkoX3RoaXMuX2V4ZWN1dGVDaGlsZEV2ZW50LmJpbmQoX3RoaXMsIG5hbWUpLCBpdGVtcyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZW1vdmVBcnJheUxpc3RlbmVyID0gY29udHJvbC5vYnNlcnZlKHRoaXMuX2NoaWxkQ29udGV4dENoYW5nZWQuYmluZCh0aGlzLCBuYW1lKSwgaXRlbXMpO1xyXG4gICAgICAgICAgICByZW1vdmVNdXRhdGlvbkxpc3RlbmVyID0gY29udHJvbC5vYnNlcnZlQXJyYXkodGhpcy5fZXhlY3V0ZUNoaWxkRXZlbnQuYmluZCh0aGlzLCBuYW1lKSwgaXRlbXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtcygwLCAoZ3JvdXAuaXRlbXMgfHwgW10pLmxlbmd0aCwgZ3JvdXBIYXNoLCAwKTtcclxuICAgICAgICAgICAgaWYgKGFuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZV8xID0gdGhpcy5fZGVmYXVsdEdyb3VwLmFuaW1hdGlvblF1ZXVlLCBhbmltYXRpb25fMSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IHRoaXMuX2FuaW1hdG9yLmVudGVyKGZyYWdtZW50LCBfX0VudGVyLCB0aGlzLl9jb250YWluZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbmltYXRpb25RdWV1ZV8xLmluZGV4T2YoYW5pbWF0aW9uXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWVfMS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy5fc2V0R3JvdXBDb250YWluZXJQYWRkaW5nLmJpbmQoX3RoaXMsIGdyb3VwQ29udGFpbmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAgICAgb3A6IG51bGxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZV8xLnB1c2goYW5pbWF0aW9uXzEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIG51bGwpO1xyXG4gICAgICAgICAgICB1dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fc2V0R3JvdXBDb250YWluZXJQYWRkaW5nLmJpbmQodGhpcywgZ3JvdXBDb250YWluZXIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZSBiaW5kaW5nIG9mIGEgc2luZ2xlIGdyb3VwLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGdyb3VwIGluIGNvbnRleHQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9iaW5kR3JvdXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZGFibGVUZW1wbGF0ZXMuYmluZChfX0xpc3R2aWV3ICsgXCItZ3JvdXBcIiwgaW5kZXgsIHRoaXMuX2dldEFsaWFzZXModGhpcy5jb250ZXh0LCBpbmRleCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlbXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBzdGFydCBjcmVhdGluZyBpdGVtcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgVGhlIG51bWJlciBvZiBpdGVtcyB0byBjcmVhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIGZvciB3aGljaCB3ZSdyZSBjcmVhdGluZyBpdGVtcy5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0ZUl0ZW1zIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2NyZWF0ZUl0ZW1zID0gZnVuY3Rpb24gKGluZGV4LCBjb3VudCwgZ3JvdXAsIGFuaW1hdGVJdGVtcykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBvcEdyb3VwID0gZ3JvdXAgfHwgdGhpcy5fZGVmYXVsdEdyb3VwLCBjb250cm9sID0gb3BHcm91cC5jb250cm9sLCBpc1ZlcnRpY2FsID0gdGhpcy5faXNWZXJ0aWNhbCwgaXNDb250cm9sID0gdGhpcyA9PT0gY29udHJvbDtcclxuICAgICAgICAgICAgaWYgKGlzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlclRlbXBsYXRlUHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZEdyb3Vwcyhjb3VudCwgaW5kZXgsIGFuaW1hdGVJdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhfdGhpcy50eXBlICsgXCIgZXJyb3I6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYWRkUXVldWUgPSBvcEdyb3VwLmFkZFF1ZXVlLCBhZGRQcm9taXNlLCBwb3N0TG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleE9mID0gYWRkUXVldWUuaW5kZXhPZihhZGRQcm9taXNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleE9mICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnNwbGljZShpbmRleE9mLCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcEdyb3VwLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKF9fSGlkZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCB8fCBpc0NvbnRyb2wgfHwgIV90aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBzZXQgd2lkdGggZm9yIGZsZXhib3ggY29udGFpbmVyIFxyXG4gICAgICAgICAgICAgICAgdXRpbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLl9zZXRHcm91cENvbnRhaW5lcldpZHRoLmJpbmQoX3RoaXMsIG9wR3JvdXAuaXRlbUNvbnRhaW5lcikpO1xyXG4gICAgICAgICAgICB9LCBvbkVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKF90aGlzLnR5cGUgKyBcIiBlcnJvcjogXCIgKyAodXRpbHMuaXNTdHJpbmcoZXJyb3IubWVzc2FnZSkgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24odGhpcy5fdGVtcGxhdGVTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgb3BHcm91cC5pdGVtQ291bnQgKz0gY291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyArK2ksICsraW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX3JlbmRlclVzaW5nRnVuY3Rpb24oaW5kZXgsIG9wR3JvdXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBpdGVtc0xvYWRlZCA9IHRoaXMuaXRlbXNMb2FkZWQgPSB0aGlzLl9Qcm9taXNlLmFsbChwcm9taXNlcylcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobm9kZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gbm9kZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCBsZW5ndGg7ICsraWkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGVuZFJlbmRlcmVkSXRlbShub2Rlc1tpaV0sIG9wR3JvdXAsIGlpIDwgYW5pbWF0ZUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KS50aGVuKHBvc3RMb2FkLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgICAgIGFkZFF1ZXVlLnB1c2goaXRlbXNMb2FkZWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSB0aGlzLl9pdGVtVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh0aGlzLmJpbmRhYmxlVGVtcGxhdGVzLnRlbXBsYXRlc1trZXldKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VGcm9tSW5kZXgoaW5kZXgsIG9wR3JvdXApO1xyXG4gICAgICAgICAgICBvcEdyb3VwLml0ZW1Db3VudCArPSBjb3VudDtcclxuICAgICAgICAgICAgYWRkUHJvbWlzZSA9IHRoaXMuX2FkZEl0ZW1zKGluZGV4LCBjb3VudCwgb3BHcm91cCwgYW5pbWF0ZUl0ZW1zKS50aGVuKHBvc3RMb2FkLCBvbkVycm9yKTtcclxuICAgICAgICAgICAgYWRkUXVldWUucHVzaChhZGRQcm9taXNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgbmV3IGl0ZW1zIHRvIHRoZSBjb250cm9sJ3MgZWxlbWVudCB3aGVuIGl0ZW1zIGFyZSBhZGRlZCB0b1xyXG4gICAgICAgICAqIHRoZSBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHBvaW50IGluIHRoZSBhcnJheSB0byBzdGFydCBhZGRpbmcgaXRlbXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBpdGVtcyB0byBhZGQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIHRoYXQgd2UncmUgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiBvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5pbWF0ZUl0ZW1zIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2FkZEl0ZW1zID0gZnVuY3Rpb24gKGluZGV4LCBudW1iZXJPZkl0ZW1zLCBncm91cCwgYW5pbWF0ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBvcEdyb3VwID0gZ3JvdXAgfHwgdGhpcy5fZGVmYXVsdEdyb3VwLCBjb250cm9sID0gb3BHcm91cC5jb250cm9sLCBjb250YWluZXIgPSBvcEdyb3VwLml0ZW1Db250YWluZXIsIG1heCA9ICsoaW5kZXggKyBudW1iZXJPZkl0ZW1zKSwgcHJvbWlzZXMgPSBbXSwgaXRlbVRlbXBsYXRlID0gdGhpcy5faXRlbVRlbXBsYXRlLCBiaW5kYWJsZVRlbXBsYXRlcyA9IGNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMsIGluaXRpYWxJbmRleCA9IGluZGV4LCBpZGVudGlmaWVyLCBjb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9ICcnO1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSAnaXRlbXMuJztcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250cm9sLmNvbnRleHQuaXRlbXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGJpbmRhYmxlVGVtcGxhdGVzLmJpbmQoaXRlbVRlbXBsYXRlLCBpZGVudGlmaWVyICsgaW5kZXgsIHRoaXMuX2dldEFsaWFzZXMoY29udGV4dCwgaW5kZXgrKykpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtc0xvYWRlZCA9IHRoaXMuX1Byb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uICh0ZW1wbGF0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZUl0ZW1zID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzIgPSB0ZW1wbGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF8yOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpIDwgYW5pbWF0ZUl0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FwcGVuZEFuaW1hdGVkSXRlbSh0ZW1wbGF0ZXNbaV0sIG9wR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh0ZW1wbGF0ZXNbaV0sIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fYXBwZW5kSXRlbXModGVtcGxhdGVzLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdXBkYXRlUmVzb3VyY2UoaW5pdGlhbEluZGV4IC0gMSwgY29udHJvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnV0aWxzLmlzRnVuY3Rpb24oX3RoaXMuX19yZXNvbHZlRm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9fcmVzb2x2ZUZuID0gX3RoaXMuX19yZWplY3RGbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXRpbHMucG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLmRlYnVnKGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zTG9hZGVkO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVuZGVyIGl0ZW1zIHVzaW5nIGEgZGVmaW5lZCByZW5kZXIgZnVuY3Rpb24gc3RhcnRpbmcgYXQgYSBnaXZlbiBpbmRleCBhbmQgY29udGludWluZ1xyXG4gICAgICAgICAqIHRocm91Z2ggZm9yIGEgc2V0IG51bWJlciBvZiBpdGVtcy4gSWYgdW5kZWZpbmVkIG9yIG51bGwgaXMgcmV0dXJuZWQgZnJvbSB0aGUgZnVuY3Rpb24sXHJcbiAgICAgICAgICogcmVuZGVyaW5nIHdpbGwgc3RvcC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHN0YXJ0aW5nIGluZGV4IHRvIHJlbmRlci5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cD8gVGhlIGdyb3VwIHRoYXQgd2UncmUgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3JlbmRlclVzaW5nRnVuY3Rpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBfUHJvbWlzZSA9IHRoaXMuX1Byb21pc2UsIHV0aWxzID0gdGhpcy51dGlscywgb3BHcm91cCA9IGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cCwgY29udHJvbCA9IG9wR3JvdXAuY29udHJvbCwgaWRlbnRpZmllciwgY29udGV4dCwgZ3JvdXBOYW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgaWRlbnRpZmllciA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBcIml0ZW1zLlwiICsgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gY29udHJvbC5jb250ZXh0Lml0ZW1zO1xyXG4gICAgICAgICAgICAgICAgZ3JvdXBOYW1lID0gb3BHcm91cC5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBfUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3RlbXBsYXRlU2VsZWN0b3JQcm9taXNlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fdGVtcGxhdGVTZWxlY3RvclByb21pc2UgPSBfUHJvbWlzZS5yZXNvbHZlKF90aGlzLl90ZW1wbGF0ZVNlbGVjdG9yKGNvbnRleHRbaW5kZXhdLCBpbmRleCwgZ3JvdXBOYW1lKSk7XHJcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNlbGVjdGVkVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiaW5kYWJsZVRlbXBsYXRlcyA9IGNvbnRyb2wuYmluZGFibGVUZW1wbGF0ZXMsIHRlbXBsYXRlcyA9IGJpbmRhYmxlVGVtcGxhdGVzLnRlbXBsYXRlcywgY29udHJvbHMgPSBjb250cm9sLmNvbnRyb2xzLCBrZXkgPSBfdGhpcy5fbm9ybWFsaXplVGVtcGxhdGVOYW1lKHNlbGVjdGVkVGVtcGxhdGUpLCBuYW1lID0gb3BHcm91cC5uYW1lLCB0ZW1wbGF0ZUtleXMgPSBfdGhpcy5fdGVtcGxhdGVTZWxlY3RvcktleXNbbmFtZV0sIGNvbnRyb2xFeGlzdHMgPSBpbmRleCA8IGNvbnRyb2xzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc1VuZGVmaW5lZCh0ZW1wbGF0ZUtleXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVLZXlzID0gX3RoaXMuX3RlbXBsYXRlU2VsZWN0b3JLZXlzW25hbWVdID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKHRlbXBsYXRlc1trZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IHRlbXBsYXRlS2V5c1tpbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUtleXNbaW5kZXhdID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZGFibGVUZW1wbGF0ZXMucmVwbGFjZShpbmRleCwga2V5LCBpZGVudGlmaWVyLCBfdGhpcy5fZ2V0QWxpYXNlcyhjb250ZXh0LCBpbmRleCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZUtleXNbaW5kZXhdID0ga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kYWJsZVRlbXBsYXRlcy5iaW5kKGtleSwgaWRlbnRpZmllciwgX3RoaXMuX2dldEFsaWFzZXMoY29udGV4dCwgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZGVidWcoX3RoaXMudHlwZSArIFwiIHRlbXBsYXRlIFxcXCJcIiArIHNlbGVjdGVkVGVtcGxhdGUgKyBcIlxcXCIgd2FzIG5vdCBmb3VuZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xFeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX1RlbXBsYXRlQ29udHJvbEZhY3RvcnkuZGlzcG9zZShjb250cm9sc1tpbmRleF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBcHBlbmRzIHRoZSByZW5kZXJlZCBpdGVtIGZyb20gdGhlIGRlZmluZWQgcmVuZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBub2RlIFRoZSBub2RlIHRvIHBsYWNlIGludG8gdGhlIGl0ZW0gY29udGFpbmVyIGlmIGF2YWlsYWJsZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cD8gVGhlIGdyb3VwIHRoYXQgd2UncmUgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiBvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFuaW1hdGU/IFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIG5ldyBpdGVtLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fYXBwZW5kUmVuZGVyZWRJdGVtID0gZnVuY3Rpb24gKG5vZGUsIGdyb3VwLCBhbmltYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXA7XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc051bGwobm9kZSkgfHwgdXRpbHMuaXNBcnJheShub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGFuaW1hdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZV8yID0gb3BHcm91cC5hbmltYXRpb25RdWV1ZSwgYW5pbWF0aW9uXzIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiB0aGlzLl9hbmltYXRvci5lbnRlcihub2RlLCBfX0VudGVyLCBvcEdyb3VwLml0ZW1Db250YWluZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXggPSBhbmltYXRpb25RdWV1ZV8yLmluZGV4T2YoYW5pbWF0aW9uXzIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWVfMi5zcGxpY2UoYW5pbWF0aW9uSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIG9wOiBudWxsXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWVfMi5wdXNoKGFuaW1hdGlvbl8yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvbnRhaW5lci5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24odGhpcy5fX3Jlc29sdmVGbikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXNvbHZlRm4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19yZXNvbHZlRm4gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGVzIHRoZSBjb250cm9sJ3MgY2hpbGRyZW4gcmVzb3VyY2Ugb2JqZWN0cyB3aGVuXHJcbiAgICAgICAgICogdGhlIGFycmF5IGNoYW5nZXMuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4PyBUaGUgaW5kZXggdG8gYmVnaW4gdXBkYXRpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50PyBUaGUgbnVtYmVyIG9mIHJlc291cmNlcyB0byB1cGRhdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLlRlbXBsYXRlQ29udHJvbH0gY29udHJvbCBUaGUgY29udHJvbCB3aG9zZSByZXNvdXJjZXMgYXJlIHRvIGJlIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl91cGRhdGVSZXNvdXJjZSA9IGZ1bmN0aW9uIChpbmRleCwgY29udHJvbCkge1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbHMgPSBjb250cm9sLmNvbnRyb2xzO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IGNvbnRyb2xzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRyb2xzW2luZGV4XS5yZXNvdXJjZXMuYWRkKHRoaXMuX2dldEFsaWFzZXModGhpcyA9PT0gY29udHJvbCA/IHRoaXMuY29udGV4dCA6IGNvbnRyb2wuY29udGV4dC5pdGVtcywgaW5kZXgpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYSByZXNvdXJjZSBhbGlhcyBvYmplY3QgZm9yIGFuIGl0ZW0gaW4gdGhlIGFycmF5LiBUaGVcclxuICAgICAgICAgKiByZXNvdXJjZSBvYmplY3QgY29udGFpbnMgaW5kZXg6bnVtYmVyLCBldmVuOmJvb2xlYW4sIG9kZDpib29sZWFuLFxyXG4gICAgICAgICAqIGZpcnN0OmJvb2xlYW4sIGFuZCBsYXN0OmJvb2xlYW4uXHJcbiAgICAgICAgICogQHBhcmFtIHthbnl9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gZ2V0IHRoZSBhbGlhc2VzIGZvci5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHVzZWQgdG8gY3JlYXRlIHRoZSByZXNvdXJjZSBhbGlhc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZ2V0QWxpYXNlcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbmRleCkge1xyXG4gICAgICAgICAgICB2YXIgaXNFdmVuID0gKGluZGV4ICYgMSkgPT09IDAsIGFsaWFzZXMgPSB7fSwgX2FsaWFzZXMgPSB0aGlzLl9hbGlhc2VzLCB0eXBlID0gX19MSVRFUkFMX1JFU09VUkNFO1xyXG4gICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmluZGV4XSA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5ldmVuXSA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBpc0V2ZW4sXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGFsaWFzZXNbX2FsaWFzZXMub2RkXSA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiAhaXNFdmVuLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbGlhc2VzW19hbGlhc2VzLmZpcnN0XSA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCA9PT0gMCxcclxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYWxpYXNlc1tfYWxpYXNlcy5sYXN0XSA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBpbmRleCA9PT0gKGNvbnRleHQubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBhbGlhc2VzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhbiBBcnJheSBvZiBpdGVtcyB0byB0aGUgZWxlbWVudCB3aXRob3V0IGFuaW1hdGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBpdGVtcyBUaGUgQXJyYXkgb2YgaXRlbXMgdG8gYWRkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIFRIZSBjb250YWluZXIgdG8gYWRkIHRoZSBpdGVtcyB0by5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2FwcGVuZEl0ZW1zID0gZnVuY3Rpb24gKGl0ZW1zLCBjb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kb20uYXBwZW5kQ2hpbGRyZW4oaXRlbXMsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBZGRzIGFuIGl0ZW0gdG8gdGhlIGNvbnRyb2wncyBlbGVtZW50IGFuaW1hdGluZyBpdHMgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBpdGVtIFRoZSBIVE1MIGZyYWdtZW50IHJlcHJlc2VudGluZyBhIHNpbmdsZSBpdGVtLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwIFRoZSBncm91cCBpdGVtcyBhcmUgYmVpbmcgYWRkZWQgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9hcHBlbmRBbmltYXRlZEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSwgZ3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzTm9kZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZSA9IGdyb3VwLmFuaW1hdGlvblF1ZXVlLCBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IHRoaXMuX2FuaW1hdG9yLmVudGVyKGl0ZW0sIF9fRW50ZXIsIGdyb3VwLml0ZW1Db250YWluZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuaW1hdGlvblF1ZXVlLmluZGV4T2YoYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgb3A6IG51bGxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uUXVldWUucHVzaChhbmltYXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVtb3ZlcyBpdGVtcyBmcm9tIHRoZSBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHN0YXJ0IGRpc3Bvc2luZyBmcm9tLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkl0ZW1zIFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gcmVtb3ZlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwIFRoZSBncm91cCBmb3Igd2hpY2ggd2UncmUgZGlzcG9zaW5nIGl0ZW1zLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fcmVtb3ZlSXRlbXMgPSBmdW5jdGlvbiAoaW5kZXgsIG51bWJlck9mSXRlbXMsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBkaXNwb3NlID0gdGhpcy5fVGVtcGxhdGVDb250cm9sRmFjdG9yeS5kaXNwb3NlLCBjb250cm9sID0gZ3JvdXAuY29udHJvbCwgY29udHJvbHMgPSBjb250cm9sLmNvbnRyb2xzLCBsYXN0ID0gaW5kZXggKyBudW1iZXJPZkl0ZW1zLCBjb250cm9sRGlzcG9zZWQgPSBsYXN0ID4gaW5kZXg7XHJcbiAgICAgICAgICAgIHdoaWxlIChsYXN0LS0gPiBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zZShjb250cm9sc1tsYXN0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVzb3VyY2UoY29udHJvbHMubGVuZ3RoIC0gMSwgY29udHJvbCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzID09PSBjb250cm9sKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29udHJvbHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBncm91cC5lbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb250cm9sRGlzcG9zZWQgJiYgdGhpcy5faXNHcm91cGVkICYmICF0aGlzLl9pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9zZXRHcm91cENvbnRhaW5lcldpZHRoLmJpbmQodGhpcywgZ3JvdXAuaXRlbUNvbnRhaW5lcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXNwb3NlIG9mIHRoZSBjb250cm9scyBhbmQgRE9NIHN0YXJ0aW5nIGF0IGEgZ2l2ZW4gaW5kZXguXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBzdGFydGluZyBpbmRleCB0byBkaXNwb3NlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgZm9yIHdoaWNoIHdlJ3JlIGRpc3Bvc2luZyBpdGVtcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2Rpc3Bvc2VGcm9tSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBvcEdyb3VwID0gZ3JvdXAgfHwgdGhpcy5fZGVmYXVsdEdyb3VwLCBjb250cm9sID0gb3BHcm91cC5jb250cm9sLCBjb250cm9scyA9IGNvbnRyb2wuY29udHJvbHMsIGRpc3Bvc2UgPSB0aGlzLl9UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5LmRpc3Bvc2UsIGxhc3QgPSBjb250cm9scy5sZW5ndGgsIGNvbnRyb2xEaXNwb3NlZCA9IGxhc3QgPiBpbmRleDtcclxuICAgICAgICAgICAgd2hpbGUgKGxhc3QtLSA+IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlKGNvbnRyb2xzW2xhc3RdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcyA9PT0gY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRyb2xzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZ3JvdXAuZWxlbWVudC5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29udHJvbERpc3Bvc2VkICYmIHRoaXMuX2lzR3JvdXBlZCAmJiAhdGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fc2V0R3JvdXBDb250YWluZXJXaWR0aC5iaW5kKHRoaXMsIGdyb3VwLml0ZW1Db250YWluZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCBhbmQgZGV0ZXJtaW5lIHRoZSBwcm9wZXIgbG9hZGluZyBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdEl0ZW1zIFRoZSBwcm9wZXJ0eSBmb3IgaW5kaWNhdGluZyB0aGUgZnVuY3Rpb24gZm9yIHJlcXVlc3RpbmcgbW9yZSBpdGVtcy5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGVSaW5nPyBXaGV0aGVyIG9yIG5vdCB0byBoaWRlIHRoZSBwcm9ncmVzcyByaW5nIGZvciBcImluY3JlbWVudGFsXCIgbG9hZGluZy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2RldGVybWluZUxvYWRpbmcgPSBmdW5jdGlvbiAocmVxdWVzdEl0ZW1zLCBzaG93UmluZykge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgY29udHJvbFByb3BlcnR5ID0gdGhpcy5maW5kUHJvcGVydHkocmVxdWVzdEl0ZW1zKSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzRnVuY3Rpb24oY29udHJvbFByb3BlcnR5LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKF9fTGlzdHZpZXcgKyBcIiBvbkl0ZW1zUmVxdWVzdGVkIGZ1bmN0aW9uIFxcXCJcIiArIHJlcXVlc3RJdGVtcyArIFwiXFxcIiB3YXMgbm90IGZvdW5kLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SXRlbXMgPSBjb250cm9sUHJvcGVydHkudmFsdWUuYmluZChjb250cm9sUHJvcGVydHkuY29udHJvbCk7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmVzc1JpbmdDb250YWluZXI7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fbG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaW5maW5pdGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVTY3JvbGxfMSwgcmVtb3ZlUmVxdWVzdF8xID0gbm9vcDtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVTY3JvbGxfMSA9IHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9zY3JvbGxDb250YWluZXIsICdzY3JvbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3Njcm9sbFJlYWR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbFJlYWR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVJlcXVlc3RfMSA9IF90aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2Nyb2xsUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zY3JvbGxSZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVSZXF1ZXN0XzEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlU2Nyb2xsXzEoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93UmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1JpbmdDb250YWluZXIgPSB0aGlzLl9sb2FkaW5nUHJvZ3Jlc3NSaW5nID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImluZmluaXRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5fZ2VuZXJhdGVQcm9ncmVzc1JpbmcoKSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXNMb2FkZWQudGhlbih0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2luY3JlbWVudGFsJzpcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1JpbmdDb250YWluZXIgPSB0aGlzLl9sb2FkaW5nUHJvZ3Jlc3NSaW5nID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyLmNsYXNzTmFtZSA9IF9fUGxhdCArIFwiaW5jcmVtZW50YWxcIjtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1JpbmdDb250YWluZXIuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5fZ2VuZXJhdGVQcm9ncmVzc1JpbmcoKSwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZShwcm9ncmVzc1JpbmdDb250YWluZXIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNjcm9sbCBldmVudCBsaXN0ZW5lci5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX29uU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5fc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxQb3MgPSB0aGlzLl9zY3JvbGxQb3NpdGlvbiwgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl9pc1ZlcnRpY2FsID9cclxuICAgICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKyBzY3JvbGxDb250YWluZXIub2Zmc2V0SGVpZ2h0IDpcclxuICAgICAgICAgICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICsgc2Nyb2xsQ29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBpZiAoc2Nyb2xsUG9zID4gc2Nyb2xsUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gc2Nyb2xsUG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsUG9zICsgNSA+IHNjcm9sbFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWJvdW5jZSBleGNlc3NpdmUgc2Nyb2xsIGV2ZW50IGNhbGxzIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFBvc2l0aW9uID0gc2Nyb2xsUG9zaXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVNjcm9sbCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBzY3JvbGxpbmcgaGFzIGhpdCB0aGUgcHJvcGVyIHRocmVzaG9sZCBhbmQgcmVxdWVzdHMgbW9yZSBpdGVtcyBpZiBpdCBoYXMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIGluZmluaXRlIHNjcm9sbGluZyBzZXQgdG8gbG9hZCBpdGVtcyBhdCA4MCUgb2Ygc2Nyb2xsIGxlbmd0aCBcclxuICAgICAgICAgICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IHRoaXMuX3Njcm9sbENvbnRhaW5lciwgc2Nyb2xsTGVuZ3RoID0gMC44ICogKHRoaXMuX2lzVmVydGljYWwgPyBzY3JvbGxDb250YWluZXIuc2Nyb2xsSGVpZ2h0IDogc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFdpZHRoKTtcclxuICAgICAgICAgICAgaWYgKHNjcm9sbExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3Njcm9sbFBvc2l0aW9uID49IHNjcm9sbExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHV0aWxzXzIgPSB0aGlzLnV0aWxzLCBpdGVtc1JlbWFpbiA9IHRoaXMuX3JlcXVlc3RJdGVtcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1zUmVtYWluID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVNjcm9sbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbHNfMi5pc1Byb21pc2UoaXRlbXNSZW1haW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzUmluZ18xID0gdGhpcy5fbG9hZGluZ1Byb2dyZXNzUmluZywgc2hvd1Byb2dyZXNzXzEgPSAhdXRpbHNfMi5pc051bGwocHJvZ3Jlc3NSaW5nXzEpLCBjb250YWluZXJfMSA9IHRoaXMuX2NvbnRhaW5lcjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxSZWFkeSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93UHJvZ3Jlc3NfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsc18yLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJfMS5pbnNlcnRCZWZvcmUocHJvZ3Jlc3NSaW5nXzEsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNSZW1haW4udGhlbihmdW5jdGlvbiAobW9yZUl0ZW1zUmVtYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93UHJvZ3Jlc3NfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfMi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcl8xLnJlbW92ZUNoaWxkKHByb2dyZXNzUmluZ18xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb3JlSXRlbXNSZW1haW4gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3Njcm9sbFJlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzXzIucG9zdHBvbmUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pdGVtc0xvYWRlZC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2Nyb2xsUmVhZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaW5kIGFuZCBkZXRlcm1pbmUgdGhlIHB1bGwtdG8tcmVmcmVzaCBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHVsbFJlZnJlc2ggVGhlIHByb3BlcnR5IGZvciBpbmRpY2F0aW5nIHRoZSBwdWxsLXRvLXJlZnJlc2ggZnVuY3Rpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9pbml0aWFsaXplUmVmcmVzaCA9IGZ1bmN0aW9uIChyZWZyZXNoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250cm9sUHJvcGVydHkgPSB0aGlzLmZpbmRQcm9wZXJ0eShyZWZyZXNoKSB8fCB7fTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzRnVuY3Rpb24oY29udHJvbFByb3BlcnR5LnZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKF9fTGlzdHZpZXcgKyBcIiBvblJlZnJlc2ggZnVuY3Rpb24gXFxcIlwiICsgcmVmcmVzaCArIFwiXFxcIiB3YXMgbm90IGZvdW5kLlwiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZWZyZXNoID0gY29udHJvbFByb3BlcnR5LnZhbHVlLmJpbmQoY29udHJvbFByb3BlcnR5LmNvbnRyb2wpO1xyXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3NSaW5nQ29udGFpbmVyID0gdGhpcy5fcmVmcmVzaFByb2dyZXNzUmluZyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBwcm9ncmVzc1JpbmdDb250YWluZXIuY2xhc3NOYW1lID0gX19QbGF0ICsgXCJyZWZyZXNoXCI7XHJcbiAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoX19IaWRlLCAnJyk7XHJcbiAgICAgICAgICAgIHByb2dyZXNzUmluZ0NvbnRhaW5lci5pbnNlcnRCZWZvcmUodGhpcy5fZ2VuZXJhdGVQcm9ncmVzc1JpbmcoKSwgbnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5pbnNlcnRCZWZvcmUocHJvZ3Jlc3NSaW5nQ29udGFpbmVyLCBudWxsKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBwcm9wZXIgdHJhY2tpbmcgZXZlbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9hZGluZyBXaGV0aGVyIG9yIG5vdCB0byBpbml0aWFsaXplIHRoZSBsb2FkaW5nIHRyYWNraW5nIGV2ZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZnJlc2ggV2hldGhlciBvciBub3QgdG8gaW5pdGlhbGl6ZSB0aGUgcmVmcmVzaCB0cmFja2luZyBldmVudHMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9pbml0aWFsaXplVHJhY2tpbmcgPSBmdW5jdGlvbiAobG9hZGluZywgcmVmcmVzaCkge1xyXG4gICAgICAgICAgICBpZiAoIShsb2FkaW5nIHx8IHJlZnJlc2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHZhciB0cmFjaywgcmV2ZXJzZVRyYWNrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2sgPSBfXyR0cmFjayArIFwiZG93blwiO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVRyYWNrID0gX18kdHJhY2sgKyBcInVwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cmFjayA9IF9fJHRyYWNrICsgXCJyaWdodFwiO1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZVRyYWNrID0gX18kdHJhY2sgKyBcImxlZnRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCwgdG91Y2hFbmQsIHRyYWNrRm47XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdG91Y2hzdGFydCwgdGhpcy5fdG91Y2hTdGFydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAobG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgdG91Y2hFbmQgPSB0aGlzLl90b3VjaEVuZExvYWQ7XHJcbiAgICAgICAgICAgICAgICB0cmFja0ZuID0gdGhpcy5fdHJhY2tMb2FkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0b3VjaGVuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIF9fJHRvdWNoY2FuY2VsLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCB0cmFjaywgdHJhY2tGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCByZXZlcnNlVHJhY2ssIHRyYWNrRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVmcmVzaCkge1xyXG4gICAgICAgICAgICAgICAgdG91Y2hFbmQgPSB0aGlzLl90b3VjaEVuZFJlZnJlc2g7XHJcbiAgICAgICAgICAgICAgICB0cmFja0ZuID0gdGhpcy5fdHJhY2tSZWZyZXNoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCBfXyR0b3VjaGVuZCwgdG91Y2hFbmQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih2aWV3cG9ydCwgX18kdHJhY2tlbmQsIHRvdWNoRW5kLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIodmlld3BvcnQsIF9fJHRvdWNoY2FuY2VsLCB0b3VjaEVuZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCB0cmFjaywgdHJhY2tGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKHZpZXdwb3J0LCByZXZlcnNlVHJhY2ssIHRyYWNrRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRvdWNoIHN0YXJ0IGV2ZW50IGxpc3RlbmVyIGZvciB3aGVuIGxvb2tpbmcgZm9yIGEgcmVmcmVzaC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0b3VjaHN0YXJ0IGV2ZW50IG9iamVjdC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3RvdWNoU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3RvdWNoU3RhdGUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IE1hdGguY2VpbChldi5vZmZzZXRZKSwgXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSdyZSBnb2luZyB0byBkZWNyZWFzZSB0aGUgdGhyZXNob2xkIGJ5IDIwIHRvIGJ1ZmZlciB0aGUgc2Nyb2xsYmFyIFxyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gdGhpcy5fdmlld3BvcnQub2Zmc2V0SGVpZ2h0IC0gMjA7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zID49IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoID0ge1xyXG4gICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCxcclxuICAgICAgICAgICAgICAgIHk6IGV2LmNsaWVudFlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnV0aWxzLmlzTnVsbCh0aGlzLl90b3VjaEFuaW1hdGlvblRoZW5hYmxlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdG91Y2hBbmltYXRpb25UaGVuYWJsZS5jYW5jZWwoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hBbmltYXRpb25UaGVuYWJsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoU3RhdGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hTdGF0ZSA9IDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdG91Y2ggZW5kIGV2ZW50IGxpc3RlbmVyIGZvciB3aGVuIGxvb2tpbmcgZm9yIGFuIGluY3JlbWVudGFsIGxvYWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdG91Y2hlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdG91Y2hFbmRMb2FkID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBpc0xvYWRpbmcgPSB0aGlzLl9pc0xvYWRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIWlzTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1JlZnJlc2hpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5fc2Nyb2xsQ29udGFpbmVyLCBzY3JvbGxMZW5ndGgsIHRocmVzaG9sZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbExlbmd0aCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKyBzY3JvbGxDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjcm9sbExlbmd0aCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICsgc2Nyb2xsQ29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGRvIHBsdXMgMSBoZXJlIGZvciBicm93c2VyIHBpeGVsIGluY29uc2lzdGVuY3kgXHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxMZW5ndGggKyAxIDwgdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaEVuZChldiwgZmFsc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRvdWNoIGVuZCBldmVudCBsaXN0ZW5lciBmb3Igd2hlbiBsb29raW5nIGZvciBhIHJlZnJlc2guXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdG91Y2hlbmQgZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdG91Y2hFbmRSZWZyZXNoID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBpc1JlZnJlc2hpbmcgPSB0aGlzLl9pc1JlZnJlc2hpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUmVmcmVzaGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIWlzUmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgodGhpcy5faXNWZXJ0aWNhbCA/IHRoaXMuX3Njcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgOiB0aGlzLl9zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaFN0YXRlID0gMDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90b3VjaEVuZChldiwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNvbW1vbiB0b3VjaCBlbmQgZXZlbnQgbGlzdGVuZXIgZm9yIGJvdGggcmVmcmVzaCBhbmQgaW5jcmVtZW50YWwgbG9hZGluZy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0b3VjaGVuZCBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZWZyZXNoaW5nIFdoZXRoZXIgdGhpcyB0cmFuc2xhdGlvbiBpcyBmb3IgcmVmcmVzaCBvciBpbmNyZW1lbnRhbCBsb2FkaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdG91Y2hFbmQgPSBmdW5jdGlvbiAoZXYsIHJlZnJlc2hpbmcpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5fdG91Y2hTdGF0ZSwgaGFzTW92ZWQgPSB0aGlzLl9oYXNNb3ZlZDtcclxuICAgICAgICAgICAgdGhpcy5faGFzTW92ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHN0YXRlIDwgMiB8fCAhaGFzTW92ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IHt9LCBkb20gPSB0aGlzLmRvbSwgdmlld3BvcnQgPSB0aGlzLl92aWV3cG9ydCwgcHJvZ3Jlc3NSaW5nID0gcmVmcmVzaGluZyA/IHRoaXMuX3JlZnJlc2hQcm9ncmVzc1JpbmcgOiB0aGlzLl9sb2FkaW5nUHJvZ3Jlc3NSaW5nLCBpc0FjdGlvblN0YXRlID0gc3RhdGUgPT09IDMsIG5leHRUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgaWYgKGlzQWN0aW9uU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHJlZnJlc2hpbmcgPyBwcm9ncmVzc1Jpbmcub2Zmc2V0SGVpZ2h0IDogLXByb2dyZXNzUmluZy5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUzZCgwLFwiICsgb2Zmc2V0ICsgXCJweCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gcmVmcmVzaGluZyA/IHByb2dyZXNzUmluZy5vZmZzZXRXaWR0aCA6IC1wcm9ncmVzc1Jpbmcub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRyYW5zbGF0aW9uID0gXCJ0cmFuc2xhdGUzZChcIiArIG9mZnNldCArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV4dFRyYW5zbGF0aW9uID0gdGhpcy5fcHJlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnNbdGhpcy5fdHJhbnNmb3JtXSA9IG5leHRUcmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fdG91Y2hBbmltYXRpb25UaGVuYWJsZSA9IHRoaXMuX2FuaW1hdG9yLmFuaW1hdGUodmlld3BvcnQsIF9fVHJhbnNpdGlvbiwge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLl90b3VjaFN0YXRlID0gNDtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9oYXNNb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoQW5pbWF0aW9uVGhlbmFibGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aW9uU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX1Byb21pc2UucmVzb2x2ZShyZWZyZXNoaW5nID8gX3RoaXMuX3JlZnJlc2goKSA6IF90aGlzLl9yZXF1ZXN0SXRlbXMoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Modmlld3BvcnQsIF9fUGxhdCArIFwibWFuaXB1bGF0aW9uLXByZXBcIik7XHJcbiAgICAgICAgICAgICAgICBwcm9ncmVzc1Jpbmcuc2V0QXR0cmlidXRlKF9fSGlkZSwgJycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWN0aW9uU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fdG91Y2hTdGF0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKHByb2dyZXNzUmluZywgX19QbGF0ICsgXCJwbGF5XCIpO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9uc1tfdGhpcy5fdHJhbnNmb3JtXSA9IF90aGlzLl9wcmVUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3RvdWNoQW5pbWF0aW9uVGhlbmFibGUgPSBfdGhpcy5fYW5pbWF0b3IuYW5pbWF0ZSh2aWV3cG9ydCwgX19UcmFuc2l0aW9uLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogYW5pbWF0aW9uT3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl90b3VjaEFuaW1hdGlvblRoZW5hYmxlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3Modmlld3BvcnQsIF9fUGxhdCArIFwibWFuaXB1bGF0aW9uLXByZXBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NSaW5nLnNldEF0dHJpYnV0ZShfX0hpZGUsICcnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KS50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3RvdWNoU3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy5kZWJ1ZyhfdGhpcy50eXBlICsgXCIgZXJyb3I6IFwiICsgZXJyb3IpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0cmFja2luZyBldmVudCBsaXN0ZW5lciBmb3IgbG9va2luZyBmb3IgYSBsb2FkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrW2RpcmVjdGlvbl0gZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdHJhY2tMb2FkID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1JlZnJlc2hpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbENvbnRhaW5lciA9IHRoaXMuX3Njcm9sbENvbnRhaW5lciwgc2Nyb2xsTGVuZ3RoID0gdm9pZCAwLCB0aHJlc2hvbGQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5kaXJlY3Rpb24ueSAhPT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlbmd0aCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKyBzY3JvbGxDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYuZGlyZWN0aW9uLnggIT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbExlbmd0aCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICsgc2Nyb2xsQ29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRvIHBsdXMgMSBoZXJlIGZvciBicm93c2VyIHBpeGVsIGluY29uc2lzdGVuY3kgXHJcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsTGVuZ3RoICsgMSA8IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdHJhY2soZXYsIGZhbHNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0cmFja2luZyBldmVudCBsaXN0ZW5lciBmb3IgbG9va2luZyBmb3IgYSByZWZyZXNoLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgJHRyYWNrW2RpcmVjdGlvbl0gZXZlbnQgb2JqZWN0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdHJhY2tSZWZyZXNoID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXYuZGlyZWN0aW9uLnkgIT09ICdkb3duJyB8fCB0aGlzLl9zY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXYuZGlyZWN0aW9uLnggIT09ICdyaWdodCcgfHwgdGhpcy5fc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNSZWZyZXNoaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90cmFjayhldiwgdHJ1ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIHRoZSB0cmFuc2xhdGlvbiBvZiB0aGUgdmlld3BvcnQgd2hpbGUgdHJhY2tpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2IFRoZSAkdHJhY2tbZGlyZWN0aW9uXSBldmVudCBvYmplY3QuXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSByZWZyZXNoaW5nIFdoZXRoZXIgdGhpcyB0cmFuc2xhdGlvbiBpcyBmb3IgcmVmcmVzaCBvciBpbmNyZW1lbnRhbCBsb2FkaW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fdHJhY2sgPSBmdW5jdGlvbiAoZXYsIHJlZnJlc2hpbmcpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHRvdWNoU3RhdGUgPSB0aGlzLl90b3VjaFN0YXRlO1xyXG4gICAgICAgICAgICBpZiAoISh0b3VjaFN0YXRlID09PSAyIHx8IHRvdWNoU3RhdGUgPT09IDMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gdGhpcy5fY2FsY3VsYXRlVHJhbnNsYXRpb24oZXYsIHJlZnJlc2hpbmcpO1xyXG4gICAgICAgICAgICB0aGlzLnV0aWxzLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fdmlld3BvcnQuc3R5bGVbX3RoaXMuX3RyYW5zZm9ybV0gPSB0cmFuc2xhdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSB0cmFuc2xhdGlvbiB2YWx1ZSBmb3Igc2V0dGluZyB0aGUgdHJhbnNmb3JtIHZhbHVlIGR1cmluZyB0cmFja2luZy5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXYgVGhlICR0cmFja2luZyBldmVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZnJlc2hpbmcgV2hldGhlciB0aGlzIHRyYW5zbGF0aW9uIGlzIGZvciByZWZyZXNoIG9yIGluY3JlbWVudGFsIGxvYWRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9jYWxjdWxhdGVUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChldiwgcmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICB2YXIgaXNWZXJ0aWNhbCA9IHRoaXMuX2lzVmVydGljYWwsIHByb2dyZXNzUmluZyA9IHJlZnJlc2hpbmcgPyB0aGlzLl9yZWZyZXNoUHJvZ3Jlc3NSaW5nIDogdGhpcy5fbG9hZGluZ1Byb2dyZXNzUmluZywgZGlmZiwgdGhyZXNob2xkO1xyXG4gICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IGV2LmNsaWVudFkgLSB0aGlzLl9sYXN0VG91Y2gueTtcclxuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IHByb2dyZXNzUmluZy5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmID0gZXYuY2xpZW50WCAtIHRoaXMuX2xhc3RUb3VjaC54O1xyXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkID0gcHJvZ3Jlc3NSaW5nLm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgocmVmcmVzaGluZyAmJiBkaWZmIDwgMCkgfHwgKCFyZWZyZXNoaW5nICYmIGRpZmYgPiAwKSkge1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hhc01vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNNb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0aGlzLl92aWV3cG9ydCwgX19QbGF0ICsgXCJtYW5pcHVsYXRpb24tcHJlcFwiKTtcclxuICAgICAgICAgICAgICAgIHByb2dyZXNzUmluZy5yZW1vdmVBdHRyaWJ1dGUoX19IaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhkaWZmKSA+PSB0aHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b3VjaFN0YXRlIDwgMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKHByb2dyZXNzUmluZywgX19QbGF0ICsgXCJwbGF5XCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3RvdWNoU3RhdGUgPT09IDMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoU3RhdGUgPSAyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kb20ucmVtb3ZlQ2xhc3MocHJvZ3Jlc3NSaW5nLCBfX1BsYXQgKyBcInBsYXlcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKDAsXCIgKyBkaWZmICsgXCJweCwwKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcInRyYW5zbGF0ZTNkKFwiICsgZGlmZiArIFwicHgsMCwwKVwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2J0YWlucyB0aGUgY3VycmVudCBicm93c2VyJ3MgdHJhbnNmb3JtIHByb3BlcnR5IHZhbHVlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl92aWV3cG9ydC5zdHlsZSwgaXNVbmRlZmluZWQgPSB0aGlzLnV0aWxzLmlzVW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YXIgdmVuZG9yUHJlZml4ID0gdGhpcy5fY29tcGF0LnZlbmRvclByZWZpeDtcclxuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9wcmVUcmFuc2Zvcm0gPSBzdHlsZVsodmVuZG9yUHJlZml4Lmxvd2VyQ2FzZSArIFwiVHJhbnNmb3JtXCIpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHZlbmRvclByZWZpeC5sb3dlckNhc2UgKyBcIlRyYW5zZm9ybVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9wcmVUcmFuc2Zvcm0gPSBzdHlsZVsodmVuZG9yUHJlZml4LnVwcGVyQ2FzZSArIFwiVHJhbnNmb3JtXCIpXSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHZlbmRvclByZWZpeC51cHBlckNhc2UgKyBcIlRyYW5zZm9ybVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlVHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gJ3RyYW5zZm9ybSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENsb25lcyBhbmQgcGFyc2VzIHRoZXMgaW5uZXJUZW1wbGF0ZSBhbmQgY3JlYXRlcyB0aGUgdGVtcGxhdGVzIG9iamVjdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaXRlbVRlbXBsYXRlIFRoZSBub3JtYWxpemVkIGl0ZW0gdGVtcGxhdGUgbmFtZSBmcm9tIHRoZSBvcHRpb25zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZWFkZXJUZW1wbGF0ZT8gVGhlIG5vcm1hbGl6ZWQgZ3JvdXAgaGVhZGVyIHRlbXBsYXRlIG5hbWUgZnJvbSB0aGUgb3B0aW9ucy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3BhcnNlSW5uZXJUZW1wbGF0ZSA9IGZ1bmN0aW9uIChpdGVtVGVtcGxhdGUsIGhlYWRlclRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZXMgPSB0aGlzLl90ZW1wbGF0ZXMsIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLCBhcHBlbmRDaGlsZHJlbiA9IHRoaXMuZG9tLmFwcGVuZENoaWxkcmVuLCBfZG9jdW1lbnQgPSB0aGlzLl9kb2N1bWVudCwgdmFsaWRHcm91cFRlbXBsYXRlID0gIXRoaXMudXRpbHMuaXNOdWxsKGhlYWRlclRlbXBsYXRlKSwgY2hpbGROb2RlcyA9IHNsaWNlLmNhbGwodGhpcy5pbm5lclRlbXBsYXRlLmNoaWxkTm9kZXMpLCBjaGlsZE5vZGUsIHRlbXBsYXRlTmFtZSwgY29udGFpbmVyO1xyXG4gICAgICAgICAgICB3aGlsZSAoY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlTmFtZSA9IHRoaXMuX25vcm1hbGl6ZVRlbXBsYXRlTmFtZShjaGlsZE5vZGUubm9kZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkR3JvdXBUZW1wbGF0ZSAmJiB0ZW1wbGF0ZU5hbWUgPT09IGhlYWRlclRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImhlYWRlclwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkcmVuKGNoaWxkTm9kZS5jaGlsZE5vZGVzLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVzW3RlbXBsYXRlTmFtZV0gPSBjb250YWluZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlY2VpdmVzIGFuIGV2ZW50IHdoZW4gYSBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIG9uIGFuIGFycmF5IGFuZCBtYXBzIHRoZSBhcnJheVxyXG4gICAgICAgICAqIG1ldGhvZCB0byBpdHMgYXNzb2NpYXRlZCBtZXRob2QgaGFuZGxlci5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBtdXRhdGlvbiBldmVudCBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2V4ZWN1dGVFdmVudCA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIl9cIiArIGNoYW5nZXNbMF0udHlwZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZF0oY2hhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgbmV3IGdyb3VwIHRvIHRoZSBjb250cm9sJ3MgZWxlbWVudC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lIFRoZSBncm91cCBuYW1lIG9mIHRoZSBjdXJyZW50bHkgY2hhbmdpbmcgQXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgY2hhbmdlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fZXhlY3V0ZUNoaWxkRXZlbnQgPSBmdW5jdGlvbiAoZ3JvdXBOYW1lLCBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIG1ldGhvZCA9IFwiX1wiICsgY2hhbmdlc1swXS50eXBlO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc051bGwoZ3JvdXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2RdKGNoYW5nZXMsIGdyb3VwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyc3QgY2hlY2tzIGlmIHRoZSBwdXNoIHdpbGwgZG8gYW55dGhpbmcsIHRoZW4gaGFuZGxlcyBpdGVtcyBiZWluZyBwdXNoZWQgaW50byB0aGUgYXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgY2hhbmdlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBncm91cCkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1swXSwgYWRkZWRDb3VudCA9IGNoYW5nZS5hZGRlZENvdW50O1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtcyhjaGFuZ2UuaW5kZXgsIGFkZGVkQ291bnQsIGdyb3VwLCB0aGlzLl9hbmltYXRlID8gYWRkZWRDb3VudCA6IDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyBwb3BwZWQgb2ZmIHRoZSBhcnJheS5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PHBsYXQub2JzZXJ2YWJsZS5JQXJyYXlDaGFuZ2VzPGFueT4+fSBjaGFuZ2VzIFRoZSBBcnJheSBjaGFuZ2UgaW5mb3JtYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSUdyb3VwSGFzaH0gZ3JvdXA/IFRoZSBncm91cCB0aGF0IHdlJ3JlIHBlcmZvcm1pbmcgdGhpcyBvcGVyYXRpb24gb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9wb3AgPSBmdW5jdGlvbiAoY2hhbmdlcywgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGFkZFF1ZXVlID0gb3BHcm91cC5hZGRRdWV1ZSwgY2hhbmdlID0gY2hhbmdlc1swXSwgc3RhcnQgPSBjaGFuZ2Uub2JqZWN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZS5yZW1vdmVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVJbmRleCA9IGNoYW5nZS5vYmplY3QubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAob3BHcm91cC5pdGVtQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBvcEdyb3VwLml0ZW1Db3VudC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX1Byb21pc2UuYWxsKGFkZFF1ZXVlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fYW5pbWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRlSXRlbXMoc3RhcnQsIDEsIF9fTGVhdmUsIG9wR3JvdXAsICdsZWF2ZScsIGZhbHNlKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUl0ZW1zKHJlbW92ZUluZGV4LCAxLCBvcEdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMocmVtb3ZlSW5kZXgsIDEsIG9wR3JvdXApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhhbmRsZXMgaXRlbXMgYmVpbmcgdW5zaGlmdGVkIGludG8gdGhlIGFycmF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8cGxhdC5vYnNlcnZhYmxlLklBcnJheUNoYW5nZXM8YW55Pj59IGNoYW5nZXMgVGhlIEFycmF5IGNoYW5nZSBpbmZvcm1hdGlvbi5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JR3JvdXBIYXNofSBncm91cD8gVGhlIGdyb3VwIHRoYXQgd2UncmUgcGVyZm9ybWluZyB0aGlzIG9wZXJhdGlvbiBvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3Vuc2hpZnQgPSBmdW5jdGlvbiAoY2hhbmdlcywgZ3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNGdW5jdGlvbih0aGlzLl90ZW1wbGF0ZVNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXJlbmRlcihncm91cCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGNoYW5nZSA9IGNoYW5nZXNbMF0sIGFkZGVkQ291bnQgPSBjaGFuZ2UuYWRkZWRDb3VudDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25RdWV1ZSA9IG9wR3JvdXAuYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbkxlbmd0aCA9IGFuaW1hdGlvblF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGVJdGVtcygwLCBhZGRlZENvdW50LCBfX0VudGVyLCBvcEdyb3VwLCBudWxsLCBhbmltYXRpb25MZW5ndGggPiAwICYmIGFuaW1hdGlvblF1ZXVlW2FuaW1hdGlvbkxlbmd0aCAtIDFdLm9wID09PSAnY2xvbmUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtcyhjaGFuZ2Uub2JqZWN0Lmxlbmd0aCAtIGFkZGVkQ291bnQsIGFkZGVkQ291bnQsIG9wR3JvdXAsIDApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBpdGVtcyBiZWluZyBzaGlmdGVkIG9mZiB0aGUgYXJyYXkuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgY2hhbmdlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fc2hpZnQgPSBmdW5jdGlvbiAoY2hhbmdlcywgZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGFkZFF1ZXVlID0gb3BHcm91cC5hZGRRdWV1ZSwgY2hhbmdlID0gY2hhbmdlc1swXTtcclxuICAgICAgICAgICAgaWYgKGNoYW5nZS5yZW1vdmVkLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2FuaW1hdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhZGRRdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRRdWV1ZSA9IGFkZFF1ZXVlLmNvbmNhdChbdGhpcy5fYW5pbWF0ZUl0ZW1zKDAsIDEsIF9fTGVhdmUsIG9wR3JvdXAsICdjbG9uZScsIHRydWUpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUluZGV4ID0gY2hhbmdlLm9iamVjdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChvcEdyb3VwLml0ZW1Db3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvdW50LS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUl0ZW1zKHJlbW92ZUluZGV4LCAxLCBvcEdyb3VwKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGFkZGluZy9yZW1vdmluZyBpdGVtcyB3aGVuIGFuIGFycmF5IGlzIHNwbGljZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxwbGF0Lm9ic2VydmFibGUuSUFycmF5Q2hhbmdlczxhbnk+Pn0gY2hhbmdlcyBUaGUgQXJyYXkgY2hhbmdlIGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IGdyb3VwPyBUaGUgZ3JvdXAgdGhhdCB3ZSdyZSBwZXJmb3JtaW5nIHRoaXMgb3BlcmF0aW9uIG9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fc3BsaWNlID0gZnVuY3Rpb24gKGNoYW5nZXMsIGdyb3VwKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB1dGlscyA9IHRoaXMudXRpbHMsIGNoYW5nZSA9IGNoYW5nZXNbMF0sIG9wR3JvdXAgPSBncm91cCB8fCB0aGlzLl9kZWZhdWx0R3JvdXAsIGFkZENvdW50ID0gY2hhbmdlLmFkZGVkQ291bnQsIGN1cnJlbnRMZW5ndGggPSBvcEdyb3VwLml0ZW1Db3VudCwgY29udHJvbCA9IG9wR3JvdXAuY29udHJvbCwgYWRkUXVldWUgPSBvcEdyb3VwLmFkZFF1ZXVlLCBhbmltYXRpbmcgPSB0aGlzLl9hbmltYXRlO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNOdWxsKGFkZENvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbEN1cnJlbnRBbmltYXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3TGVuZ3RoID0gY2hhbmdlLm9iamVjdC5sZW5ndGgsIGl0ZW1Db3VudF8xID0gY3VycmVudExlbmd0aCAtIG5ld0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdMZW5ndGggPiBjdXJyZW50TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24odGhpcy5fdGVtcGxhdGVTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHV0aWxzLmlzTnVsbChjaGFuZ2UuaW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcmVuZGVyKG9wR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoY2hhbmdlLmluZGV4LCBhZGRDb3VudCwgb3BHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBpdGVtQ291bnQgd2lsbCBiZSBuZWdhdGl2ZSBcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtcyhjdXJyZW50TGVuZ3RoLCAtaXRlbUNvdW50XzEsIG9wR3JvdXAsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudExlbmd0aCA+IG5ld0xlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcEdyb3VwLml0ZW1Db3VudCA+PSBpdGVtQ291bnRfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcEdyb3VwLml0ZW1Db3VudCAtPSBpdGVtQ291bnRfMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wR3JvdXAuaXRlbUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlSXRlbXMoY3VycmVudExlbmd0aCAtIGl0ZW1Db3VudF8xLCBpdGVtQ291bnRfMSwgb3BHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJlbW92ZUNvdW50ID0gY2hhbmdlLnJlbW92ZWQubGVuZ3RoLCBhbmltYXRpb25RdWV1ZSA9IG9wR3JvdXAuYW5pbWF0aW9uUXVldWU7XHJcbiAgICAgICAgICAgIGlmIChhZGRDb3VudCA+IHJlbW92ZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXRlbUFkZENvdW50ID0gYWRkQ291bnQgLSByZW1vdmVDb3VudCwgYW5pbWF0aW9uQ291bnQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0aGlzLl90ZW1wbGF0ZVNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh1dGlscy5pc051bGwoY2hhbmdlLmluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcmVuZGVyKG9wR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoY2hhbmdlLmluZGV4LCBhZGRDb3VudCwgb3BHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Db3VudCA9IGFkZENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25MZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGgsIHN0YXJ0SW5kZXggPSBjaGFuZ2UuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCBhZGRDb3VudCAtIHN0YXJ0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uQ291bnQgPSBjdXJyZW50TGVuZ3RoIC0gc3RhcnRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0ZUl0ZW1zKHN0YXJ0SW5kZXgsIGFuaW1hdGlvbkNvdW50LCBfX0VudGVyLCBvcEdyb3VwLCBudWxsLCBhbmltYXRpb25MZW5ndGggPiAwICYmIGFuaW1hdGlvblF1ZXVlW2FuaW1hdGlvbkxlbmd0aCAtIDFdLm9wID09PSAnY2xvbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Db3VudCA9IGFkZENvdW50IC0gYW5pbWF0aW9uQ291bnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Db3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVJdGVtcyhjaGFuZ2Uub2JqZWN0Lmxlbmd0aCAtIGl0ZW1BZGRDb3VudCwgaXRlbUFkZENvdW50LCBvcEdyb3VwLCBhbmltYXRpb25Db3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVtb3ZlQ291bnQgPiBhZGRDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFkZGluZ18xID0gYWRkQ291bnQgPiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGluZyAmJiAhYWRkaW5nXzEgJiYgYWRkUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUXVldWUgPSBhZGRRdWV1ZS5jb25jYXQoW3RoaXMuX2FuaW1hdGVJdGVtcyhjaGFuZ2UuaW5kZXgsIHJlbW92ZUNvdW50LCBfX0xlYXZlLCBvcEdyb3VwLCAnY2xvbmUnLCB0cnVlKV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0ZUNvdW50XzEgPSByZW1vdmVDb3VudCAtIGFkZENvdW50O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wR3JvdXAuaXRlbUNvdW50ID49IGRlbGV0ZUNvdW50XzEpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcEdyb3VwLml0ZW1Db3VudCAtPSBkZWxldGVDb3VudF8xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3BHcm91cC5pdGVtQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fUHJvbWlzZS5hbGwoYWRkUXVldWUpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpbmcgJiYgYWRkaW5nXzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1MZW5ndGggPSBhbmltYXRpb25RdWV1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9hbmltYXRlSXRlbXMoY2hhbmdlLmluZGV4LCBhZGRDb3VudCwgX19FbnRlciwgb3BHcm91cCwgbnVsbCwgYW5pbUxlbmd0aCA+IDAgJiYgYW5pbWF0aW9uUXVldWVbYW5pbUxlbmd0aCAtIDFdLm9wID09PSAnY2xvbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUl0ZW1zKGN1cnJlbnRMZW5ndGggLSBkZWxldGVDb3VudF8xLCBkZWxldGVDb3VudF8xLCBvcEdyb3VwKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmltYXRlcyB0aGUgaW5kaWNhdGVkIGl0ZW1zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IFRoZSBzdGFydGluZyBpbmRleCBvZiBpdGVtcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkl0ZW1zIFRoZSBudW1iZXIgb2YgY29uc2VjdXRpdmUgaXRlbXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhbmltYXRpb24ga2V5L3R5cGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtJR3JvdXBIYXNofSBncm91cCBUaGUgZ3JvdXAgcGVyZm9ybWluZyB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25PcCBEZW5vdGVzIGFuaW1hdGlvbiBvcGVyYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjYW5jZWwgV2hldGhlciBvciBub3QgdG8gY2FuY2VsIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBiZWZvcmUgYmVnaW5uaW5nIHRoaXMgb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fYW5pbWF0ZUl0ZW1zID0gZnVuY3Rpb24gKHN0YXJ0SW5kZXgsIG51bWJlck9mSXRlbXMsIGtleSwgZ3JvdXAsIGFuaW1hdGlvbk9wLCBjYW5jZWwpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChhbmltYXRpb25PcCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvbmUnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDbG9uZWRDb250YWluZXJBbmltYXRpb24odGhpcy5fZ2V0QW5pbWF0ZWROb2RlcyhzdGFydEluZGV4LCBudW1iZXJPZkl0ZW1zLCBncm91cCksIGtleSwgZ3JvdXAsIGNhbmNlbCA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsZWF2ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUxlYXZlKHRoaXMuX2dldEFuaW1hdGVkTm9kZXMoc3RhcnRJbmRleCwgbnVtYmVyT2ZJdGVtcywgZ3JvdXApLCBrZXksIGdyb3VwKTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVNpbXBsZUFuaW1hdGlvbih0aGlzLl9nZXRBbmltYXRlZE5vZGVzKHN0YXJ0SW5kZXgsIG51bWJlck9mSXRlbXMsIGdyb3VwKSwga2V5LCBncm91cCwgY2FuY2VsID09PSB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhbnNsYXRlcyB0aGUgaXRlbXMgdG8gYmUgYW5pbWF0ZWQgaW50byB0aGUgbm9kZXMgdG8gYmUgYW5pbWF0ZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggVGhlIHN0YXJ0aW5nIGluZGV4IG9mIGl0ZW1zIHRvIGFuaW1hdGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mSXRlbXMgVGhlIG51bWJlciBvZiBjb25zZWN1dGl2ZSBpdGVtcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7SUdyb3VwSGFzaH0gZ3JvdXAgVGhlIGdyb3VwIHBlcmZvcm1pbmcgdGhlIGFuaW1hdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2dldEFuaW1hdGVkTm9kZXMgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgbnVtYmVyT2ZJdGVtcywgZ3JvdXApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzR3JvdXBlZCAmJiBncm91cCA9PT0gdGhpcy5fZGVmYXVsdEdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgYW5pbWF0aW5nIGEgZ3JvdXAgc28gYmxvY2sgbGVuZ3RoID09PSAzIChvbmUgZWxlbWVudCBub2RlIGFuZCB0d28gY29tbWVudCBub2RlcykgXHJcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tMZW5ndGggPSAzLCBzdGFydCA9IHN0YXJ0SW5kZXggKiBibG9ja0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChncm91cC5pdGVtQ29udGFpbmVyLmNoaWxkTm9kZXMsIHN0YXJ0LCBudW1iZXJPZkl0ZW1zICogYmxvY2tMZW5ndGggKyBzdGFydCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHV0aWxzID0gdGhpcy51dGlscywgaXNOb2RlID0gdXRpbHMuaXNOb2RlLCBub2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGdyb3VwLml0ZW1Db250YWluZXIuY2hpbGROb2RlcyksIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIG51bWJlck9mSXRlbXMgLSAxLCBjb250cm9scyA9IGdyb3VwLmNvbnRyb2wuY29udHJvbHM7XHJcbiAgICAgICAgICAgIGlmIChjb250cm9scy5sZW5ndGggPD0gZW5kSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gY29udHJvbHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlID0gY29udHJvbHNbc3RhcnRJbmRleF0uc3RhcnROb2RlLCBlbmROb2RlID0gY29udHJvbHNbZW5kSW5kZXhdLmVuZE5vZGU7XHJcbiAgICAgICAgICAgIGlmICghKGlzTm9kZShzdGFydE5vZGUpICYmIGlzTm9kZShlbmROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3RhcnROb2RlSW5kZXggPSBub2Rlcy5pbmRleE9mKHN0YXJ0Tm9kZSksIGVuZE5vZGVJbmRleCA9IG5vZGVzLmluZGV4T2YoZW5kTm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE5vZGVJbmRleCA9PT0gLTEgfHwgZW5kTm9kZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBub2Rlcy5zbGljZShzdGFydE5vZGVJbmRleCwgZW5kTm9kZUluZGV4ICsgMSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGEgc2ltcGxlIGFuaW1hdGlvbiBvZiBhIGJsb2NrIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzIFRoZSBBcnJheSBvZiBub2RlcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0lHcm91cEhhc2h9IGdyb3VwIFRoZSBncm91cCBwZXJmb3JtaW5nIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBjYW5jZWwgV2hldGhlciBvciBub3QgdG8gY2FuY2VsIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBiZWZvcmUgYmVnaW5uaW5nIHRoaXMgb25lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5faGFuZGxlU2ltcGxlQW5pbWF0aW9uID0gZnVuY3Rpb24gKG5vZGVzLCBrZXksIGdyb3VwLCBjYW5jZWwpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX1Byb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBncm91cC5pdGVtQ29udGFpbmVyLCBhbmltYXRpb25RdWV1ZSA9IGdyb3VwLmFuaW1hdGlvblF1ZXVlLCBhbmltYXRpb25DcmVhdGlvbiA9IHRoaXMuX2FuaW1hdG9yLmNyZWF0ZShub2Rlcywga2V5KSwgYW5pbWF0aW9uLCBhbmltYXRpb25Qcm9taXNlID0gYW5pbWF0aW9uQ3JlYXRpb24uY3VycmVudC50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFuaW1hdGlvblF1ZXVlLmluZGV4T2YoYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9KSwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25DcmVhdGlvbi5wcmV2aW91cy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25Qcm9taXNlLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvblByb21pc2UsXHJcbiAgICAgICAgICAgICAgICBvcDogbnVsbFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoY2FuY2VsICYmIGFuaW1hdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYW5jZWxQcm9taXNlID0gdGhpcy5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMoKS50aGVuKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goYW5pbWF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGVzIGEgc2ltcGxlIGFuaW1hdGlvbiBvZiBhIGJsb2NrIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzIFRoZSBBcnJheSBvZiBub2RlcyB0byBhbmltYXRlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGFuaW1hdGlvbiBrZXkvdHlwZS5cclxuICAgICAgICAgKiBAcGFyYW0ge0lHcm91cEhhc2h9IGdyb3VwIFRoZSBncm91cCBwZXJmb3JtaW5nIHRoZSBhbmltYXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9oYW5kbGVMZWF2ZSA9IGZ1bmN0aW9uIChub2Rlcywga2V5LCBncm91cCkge1xyXG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGdyb3VwLml0ZW1Db250YWluZXIsIGFuaW1hdGlvblF1ZXVlID0gZ3JvdXAuYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbiwgYW5pbWF0aW9uUHJvbWlzZSA9IHRoaXMuX2FuaW1hdG9yLmxlYXZlKG5vZGVzLCBrZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFuaW1hdGlvblF1ZXVlLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhbmltYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvblByb21pc2UsXHJcbiAgICAgICAgICAgICAgICBvcDogJ2xlYXZlJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlcyBhIHNpbXBsZSBhbmltYXRpb24gb2YgYSBibG9jayBvZiBlbGVtZW50cy5cclxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2RlcyBUaGUgQXJyYXkgb2Ygbm9kZXMgdG8gYW5pbWF0ZS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBhbmltYXRpb24ga2V5L3R5cGUuXHJcbiAgICAgICAgICogQHBhcmFtIHtJR3JvdXBIYXNofSBncm91cCBUaGUgZ3JvdXAgcGVyZm9ybWluZyB0aGUgYW5pbWF0aW9uLlxyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FuY2VsIFdoZXRoZXIgb3Igbm90IHRvIGNhbmNlbCB0aGUgY3VycmVudCBhbmltYXRpb24gYmVmb3JlIGJlZ2lubmluZyB0aGlzIG9uZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX2hhbmRsZUNsb25lZENvbnRhaW5lckFuaW1hdGlvbiA9IGZ1bmN0aW9uIChub2Rlcywga2V5LCBncm91cCwgY2FuY2VsKSB7XHJcbiAgICAgICAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9Qcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ3JvdXAuaXRlbUNvbnRhaW5lciwgY2xvbmVkQ29udGFpbmVyID0gY29udGFpbmVyLmNsb25lTm9kZSh0cnVlKSwgcGFyZW50Tm9kZSwgYW5pbWF0aW9uUXVldWUgPSBncm91cC5hbmltYXRpb25RdWV1ZSwgaXNOdWxsID0gdGhpcy51dGlscy5pc051bGwsIGFuaW1hdGlvbkNyZWF0aW9uID0gdGhpcy5fYW5pbWF0b3IuY3JlYXRlKG5vZGVzLCBrZXkpLCBhbmltYXRpb24sIGFuaW1hdGlvblByb21pc2UgPSBhbmltYXRpb25DcmVhdGlvbi5jdXJyZW50LnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYW5pbWF0aW9uUXVldWUuaW5kZXhPZihhbmltYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnROb2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGNvbnRhaW5lciwgY2xvbmVkQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgfSksIGNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChwYXJlbnROb2RlKSB8fCBhbmltYXRpb25Qcm9taXNlLmlzQ2FuY2VsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb25Qcm9taXNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY2xvbmVkQ29udGFpbmVyLCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uQ3JlYXRpb24ucHJldmlvdXMudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZS5zdGFydCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uUHJvbWlzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgYW5pbWF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBhbmltYXRpb25Qcm9taXNlLFxyXG4gICAgICAgICAgICAgICAgb3A6ICdjbG9uZSdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGNhbmNlbCAmJiBhbmltYXRpb25RdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FuY2VsUHJvbWlzZSA9IHRoaXMuX2NhbmNlbEN1cnJlbnRBbmltYXRpb25zKCkudGhlbihjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5wdXNoKGFuaW1hdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuY2VscyBhbGwgY3VycmVudCBhbmltYXRpb25zLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdHVpLklHcm91cEhhc2h9IFRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGdyb3VwLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fY2FuY2VsQ3VycmVudEFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoZ3JvdXApIHtcclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gKGdyb3VwIHx8IHRoaXMuX2RlZmF1bHRHcm91cCkuYW5pbWF0aW9uUXVldWUsIGFuaW1hdGlvbnMgPSBbXSwgbGVuZ3RoID0gYW5pbWF0aW9uUXVldWUubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uUXVldWVbaV0uYW5pbWF0aW9uLmNhbmNlbCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3JtYWxpemVzIHRlbXBsYXRlIG5hbWVzIGJ5IHJlbW92aW5nIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVtcGxhdGVOYW1lIFRoZSBuYW1lIHRvIG5vcm1hbGl6ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX25vcm1hbGl6ZVRlbXBsYXRlTmFtZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZU5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNTdHJpbmcodGVtcGxhdGVOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UodGhpcy5fbm9kZU5vcm1hbGl6ZVJlZ2V4LCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBwcm9ncmVzcyByaW5nIGVsZW1lbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9nZW5lcmF0ZVByb2dyZXNzUmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBjb250cm9sID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCByaW5nID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb250cm9sLmNsYXNzTmFtZSA9IF9fTGlzdHZpZXcgKyBcIi1yaW5nIFwiICsgX19QbGF0ICsgXCJyaW5nIFwiICsgX19QbGF0ICsgXCJyaW5nLTBcIjtcclxuICAgICAgICAgICAgcmluZy5jbGFzc05hbWUgPSBfX1BsYXQgKyBcImFuaW1hdGVkLXJpbmdcIjtcclxuICAgICAgICAgICAgY29udHJvbC5pbnNlcnRCZWZvcmUocmluZywgbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2tzIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgY29udHJvbCBhbmQgZW5zdXJlcyBpdCBpcyB2YWxpZC5cclxuICAgICAgICAgKiBXaWxsIGRlZmF1bHQgdG8gXCJob3Jpem9udGFsXCIgaWYgaW52YWxpZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZW50YXRpb24gVGhlIGVsZW1lbnQgdG8gYmFzZSB0aGUgbGVuZ3RoIG9mZiBvZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBMaXN0dmlldy5wcm90b3R5cGUuX3ZhbGlkYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3JpZW50YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudXRpbHMuaXNVbmRlZmluZWQob3JpZW50YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3ZlcnRpY2FsJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsaWRPcmllbnRhdGlvbjtcclxuICAgICAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZE9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xyXG4gICAgICAgICAgICAgICAgdmFsaWRPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nLmRlYnVnKFwiSW52YWxpZCBvcmllbnRhdGlvbiBcXFwiXCIgKyBvcmllbnRhdGlvbiArIFwiXFxcIiBmb3IgXCIgKyB0aGlzLnR5cGUgKyBcIi4gRGVmYXVsdGluZyB0byBcXFwidmVydGljYWwuXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgIHZhbGlkT3JpZW50YXRpb24gPSAndmVydGljYWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxpZE9yaWVudGF0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGEgaG9yaXpvbnRhbGx5IGdyb3VwZWQgTGlzdHZpZXcncyBjb250YWluZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zZXRDb250YWluZXJIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZlcnRpY2FsIHx8ICF0aGlzLl9pc0dyb3VwZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICghaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRWaXNpYmlsaXR5TGlzdGVuZXIodGhpcy5fc2V0Q29udGFpbmVySGVpZ2h0LmJpbmQodGhpcyksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIHNjcm9sbCBiYXIgaGVpZ2h0IGV2ZW4gaWYgc2Nyb2xsIGJhciBpc24ndCB2aXNpYmxlIFxyXG4gICAgICAgICAgICAvLyBhbGxvd3MgZm9yIHRyYW5zaXRpb24gb2Ygc2Nyb2xsIGJhciBpbiBhbmQgb3V0IG9mIHBhZ2UgaW4gYnJvd3NlcnMgd2hlcmUgc2Nyb2xsIGJhciBhZmZlY3RzIGhlaWdodCBcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gdGhpcy5fZ2V0U2Nyb2xsQmFyV2lkdGgoKTtcclxuICAgICAgICAgICAgaWYgKGhlaWdodCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHdpZHRoIG9mIGEgZ3JvdXAgY29udGFpbmVyIGJhc2VkIG9uIHRoZSBzY3JvbGwgd2lkdGggb2YgdGhlIGdyb3VwJ3MgaXRlbSBjb250YWluZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaXRlbUNvbnRhaW5lciBUaGUgaXRlbSBjb250YWluZXIgZWxlbWVudCB3aG9zZSBwYXJlbnQgd2UncmUgZ29pbmcgdG8gc2V0IGl0cyBzY3JvbGwgd2lkdGggb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zZXRHcm91cENvbnRhaW5lcldpZHRoID0gZnVuY3Rpb24gKGl0ZW1Db250YWluZXIpIHtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gaXRlbUNvbnRhaW5lci5zY3JvbGxXaWR0aDtcclxuICAgICAgICAgICAgaWYgKCF3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVmlzaWJpbGl0eUxpc3RlbmVyKHRoaXMuX3NldEdyb3VwQ29udGFpbmVyV2lkdGguYmluZCh0aGlzLCBpdGVtQ29udGFpbmVyKSwgaXRlbUNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbUNvbnRhaW5lci5wYXJlbnRFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBwYWRkaW5nIG9mIGEgZ3JvdXAncyBlbGVtZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGdyb3VwIGNvbnRhaW5lciBlbGVtZW50IHdobyB3ZSdyZSBzZXR0aW5nIHBhZGRpbmcgb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9zZXRHcm91cENvbnRhaW5lclBhZGRpbmcgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFZpc2liaWxpdHlMaXN0ZW5lcih0aGlzLl9zZXRHcm91cENvbnRhaW5lclBhZGRpbmcuYmluZCh0aGlzLCBlbGVtZW50KSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGhlYWRlciA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQsIGhlYWRlckhlaWdodCA9IGhlYWRlci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICghaGVhZGVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRWaXNpYmlsaXR5TGlzdGVuZXIodGhpcy5fc2V0R3JvdXBDb250YWluZXJQYWRkaW5nLmJpbmQodGhpcywgZWxlbWVudCksIGhlYWRlcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wID0gaGVhZGVySGVpZ2h0ICsgXCJweFwiO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VhdGVzIHRoZSB3aWR0aCBvZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGwgYmFyIGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTGlzdHZpZXcucHJvdG90eXBlLl9nZXRTY3JvbGxCYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IHRoaXMuX2RvY3VtZW50LCBib2R5ID0gX2RvY3VtZW50LmJvZHksIGlubmVyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCBvdXRlciA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgaW5uZXJTdHlsZSA9IGlubmVyLnN0eWxlLCBvdXRlclN0eWxlID0gb3V0ZXIuc3R5bGU7XHJcbiAgICAgICAgICAgIGlubmVyU3R5bGUud2lkdGggPSBpbm5lclN0eWxlLmhlaWdodCA9IG91dGVyU3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcclxuICAgICAgICAgICAgb3V0ZXJTdHlsZS53aWR0aCA9ICc1MHB4JztcclxuICAgICAgICAgICAgb3V0ZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgIG91dGVyU3R5bGUudG9wID0gb3V0ZXJTdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgICAgIG91dGVyU3R5bGUudmlzaWJpbGl0eSA9IG91dGVyU3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgb3V0ZXIuaW5zZXJ0QmVmb3JlKGlubmVyLCBudWxsKTtcclxuICAgICAgICAgICAgYm9keS5pbnNlcnRCZWZvcmUob3V0ZXIsIG51bGwpO1xyXG4gICAgICAgICAgICB2YXIgdzEgPSBpbm5lci5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIG91dGVyU3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcclxuICAgICAgICAgICAgdmFyIHcyID0gaW5uZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAodzEgPT09IHcyKSB7XHJcbiAgICAgICAgICAgICAgICB3MiA9IG91dGVyLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2R5LnJlbW92ZUNoaWxkKG91dGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuICh3MSAtIHcyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFkZHMgYSB2aXNpYmlsaXR5IGxpc3RlbmVyIGFuZCBoaWRlcyBhbmQgc2hvd3MgZWxlbWVudCBhY2NvcmRpbmdseVxyXG4gICAgICAgICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHRvIGZpcmUgd2hlbiB2aXNpYmxlLlxyXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gbGlzdGVuIGZvciB2aXNpYmlsaXR5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIExpc3R2aWV3LnByb3RvdHlwZS5fYWRkVmlzaWJpbGl0eUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB2aXNpYmlsaXR5UmVtb3ZlcnMgPSB0aGlzLl92aXNpYmlsaXR5UmVtb3ZlTGlzdGVuZXJzLCByZW1vdmUsIGNiID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gdmlzaWJpbGl0eVJlbW92ZXJzLmluZGV4T2YocmVtb3ZlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpc2liaWxpdHlSZW1vdmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmlzaWJpbGl0eVJlbW92ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKF9fSGlkZGVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVtb3ZlID0gdGhpcy5kb20ud2hlblZpc2libGUodGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh0aGlzLCBjYiksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpZiAodmlzaWJpbGl0eVJlbW92ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShfX0hpZGRlbiwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZpc2liaWxpdHlSZW1vdmVycy5wdXNoKHJlbW92ZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBMaXN0dmlldy5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfZG9jdW1lbnQ6IF9fRG9jdW1lbnQsXHJcbiAgICAgICAgICAgIF93aW5kb3c6IF9fV2luZG93LFxyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX2FuaW1hdG9yOiBfX0FuaW1hdG9yLFxyXG4gICAgICAgICAgICBfUHJvbWlzZTogX19Qcm9taXNlLFxyXG4gICAgICAgICAgICBfVGVtcGxhdGVDb250cm9sRmFjdG9yeTogX19UZW1wbGF0ZUNvbnRyb2xGYWN0b3J5XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTGlzdHZpZXc7XHJcbiAgICB9KHBsYXQudWkuVGVtcGxhdGVDb250cm9sKSk7XHJcbiAgICBwbGF0dWkuTGlzdHZpZXcgPSBMaXN0dmlldztcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX0xpc3R2aWV3LCBMaXN0dmlldyk7XHJcbiAgICAvKipcclxuICAgICAqIEFuIElUZW1wbGF0ZUNvbnRyb2wgdGhhdCBhY3RzIGFzIGEgZ2xvYmFsIG5hdmlnYXRpb24gYmFyIHRoYXQgZGVmaW5lcyBpdHMgb3duIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIHZhciBOYXZiYXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhOYXZiYXIsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gTmF2YmFyKCkge1xyXG4gICAgICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHRlbXBsYXRlIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZVN0cmluZyA9ICc8ZGl2IGNsYXNzPVwicGxhdC1uYXZiYXItbGVmdFwiPlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8ZGl2IGNsYXNzPVwicGxhdC1uYXZiYXItaXRlbXNcIiBwbGF0LWNvbnRyb2w9XCInICsgX19Gb3JFYWNoICsgJ1wiIHBsYXQtY29udGV4dD1cImxlZnRcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1pdGVtXCIgcGxhdC1jb250cm9sPVwiJyArIF9fSHRtbCArICdcIiBwbGF0LW9wdGlvbnM9XCJ7IGh0bWw6IGNvbnRlbnQsIGNvbXBpbGU6IHRydWUgfVwiIHBsYXQtdGFwPVwibGVmdEFjdGlvbihAaW5kZXgpXCI+PC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1jZW50ZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLWl0ZW1zXCIgcGxhdC1jb250cm9sPVwiJyArIF9fRm9yRWFjaCArICdcIiBwbGF0LWNvbnRleHQ9XCJjZW50ZXJcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1pdGVtXCIgcGxhdC1jb250cm9sPVwiJyArIF9fSHRtbCArICdcIiBwbGF0LW9wdGlvbnM9XCJ7IGh0bWw6IGNvbnRlbnQsIGNvbXBpbGU6IHRydWUgfVwiIHBsYXQtdGFwPVwiY2VudGVyQWN0aW9uKEBpbmRleClcIj48L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgPC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPC9kaXY+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInBsYXQtbmF2YmFyLXJpZ2h0XCI+XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1pdGVtc1wiIHBsYXQtY29udHJvbD1cIicgKyBfX0ZvckVhY2ggKyAnXCIgcGxhdC1jb250ZXh0PVwicmlnaHRcIj5cXG4nICtcclxuICAgICAgICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJwbGF0LW5hdmJhci1pdGVtXCIgcGxhdC1jb250cm9sPVwiJyArIF9fSHRtbCArICdcIiBwbGF0LW9wdGlvbnM9XCJ7IGh0bWw6IGNvbnRlbnQsIGNvbXBpbGU6IHRydWUgfVwiIHBsYXQtdGFwPVwicmlnaHRBY3Rpb24oQGluZGV4KVwiPjwvZGl2PlxcbicgK1xyXG4gICAgICAgICAgICAgICAgJyAgICA8L2Rpdj5cXG4nICtcclxuICAgICAgICAgICAgICAgICc8L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIE5hdmJhciBjb250cm9sJ3MgY29udGV4dC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG5vb3BcclxuICAgICAgICAgICAgICAgICAgICB9XSxcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogW3tcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogbm9vcFxyXG4gICAgICAgICAgICAgICAgICAgIH1dLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IG5vb3BcclxuICAgICAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogU3BlY2lmaWVzIHRoYXQgdGhlIE5hdmJhciBkZWZpbmVzIGl0J3Mgb3duIGNvbnRleHQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmhhc093bkNvbnRleHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gb2JqZWN0IHNwZWNpZnlpbmcgd2hldGhlciBhIHBhcnRpY3VsYXIgc2VjdGlvbiBvZiB0aGUgTmF2YmFyXHJcbiAgICAgICAgICAgICAqIGhhcyBiZWVuIG92ZXJyaWRkZW4uXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLl9vdmVycmlkZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGNlbnRlcjogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByaWdodDogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgcHJvcGVyIGVsZW1lbnRzLlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWU/IEFuIG9wdGlvbmFsLCBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgb3IgY2xhc3MgbmFtZXMgdG8gc2V0IG9uIHRoZSBjb250cm9sXHJcbiAgICAgICAgICogaW4gYWRkaXRpb24gdG8gaXRzIHN0YW5kYXJkIHNldC5cclxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ/IFRoZSBlbGVtZW50IHRvIHNldCB0aGUgY2xhc3MgbmFtZSBvbi4gU2hvdWxkIGRlZmF1bHQgdG9cclxuICAgICAgICAgKiB0aGUgY29udHJvbCdzIGVsZW1lbnQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLnNldENsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tLmFkZENsYXNzKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50LCBfX05hdmJhciArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzc2VzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMb29rcyBmb3IgYW5kIGFwcGxpZXMgb3ZlcndyaXR0ZW4gY29tcG9uZW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLnNldFRlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaXNOdWxsID0gdGhpcy51dGlscy5pc051bGwsIGlubmVyVGVtcGxhdGUgPSB0aGlzLmlubmVyVGVtcGxhdGU7XHJcbiAgICAgICAgICAgIGlmIChpc051bGwoaW5uZXJUZW1wbGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5fZG9jdW1lbnQsIG92ZXJyaWRlcyA9IHRoaXMuX292ZXJyaWRlcywgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGFwcGVuZENoaWxkcmVuID0gdGhpcy5kb20uYXBwZW5kQ2hpbGRyZW4sIGNoaWxkTm9kZXMgPSBzbGljZS5jYWxsKGlubmVyVGVtcGxhdGUuY2hpbGROb2RlcyksIGNoaWxkTm9kZSwgbmV3Tm9kZSwgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgZWxlbWVudE5vZGVzID0gc2xpY2UuY2FsbChlbGVtZW50LmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgd2hpbGUgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmxlZnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmNsYXNzTmFtZSA9IF9fTmF2YmFyICsgXCItbGVmdFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShfX0NvbnRleHQsICdsZWZ0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVwbGFjZUNoaWxkKGFwcGVuZENoaWxkcmVuKHNsaWNlLmNhbGwoY2hpbGROb2RlLmNoaWxkTm9kZXMpLCBuZXdOb2RlKSwgZWxlbWVudE5vZGVzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmNlbnRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuY2xhc3NOYW1lID0gX19OYXZiYXIgKyBcIi1jZW50ZXJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoX19Db250ZXh0LCAnY2VudGVyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVwbGFjZUNoaWxkKGFwcGVuZENoaWxkcmVuKHNsaWNlLmNhbGwoY2hpbGROb2RlLmNoaWxkTm9kZXMpLCBuZXdOb2RlKSwgZWxlbWVudE5vZGVzWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXMucmlnaHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLmNsYXNzTmFtZSA9IF9fTmF2YmFyICsgXCItcmlnaHRcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoX19Db250ZXh0LCAncmlnaHQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZXBsYWNlQ2hpbGQoYXBwZW5kQ2hpbGRyZW4oc2xpY2UuY2FsbChjaGlsZE5vZGUuY2hpbGROb2RlcyksIG5ld05vZGUpLCBlbGVtZW50Tm9kZXNbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5pdGlhbGl6ZXMgYWxsIG9wdGlvbnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5sb2FkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25PYmogPSB0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMgPSBvcHRpb25PYmoudmFsdWUgfHwge30sIHBvc2l0aW9uID0gdGhpcy51dGlscy5pc1N0cmluZyhvcHRpb25zLnBvc2l0aW9uKSAmJiBvcHRpb25zLnBvc2l0aW9uLnRvTG93ZXJDYXNlKCkgPT09ICdib3R0b20nID8gJy1ib3R0b20nIDogJy10b3AnO1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyh0aGlzLmVsZW1lbnQsIF9fTmF2YmFyICsgcG9zaXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5zZXRMZWZ0ID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q29tcG9uZW50KCdsZWZ0JywgY29tcG9uZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENvbXBvbmVudCgnY2VudGVyJywgY29tcG9uZW50cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLnNldFJpZ2h0ID0gZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q29tcG9uZW50KCdyaWdodCcsIGNvbXBvbmVudHMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmluZWQgYWN0aW9uIG9mIHRoZSBsZWZ0IHBhcnQgb2YgdGhlIE5hdmJhciB3aGVuIHRhcHBlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXg/IFRoZSBpbmRleCBvZiB0aGUgYWN0aW9uIHRhcHBlZC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXQudWkuSUdlc3R1cmVFdmVudH0gZXY/IFRoZSBcIiR0YXBcIiBldmVudC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLmxlZnRBY3Rpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGV2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGVBY3Rpb24oZXYsICdsZWZ0JywgaW5kZXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmluZWQgYWN0aW9uIG9mIHRoZSBjZW50ZXIgcGFydCBvZiB0aGUgTmF2YmFyIHdoZW4gdGFwcGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleD8gVGhlIGluZGV4IG9mIHRoZSBhY3Rpb24gdGFwcGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldj8gVGhlIFwiJHRhcFwiIGV2ZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuY2VudGVyQWN0aW9uID0gZnVuY3Rpb24gKGluZGV4LCBldikge1xyXG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlQWN0aW9uKGV2LCAnY2VudGVyJywgaW5kZXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmluZWQgYWN0aW9uIG9mIHRoZSByaWdodCBwYXJ0IG9mIHRoZSBOYXZiYXIgd2hlbiB0YXBwZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4PyBUaGUgaW5kZXggb2YgdGhlIGFjdGlvbiB0YXBwZWQuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0LnVpLklHZXN0dXJlRXZlbnR9IGV2PyBUaGUgXCIkdGFwXCIgZXZlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5yaWdodEFjdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgZXYpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZUFjdGlvbihldiwgJ3JpZ2h0JywgaW5kZXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgTmF2YmFyLnByb3RvdHlwZS5fc2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudXRpbHMuaXNBcnJheShjb21wb25lbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyaWRlc1twb3NpdGlvbl0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJzZUNvbXBvbmVudChjb21wb25lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0W3Bvc2l0aW9uXSA9IGNvbXBvbmVudHM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50cyA9IFtjb21wb25lbnRzXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3VyciA9IGNvbXBvbmVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoY3Vyci0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyc2VDb21wb25lbnQoY29tcG9uZW50c1tjdXJyXSwgY29udGV4dFtwb3NpdGlvbl1bY3Vycl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRleHRbcG9zaXRpb25dID0gY29tcG9uZW50cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgZGVmYXVsdCBjb21wb25lbnQgcGFyYW1ldGVycyBhbmQgZ3JhYnMgY3VzdG9tIGFjdGlvbnMgZnJvbSBpdC5cclxuICAgICAgICAgKiBAcGFyYW0ge3BsYXR1aS5JTmF2YmFyQ29tcG9uZW50fSBuZXdDb21wb25lbnQgVGhlIG5ldyBJTmF2YmFyQ29tcG9uZW50XHJcbiAgICAgICAgICogdG8gcGFyc2UuXHJcbiAgICAgICAgICogQHBhcmFtIHtwbGF0dWkuSU5hdmJhckNvbXBvbmVudH0gb2xkQ29tcG9uZW50PyBUaGUgb2xkIElOYXZiYXJDb21wb25lbnRcclxuICAgICAgICAgKiB3aG9zZSBwbGFjZSBpcyBiZWluZyB0YWtlbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBOYXZiYXIucHJvdG90eXBlLl9wYXJzZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChuZXdDb21wb25lbnQsIG9sZENvbXBvbmVudCkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc09iamVjdCA9IHV0aWxzLmlzT2JqZWN0LCBvbGRDb21wb25lbnRFeGlzdHMgPSBpc09iamVjdChvbGRDb21wb25lbnQpLCBjdXN0b21BY3Rpb25zLCBrZXlzLCBrZXksIGN1cnJLZXk7XHJcbiAgICAgICAgICAgIGlmIChvbGRDb21wb25lbnRFeGlzdHMgJiYgdXRpbHMuaXNVbmRlZmluZWQobmV3Q29tcG9uZW50LmNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDb21wb25lbnQuY29udGVudCA9IG9sZENvbXBvbmVudC5jb250ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNGdW5jdGlvbihuZXdDb21wb25lbnQuYWN0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q29tcG9uZW50LmFjdGlvbiA9IG9sZENvbXBvbmVudEV4aXN0cyA/IG9sZENvbXBvbmVudC5hY3Rpb24gOiBub29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1c3RvbUFjdGlvbnMgPSBuZXdDb21wb25lbnQuY3VzdG9tQWN0aW9ucztcclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGN1c3RvbUFjdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMoY3VzdG9tQWN0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyS2V5ID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VycktleS0tID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleXNbY3VycktleV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gY3VzdG9tQWN0aW9uc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeGVjdXRlcyB0aGUgcHJvcGVyIGFjdGlvbiBhc3NvY2lhdGVkIHdpdGggYSBOYXZiYXIgY29tcG9uZW50LlxyXG4gICAgICAgICAqIEBwYXJhbSB7cGxhdC51aS5JR2VzdHVyZUV2ZW50fSBldiBUaGUgZXhlY3V0ZWQgZXZlbnQuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uIFRoZSBwYXJ0IG9mIHRoZSBOYXZiYXIgd2hvc2UgYWN0aW9uIGlzIGJlaW5nIGV4ZWN1dGVkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7YW55fSBwcm9wZXJ0eT8gVGhlIGluZGV4aW5nIHByb3BlcnR5LiBXaWxsIGJ5IGRlZmF1bHQgYmUgYW4gaW5kZXggaW50byB0aGUgY29tcG9uZW50IEFycmF5LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIE5hdmJhci5wcm90b3R5cGUuX2V4ZWN1dGVBY3Rpb24gPSBmdW5jdGlvbiAoZXYsIHBvc2l0aW9uLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICB2YXIgdXRpbHMgPSB0aGlzLnV0aWxzLCBjb21wb25lbnQgPSB0aGlzLmNvbnRleHRbcG9zaXRpb25dO1xyXG4gICAgICAgICAgICBpZiAodXRpbHMuaXNBcnJheShjb21wb25lbnQpICYmICF1dGlscy5pc051bGwocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGNvbXBvbmVudC5hY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuYWN0aW9uKGV2KTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2cuZGVidWcoXCJBbiBhY3Rpb24gZnVuY3Rpb24gaXMgbm90IGRlZmluZWQgZm9yIHRoZSBjb21wb25lbnQgXCIgKyBjb21wb25lbnQgKyBcIi5cIik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBOYXZiYXIuX2luamVjdCA9IHtcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gTmF2YmFyO1xyXG4gICAgfShwbGF0LnVpLlRlbXBsYXRlQ29udHJvbCkpO1xyXG4gICAgcGxhdHVpLk5hdmJhciA9IE5hdmJhcjtcclxuICAgIHBsYXQucmVnaXN0ZXIuY29udHJvbChfX05hdmJhciwgTmF2YmFyLCBudWxsLCB0cnVlKTtcclxuICAgIC8qKlxyXG4gICAgICogQW4gVGVtcGxhdGVDb250cm9sIHRoYXQga2VlcHMgdHJhY2sgb2YgYSBsb2FkaW5nIGltYWdlLlxyXG4gICAgICovXHJcbiAgICB2YXIgSW1hZ2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIF9fZXh0ZW5kcyhJbWFnZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBJbWFnZSgpIHtcclxuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTCB0ZW1wbGF0ZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGVTdHJpbmcgPSAnPGRpdiBwbGF0LWNvbnRyb2w9XCInICsgX19Qcm9ncmVzc1JpbmcgKyAnXCIgY2xhc3M9XCJwbGF0LWltYWdlLXJpbmdcIj48L2Rpdj5cXG4nO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogVGhlIGltYWdlIGlzIGEgQ1NTIGJhY2tncm91bmQgaW1hZ2UuIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5faXNCYWNrZ3JvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgSFRNTEltYWdlRWxlbWVudCB1c2UgdG8gc291cmNlIHRoZSBpbWFnZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ltZyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBjbGFzc2VzIG9uIHRoZSBwcm9wZXIgZWxlbWVudHMuXHJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZT8gQW4gb3B0aW9uYWwsIGFkZGl0aW9uYWwgY2xhc3MgbmFtZSBvciBjbGFzcyBuYW1lcyB0byBzZXQgb24gdGhlIGNvbnRyb2xcclxuICAgICAgICAgKiBpbiBhZGRpdGlvbiB0byBpdHMgc3RhbmRhcmQgc2V0LlxyXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudD8gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBjbGFzcyBuYW1lIG9uLiBTaG91bGQgZGVmYXVsdCB0b1xyXG4gICAgICAgICAqIHRoZSBjb250cm9sJ3MgZWxlbWVudCBpZiBub3Qgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEltYWdlLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSwgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50IHx8IHRoaXMuZWxlbWVudCwgX19JbWFnZSArIFwiIFwiICsgKGNsYXNzTmFtZSB8fCAnJykpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoZSBjbGFzcyBuYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEltYWdlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldENsYXNzZXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGUgc3R5bGUgYW5kIGluaXRpYWxpemUgdGhlIGFjdGlvbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBJbWFnZS5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCwgdXRpbHMgPSB0aGlzLnV0aWxzLCBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nLCBpc09iamVjdCA9IHV0aWxzLmlzT2JqZWN0LCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLCBvcHRpb25zID0gdGhpcy5vcHRpb25zLCB1cmw7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyh1cmwgPSBhdHRyaWJ1dGVzW19fQ2FtZWxTcmNdKSkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5vYnNlcnZlKHRoaXMuX3NldFNyYywgX19DYW1lbFNyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodXJsID0gYXR0cmlidXRlc1tfX3NyY10pKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLm9ic2VydmUodGhpcy5fc2V0U3JjLCBfX3NyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpICYmIGlzT2JqZWN0KG9wdGlvbnMudmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0JhY2tncm91bmQgPSBvcHRpb25zLnZhbHVlLmlzQmFja2dyb3VuZCA9PT0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRvbS5hZGRDbGFzcyhlbGVtZW50LCBfX1BsYXQgKyBcImJhY2tncm91bmRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX05vZGVNYW5hZ2VyU3RhdGljLmhhc01hcmt1cCh1cmwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2V0U3JjKHVybCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIGFuZCBzb3VyY2VzIHRoZSBpbWFnZSB0byBkaXNwbGF5LlxyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIHNvdXJjZSBVUkwgdG8gZGlzcGxheS5cclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkVXJsPyBUaGUgb2xkIHNvdXJjZSBVUkwgdGhhdCB3YXMgYmVpbmcgZGlzcGxheWVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEltYWdlLnByb3RvdHlwZS5fc2V0U3JjID0gZnVuY3Rpb24gKHVybCwgb2xkVXJsKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSB0aGlzLl9pbWcsIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQsIGRvbSA9IHRoaXMuZG9tLCBpbWFnZUxvYWQgPSBfX1BsYXQgKyBcImxvYWQtaW1hZ2VcIiwgaW1hZ2VFcnJvciA9IF9fSW1hZ2UgKyBcIi1lcnJvclwiLCBsb2FkZXIgPSB0aGlzLl9sb2FkZXI7XHJcbiAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhpbWcsIGltYWdlTG9hZCk7XHJcbiAgICAgICAgICAgIGltZy5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlcnJvciBjbGFzcyBpbiBjYXNlIGltYWdlIGZhaWxlZCBhbmQgdGhlbiBkZWNpZGVzIHRvIGxvYWQgXHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGltYWdlRXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNCYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gXCJ1cmwoXFxcIlwiICsgdXJsICsgXCJcXFwiKVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhpbWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGltZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMobG9hZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChsb2FkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGltZywgaW1hZ2VMb2FkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhsb2FkZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQobG9hZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy51dGlscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5hZGRDbGFzcyhlbGVtZW50LCBpbWFnZUVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhpbWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoaW1nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMobG9hZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGxvYWRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGxvYWRlciwgbnVsbCk7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGltZywgbnVsbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBJbWFnZS5faW5qZWN0ID0ge1xyXG4gICAgICAgICAgICBfY29tcGF0OiBfX0NvbXBhdCxcclxuICAgICAgICAgICAgX2RvY3VtZW50OiBfX0RvY3VtZW50LFxyXG4gICAgICAgICAgICBfTm9kZU1hbmFnZXJTdGF0aWM6IF9fTm9kZU1hbmFnZXJTdGF0aWNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBJbWFnZTtcclxuICAgIH0ocGxhdC51aS5UZW1wbGF0ZUNvbnRyb2wpKTtcclxuICAgIHBsYXR1aS5JbWFnZSA9IEltYWdlO1xyXG4gICAgcGxhdC5yZWdpc3Rlci5jb250cm9sKF9fSW1hZ2UsIEltYWdlKTtcclxufSkocGxhdHVpIHx8IChwbGF0dWkgPSB7fSkpO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHBsYXR1aTtcclxuIl19
